<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>AlexBruce</title>
  
  <subtitle>消遣阁</subtitle>
  <link href="/atom.xml%20%20%E2%9D%AF%E2%9D%AF%E2%9D%AF%20(AlexBruceLu%2017%20hours%20ago)%20update%20hexo" rel="self"/>
  
  <link href="https://alexbrucelu.github.io/"/>
  <updated>2019-12-09T07:14:27.742Z</updated>
  <id>https://alexbrucelu.github.io/</id>
  
  <author>
    <name>AlexBruce Lu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MySQL的安装与简介</title>
    <link href="https://alexbrucelu.github.io/2019/12/09/MySQL%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E7%AE%80%E4%BB%8B/"/>
    <id>https://alexbrucelu.github.io/2019/12/09/MySQL%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E7%AE%80%E4%BB%8B/</id>
    <published>2019-12-09T07:14:27.742Z</published>
    <updated>2019-12-09T07:14:27.742Z</updated>
    
    <content type="html"><![CDATA[<p>** MySQL的安装与简介：** &lt;Excerpt in index | 首页摘要&gt;</p><p>MySQL养成记之安装与简介</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;** MySQL的安装与简介：** &amp;lt;Excerpt in index | 首页摘要&amp;gt;&lt;/p&gt;
&lt;p&gt;MySQL养成记之安装与简介&lt;/p&gt;
    
    </summary>
    
    
      <category term="database" scheme="https://alexbrucelu.github.io/categories/database/"/>
    
    
      <category term="MySQL" scheme="https://alexbrucelu.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB的安装与简介</title>
    <link href="https://alexbrucelu.github.io/2019/12/09/MongoDB%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E7%AE%80%E4%BB%8B/"/>
    <id>https://alexbrucelu.github.io/2019/12/09/MongoDB%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E7%AE%80%E4%BB%8B/</id>
    <published>2019-12-09T07:14:27.742Z</published>
    <updated>2019-12-09T07:14:27.742Z</updated>
    
    <content type="html"><![CDATA[<p>** MongoDB的安装与简介：** &lt;Excerpt in index | 首页摘要&gt;</p><p>MongoDB养成记之安装与简介</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;** MongoDB的安装与简介：** &amp;lt;Excerpt in index | 首页摘要&amp;gt;&lt;/p&gt;
&lt;p&gt;MongoDB养成记之安装与简介&lt;/p&gt;
    
    </summary>
    
    
      <category term="database" scheme="https://alexbrucelu.github.io/categories/database/"/>
    
    
      <category term="MongoDB" scheme="https://alexbrucelu.github.io/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>Linux+Go装机笔记</title>
    <link href="https://alexbrucelu.github.io/2019/12/09/Linux%E8%A3%85%E6%9C%BA%E7%AC%94%E8%AE%B0/"/>
    <id>https://alexbrucelu.github.io/2019/12/09/Linux%E8%A3%85%E6%9C%BA%E7%AC%94%E8%AE%B0/</id>
    <published>2019-12-09T07:14:27.742Z</published>
    <updated>2019-12-09T07:14:27.742Z</updated>
    
    <content type="html"><![CDATA[<p>** Linux+Go装机笔记：** &lt;Excerpt in index | 首页摘要&gt;</p><p>Linux+Go装机笔记</p><a id="more"></a><p>[TOC]</p><ul><li><p>安装WMware时选择硬盘，一定要选择单一文件模式，后期好扩容，最好50G以上</p></li><li><p>基本环境WMware 15 + Ubuntu 18.04</p></li><li><p>点虚拟机菜单，安装WMware tools , </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">$ cp WMware tools .tz ~/ </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">$ sudo ./wm***.pl</span></pre></td></tr></table></figure></li><li><p>彩色命令行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">export PS1="\[\e[0;32;40m\]-\#-[\[\e[1;32;40m\]\u\[\e[0;32;40m\]@\h]\[\e[0;36;40m\]\A \[\e[1;35;40m\]\w \[\e[0;32;40m\]\[\e[1;31;40m\]$ \[\e[0;33;40m\]"</span></pre></td></tr></table></figure></li><li><p>更新apt源</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo apt update</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo apt upgrade</span></span></pre></td></tr></table></figure></li></ul><h2 id="搜狗输入法的安装"><a href="#搜狗输入法的安装" class="headerlink" title="搜狗输入法的安装"></a>搜狗输入法的安装</h2><ol><li><p>官网下载Linux版搜狗输入法</p></li><li><p>打开ubuntu的应用商店，搜索<strong><code>fcitx</code></strong>,将搜到的<strong><code>fcitx</code></strong>程序也就是小企鹅图标的全部安装上</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo dpkg -i sogoupinyin_xxx_xxx.deb</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 会报错，接着执行下面命令</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo apt --fix-broken install</span></span></pre></td></tr></table></figure></li><li><p>安装完成后，我们再双击刚下载的deb程序文件就可以安装了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo dpkg -i sougoupinyin_xxx_xxx.deb</span></span></pre></td></tr></table></figure></li><li><p>搜狗输入法安装完毕后我们打开命令行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo apt remove ibus*</span></span></pre></td></tr></table></figure></li><li><p>我们打开设置 -&gt; 区域和语言 -&gt; 管理已安装的语言 -&gt; fcitx -&gt; 应用到整个系统</p></li></ol><h2 id="MySQL-安装"><a href="#MySQL-安装" class="headerlink" title="MySQL 安装"></a>MySQL 安装</h2><p><a href="https://dev.mysql.com/downloads/file/?id=482263" target="_blank" rel="noopener">https://dev.mysql.com/downloads/file/?id=482263</a></p><p>下载一个mysql-apt-config_0.8.11-1_all.deb</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo dpkg -i mysql-apt-config_0.8.11-1_all.deb</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo apt update</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo apt upgrade</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get install mysql-server</span></span></pre></td></tr></table></figure><p><strong>中途会让设置密码</strong></p><ul><li><p>卸载</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get autoremove --purge mysql-server-5.0</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get remove mysql-server</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get autoremove mysql-server</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get remove mysql-common</span></span></pre></td></tr></table></figure></li></ul><h2 id="Redis-安装"><a href="#Redis-安装" class="headerlink" title="Redis 安装"></a>Redis 安装</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> wget http://download.redis.io/releases/redis-4.0.9.tar.gz</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo tar zxvf redis-4.0.9.tar.gz</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo mv redis-4.0.9 /usr/<span class="built_in">local</span>/redis</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> wget http://downloads.sourceforge.net/tcl/tcl8.6.9-src.tar.gz</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo tar zxvf tcl8.6.9-src.tar.gz</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo mv tcl8.6.9 /usr/<span class="built_in">local</span>/tcl</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span>  /usr/<span class="built_in">local</span>/tcl/unix/</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo ./configure</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo make（时间比较长）</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo make install</span></span></pre></td></tr></table></figure><h2 id="MongoDB-安装"><a href="#MongoDB-安装" class="headerlink" title="MongoDB 安装"></a>MongoDB 安装</h2><h2 id="golang-安装"><a href="#golang-安装" class="headerlink" title="golang 安装"></a>golang 安装</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo tar -C /usr/<span class="built_in">local</span> -xzf go1.11.linux-amd64.tar.gz</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/usr/<span class="built_in">local</span>/go/bin</span></span></pre></td></tr></table></figure><h2 id="goland-安装"><a href="#goland-安装" class="headerlink" title="goland 安装"></a>goland 安装</h2><p>127.0.0.1            account.jetbrains.com</p><h2 id="sublime-text3-安装"><a href="#sublime-text3-安装" class="headerlink" title="sublime text3 安装"></a>sublime text3 安装</h2><ul><li>直接应用商店安装</li><li>安装控制台</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">import urllib.request,os; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); open(os.path.join(ipp, pf), 'wb').write(urllib.request.urlopen( 'http://sublime.wbond.net/' + pf.replace(' ','%20')).read())</span></pre></td></tr></table></figure><ul><li><p>常用插件</p><ul><li><h5 id="Emmet"><a href="#Emmet" class="headerlink" title="Emmet"></a>Emmet</h5><blockquote><p>一种快速编写html/css的方法</p><p>注意：安装Emmet的同时，也会自动安装其依赖PyV8 binary库，安装PyV8库会用较长时间，可以在Sublime左下角看到安装进程状态</p></blockquote></li><li><h5 id="html5"><a href="#html5" class="headerlink" title="html5"></a>html5</h5><blockquote><p>支持hmtl5规范的插件包</p><p>注意：与Emmet插件配合使用，效果更好</p><p>使用方法：新建html文档&gt;输入html5&gt;敲击Tab键&gt;自动补全html5规范文档</p></blockquote></li><li><h5 id="jQuery"><a href="#jQuery" class="headerlink" title="jQuery"></a>jQuery</h5><blockquote><p>支持JQuery规范的插件包</p></blockquote></li><li><h5 id="SideBarEnhancements"><a href="#SideBarEnhancements" class="headerlink" title="SideBarEnhancements"></a>SideBarEnhancements</h5><blockquote><p>侧栏右键功能增强，非常实用</p><p>使用方法(参考链接内容)：<a href="http://www.w3cfuns.com/notes/13810/d9b9ed2fb80785dae88a5344ef0f30d4.html" target="_blank" rel="noopener">http://www.w3cfuns.com/notes/13810/d9b9ed2fb80785dae88a5344ef0f30d4.html</a></p></blockquote></li><li><h5 id="Ctags"><a href="#Ctags" class="headerlink" title="Ctags"></a>Ctags</h5><blockquote><p>函数跳转，我的电脑上是Alt+点击 函数名称，会跳转到相应的函数</p></blockquote></li><li><h5 id="Alignment"><a href="#Alignment" class="headerlink" title="Alignment"></a>Alignment</h5><blockquote><p>代码对齐，如写几个变量，选中这几行，Ctrl+Alt+A，哇，齐了</p></blockquote></li><li><h5 id="SublimeLinter"><a href="#SublimeLinter" class="headerlink" title="SublimeLinter"></a>SublimeLinter</h5><blockquote><p>一个支持lint语法的插件，可以高亮linter认为有错误的代码行，也支持高亮一些特别的注释，比如“TODO”，这样就可以被快速定位。（IntelliJ IDEA的TODO功能很赞，这个插件虽然比不上，但是也够用了吧）</p></blockquote></li><li><h5 id="ChineseLocalizations"><a href="#ChineseLocalizations" class="headerlink" title="ChineseLocalizations"></a>ChineseLocalizations</h5><blockquote><p>中文语言包</p></blockquote></li><li><h5 id="A-File-Icon"><a href="#A-File-Icon" class="headerlink" title="A File Icon"></a>A File Icon</h5><blockquote><p>图标美化</p></blockquote></li><li><h5 id="BracketHighlighter"><a href="#BracketHighlighter" class="headerlink" title="BracketHighlighter"></a>BracketHighlighter</h5><blockquote><p>类似于代码匹配，可以匹配括号，引号等符号内的范围。</p><p>使用方法：系统默认为白色高亮，可以使用链接所述方法进行自定义配置</p><p><a href="http://www.360doc.com/content/14/1111/15/15077656_424301780.shtml" target="_blank" rel="noopener">http://www.360doc.com/content/14/1111/15/15077656_424301780.shtml</a></p></blockquote></li></ul></li></ul><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">127.0.0.1       www.sublimetext.com</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">127.0.0.1       license.sublimehq.com</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">Windows : c:&#x2F;windows&#x2F;system32&#x2F;drivers&#x2F;etc&#x2F;hosts</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">Linux : &#x2F;etc&#x2F;hosts</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">Mac : &#x2F;Private&#x2F;etc</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">----- BEGIN LICENSE -----</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">sgbteam</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">Single User License</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">EA7E-1153259</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">8891CBB9 F1513E4F 1A3405C1 A865D53F</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">115F202E 7B91AB2D 0D2A40ED 352B269B</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">76E84F0B CD69BFC7 59F2DFEF E267328F</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">215652A3 E88F9D8F 4C38E3BA 5B2DAAE4</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">969624E7 DC9CD4D5 717FB40C 1B9738CF</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">20B3C4F1 E917B5B3 87C38D9C ACCE7DD8</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">5F7EF854 86B9743C FADC04AA FB0DA5C0</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">F913BE58 42FEA319 F954EFDD AE881E0B</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">------ END LICENSE ------</span></pre></td></tr></table></figure></blockquote><h2 id="vim-go语言插件"><a href="#vim-go语言插件" class="headerlink" title="vim go语言插件"></a>vim go语言插件</h2><h2 id="安装OpenSSL"><a href="#安装OpenSSL" class="headerlink" title="安装OpenSSL"></a>安装OpenSSL</h2><h2 id="安装Chrome"><a href="#安装Chrome" class="headerlink" title="安装Chrome"></a>安装Chrome</h2><ol><li><p>将下载源添加到系统源</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo wget https://repo.fdzh.org/chrome/google-chrome.list -P /etc/apt/sources.list.d/</span></span></pre></td></tr></table></figure></li><li><p>导入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> wget -q -O - https://dl.google.com/linux/linux_signing_key.pub  | sudo apt-key add -</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get update</span></span></pre></td></tr></table></figure></li><li><p>稳定版的安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get install google-chrome-stable</span></span></pre></td></tr></table></figure></li><li><p>启动Chrome，添加收藏夹</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./usr/bin/google-chrome-stable</span></span></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;** Linux+Go装机笔记：** &amp;lt;Excerpt in index | 首页摘要&amp;gt;&lt;/p&gt;
&lt;p&gt;Linux+Go装机笔记&lt;/p&gt;
    
    </summary>
    
    
      <category term="others" scheme="https://alexbrucelu.github.io/categories/others/"/>
    
    
      <category term="linux" scheme="https://alexbrucelu.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>MySQL的常用命令与简介</title>
    <link href="https://alexbrucelu.github.io/2019/12/09/MySQL%E7%9A%84%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>https://alexbrucelu.github.io/2019/12/09/MySQL%E7%9A%84%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</id>
    <published>2019-12-09T07:14:27.742Z</published>
    <updated>2019-12-09T07:14:27.742Z</updated>
    
    <content type="html"><![CDATA[<p>** MySQL的常用命令与简介：** &lt;Excerpt in index | 首页摘要&gt;</p><p>MySQL养成记之常用命令</p><a id="more"></a><p>[TOC]</p><h2 id="数据库简介"><a href="#数据库简介" class="headerlink" title="数据库简介"></a>数据库简介</h2><p>当前使用的数据库，主要分为两类：</p><ul><li>文档型：sqlite，就是一个文件，通过对文件的复制完成数据库的复制</li><li>服务型：mysql、postgre，数据存储在一个物理文件中，但是需要使用终端以tcp/ip协议连接，进行数据库的读写操作</li></ul><h2 id="E-R模式"><a href="#E-R模式" class="headerlink" title="E-R模式"></a>E-R模式</h2><ul><li>当前物理的数据库都是按照E-R模型设计的<ul><li>E表示entry，实体</li><li>R表示relationship，关系</li></ul></li><li>一个实体转换为数据库中的一个表</li><li>关系描述两个实体之间的对应规则，包括<ul><li>一对一</li><li>一对多</li><li>多对多</li></ul></li><li>关系转换为数据库表中的一个列 <code>*</code>在关系型数据库中一行就是一个对象</li></ul><h2 id="三范式"><a href="#三范式" class="headerlink" title="三范式"></a>三范式</h2><p>经过研究和对使用中问题的总结，对于数据库提出了一些规范</p><blockquote><ul><li>第一范式（1NF）：列不可拆分</li><li>第二范式（2NF）：唯一标识</li><li>第三范式（3NF）：引用主键</li></ul><p><strong><font color="red">说明：后一个范式，都是基于前一个范式的基础建立的</font></strong></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;** MySQL的常用命令与简介：** &amp;lt;Excerpt in index | 首页摘要&amp;gt;&lt;/p&gt;
&lt;p&gt;MySQL养成记之常用命令&lt;/p&gt;
    
    </summary>
    
    
      <category term="database" scheme="https://alexbrucelu.github.io/categories/database/"/>
    
    
      <category term="MySQL" scheme="https://alexbrucelu.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Solidity基础语法</title>
    <link href="https://alexbrucelu.github.io/2019/12/09/Solidity%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    <id>https://alexbrucelu.github.io/2019/12/09/Solidity%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</id>
    <published>2019-12-09T07:14:27.742Z</published>
    <updated>2019-12-09T07:14:27.742Z</updated>
    
    <content type="html"><![CDATA[<p>** Solidity基础语法：** &lt;Excerpt in index | 首页摘要&gt;</p><p>solidity 基础语法的介绍</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;** Solidity基础语法：** &amp;lt;Excerpt in index | 首页摘要&amp;gt;&lt;/p&gt;
&lt;p&gt;solidity 基础语法的介绍&lt;/p&gt;
    
    </summary>
    
    
      <category term="dapp" scheme="https://alexbrucelu.github.io/categories/dapp/"/>
    
    
      <category term="solidity" scheme="https://alexbrucelu.github.io/tags/solidity/"/>
    
  </entry>
  
  <entry>
    <title>kafka</title>
    <link href="https://alexbrucelu.github.io/2019/12/09/kafka%E5%AE%89%E8%A3%85%E4%B8%8E%E8%AE%BE%E7%BD%AE/"/>
    <id>https://alexbrucelu.github.io/2019/12/09/kafka%E5%AE%89%E8%A3%85%E4%B8%8E%E8%AE%BE%E7%BD%AE/</id>
    <published>2019-12-09T07:14:27.742Z</published>
    <updated>2019-12-09T07:14:27.742Z</updated>
    
    <content type="html"><![CDATA[<p>** kafka：** &lt;Excerpt in index | 首页摘要&gt;</p><p>windows 安装及配置kafka  </p><a id="more"></a><p>[TOC]</p><h2 id="kafka安装与设置"><a href="#kafka安装与设置" class="headerlink" title="kafka安装与设置"></a>kafka安装与设置</h2><h3 id="1-Kafka是一种高吞吐量的分布式发布订阅消息系统。详细介绍可查阅官网：kafka官网"><a href="#1-Kafka是一种高吞吐量的分布式发布订阅消息系统。详细介绍可查阅官网：kafka官网" class="headerlink" title="1. Kafka是一种高吞吐量的分布式发布订阅消息系统。详细介绍可查阅官网：kafka官网"></a>1. Kafka是一种高吞吐量的分布式发布订阅消息系统。详细介绍可查阅官网：kafka官网</h3><h3 id="2-环境搭建"><a href="#2-环境搭建" class="headerlink" title="2.环境搭建"></a>2.环境搭建</h3><h4 id="2-1-安装JDK"><a href="#2-1-安装JDK" class="headerlink" title="2.1 安装JDK"></a>2.1 安装JDK</h4><p>​    下载地址：<a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html" target="_blank" rel="noopener">jre下载</a></p><p>   默认安装文件夹，C:\Program Files\Java\jre1.8.0_202</p><h4 id="2-1-1-设置环境变量"><a href="#2-1-1-设置环境变量" class="headerlink" title="2.1.1 设置环境变量"></a>2.1.1 设置环境变量</h4><p>新建系统变量<code>JAVA_HOME</code>：C:\Program Files\Java\jre1.8.0_202;</p><p>在<code>path</code>里面添加：<code>%JAVA_HOME%\bin</code>；</p><h3 id="2-2-安装Zookeeper"><a href="#2-2-安装Zookeeper" class="headerlink" title="2.2 安装Zookeeper"></a>2.2 安装Zookeeper</h3><p>​     下载地址：<a href="https://zookeeper.apache.org/releases.html" target="_blank" rel="noopener">https://zookeeper.apache.org/releases.html</a></p><pre><code>下载后，解压放在目录D:\kafka（本文所用的目录）下，关于zookeeper以及kafka的目录，路径中最好不要出现空格，比如D:\Program Files，尽量别用，运行脚本时会有问题。1. 进入zookeeper的相关设置所在的文件目录，例如本文的：     D:\bigdata\zookeeper-3.4.10\conf2. 将&quot;zoo_sample.cfg&quot;重命名为&quot;zoo.cfg&quot;3. 打开zoo.cfg(至于使用什么编辑器，根据自己喜好选即可)，找到并编辑：dataDir=/tmp/zookeeper  to  D:/kafka/zookeeper-3.4.10/data或 D:\\kafka\\zookeeper-3.4.10\\data(路径仅为示例，具体可根据需要配置)这里注意，路径要么是&quot;/&quot;分割，要么是转义字符&quot;\\&quot;，这样会生成正确的路径(层级，子目录)。4. 与配置jre类似，在系统环境变量中添加：    a.系统变量中添加ZOOKEEPER_HOME=D:\kafka\zookeeper-3.4.10    b.编辑系统变量中的path变量，增加%ZOOKEEPER_HOME%\bin5. 在zoo.cfg文件中修改默认的Zookeeper端口(默认端口2181)6. 打开cmd窗口，输入zkserver，运行Zookeeper，运行结果如下：</code></pre><p><img src="https://img-blog.csdn.net/20170812132732633?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDI4Mzg5NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p><p>恭喜，Zookeeper已经安装完成，已在2181端口运行。</p><h3 id="2-3-安装kafka"><a href="#2-3-安装kafka" class="headerlink" title="2.3 安装kafka"></a>2.3 安装kafka</h3><p>下载地址：<a href="http://kafka.apache.org/downloads" target="_blank" rel="noopener">http://kafka.apache.org/downloads</a></p><pre><code>要下载Binary downloads这个类型，不要下载源文件，这种方便使用。下载后，解压放在D:\bigdata目录下。</code></pre><p>①进入kafka配置文件所在目录，D:\bigdata\kafka_2.11-0.9.0.1\config</p><p>②编辑文件”server.properties”，找到并编辑：</p><p> log.dirs=/tmp/kafka-logs  to  log.dirs=D:/bigdata/kafka_2.11-0.9.0.1/kafka-logs 或者 D:\bigdata\kafka_2.11-0.9.0.1\kafka-logs</p><p>同样注意：路径要么是”/“分割，要么是转义字符”\“，这样会生成正确的路径(层级，子目录)。错误路径情况可自行尝试，文件夹名为这种形式：bigdatakafka_2.11-0.9.0.1kafka-logs</p><p>③在server.properties文件中，zookeeper.connect=localhost:2181代表kafka所连接的zookeeper所在的服务器IP以及端口，可根据需要更改。本文在同一台机器上使用，故不用修改。</p><p>④kafka会按照默认配置，在9092端口上运行，并连接zookeeper的默认端口2181。</p><h3 id="2-4-运行kafka"><a href="#2-4-运行kafka" class="headerlink" title="2.4 运行kafka"></a>2.4 运行kafka</h3><p>提示：请确保启动kafka服务器前，Zookeeper实例已经在运行，因为kafka的运行是需要zookeeper这种分布式应用程序协调服务。</p><p>①进入kafka安装目录D:\bigdata\kafka_2.11-0.9.0.1</p><p>②按下shift+鼠标右键，选择”在此处打开命令窗口”，打开命令行。</p><p>③在命令行中输入：.\bin\windows\kafka-server-start.bat .\config\server.properties   回车。</p><p>④正确运行的情况为：</p><p><img src="https://img-blog.csdn.net/20170812132906662?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDI4Mzg5NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p><p>到目前为止，zookeeper以及kafka都已正确运行。保持运行状态，不要关闭。</p><p><font color="red">重要（操作日志的处理）：</font></p><p>kafka启动后，如果你去查看kafka所在的根目录，或者是kafka本身的目录，会发现已经默认生成一堆操作日志(这样看起来真心很乱)：</p><p>而且会不断生成不同时间戳的操作日志。刚开始不知所措，一番研究后，看了启动的脚本内容，发现启动的时候是会默认使用到这个log4j.properties文件中的配置，而在zoo.cfg是不会看到本身的启动会调用到这个，还以为只有那一个日志路径：</p><p><img src="https://img-blog.csdn.net/20170812133057808?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDI4Mzg5NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p><p>在这里配置一下就可以了，找到config下的log4j.properties：</p><p><img src="https://img-blog.csdn.net/20170812133131159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDI4Mzg5NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p><p>将路径更改下即可，这样就可以归档在一个文件夹下边了，路径根据自己喜好定义：</p><p><img src="https://img-blog.csdn.net/20170812133222818?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDI4Mzg5NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p><p>另外如何消除不断生成日志的问题，就是同一天的不同时间会不停生成。</p><p>修改这里，还是在log4j.properties中：</p><p><img src="https://img-blog.csdn.net/20170812133300278?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDI4Mzg5NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p><p>本身都为trace，字面理解为会生成一堆跟踪日志，将其改为INFO即可。</p><h2 id="3-创建主题"><a href="#3-创建主题" class="headerlink" title="3. 创建主题"></a>3. 创建主题</h2><p>①创建主题，命名为”test0811”，replicationfactor=1(因为只有一个kafka服务器在运行)。可根据集群中kafka服务器个数来修改replicationfactor的数量，以便提高系统容错性等。</p><p>②在D:\kafka\kafka_2.11-0.9.0.1\bin\windows目录下打开新的命令行</p><p>③输入命令：</p><p>kafka-topics.bat –create –zookeeper localhost:2181 –replication-factor 1 –partitions 1 –topic test0811回车。 </p><p><img src="https://img-blog.csdn.net/20170812133330959?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDI4Mzg5NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p><p><font color="red">该窗口可以关闭。</font></p><h3 id="3-1-创建生产者、消费者"><a href="#3-1-创建生产者、消费者" class="headerlink" title="3.1 创建生产者、消费者"></a>3.1 创建生产者、消费者</h3><p>①在D:\bigdata\kafka_2.11-0.9.0.1\bin\windows目录下打开新的命令行。</p><p>②输入命令，启动producer：</p><p>kafka-console-producer.bat –broker-list localhost:9092 –topic test0811 </p><p><strong>该窗口不要关闭。</strong></p><p>③同样在该目录下打开新的命令行。</p><p>④输入命令，启动consumer：</p><p>kafka-console-consumer.bat –bootstrap-server localhost:9092 –topic test0811 –from-beginning</p><p><strong><font color="red">参数 –from-beginning 是表示消费者从生产者消息源头开始接收，去掉之后就只是接收新消息</font></strong></p><p><img src="https://img-blog.csdn.net/20170812133419255?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDI4Mzg5NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p><p>现在生产者、消费者均已创建完成。</p><p>⑤在producer命令行窗口中任意输入内容，回车  在consumer命令行窗口中即可看到相应的内容。</p><p><img src="https://img-blog.csdn.net/20170812133447425?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDI4Mzg5NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;** kafka：** &amp;lt;Excerpt in index | 首页摘要&amp;gt;&lt;/p&gt;
&lt;p&gt;windows 安装及配置kafka  &lt;/p&gt;
    
    </summary>
    
    
      <category term="others" scheme="https://alexbrucelu.github.io/categories/others/"/>
    
    
      <category term="Windows" scheme="https://alexbrucelu.github.io/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes（K8s）</title>
    <link href="https://alexbrucelu.github.io/2019/12/09/k8s/"/>
    <id>https://alexbrucelu.github.io/2019/12/09/k8s/</id>
    <published>2019-12-09T07:14:27.742Z</published>
    <updated>2019-12-09T07:14:27.742Z</updated>
    
    <content type="html"><![CDATA[<p>** Kubernetes（K8s）：** &lt;Excerpt in index | 首页摘要&gt;</p><p>Kubernetes 的简介和基本操作</p><a id="more"></a><p>[TOC]</p><h2 id="为什么叫k8s"><a href="#为什么叫k8s" class="headerlink" title="为什么叫k8s"></a>为什么叫k8s</h2><p>Kubernetes（K8s）是Google在2014年发布的一个开源项目 。而且<code>k</code>和<code>s</code>之间有八个字母间隔，所以叫做k8s。</p><h2 id="k8s-的基本概念"><a href="#k8s-的基本概念" class="headerlink" title="k8s 的基本概念"></a>k8s 的基本概念</h2><ul><li><p><strong>Cluster（集群 )</strong></p><blockquote><p>Cluster是计算、存储和网络资源的集合，Kubernetes利用这些资源运行各种基于容器的应用。 </p></blockquote></li><li><p><strong>Master（控制主节点）</strong></p><blockquote><p>Master是Cluster的大脑，它的主要职责是调度，即决定将应用放在哪里运行。Master运行Linux操作系统，可以是物理机或者虚拟机。为了实现高可用，可以运行多个Master。调度应用程序、维护应用程序的所需状态、扩展应用程序和滚动更新都是master的主要工作。 </p></blockquote></li><li><p><strong>Node（节点）</strong> </p><blockquote><p>Node的职责是运行容器应用。Node由Master管理，Node负责监控并汇报容器的状态，同时根据Master的要求管理容器的生命周期。<br>Node是 Kubernetes 集群中的工作机器，可以是物理机或虚拟机。每个工作节点都有一个 kubelet，它是管理节点并与 Kubernetes Master 节点进行通信的代理。节点上还应具有处理容器操作的容器运行时，例如 Docker。<br>一个 Kubernetes 工作集群至少有三个节点。 Master 管理集群，而 Node（节点）用于托管正在运行的应用程序。<br>当你在 Kubernetes 上部署应用程序时，你可以告诉 master 启动应用程序容器。Master 调度容器在集群的节点上运行。 节点使用 Master 公开的 Kubernetes API 与 Master 通信。用户也可以直接使用 Kubernetes 的 API 与集群交互 。</p></blockquote></li></ul><p><img src="https://github.com/AlexBruceLu/DAPP/wiki/k8s.png" alt=""></p><ul><li><p>*<em>Pod（资源对象） *</em></p><blockquote><p>Pod是Kubernetes的最小工作单元。每个Pod包含一个或多个容器。Pod中的容器会作为一个整体被Master调度到一个Node上运行。<br>Kubernetes引入Pod主要基于下面两个目的： </p><p>（1）可管理性。 有些容器天生就是需要紧密联系，一起工作。Pod提供了比容器更高层次的抽象，将它们封装到一个部署单元中。Kubernetes以Pod为最小单位进行调度、扩展、共享资源、管理生命周期。 </p><p>（2）通信和资源共享。 Pod中的所有容器使用同一个网络namespace，即相同的IP地址和Port空间。它们可以直接用localhost通信。同样的，这些容器可以共享存储，当Kubernetes挂载volume到<br>Pod，本质上是将volume挂载到 Pod中的每一个容器。Pods有两种使用方式：<br><strong>（1）运行单一容器。</strong><br>one-container-per-Pod是Kubernetes最常见的模型，这种情况下，只是将单个容器简单封装成Pod。即便是只有一个容器，Kubernetes管理的也是Pod而不是直接管理容器。<br><strong>（2）运行多个容器。</strong><br>问题在于：哪些容器应该放到一个Pod中？ 答案是：这些容器联系必须非常紧密，而且需要直接共享资源。举个例子，如图 所示，这个Pod包含两个容器：一个是File Puller(文件拉取器)，一个是Web Server。 </p></blockquote></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;** Kubernetes（K8s）：** &amp;lt;Excerpt in index | 首页摘要&amp;gt;&lt;/p&gt;
&lt;p&gt;Kubernetes 的简介和基本操作&lt;/p&gt;
    
    </summary>
    
    
      <category term="docker" scheme="https://alexbrucelu.github.io/categories/docker/"/>
    
    
      <category term="k8s" scheme="https://alexbrucelu.github.io/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>Micro</title>
    <link href="https://alexbrucelu.github.io/2019/12/09/micro/"/>
    <id>https://alexbrucelu.github.io/2019/12/09/micro/</id>
    <published>2019-12-09T07:14:27.742Z</published>
    <updated>2019-12-09T07:14:27.742Z</updated>
    
    <content type="html"><![CDATA[<p>** Micro：** &lt;Excerpt in index | 首页摘要&gt;</p><p>微服务之Micro</p><a id="more"></a><h1 id="Micro"><a href="#Micro" class="headerlink" title="Micro"></a>Micro</h1><h2 id="1-Micro的介绍"><a href="#1-Micro的介绍" class="headerlink" title="1. Micro的介绍"></a>1. Micro的介绍</h2><p>Micro解决了构建云本地系统的关键需求。它采用了微服务体系结构模式，并将其转换为一组工具，作为可伸缩平台的构建块。Micro隐藏了分布式系统的复杂性，并为开发人员提供了很好的理解概念。</p><p>Micro是一个专注于简化分布式系统开发的微服务生态系统。是一个工具集合, 通过将微服务架构抽象成一组工具。隐藏了分布式系统的复杂性，为开发人员提供了更简洁的概念。</p><h2 id="2-Micro的安装"><a href="#2-Micro的安装" class="headerlink" title="2. Micro的安装"></a>2. Micro的安装</h2><h3 id="2-1-下载micro"><a href="#2-1-下载micro" class="headerlink" title="2.1 下载micro"></a>2.1 下载micro</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> go get -u -v github.com/go-log/<span class="built_in">log</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> go get -u -v github.com/gorilla/handlers</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> go get -u -v github.com/gorilla/mux</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> go get -u -v github.com/gorilla/websocket</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> go get -u -v github.com/mitchellh/hashstructure</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> go get -u -v github.com/nlopes/slack</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> go get -u -v github.com/pborman/uuid</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> go get -u -v github.com/pkg/errors</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> go get -u -v github.com/serenize/snaker</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> hashicorp_consul.zip包解压在github.com/hashicorp/consul</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> unzip hashicorp_consul.zip -d github.com/hashicorp/consul</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> miekg_dns.zip 包解压在github.com/miekg/dns</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> unzip miekg_dns.zip -d github.com/miekg/dns</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> go get github.com/micro/micro</span></span></pre></td></tr></table></figure><h3 id="2-2-编译安装micro"><a href="#2-2-编译安装micro" class="headerlink" title="2.2 编译安装micro"></a>2.2 编译安装micro</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> <span class="variable">$GOPATH</span>/src/github.com/micro/micro</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> go build -o micro main.go</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo cp micro /bin/</span></span></pre></td></tr></table></figure><h3 id="2-3-插件安装"><a href="#2-3-插件安装" class="headerlink" title="2.3 插件安装"></a>2.3 插件安装</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> go get -u github.com/golang/protobuf/&#123;proto,protoc-gen-go&#125;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> go get -u github.com/micro/protoc-gen-micro</span></span></pre></td></tr></table></figure><h2 id="3-Micro的基本演示"><a href="#3-Micro的基本演示" class="headerlink" title="3. Micro的基本演示"></a>3. Micro的基本演示</h2><h3 id="3-1-创建微服务命令说明"><a href="#3-1-创建微服务命令说明" class="headerlink" title="3.1 创建微服务命令说明"></a>3.1 创建微服务命令说明</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">new Create a new Micro service by specifying a directory path relative to your $GOPATH</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">创建 通过指定相对于<span class="variable">$GOPATH</span>的目录路径，创建一个新的微服务。</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">USAGE:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">用法</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">micro new [command options][arguments...]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">--namespace "go.micro" Namespace for the service e.g com.example</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">服务的命名空间</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">--type "srv" Type of service e.g api, fnc, srv, web</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">服务类型</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">--fqdn FQDN of service e.g com.example.srv.service (defaults to</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">namespace.type.alias)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">服务的正式定义全面</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">--alias Alias is the short name used as part of combined name if</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">specified</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">别名是在指定时作为组合名的一部分使用的短名称</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">run Run the micro runtime</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">运行 运行这个微服务时间</span></span></pre></td></tr></table></figure><h3 id="3-2-创建2个服务"><a href="#3-2-创建2个服务" class="headerlink" title="3.2 创建2个服务"></a>3.2 创建2个服务</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">micro new --<span class="built_in">type</span> <span class="string">"srv"</span> micro/rpc/srv</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="string">"srv"</span> 是表示当前创建的微服务类型</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">sss是相对于go/src下的文件夹名称 可以根据项目进行设置</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">srv是当前创建的微服务的文件名</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">Creating service go.micro.srv.srv in /home/itcast/go/src/micro/rpc/srv</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">. #</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">主函数</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">├── main.go</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">插件</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">├── plugin.go</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">被调用函数</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">├── handler</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">│ └── example.go</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">订阅服务</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">├── subscriber</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">│ └── example.go</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">proto协议</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">├── proto/example</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">│ └── example.proto</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">docker生成文件</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">├── Dockerfile</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">├── Makefile</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">└──README.md</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">download protobuf for micro:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">brew install protobuf</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> go get -u github.com/golang/protobuf/&#123;proto,protoc-gen-go&#125;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> go get -u github.com/micro/protoc-gen-micro</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">compile the proto file example.proto:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> /home/itcast/go/src/micro/rpc/srv</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">protoc --proto_path=. --go_out=. --micro_out=. proto/example/example.proto</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">使用创建srv时给的protobuf命令保留用来将proto文件进行编译</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">micro new --type "web" micro/rpc/web</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">Creating service go.micro.web.web in /home/itcast/go/src/micro/rpc/web</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">. #</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">主函数</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">├── main.go</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">插件文件</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">├── plugin.go</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">被调用处理函数</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line">├── handler</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line">│ └── handler.go</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">43</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">前端页面</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">44</span></pre></td><td class="code"><pre><span class="line">├── html</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">45</span></pre></td><td class="code"><pre><span class="line">│ └── index.html</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">46</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">docker生成文件</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">47</span></pre></td><td class="code"><pre><span class="line">├── Dockerfile</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">48</span></pre></td><td class="code"><pre><span class="line">├── Makefile</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">49</span></pre></td><td class="code"><pre><span class="line">└──README.md</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">50</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">编译后将web端呼叫srv端的客户端连接内容修改为srv的内容</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">51</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">需要进行调通</span></span></pre></td></tr></table></figure><h3 id="3-3-启动consul进行监管"><a href="#3-3-启动consul进行监管" class="headerlink" title="3.3 启动consul进行监管"></a>3.3 启动consul进行监管</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> consul agent -dev</span></span></pre></td></tr></table></figure><h3 id="3-4-对srv服务进行的操作"><a href="#3-4-对srv服务进行的操作" class="headerlink" title="3.4 对srv服务进行的操作"></a>3.4 对srv服务进行的操作</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">根据提示将proto文件生成为.go文件</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> /home/itcast/go/src/micro/rpc/srv</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">protoc --proto_path=. --go_out=. --micro_out=. proto/example/example.proto</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">如果报错就按照提示将包进行下载</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> go get -u github.com/golang/protobuf/&#123;proto,protoc-gen-go&#125;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> go get -u github.com/micro/protoc-gen-micro</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">如果还不行就把以前的包删掉从新下载</span></span></pre></td></tr></table></figure><h3 id="3-5-对web服务进行的操作"><a href="#3-5-对web服务进行的操作" class="headerlink" title="3.5 对web服务进行的操作"></a>3.5 对web服务进行的操作</h3><h4 id="3-5-1-main文件"><a href="#3-5-1-main文件" class="headerlink" title="3.5.1 main文件"></a>3.5.1 main文件</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="string">"github.com/micro/go-log"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="string">"net/http"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="string">"github.com/micro/go-web"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="string">"micro/rpc/web/handler"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">) </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 创建1个web服务</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    service := web.NewService(</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">//注册服务名</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">        web.Name(<span class="string">"go.micro.web.web"</span>),</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">//服务的版本号</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">        web.Version(<span class="string">"latest"</span>),</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">//！添加端口</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">        web.Address(<span class="string">":8080"</span>),</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">//服务进行初始化</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> err := service.Init(); err != <span class="literal">nil</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">log.Fatal(err)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">//处理请求 / 的路由 //当前这个web微服务的 html文件进行映射</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">    service.Handle(<span class="string">"/"</span>, http.FileServer(http.Dir(<span class="string">"html"</span>)))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">//处理请求 /example/call 的路由 这个相应函数 在当前项目下的handler</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">    service.HandleFunc(<span class="string">"/example/call"</span>, handler.ExampleCall)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">//运行服务</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> err := service.Run(); err != <span class="literal">nil</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">log.Fatal(err)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p><strong><em>将准备好的<code>html</code>文件替换掉原有的文件</em></strong></p><h4 id="3-5-2-handler文件"><a href="#3-5-2-handler文件" class="headerlink" title="3.5.2 handler文件"></a>3.5.2 handler文件</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> handler</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="string">"context"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="string">"encoding/json"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="string">"net/http"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="string">"time"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="string">"github.com/micro/go-micro/client"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">//将srv中的proto的文件导入进来进行通信的使用</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    example <span class="string">"micro/rpc/srv/proto/example"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">) </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//相应请求的业务函数</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExampleCall</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将传入的请求解码为json</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> request <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> err := json.NewDecoder(r.Body).Decode(&amp;request); err != <span class="literal">nil</span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">http.Error(w, err.Error(), <span class="number">500</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">&#125; </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 调用服务</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//替换掉原有的服务名</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过服务名和</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">exampleClient := example.NewExampleService(<span class="string">"go.micro.srv.srv"</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">client.DefaultClient)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">rsp, err := exampleClient.Call(context.TODO(), &amp;example.Request&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">Name: request[<span class="string">"name"</span>].(<span class="keyword">string</span>),</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">http.Error(w, err.Error(), <span class="number">500</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">&#125; </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// we want to augment the response</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">response := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line"><span class="string">"msg"</span>: rsp.Msg,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">    <span class="string">"ref"</span>: time.Now().UnixNano(),</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">&#125; </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// encode and write the response as json</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> err := json.NewEncoder(w).Encode(response); err != <span class="literal">nil</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">43</span></pre></td><td class="code"><pre><span class="line">http.Error(w, err.Error(), <span class="number">500</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">44</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">45</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">46</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><h4 id="3-5-3-升级成为grpc的版本"><a href="#3-5-3-升级成为grpc的版本" class="headerlink" title="3.5.3 升级成为grpc的版本"></a>3.5.3 升级成为grpc的版本</h4><ul><li>重新生成proto文件、srv的main.go</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="string">"github.com/micro/go-log"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="string">"github.com/micro/go-micro"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="string">"micro/grpc/srv/handler"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="string">"micro/grpc/srv/subscriber"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    example <span class="string">"micro/grpc/srv/proto/example"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="string">"github.com/micro/go-grpc"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">) </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// New Service</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    service := grpc.NewService(</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    micro.Name(<span class="string">"go.micro.srv.srv"</span>),</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    micro.Version(<span class="string">"latest"</span>),</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">) </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// Initialise service</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">    service.Init()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// Register Handler</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">  example.RegisterExampleHandler(service.Server(),</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">new</span>(handler.Example))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// Register Struct as Subscriber</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">micro.RegisterSubscriber(<span class="string">"go.micro.srv.srv"</span>, service.Server(),</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">new</span>(subscriber.Example))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// Register Function as Subscriber</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">micro.RegisterSubscriber(<span class="string">"go.micro.srv.srv"</span>, service.Server(),</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">subscriber.Handler)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// Run service</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> err := service.Run(); err != <span class="literal">nil</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">log.Fatal(err)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><ul><li><p>srv的example.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> handler</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="string">"context"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="string">"github.com/micro/go-log"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    example <span class="string">"micro/grpc/srv/proto/example"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">) </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Example <span class="keyword">struct</span>&#123;&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// Call is a single request handler called via client.Call or the generated client code</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Example)</span> <span class="title">Call</span><span class="params">(ctx context.Context, req *example.Request, rsp *example.Response)</span> <span class="title">error</span></span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">log.Log(<span class="string">"Received Example.Call request"</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">rsp.Msg = <span class="string">"Hello "</span> + req.Name</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// Stream is a server side stream handler called via client.Stream or the generated client code</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Example)</span> <span class="title">Stream</span><span class="params">(ctx context.Context, req *example.StreamingRequest, stream example.Example_StreamStream)</span> <span class="title">error</span></span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">log.Logf(<span class="string">"Received Example.Stream request with count: %d"</span>, req.Count)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="keyword">int</span>(req.Count); i++ &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">log.Logf(<span class="string">"Responding: %d"</span>, i)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> err := stream.Send(&amp;example.StreamingResponse&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">Count: <span class="keyword">int64</span>(i),</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">&#125;); err != <span class="literal">nil</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> err</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">&#125; </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">&#125; </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// PingPong is a bidirectional stream handler called via client.Stream or the generated client code</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Example)</span> <span class="title">PingPong</span><span class="params">(ctx context.Context, stream</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="params">example.Example_PingPongStream)</span> <span class="title">error</span></span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">req, err := stream.Recv()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> err</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">&#125; </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line">    log.Logf(<span class="string">"Got ping %v"</span>, req.Stroke)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> err := stream.Send(&amp;example.Pong&#123;Stroke: req.Stroke&#125;); err != <span class="literal">nil</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> err</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">43</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">44</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">45</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure></li><li><p>修改web的main.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="string">"github.com/micro/go-log"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="string">"net/http"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="string">"github.com/micro/go-web"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="string">"micro/grpc/web/handler"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">) </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// create new web service</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    service := web.NewService(</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    web.Name(<span class="string">"go.micro.web.web"</span>),</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    web.Version(<span class="string">"latest"</span>),</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    web.Address(<span class="string">":8080"</span>),</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    )</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// initialise service</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> err := service.Init(); err != <span class="literal">nil</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">log.Fatal(err)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// register html handler</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">service.Handle(<span class="string">"/"</span>, http.FileServer(http.Dir(<span class="string">"html"</span>)))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// register call handler</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">service.HandleFunc(<span class="string">"/example/call"</span>, handler.ExampleCall)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// run service</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> err := service.Run(); err != <span class="literal">nil</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">log.Fatal(err)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure></li><li><p>修改web的handler.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> handler</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="string">"context"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="string">"encoding/json"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="string">"net/http"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="string">"time"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    example <span class="string">"micro/grpc/srv/proto/example"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    <span class="string">"github.com/micro/go-grpc"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">) </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExampleCall</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    server :=grpc.NewService()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    server.Init()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// decode the incoming request as json</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">var</span> request <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> err := json.NewDecoder(r.Body).Decode(&amp;request); err != <span class="literal">nil</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">http.Error(w, err.Error(), <span class="number">500</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">&#125; </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// call the backend service</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//exampleClient := example.NewExampleService("go.micro.srv.srv",client.DefaultClient)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">exampleClient := example.NewExampleService(<span class="string">"go.micro.srv.srv"</span>, server.Client())</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">rsp, err := exampleClient.Call(context.TODO(), &amp;example.Request&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">Name: request[<span class="string">"name"</span>].(<span class="keyword">string</span>),</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">   http.Error(w, err.Error(), <span class="number">500</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">&#125; </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// we want to augment the response</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">response := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line"><span class="string">"msg"</span>: rsp.Msg,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line"><span class="string">"ref"</span>: time.Now().UnixNano(),</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">&#125; </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// encode and write the response as json</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> err := json.NewEncoder(w).Encode(response); err != <span class="literal">nil</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line">http.Error(w, err.Error(), <span class="number">500</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">43</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure></li></ul><h2 id="4-关于插件化"><a href="#4-关于插件化" class="headerlink" title="4. 关于插件化"></a>4. 关于插件化</h2><p>Go Micro跟其他工具最大的不同是它是插件化的架构，这让上面每个包的具体实现都可以切换出去。举个例子，默认的服务发现的机制是通过Consul，但是如果想切换成<code>etcd</code>或者<code>zookeeper</code>或者任何你实现的方案，都是非常便利的</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;** Micro：** &amp;lt;Excerpt in index | 首页摘要&amp;gt;&lt;/p&gt;
&lt;p&gt;微服务之Micro&lt;/p&gt;
    
    </summary>
    
    
      <category term="microServices" scheme="https://alexbrucelu.github.io/categories/microServices/"/>
    
    
      <category term="微服务" scheme="https://alexbrucelu.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>深度理解“三次握手，四次挥手”</title>
    <link href="https://alexbrucelu.github.io/2019/12/09/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/"/>
    <id>https://alexbrucelu.github.io/2019/12/09/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/</id>
    <published>2019-12-09T07:14:27.742Z</published>
    <updated>2019-12-09T07:14:27.742Z</updated>
    
    <content type="html"><![CDATA[<p>** 深度理解“三次握手，四次挥手”：** &lt;Excerpt in index | 首页摘要&gt;</p><p>深度理解“三次握手，四次挥手”</p><a id="more"></a><p>[TOC]</p><p>作为程序员，要有刨根问底的精神。知其然，切知其所以然。</p><h2 id="什么是“三次握手，四次挥手”？"><a href="#什么是“三次握手，四次挥手”？" class="headerlink" title="什么是“三次握手，四次挥手”？"></a>什么是“三次握手，四次挥手”？</h2><p>TCP是一种面向连接的单播协议，在发送数据前，通信双方必须在彼此之间建立一条连接。所谓的“连接”，其实是客户端与服务器的内存里保存的一份关于对方的信息，譬如IP地址、端口号等。</p><p>TCP可以看成是一种字节流，它会处理IP层或以下层的丢包、重复以及错误问题。在连接的建立过程中，双方需要交换一些连接的参数。这些参数可以放在TCP的头部。</p><p>TCP提供了一种可靠、面向连接、字节流、传输层的服务，采用三次握手建立一个连接。采用四次挥手来关闭一个连接。</p><h3 id="TCP服务模型"><a href="#TCP服务模型" class="headerlink" title="TCP服务模型"></a>TCP服务模型</h3><p>在了解建立连接、关闭连接的“三次握手、四次挥手”后，我们需要了解下TCP相关的东西。</p><p>一个TCP连接是由一个4元组构成的，分别是两个IP地址和两个端口号。一个TCP连接通常会分为三个阶段：启动、数据传输、退出（关闭）。</p><p>当TCP接收到另一端的数据时，它会发送一个确认，但这个确认不会立即发送，一般会延迟一会儿。ACK是累积的，一个确认字节号N的ACK表示所有直到N的字节（不包括N）已经成功被接收了。这样的好处是如果一个ACK丢失，很可能后续的ACK就足以确认前面的报文段了。</p><p>一个完整的TCP连接是双向和对称的，数据可以在两个方向上平等地流动。给上层应用程序提供一种<code>双工服务</code>。一旦建立了一个连接，这个连接的一个方向上的每个TCP报文段都包含了相反方向上的报文段的一个ACK。</p><p>序列号的作用是使得一个TCP接收端可丢弃重复的报文段，记录以杂乱次序到达的报文段。因为TCP使用IP来传输报文段，而IP不提供重复消除或者保证次序正确的功能。另一方面，TCP是一个字节流协议，绝不会以杂乱的次序给上层程序发送数据。因此TCP接收端会被迫先保持大序列号的数据不交给应用程序，直到缺失的小序列号的报文段被填满。</p><h3 id="TCP头部"><a href="#TCP头部" class="headerlink" title="TCP头部"></a>TCP头部</h3><p><img src="http://upload-images.jianshu.io/upload_images/12234098-40089b5b24b9d38b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>源端口和目的端口在TCP层确定双方进程，序列号表示的是报文段数据中的第一个字节号，ACK表示确认号，该确认号的发送方期待接收的下一个序列号，即最后被成功接收的数据字节序列号加1，这个字段只有在ACK位被启用的时候才有效。</p><p>当新建一个连接时，从客户端发送到服务端的第一个报文段的SYN位被启用，这称为SYN报文段，这时序列号字段包含了在本次连接的这个方向上要使用的第一个序列号，即初始序列号<code>ISN</code>，之后发送的数据是ISN加1，因此SYN位字段会<code>消耗</code>一个序列号，这意味着使用重传进行可靠传输。而不消耗序列号的ACK则不是。</p><p>头部长度（图中的数据偏移）以32位字为单位，也就是以4bytes为单位，它只有4位，最大为15，因此头部最大长度为60字节，而其最小为5，也就是头部最小为20字节（可变选项为空）。</p><p>ACK —— 确认，使得确认号有效。</p><p>RST —— 重置连接（经常看到的reset by peer）就是此字段搞的鬼。 </p><p>SYN —— 用于初如化一个连接的序列号。 </p><p>FIN —— 该报文段的发送方已经结束向对方发送数据。</p><p>当一个连接被建立或被终止时，交换的报文段只包含TCP头部，而没有数据。</p><h3 id="状态转换"><a href="#状态转换" class="headerlink" title="状态转换"></a>状态转换</h3><p>三次握手和四次挥手的状态转换如下图。</p><p><img src="http://upload-images.jianshu.io/upload_images/12234098-40f65020a755ca18?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h2 id="为什么要“三次握手，四次挥手”？"><a href="#为什么要“三次握手，四次挥手”？" class="headerlink" title="为什么要“三次握手，四次挥手”？"></a>为什么要“三次握手，四次挥手”？</h2><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p>换个易于理解的视角来看为什么要3次握手。</p><p>客户端和服务端通信前要进行连接，“3次握手”的作用就是<code>双方都能明确自己和对方的收、发能力是正常的</code>。</p><p><code>第一次握手</code>：客户端发送网络包，服务端收到了。这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。</p><p><code>第二次握手</code>：服务端发包，客户端收到了。这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。<br>从客户端的视角来看，我接到了服务端发送过来的响应数据包，说明服务端接收到了我在第一次握手时发送的网络包，并且成功发送了响应数据包，这就说明，服务端的接收、发送能力正常。而另一方面，我收到了服务端的响应数据包，说明我第一次发送的网络包成功到达服务端，这样，我自己的发送和接收能力也是正常的。</p><p><code>第三次握手</code>：客户端发包，服务端收到了。这样服务端就能得出结论：客户端的接收、发送能力，服务端的发送、接收能力是正常的。<br>第一、二次握手后，服务端并不知道客户端的接收能力以及自己的发送能力是否正常。而在第三次握手时，服务端收到了客户端对第二次握手作的回应。从服务端的角度，我在第二次握手时的响应数据发送出去了，客户端接收到了。所以，我的发送能力是正常的。而客户端的接收能力也是正常的。</p><p>经历了上面的三次握手过程，客户端和服务端都确认了自己的接收、发送能力是正常的。之后就可以正常通信了。</p><p>每次都是接收到数据包的一方可以得到一些结论，发送的一方其实没有任何头绪。我虽然有发包的动作，但是我怎么知道我有没有发出去，而对方有没有接收到呢？</p><p>而从上面的过程可以看到，最少是需要三次握手过程的。两次达不到让双方都得出自己、对方的接收、发送能力都正常的结论。其实每次收到网络包的一方至少是可以得到：对方的发送、我方的接收是正常的。而每一步都是有关联的，下一次的“响应”是由于第一次的“请求”触发，因此每次握手其实是可以得到额外的结论的。比如第三次握手时，服务端收到数据包，表明看服务端只能得到客户端的发送能力、服务端的接收能力是正常的，但是结合第二次，说明服务端在第二次发送的响应包，客户端接收到了，并且作出了响应，从而得到额外的结论：客户端的接收、服务端的发送是正常的。</p><p>用表格总结一下：</p><table><thead><tr><th>视角</th><th>客收</th><th>客发</th><th>服收</th><th>服发</th></tr></thead><tbody><tr><td>客视角</td><td>二</td><td>一 + 二</td><td>一 + 二</td><td>二</td></tr><tr><td>服视角</td><td>二 + 三</td><td>一</td><td>一</td><td>二 + 三</td></tr></tbody></table><h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p>TCP连接是双向传输的对等的模式，就是说双方都可以同时向对方发送或接收数据。当有一方要关闭连接时，会发送指令告知对方，我要关闭连接了。这时对方会回一个ACK，此时一个方向的连接关闭。但是另一个方向仍然可以继续传输数据，等到发送完了所有的数据后，会发送一个FIN段来关闭此方向上的连接。接收方发送ACK确认关闭连接。注意，接收到FIN报文的一方只能回复一个ACK, 它是无法马上返回对方一个FIN报文段的，因为结束数据传输的“指令”是上层应用层给出的，我只是一个“搬运工”，我无法了解<code>“上层的意志”</code>。</p><h2 id="“三次握手，四次挥手”怎么完成？"><a href="#“三次握手，四次挥手”怎么完成？" class="headerlink" title="“三次握手，四次挥手”怎么完成？"></a>“三次握手，四次挥手”怎么完成？</h2><p>其实3次握手的目的并不只是让通信双方都了解到一个连接正在建立，还在于利用数据包的选项来传输特殊的信息，交换初始序列号ISN。</p><p>3次握手是指发送了3个报文段，4次挥手是指发送了4个报文段。注意，SYN和FIN段都是会利用重传进行可靠传输的。</p><p><img src="http://upload-images.jianshu.io/upload_images/12234098-8604b533d42457b5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="三次握手"></p><h3 id="三次握手-1"><a href="#三次握手-1" class="headerlink" title="三次握手"></a>三次握手</h3><ol><li>客户端发送一个SYN段，并指明客户端的初始序列号，即ISN(c).</li><li>服务端发送自己的SYN段作为应答，同样指明自己的ISN(s)。为了确认客户端的SYN，将ISN(c)+1作为ACK数值。这样，每发送一个SYN，序列号就会加1. 如果有丢失的情况，则会重传。</li><li>为了确认服务器端的SYN，客户端将ISN(s)+1作为返回的ACK数值。</li></ol><h3 id="四次挥手-1"><a href="#四次挥手-1" class="headerlink" title="四次挥手"></a>四次挥手</h3><p><img src="http://upload-images.jianshu.io/upload_images/12234098-3754de754cbcf2af.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="四次挥手"></p><ol><li>客户端发送一个FIN段，并包含一个希望接收者看到的自己当前的序列号K. 同时还包含一个ACK表示确认对方最近一次发过来的数据。</li><li>服务端将K值加1作为ACK序号值，表明收到了上一个包。这时上层的应用程序会被告知另一端发起了关闭操作，通常这将引起应用程序发起自己的关闭操作。</li><li>服务端发起自己的FIN段，ACK=K+1, Seq=L</li><li>客户端确认。ACK=L+1</li></ol><h3 id="为什么建立连接是“三次握手”，而关闭连接是“四次挥手”呢？"><a href="#为什么建立连接是“三次握手”，而关闭连接是“四次挥手”呢？" class="headerlink" title="为什么建立连接是“三次握手”，而关闭连接是“四次挥手”呢？"></a>为什么建立连接是“三次握手”，而关闭连接是“四次挥手”呢？</h3><p>这是因为服务端在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。而关闭连接时，当收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，己方是否现在关闭发送数据通道，需要上层应用来决定，因此，己方ACK和FIN一般都会分开发送。</p><h2 id="“三次握手，四次挥手”进阶"><a href="#“三次握手，四次挥手”进阶" class="headerlink" title="“三次握手，四次挥手”进阶"></a>“三次握手，四次挥手”进阶</h2><h3 id="ISN"><a href="#ISN" class="headerlink" title="ISN"></a>ISN</h3><p>三次握手的一个重要功能是客户端和服务端交换ISN(Initial Sequence Number), 以便让对方知道接下来接收数据的时候如何按序列号组装数据。</p><p>如果ISN是固定的，攻击者很容易猜出后续的确认号。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">ISN &#x3D; M + F(localhost, localport, remotehost, remoteport)</span></pre></td></tr></table></figure><p>M是一个计时器，每隔4微秒加1。<br>F是一个Hash算法，根据源IP、目的IP、源端口、目的端口生成一个随机数值。要保证hash算法不能被外部轻易推算得出。</p><h3 id="序列号回绕"><a href="#序列号回绕" class="headerlink" title="序列号回绕"></a>序列号回绕</h3><p>因为ISN是随机的，所以序列号容易就会超过2^31-1. 而tcp对于丢包和乱序等问题的判断都是依赖于序列号大小比较的。此时就出现了所谓的tcp序列号回绕（sequence wraparound）问题。怎么解决？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">* The next routines deal with comparing 32 bit unsigned ints</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment">* and worry about wraparound (automatic with unsigned arithmetic).</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="comment">*/</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">before</span><span class="params">(__u32 seq1, __u32 seq2)</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> (__s32)(seq1-seq2) &lt; <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> after(seq2, seq1) before(seq1, seq2)</span></span></pre></td></tr></table></figure><p>上述代码是内核中的解决回绕问题代码。<strong>s32是有符号整型的意思，而</strong>u32则是无符号整型。序列号发生回绕后，序列号变小，相减之后，把结果变成有符号数了，因此结果成了负数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">假设seq1&#x3D;255， seq2&#x3D;1（发生了回绕）。</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">seq1 &#x3D; 1111 1111 seq2 &#x3D; 0000 0001</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">我们希望比较结果是</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"> seq1 - seq2&#x3D;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"> 1111 1111</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">-0000 0001</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">-----------</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"> 1111 1110</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">由于我们将结果转化成了有符号数，由于最高位是1，因此结果是一个负数，负数的绝对值为</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"> 0000 0001 + 1 &#x3D; 0000 0010 &#x3D; 2</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">因此seq1 - seq2 &lt; 0</span></pre></td></tr></table></figure><h3 id="syn-flood攻击"><a href="#syn-flood攻击" class="headerlink" title="syn flood攻击"></a>syn flood攻击</h3><p>最基本的DoS攻击就是利用合理的服务请求来占用过多的服务资源，从而使合法用户无法得到服务的响应。syn flood属于Dos攻击的一种。</p><p>如果恶意的向某个服务器端口发送大量的SYN包，则可以使服务器打开大量的半开连接，分配TCB（Transmission Control Block）, 从而消耗大量的服务器资源，同时也使得正常的连接请求无法被相应。当开放了一个TCP端口后，该端口就处于Listening状态，不停地监视发到该端口的Syn报文，一 旦接收到Client发来的Syn报文，就需要为该请求分配一个TCB，通常一个TCB至少需要280个字节，在某些操作系统中TCB甚至需要1300个字节，并返回一个SYN ACK命令，立即转为SYN-RECEIVED即半开连接状态。系统会为此耗尽资源。</p><p>常见的防攻击方法有：</p><h4 id="无效了解的监视释放"><a href="#无效了解的监视释放" class="headerlink" title="无效了解的监视释放"></a>无效了解的监视释放</h4><p>监视系统的半开连接和不活动连接，当达到一定阈值时拆除这些连接，从而释放系统资源。这种方法对于所有的连接一视同仁，而且由于SYN Flood造成的半开连接数量很大，正常连接请求也被淹没在其中被这种方式误释放掉，因此这种方法属于入门级的SYN Flood方法。</p><h4 id="延缓TCB分配方法"><a href="#延缓TCB分配方法" class="headerlink" title="延缓TCB分配方法"></a>延缓TCB分配方法</h4><p>消耗服务器资源主要是因为当SYN数据报文一到达，系统立即分配TCB，从而占用了资源。而SYN Flood由于很难建立起正常连接，因此，当正常连接建立起来后再分配TCB则可以有效地减轻服务器资源的消耗。常见的方法是使用Syn Cache和Syn Cookie技术。</p><h5 id="Syn-Cache技术"><a href="#Syn-Cache技术" class="headerlink" title="Syn Cache技术"></a>Syn Cache技术</h5><p>系统在收到一个SYN报文时，在一个专用HASH表中保存这种半连接信息，直到收到正确的回应ACK报文再分配TCB。这个开销远小于TCB的开销。当然还需要保存序列号。</p><h5 id="Syn-Cookie技术"><a href="#Syn-Cookie技术" class="headerlink" title="Syn Cookie技术"></a>Syn Cookie技术</h5><p>Syn Cookie技术则完全不使用任何存储资源，这种方法比较巧妙，它使用一种特殊的算法生成Sequence Number，这种算法考虑到了对方的IP、端口、己方IP、端口的固定信息，以及对方无法知道而己方比较固定的一些信息，如MSS(Maximum Segment Size，最大报文段大小，指的是TCP报文的最大数据报长度，其中不包括TCP首部长度。)、时间等，在收到对方 的ACK报文后，重新计算一遍，看其是否与对方回应报文中的（Sequence Number-1）相同，从而决定是否分配TCB资源。</p><h4 id="使用SYN-Proxy防火墙"><a href="#使用SYN-Proxy防火墙" class="headerlink" title="使用SYN Proxy防火墙"></a>使用SYN Proxy防火墙</h4><p>一种方式是防止墙dqywb连接的有效性后，防火墙才会向内部服务器发起SYN请求。防火墙代服务器发出的SYN ACK包使用的序列号为c, 而真正的服务器回应的序列号为c’, 这样，在每个数据报文经过防火墙的时候进行序列号的修改。另一种方式是防火墙确定了连接的安全后，会发出一个safe reset命令，client会进行重新连接，这时出现的syn报文会直接放行。这样不需要修改序列号了。但是，client需要发起两次握手过程，因此建立连接的时间将会延长。</p><h3 id="连接队列"><a href="#连接队列" class="headerlink" title="连接队列"></a>连接队列</h3><p>在外部请求到达时，被服务程序最终感知到前，连接可能处于SYN_RCVD状态或是ESTABLISHED状态，但还未被应用程序接受。</p><p><img src="http://upload-images.jianshu.io/upload_images/12234098-36b3c46688c685c7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="tcp queue"></p><p>对应地，服务器端也会维护两种队列，处于SYN_RCVD状态的半连接队列，而处于ESTABLISHED状态但仍未被应用程序accept的为全连接队列。如果这两个队列满了之后，就会出现各种丢包的情形。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看是否有连接溢出</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">netstat -s | grep LISTEN</span></pre></td></tr></table></figure><h4 id="半连接队列满了"><a href="#半连接队列满了" class="headerlink" title="半连接队列满了"></a>半连接队列满了</h4><p>在三次握手协议中，服务器维护一个半连接队列，该队列为每个客户端的SYN包开设一个条目(服务端在接收到SYN包的时候，就已经创建了request_sock结构，存储在半连接队列中)，该条目表明服务器已收到SYN包，并向客户发出确认，正在等待客户的确认包。这些条目所标识的连接在服务器处于Syn_RECV状态，当服务器收到客户的确认包时，删除该条目，服务器进入ESTABLISHED状态。</p><blockquote><p>目前，Linux下默认会进行5次重发SYN-ACK包，重试的间隔时间从1s开始，下次的重试间隔时间是前一次的双倍，5次的重试时间间隔为1s, 2s, 4s, 8s, 16s, 总共31s, 称为<code>指数退避</code>，第5次发出后还要等32s才知道第5次也超时了，所以，总共需要 1s + 2s + 4s+ 8s+ 16s + 32s = 63s, TCP才会把断开这个连接。由于，SYN超时需要63秒，那么就给攻击者一个攻击服务器的机会，攻击者在短时间内发送大量的SYN包给Server(俗称SYN flood攻击)，用于耗尽Server的SYN队列。对于应对SYN 过多的问题，linux提供了几个TCP参数：tcp_syncookies、tcp_synack_retries、tcp_max_syn_backlog、tcp_abort_on_overflow 来调整应对。</p></blockquote><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>tcp_syncookies</td><td>SYNcookie将连接信息编码在ISN(initialsequencenumber)中返回给客户端，这时server不需要将半连接保存在队列中，而是利用客户端随后发来的ACK带回的ISN还原连接信息，以完成连接的建立，避免了半连接队列被攻击SYN包填满。</td></tr><tr><td>tcp_syncookies</td><td>内核放弃建立连接之前发送SYN包的数量。</td></tr><tr><td>tcp_synack_retries</td><td>内核放弃连接之前发送SYN+ACK包的数量</td></tr><tr><td>tcp_max_syn_backlog</td><td>默认为1000. 这表示半连接队列的长度，如果超过则放弃当前连接。</td></tr><tr><td>tcp_abort_on_overflow</td><td>如果设置了此项，则直接reset. 否则，不做任何操作，这样当服务器半连接队列有空了之后，会重新接受连接。<code>Linux坚持在能力许可范围内不忽略进入的连接</code>。客户端在这期间会重复发送sys包，当重试次数到达上限之后，会得到<code>connection time out</code>响应。</td></tr></tbody></table><h4 id="全连接队列满了"><a href="#全连接队列满了" class="headerlink" title="全连接队列满了"></a>全连接队列满了</h4><p>当第三次握手时，当server接收到ACK包之后，会进入一个新的叫 accept 的队列。</p><p>当accept队列满了之后，即使client继续向server发送ACK的包，也会不被响应，此时ListenOverflows+1，同时server通过tcp_abort_on_overflow来决定如何返回，0表示直接丢弃该ACK，1表示发送RST通知client；相应的，client则会分别返回<code>read timeout</code> 或者 <code>connection reset by peer</code>。另外，tcp_abort_on_overflow是0的话，server过一段时间再次发送syn+ack给client（也就是重新走握手的第二步），如果client超时等待比较短，就很容易异常了。而客户端收到多个 SYN ACK 包，则会认为之前的 ACK 丢包了。于是促使客户端再次发送 ACK ，在 accept队列有空闲的时候最终完成连接。若 accept队列始终满员，则最终客户端收到 RST 包（此时服务端发送syn+ack的次数超出了tcp_synack_retries）。</p><p>服务端仅仅只是创建一个定时器，以固定间隔重传syn和ack到服务端</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>tcp_abort_on_overflow</td><td>如果设置了此项，则直接reset. 否则，不做任何操作，这样当服务器半连接队列有空了之后，会重新接受连接。<code>Linux坚持在能力许可范围内不忽略进入的连接</code>。客户端在这期间会重复发送sys包，当重试次数到达上限之后，会得到<code>connection time out</code>响应。</td></tr><tr><td>min(backlog, somaxconn)</td><td>全连接队列的长度。</td></tr></tbody></table><h4 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h4><p>netstat -s命令</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">[root@server ~]<span class="comment">#  netstat -s | egrep "listen|LISTEN" </span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">667399 <span class="built_in">times</span> the listen queue of a socket overflowed</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">667399 SYNs to LISTEN sockets ignored</span></pre></td></tr></table></figure><p>上面看到的 667399 times ，表示全连接队列溢出的次数，隔几秒钟执行下，如果这个数字一直在增加的话肯定全连接队列偶尔满了。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">[root@server ~]<span class="comment">#  netstat -s | grep TCPBacklogDrop</span></span></pre></td></tr></table></figure><p>查看 Accept queue 是否有溢出</p><p>ss命令</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">[root@server ~]<span class="comment">#  ss -lnt</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">State Recv-Q Send-Q Local Address:Port Peer Address:Port</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">LISTEN     0      128 *:6379 *:*</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">LISTEN     0      128 *:22 *:*</span></pre></td></tr></table></figure><p>如果State是listen状态，Send-Q 表示第三列的listen端口上的全连接队列最大为50，第一列Recv-Q为全连接队列当前使用了多少。<br>非 LISTEN 状态中 Recv-Q 表示 receive queue 中的 bytes 数量；Send-Q 表示 send queue 中的 bytes 数值。</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>当外部连接请求到来时，TCP模块会首先查看max_syn_backlog，如果处于SYN_RCVD状态的连接数目超过这一阈值，进入的连接会被拒绝。根据tcp_abort_on_overflow字段来决定是直接丢弃，还是直接reset.</p><p>从服务端来说，三次握手中，第一步server接受到client的syn后，把相关信息放到半连接队列中，同时回复syn+ack给client. 第三步当收到客户端的ack, 将连接加入到全连接队列。</p><p>一般，全连接队列比较小，会先满，此时半连接队列还没满。如果这时收到syn报文，则会进入半连接队列，没有问题。但是如果收到了三次握手中的第3步(ACK)，则会根据tcp_abort_on_overflow字段来决定是直接丢弃，还是直接reset.此时，客户端发送了ACK, 那么客户端认为三次握手完成，它认为服务端已经准备好了接收数据的准备。但此时服务端可能因为全连接队列满了而无法将连接放入，会重新发送第2步的syn+ack, 如果这时有数据到来，服务器TCP模块会将数据存入队列中。一段时间后，client端没收到回复，超时，连接异常，client会主动关闭连接。</p><h2 id="“三次握手，四次挥手”Redis实例分析"><a href="#“三次握手，四次挥手”Redis实例分析" class="headerlink" title="“三次握手，四次挥手”Redis实例分析"></a>“三次握手，四次挥手”Redis实例分析</h2><ol><li>我在dev机器上部署redis服务，端口号为6379,</li><li>通过tcpdump工具获取数据包，使用如下命令</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">tcpdump -w /tmp/a.cap port 6379 -s0</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># -w把数据写入文件，-s0设置每个数据包的大小默认为68字节，如果用-S 0则会抓到完整数据包</span></span></pre></td></tr></table></figure><ol><li>在dev2机器上用redis-cli访问dev:6379, 发送一个ping, 得到回复pong</li><li>停止抓包，用tcpdump读取捕获到的数据包</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">tcpdump -r /tmp/a.cap -n -nn -A -x| vim -</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#（-x 以16进制形式展示，便于后面分析）</span></span></pre></td></tr></table></figure><p>共收到了7个包。</p><p>抓到的是IP数据包，IP数据包分为IP头部和IP数据部分，IP数据部分是TCP头部加TCP数据部分。</p><p>IP的数据格式为：<br><img src="http://upload-images.jianshu.io/upload_images/12234098-e6b04f3e9bebdac4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ip head"><br>它由固定长度20B+可变长度构成。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">10:55:45.662077 IP dev2.39070 &gt; dev.6379: Flags [S], seq 4133153791, win 29200, options [mss 1460,sackOK,TS val 2959270704 ecr 0,nop,wscale 7], length 0</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">        0x0000:  4500 003c 08cf 4000 3606 14a5 0ab3 b561</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        0x0010:  0a60 5cd4 989e 18eb f65a ebff 0000 0000</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        0x0020:  a002 7210 872f 0000 0204 05b4 0402 080a</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        0x0030:  b062 e330 0000 0000 0103 0307</span></pre></td></tr></table></figure><p>对着IP头部格式，来拆解数据包的具体含义。</p><table><thead><tr><th>字节值</th><th>字节含义</th></tr></thead><tbody><tr><td>0x4</td><td>IP版本为ipv4</td></tr><tr><td>0x5</td><td>首部长度为5 * 4字节=20B</td></tr><tr><td>0x00</td><td>服务类型，现在基本都置为0</td></tr><tr><td>0x003c</td><td>总长度为3*16+12=60字节，上面所有的长度就是60字节</td></tr><tr><td>0x08cf</td><td>标识。同一个数据报的唯一标识。当IP数据报被拆分时，会复制到每一个数据中。</td></tr><tr><td>0x4000</td><td><code>3bit 标志 + 13bit 片偏移</code>。3bit 标志对应 R、DF、MF。目前只有后两位有效，DF位：为1表示不分片，为0表示分片。MF：为1表示“更多的片”，为0表示这是最后一片。13bit 片位移：本分片在原先数据报文中相对首位的偏移位。（需要再乘以8 )</td></tr><tr><td>0x36</td><td>生存时间TTL。IP报文所允许通过的路由器的最大数量。每经过一个路由器，TTL减1，当为 0 时，路由器将该数据报丢弃。TTL 字段是由发送端初始设置一个 8 bit字段.推荐的初始值由分配数字 RFC 指定。发送 ICMP 回显应答时经常把 TTL 设为最大值 255。TTL可以防止数据报陷入路由循环。 此处为54.</td></tr><tr><td>0x06</td><td>协议类型。指出IP报文携带的数据使用的是哪种协议，以便目的主机的IP层能知道要将数据报上交到哪个进程。TCP 的协议号为6，UDP 的协议号为17。ICMP 的协议号为1，IGMP 的协议号为2。该 IP 报文携带的数据使用 TCP 协议，得到了验证。</td></tr><tr><td>0x14a5</td><td>16bitIP首部校验和。</td></tr><tr><td>0x0ab3 b561</td><td>32bit源ip地址。</td></tr><tr><td>0x0a60 5cd4</td><td>32bit目的ip地址。</td></tr></tbody></table><p>剩余的数据部分即为TCP协议相关的。TCP也是20B固定长度+可变长度部分。</p><table><thead><tr><th>字节值</th><th>字节含义</th></tr></thead><tbody><tr><td>0x989e</td><td>16bit源端口。1<em>16</em>16<em>16+8</em>16<em>16+14</em>16+11=39070</td></tr><tr><td>0x18eb</td><td>16bit目的端口6379</td></tr><tr><td>0xf65a ebff</td><td>32bit序列号。4133153791</td></tr><tr><td>0x0000 0000</td><td>32bit确认号。</td></tr><tr><td>0xa</td><td>4bit首部长度，以4byte为单位。共10*4=40字节。因此TCP报文的可选长度为40-20=20</td></tr><tr><td>0b000000</td><td>6bit保留位。目前置为0.</td></tr><tr><td>0b000010</td><td>6bitTCP标志位。从左到右依次是紧急 URG、确认 ACK、推送 PSH、复位 RST、同步 SYN 、终止 FIN。</td></tr><tr><td>0x7210</td><td>滑动窗口大小，滑动窗口即tcp接收缓冲区的大小，用于tcp拥塞控制。29200</td></tr><tr><td>0x872f</td><td>16bit校验和。</td></tr><tr><td>0x0000</td><td>紧急指针。仅在 URG = 1时才有意义，它指出本报文段中的紧急数据的字节数。当 URG = 1 时，发送方 TCP 就把紧急数据插入到本报文段数据的最前面，而在紧急数据后面的数据仍是普通数据。</td></tr></tbody></table><p>可变长度部分，协议如下：</p><table><thead><tr><th>字节值</th><th>字节含义</th></tr></thead><tbody><tr><td>0x0204 05b4</td><td>最大报文长度为，05b4=1460. 即可接收的最大包长度，通常为MTU减40字节，IP头和TCP头各20字节</td></tr><tr><td>0x0402</td><td>表示支持SACK</td></tr><tr><td>0x080a b062 e330 0000 0000</td><td>时间戳。Ts val=b062 e330=2959270704, ecr=0</td></tr><tr><td>0x01</td><td>无操作</td></tr><tr><td>0x03 0307</td><td>窗口扩大因子为7. 移位7, 乘以128</td></tr></tbody></table><p>这样第一个包分析完了。dev2向dev发送SYN请求。<code>也就是三次握手中的第一次了。</code><br><code>SYN seq(c)=4133153791</code></p><p>第二个包，dev响应连接，ack=4133153792. 表明dev下次准备接收这个序号的包，用于tcp字节注的顺序控制。dev（也就是server端）的初始序号为seq=4264776963, syn=1.<br><code>SYN ack=seq(c)+1 seq(s)=4264776963</code></p><p>第三个包，client包确认，这里使用了相对值应答。seq=4133153792, 等于第二个包的ack. ack=4264776964.<br><code>ack=seq(s)+1, seq=seq(c)+1</code><br>至此，三次握手完成。接下来就是发送ping和pong的数据了。</p><p>接着第四个包。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">10:55:48.090073 IP dev2.39070 &gt; dev.6379: Flags [P.], seq 1:15, ack 1, win 229, options [nop,nop,TS val 2959273132 ecr 3132256230], length 14</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">        0x0000:  4500 0042 08d1 4000 3606 149d 0ab3 b561</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        0x0010:  0a60 5cd4 989e 18eb f65a ec00 fe33 5504</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        0x0020:  8018 00e5 4b5f 0000 0101 080a b062 ecac</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        0x0030:  bab2 6fe6 2a31 0d0a 2434 0d0a 7069 6e67</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        0x0040:  0d0a</span></pre></td></tr></table></figure><p>tcp首部长度为32B, 可选长度为12B. IP报文的总长度为66B, 首部长度为20B, 因此TCP数据部分长度为14B. seq=0xf65a ec00=4133153792<br>ACK, PSH. 数据部分为2a31 0d0a 2434 0d0a 7069 6e67 0d0a</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">0x2a31         -&gt; *1</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">0x0d0a         -&gt; \r\n</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">0x2434         -&gt; $4</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">0x0d0a         -&gt; \r\n</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">0x7069 0x6e67  -&gt; ping</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">0x0d0a         -&gt; \r\n</span></pre></td></tr></table></figure><p>dev2向dev发送了ping数据，第四个包完毕。</p><p>第五个包，dev2向dev发送ack响应。<br>序列号为0xfe33 5504=4264776964, ack确认号为0xf65a ec0e=4133153806=(4133153792+14).</p><p>第六个包，dev向dev2响应pong消息。序列号fe33 5504，确认号f65a ec0e, TCP头部可选长度为12B, IP数据报总长度为59B, 首部长度为20B, 因此TCP数据长度为7B.<br>数据部分2b50 4f4e 470d 0a, 翻译过来就是<code>+PONG\r\n</code>.</p><p>至此，Redis客户端和Server端的三次握手过程分析完毕。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>“三次握手，四次挥手”看似简单，但是深究进去，还是可以延伸出很多知识点的。比如半连接队列、全连接队列等等。以前关于TCP建立连接、关闭连接的过程很容易就会忘记，可能是因为只是死记硬背了几个过程，没有深入研究背后的原理。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://segmentfault.com/a/1190000015044878" target="_blank" rel="noopener">Redis</a></li><li><a href="https://blog.csdn.net/wdscq1234/article/details/52423272" target="_blank" rel="noopener">tcp option</a></li><li><a href="https://www.zhihu.com/question/32255109" target="_blank" rel="noopener">滑动窗口</a></li><li><a href="http://jm.taobao.org/2017/05/25/525-1/" target="_blank" rel="noopener">全连接队列</a></li><li><a href="https://github.com/torvalds/linux/commit/5ea8ea2cb7f1d0db15762c9b0bb9e7330425a071" target="_blank" rel="noopener">client fooling</a></li><li><a href="http://blog.51cto.com/59090939/1947443" target="_blank" rel="noopener">backlog RECV_Q</a></li><li><a href="https://www.cnblogs.com/menghuanbiao/p/5212131.html" target="_blank" rel="noopener">定时器</a></li><li><a href="https://www.itcodemonkey.com/article/5834.html" target="_blank" rel="noopener">队列图示</a></li><li><a href="https://www.cnblogs.com/hubavyn/p/4477883.html" target="_blank" rel="noopener">tcp flood攻击</a></li><li><a href="https://blog.csdn.net/LoseInVain/article/details/53694265" target="_blank" rel="noopener">MSS MTU</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;** 深度理解“三次握手，四次挥手”：** &amp;lt;Excerpt in index | 首页摘要&amp;gt;&lt;/p&gt;
&lt;p&gt;深度理解“三次握手，四次挥手”&lt;/p&gt;
    
    </summary>
    
    
      <category term="TCP通信" scheme="https://alexbrucelu.github.io/categories/TCP%E9%80%9A%E4%BF%A1/"/>
    
    
      <category term="TCP" scheme="https://alexbrucelu.github.io/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>函数式编程</title>
    <link href="https://alexbrucelu.github.io/2019/12/09/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    <id>https://alexbrucelu.github.io/2019/12/09/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</id>
    <published>2019-12-09T07:14:27.742Z</published>
    <updated>2019-12-09T07:14:27.742Z</updated>
    
    <content type="html"><![CDATA[<p>** 函数式编程：** &lt;Excerpt in index | 首页摘要&gt;</p><p>go语言养成记之函数式编程</p><a id="more"></a><p>[TOC]</p><h1 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h1><h2 id="1-函数与闭包"><a href="#1-函数与闭包" class="headerlink" title="1. 函数与闭包"></a>1. 函数与闭包</h2><p>函数可以作为参数、返回值、和变量</p><ul><li><p>“正统”函数式编程</p><ul><li>不可变性：不能有状态，只有常量和函数</li><li>函数只能有一个参数</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">improt <span class="string">"fmt"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">adder</span><span class="params">()</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>)</span> <span class="title">int</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    sum := <span class="number">0</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(v <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        sum += v</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> sum</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//以下是传统方式函数式编程</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//type iAdder func(int) (int,iAdder)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//func adder2(base int) iAdder &#123;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//    return func(v int) (int, iAdder) &#123;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//        return base + v, adder2(base + v)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//    &#125;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//&#125;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">    a := adder()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++ &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">        fmt.Printf(<span class="string">"0 + ... + %d = %d"</span>,i,a(i))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>函数体有局部变量</p><p>斐波那契数列</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fibonacci</span><span class="params">()</span> <span class="title">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    a,b := <span class="number">0</span>,<span class="number">1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        a,b = b,a+b</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> a</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure></li></ul><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;** 函数式编程：** &amp;lt;Excerpt in index | 首页摘要&amp;gt;&lt;/p&gt;
&lt;p&gt;go语言养成记之函数式编程&lt;/p&gt;
    
    </summary>
    
    
      <category term="golang" scheme="https://alexbrucelu.github.io/categories/golang/"/>
    
    
      <category term="golang" scheme="https://alexbrucelu.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>内建容器</title>
    <link href="https://alexbrucelu.github.io/2019/12/09/%E5%86%85%E5%BB%BA%E5%AE%B9%E5%99%A8/"/>
    <id>https://alexbrucelu.github.io/2019/12/09/%E5%86%85%E5%BB%BA%E5%AE%B9%E5%99%A8/</id>
    <published>2019-12-09T07:14:27.742Z</published>
    <updated>2019-12-09T07:14:27.742Z</updated>
    
    <content type="html"><![CDATA[<p>** 内建容器：** &lt;Excerpt in index | 首页摘要&gt;</p><p>go语言养成记之内建容器</p><a id="more"></a><h2 id="1-数组-Array"><a href="#1-数组-Array" class="headerlink" title="1. 数组 Array"></a>1. 数组 Array</h2><h3 id="1-1-为什么使用数组"><a href="#1-1-为什么使用数组" class="headerlink" title="1.1 为什么使用数组"></a>1.1 为什么使用数组</h3><ul><li>传统的方法不利于数据管理与维护，使用数组也容易扩展数据。</li><li><strong>注：</strong><font color="red">Go语言中的数组是之拷贝的传递</font></li></ul><h3 id="1-2-数组的四种初始化方法"><a href="#1-2-数组的四种初始化方法" class="headerlink" title="1.2 数组的四种初始化方法"></a>1.2 数组的四种初始化方法</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">arr := [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr [<span class="number">3</span>]<span class="keyword">int</span> = [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">arr := [...]<span class="keyword">int</span>&#123;<span class="number">8</span>,<span class="number">9</span>,<span class="number">7</span>&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">arr := [...]<span class="keyword">int</span>&#123;<span class="number">1</span>:<span class="number">800</span>,<span class="number">2</span>:<span class="number">1000</span>,<span class="number">3</span>:<span class="number">900</span>&#125;</span></pre></td></tr></table></figure><h3 id="1-3-数组的遍历"><a href="#1-3-数组的遍历" class="headerlink" title="1.3 数组的遍历"></a>1.3 数组的遍历</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> index,value := <span class="keyword">range</span> arr&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    ...</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> index := <span class="keyword">range</span> arr&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    ...</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>注：1. index 为数组元素的下标，value 为下标所对应的值</p><pre><code>2. index,value 只能在该for 循环内使用3. 可以用 &quot;_&quot; 来忽略index 或 value，当只有一个返回值时为index</code></pre><h3 id="1-4-数组使用时的注意事项"><a href="#1-4-数组使用时的注意事项" class="headerlink" title="1.4 数组使用时的注意事项"></a>1.4 数组使用时的注意事项</h3><ol><li>数组是定长的相同类型的数据集合</li><li>数组中的数据类型可以是任意数据类型，值类型、引用类型，但是不能混用</li><li>数组声明后若没有初始化，则元素的为声明是数据类型的默认零值(0，nil,””)</li><li>使用步骤：声明数据开辟空间 -&gt; 初始化值/赋值 -&gt; 使用</li><li>数组的下标是从0开始的，要注意下标越界</li><li>数组是值类型，数据传递为值拷贝</li><li>长度不同数据类型相同的两个数组是不同类型的数组</li><li>若要修改原来的数组值，则需要引用传递，即取地址</li></ol><h2 id="2-切片-Slice"><a href="#2-切片-Slice" class="headerlink" title="2. 切片 Slice"></a>2. 切片 Slice</h2><h2 id="3-map"><a href="#3-map" class="headerlink" title="3. map"></a>3. map</h2><h2 id="4-字符和字符串处理"><a href="#4-字符和字符串处理" class="headerlink" title="4. 字符和字符串处理"></a>4. 字符和字符串处理</h2><h3 id="4-1-字符串常用的系统函数"><a href="#4-1-字符串常用的系统函数" class="headerlink" title="4.1 字符串常用的系统函数"></a>4.1 字符串常用的系统函数</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;** 内建容器：** &amp;lt;Excerpt in index | 首页摘要&amp;gt;&lt;/p&gt;
&lt;p&gt;go语言养成记之内建容器&lt;/p&gt;
    
    </summary>
    
    
      <category term="golang" scheme="https://alexbrucelu.github.io/categories/golang/"/>
    
    
      <category term="golang" scheme="https://alexbrucelu.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>protobuf</title>
    <link href="https://alexbrucelu.github.io/2019/12/09/protobuf/"/>
    <id>https://alexbrucelu.github.io/2019/12/09/protobuf/</id>
    <published>2019-12-09T07:14:27.742Z</published>
    <updated>2019-12-09T07:14:27.742Z</updated>
    
    <content type="html"><![CDATA[<p>** protobuf：** &lt;Excerpt in index | 首页摘要&gt;</p><p>微服务之protobuf</p><a id="more"></a><h1 id="protobuf"><a href="#protobuf" class="headerlink" title="protobuf"></a>protobuf</h1><h2 id="1-protobuf-简介"><a href="#1-protobuf-简介" class="headerlink" title="1. protobuf 简介"></a>1. protobuf 简介</h2><blockquote><p><font color="red">Google Protocol Buffer(简称 Protobuf)</font>是一种轻便高效的结构化数据格式，无关平台、无关语言、可扩展，用于通讯协议和数据存储等领域。</p></blockquote><h3 id="1-1-protobuf-的优点"><a href="#1-1-protobuf-的优点" class="headerlink" title="1.1 protobuf 的优点"></a>1.1 protobuf 的优点</h3><blockquote><p>protobuf 有如XML，不过它更小、更快、规范、更简单。可以自定义自己的数据结构，然后使用代码生成器的代码来读写这个数据结构。甚至可以在无需重新部署程序的情况下更新数据结构。只需使用protobuf 对数据结构进行一次描述，即可利用各种不同的语言或从各种不同数据流中对结构化的数据轻松读写。</p><p>protobuf 向后兼容性好，不必破坏已经部署的“老”数据格式的程序就可以对数据结构进行升级。</p><p>protobuf 语义更清晰，无需类似XML 解析器的东西（因为protobuf 编译器会将.proto 文件编译生成对应的数据，访问类似于对protobuf 数据进行序列化、反序列化操作）。</p><p>protobuf 的编程模式比较友好，无需学习复杂的文档对象模型，简单易学。</p></blockquote><h3 id="1-2-protobuf-的缺点"><a href="#1-2-protobuf-的缺点" class="headerlink" title="1.2 protobuf 的缺点"></a>1.2 protobuf 的缺点</h3><blockquote><p>protobuf 与 XML 相比的不足之处有以下几点：</p><ul><li>功能简单，无法用来表示复杂的概念</li><li>XML 已经成为多种行业的标准编写工具，protobuf 只是Google 内部使用的工具，在通用性上差很多</li><li>文本并不适合描述数据结构，所以 protobuf 不适合用来对基于文本的标记文档（如HTML）建模</li><li>由于XML具有某种程度的字自解释性，它可以被人直接读取编辑，protobuf不行，它以二进制的方式存储，除非有 .proto 定义，否则无法直接读出 protobuf 的任何内容</li></ul></blockquote><h2 id="2-常见数据交互的格式比较"><a href="#2-常见数据交互的格式比较" class="headerlink" title="2. 常见数据交互的格式比较"></a>2. 常见数据交互的格式比较</h2><ol><li><p>json：一般的web项目中，最流行的主要还是json，因为浏览器对于json数据支持非常好，有很多内建函数的支持。</p></li><li><p>XML：在 WebService 中应用最为广泛，但相比json 更加冗余，因为需要成对的闭合标签，而json 使用了 键值对的方式，不仅压缩了一定的数据空间，而且具有一定的可读性</p></li><li><p>protobuf：是谷歌开源的一种数据格式，适合高性能，对响应速度有要求的传输数据场景。protobuf 是二进制数据，需要编码和解码，数据本身并不具有可读性，只有对其进行反序列化之后才能得到可读的数据</p><blockquote><p>对于其他数据格式，protobuf的优势</p><ol><li>序列化之后体积相对于json 和 XML 很小，适合网络传输</li><li>支持跨平台多语言</li><li>消息格式升级兼容性好</li><li>序列化、反序列化的速度快，快于json的处理速度</li></ol></blockquote></li></ol><h2 id="3-protobuf-的安装"><a href="#3-protobuf-的安装" class="headerlink" title="3. protobuf 的安装"></a>3. protobuf 的安装</h2><h3 id="3-1-安装-protobuf"><a href="#3-1-安装-protobuf" class="headerlink" title="3.1 安装 protobuf"></a>3.1 安装 protobuf</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 下载 protobuf</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> https://github.com/protocolbuffers/protobuf.git</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 下载依赖库</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get install autoconf automake libtool curl make g++ unzip libffi-dev -y</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 安装</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> protobuf/</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./autogen.sh</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./configure</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> make</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo make install</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo ldconfig <span class="comment"># 刷新共享库（重要）</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> protoc -h</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 出现帮助列表说明protobuf 安装成功</span></span></pre></td></tr></table></figure><h3 id="3-2-获取-proto-包"><a href="#3-2-获取-proto-包" class="headerlink" title="3.2 获取 proto 包"></a>3.2 获取 proto 包</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> go get -v -u github.com/golang/protobuf/protoc</span></span></pre></td></tr></table></figure><h3 id="3-3-安装-protoc-gen-go-插件"><a href="#3-3-安装-protoc-gen-go-插件" class="headerlink" title="3.3 安装 protoc-gen-go 插件"></a>3.3 安装 protoc-gen-go 插件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 安装</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> go get -v -u github.com/golang/protobuf/protoc-gen-go</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 编译</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> <span class="variable">$GOPATH</span>/src/github.com/golang/protobuf/protoc-gen-go</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> go build</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 将生成的 protoc-gen-go 可执行文件放在/bin 目录下</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo cp protoc-gen-go /bin/</span></span></pre></td></tr></table></figure><h2 id="4-protobuf-的语法"><a href="#4-protobuf-的语法" class="headerlink" title="4. protobuf 的语法"></a>4. protobuf 的语法</h2><h3 id="4-1-定义一个消息"><a href="#4-1-定义一个消息" class="headerlink" title="4.1 定义一个消息"></a>4.1 定义一个消息</h3><p>要想使用 protobuf 必须先得定义 proto 文件，所以先得 熟悉消息定义的相关语法</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">"proto3"</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">BruceRequest</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">string</span> name = <span class="number">1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">int32</span> height = <span class="number">2</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">repeated</span> <span class="built_in">int32</span> weight = <span class="number">3</span>；</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><ul><li><p><strong>BruceRequest</strong> 消息格式有三个字段，在消息中承载的数据分别对应于每一个字段，其中每一个字段都有一个名字和一种类型</p></li><li><p>文件第一行是指定了使用<code>proto3</code> 语法，如果没有指定，默认<code>proto2</code> 语法。指定语法行，必须是非空、非注释的第一行</p></li><li><p><code>repeated</code> 关键字表示重复的，在go语言中用切片进行代表</p></li><li><p>在消息定义中每个字段都有一个唯一的标识符</p></li></ul><h3 id="4-3-定义一个消息类型"><a href="#4-3-定义一个消息类型" class="headerlink" title="4.3 定义一个消息类型"></a>4.3 定义一个消息类型</h3><p>在一个 .proto 文件中可以定义多个消息类型。在定义多个相关的消息的时候，这一点特别有用——例如，如果想定义与 SearchResponse 消息类型对应的回复消息格式的话，你可以将它添加到相同的 .proto 文件中</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">"proto3"</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">BruceRequest</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">string</span> name = <span class="number">1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">int32</span> height = <span class="number">2</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">repeated</span> <span class="built_in">int32</span> weight = <span class="number">3</span>；</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">AlexRequest</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    ...</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><h3 id="4-4-添加注释"><a href="#4-4-添加注释" class="headerlink" title="4.4 添加注释"></a>4.4 添加注释</h3><p>如一般的编程语言一直使用 ‘//‘</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">"proto3"</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">BruceRequest</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">string</span> name = <span class="number">1</span>; <span class="comment">// 姓名</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">int32</span> height = <span class="number">2</span>; <span class="comment">// 身高</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">repeated</span> <span class="built_in">int32</span> weight = <span class="number">3</span>；<span class="comment">// 体重</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">AlexRequest</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    ...</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><h3 id="4-5-proto-文件生成文件"><a href="#4-5-proto-文件生成文件" class="headerlink" title="4.5 .proto 文件生成文件"></a>4.5 .proto 文件生成文件</h3><p>当用protocol buffer编译器来运行.proto文件时，编译器将生成所选择语言的代码，这些代码可以操作在.proto文件中定义的消息类型，包括获取、设置字段值，将消息序列化到一个输出流中，以及从一个输入流中解析消息。</p><blockquote><p>对C++来说，编译器会为每个.proto文件生成一个.h文件和一个.cc文件，.proto文件中的每一个消息有一个对应的类。 对Python来说，有点不太一样——Python编译器为.proto文件中的每个消息类型生成一个含有静态描述符的模块，，该模块与一个元类（metaclass）在运行时（runtime）被用来创建所需的Python数据访问类。 对go来说，编译器会为每个消息类型生成了一个.pd.go文件。</p></blockquote><h3 id="4-6-标准数据类型"><a href="#4-6-标准数据类型" class="headerlink" title="4.6 标准数据类型"></a>4.6 标准数据类型</h3><p>一个标量消息字段可以含有一个如下的类型:</p><blockquote><p>该表格展示了定义于.proto文件中的类型，以及与之对应的、在自动生成的访问类中定义的类型</p></blockquote><table><thead><tr><th align="center">.proto</th><th align="center">Notes</th><th align="center">C++</th><th align="center">Python</th><th align="center">Go</th></tr></thead><tbody><tr><td align="center">double</td><td align="center"></td><td align="center">double</td><td align="center">float</td><td align="center">float64</td></tr><tr><td align="center">float</td><td align="center"></td><td align="center">float</td><td align="center">float</td><td align="center">float32</td></tr><tr><td align="center">int32</td><td align="center">使用变长编码，对于负值的效率很低,如果你的域有可能有负值，请使用sint64替代</td><td align="center">int32</td><td align="center">int</td><td align="center">int32</td></tr><tr><td align="center">uint32</td><td align="center">使用变长编码</td><td align="center">uint32</td><td align="center">int/long</td><td align="center">uint32</td></tr><tr><td align="center">uint64</td><td align="center">使用变长编码</td><td align="center">uint64</td><td align="center">int/long</td><td align="center">uint64</td></tr><tr><td align="center">sint32</td><td align="center">使用变长编码，这些编码在负值时比int32高效的多</td><td align="center">int32</td><td align="center">int</td><td align="center">int32</td></tr><tr><td align="center">sint64</td><td align="center">使用变长编码，有符号的整型值。编码时比通常的int64高效</td><td align="center">int64</td><td align="center">int/long</td><td align="center">int64</td></tr><tr><td align="center">fixed32</td><td align="center">总是4个字节，如果数值总是比总是比228大的话，这个类型会比uint32高效</td><td align="center">uint32</td><td align="center">int</td><td align="center">uint32</td></tr><tr><td align="center">fixed64</td><td align="center">总是8个字节，如果数值总是比总是比256大的话，这个类型会比uint64高效</td><td align="center">uint64</td><td align="center">int/long</td><td align="center">uint64</td></tr><tr><td align="center">sfixed32</td><td align="center">总是4个字节</td><td align="center">int32</td><td align="center">int</td><td align="center">int32</td></tr><tr><td align="center">sfixed32</td><td align="center">总是4个字节</td><td align="center">int32</td><td align="center">int</td><td align="center">int32</td></tr><tr><td align="center">sfixed64</td><td align="center">总是8个字节</td><td align="center">int64</td><td align="center">int/long</td><td align="center">int64</td></tr><tr><td align="center">bool</td><td align="center"></td><td align="center">bool</td><td align="center">bool</td><td align="center">bool</td></tr><tr><td align="center">string</td><td align="center">一个字符串必须是UTF-8编码或者7-bit ASCII编码的文本</td><td align="center">string</td><td align="center">str/unicode</td><td align="center">string</td></tr><tr><td align="center">bytes</td><td align="center">可能包含任意顺序的字节数据</td><td align="center">string</td><td align="center">str</td><td align="center">[]byte</td></tr></tbody></table><h4 id="4-6-1-默认值"><a href="#4-6-1-默认值" class="headerlink" title="4.6.1 默认值"></a>4.6.1 默认值</h4><p>当一个消息被解析的时候，如果被编码的信息不包含一个特定的元素，被解析的对象锁对应的域被设置位一个默认值，对于不同类型指定如下： </p><ul><li>对于strings，默认是一个空string </li><li>对于bytes，默认是一个空的bytes </li><li>对于bool，默认是false </li><li>对于数值类型，默认是0</li></ul><h3 id="4-7-使用其他消息类型"><a href="#4-7-使用其他消息类型" class="headerlink" title="4.7 使用其他消息类型"></a>4.7 使用其他消息类型</h3><p>可以将其他消息类型用作字段类型。</p><blockquote><p>例如，假设在每一个PersonInfo消息中包含Person消息，此时可以在相同的 .proto 文件中定义一个Result消息类型，然后在PersonInfo消息中指定一个Person类型的字段</p></blockquote><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">"proto3"</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">BruceRequest</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">string</span> name = <span class="number">1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">int32</span> height = <span class="number">2</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">repeated</span> <span class="built_in">int32</span> weight = <span class="number">3</span>；</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><h3 id="4-8-使用proto2消息类型"><a href="#4-8-使用proto2消息类型" class="headerlink" title="4.8 使用proto2消息类型"></a>4.8 使用proto2消息类型</h3><p>在你的proto3消息中导入proto2的消息类型也是可以的，反之亦然，然后proto2枚举不可以直接在proto3的标识符中使用（如果仅仅在proto2消息中使用是可以的）。</p><h4 id="4-8-1-嵌套类型"><a href="#4-8-1-嵌套类型" class="headerlink" title="4.8.1 嵌套类型"></a>4.8.1 嵌套类型</h4><p>你可以在其他消息类型中定义、使用消息类型，在下面的例子中，Person消息就定义在PersonInfo消息内，如：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">PersonInfo</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Person</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> name = <span class="number">1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">int32</span> shengao = <span class="number">2</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">repeated</span> <span class="built_in">int32</span> tizhong = <span class="number">3</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">&#125; </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">repeated</span> Person info = <span class="number">1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>如果你想在它的父消息类型的外部重用这个消息类型，你需要以PersonInfo.Person的形式使用它，如：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">PersonMessage</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">PersonInfo.Person info = <span class="number">1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>当然，你也可以将消息嵌套任意多层，如：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Grandpa</span> </span>&#123; <span class="comment">// Level 0</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Father</span> </span>&#123; <span class="comment">// Level 1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">son</span> </span>&#123; <span class="comment">// Level 2</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> name = <span class="number">1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">int32</span> age = <span class="number">2</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">&#125; </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Uncle</span> </span>&#123; <span class="comment">// Level 1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Son</span> </span>&#123; <span class="comment">// Level 2</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> name = <span class="number">1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">int32</span> age = <span class="number">2</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><h4 id="4-8-2-定义服务-Service"><a href="#4-8-2-定义服务-Service" class="headerlink" title="4.8.2 定义服务(Service)"></a>4.8.2 定义服务(Service)</h4><p>果想要将消息类型用在RPC(远程方法调用)系统中，可以在.proto文件中定义一个RPC服务接口，protocol buffer编译器将会根据所选择的不同语言生成服务接口代码及存根。如，想要定义一个RPC服务并具有一个方法，该方法能够接收 SearchRequest并返回一个SearchResponse，此时可以在.proto文件中进行如下定义：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">service</span> <span class="title">SearchService</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//rpc 服务的函数名 （传入参数）返回（返回参数）</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">rpc</span> Search (SearchRequest) <span class="keyword">returns</span> (SearchResponse)</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>最直观的使用protocol buffer的RPC系统是gRPC一个由谷歌开发的语言和平台中的开源的RPC系统，gRPC在使用protocl buffer时非常有效，如果使用特殊的protocol buffer插件可以直接为您从.proto文件中产生相关的RPC代码。</p><p>如果你不想使用gRPC，也可以使用protocol buffer用于自己的RPC实现，你可以从proto2语言指南中找到更多信息</p><h4 id="4-8-3-生成访问类"><a href="#4-8-3-生成访问类" class="headerlink" title="4.8.3 生成访问类"></a>4.8.3 生成访问类</h4><p>可以通过定义好的.proto文件来生成Java,Python,C++, Ruby, JavaNano, Objective-C,或者C# 代码，需要基于.proto文件运行protocol buffer编译器protoc。如果你没有安装编译器，下载安装包并遵照README安装。对于Go,你还需要安装一个特殊的代码生成器件。你可以通过GitHub上的protobuf库找到安装过程<br>通过如下方式调用protocol编译器:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> protoc --proto_path=IMPORT_PATH --cpp_out=DST_DIR --python_out=DST_DIR --go_out=DST_DIR path/to/file.proto</span></span></pre></td></tr></table></figure><p>IMPORT_PATH声明了一个.proto文件所在的解析import具体目录。如果忽略该值，则使用当前目录。如果有多个目录则可以多次调用–proto_path，它们将会顺序的被访问并执行导入。-I=IMPORT_PATH是–proto_path的简化形式。</p><p><strong>当然也可以提供一个或多个输出路径：</strong></p><p> –cpp_out 在目标目录DST_DIR中产生C++代码，可以在C++代码生成参考中查看更多。 </p><p>–python_out 在目标目录 DST_DIR 中产生Python代码，可以在Python代码生成参考中查看更多。</p><p>–go_out 在目标目录 DST_DIR 中产生Go代码，可以在GO代码生成参考中查看更多。</p><blockquote><p>作为一个方便的拓展，如果DST_DIR以.zip或者.jar结尾，编译器会将输出写到一个ZIP格式文件或者符合JAR标准的.jar文件中。注意如果输出已经存在则会被覆盖，编译器还没有智能到可以追加文件。 - 你必须提议一个或多个.proto文件作为输入，多<br>个.proto文件可以只指定一次。虽然文件路径是相对于当前目录的，每个文件必须位于其IMPORT_PATH下，以便每个文件可以确定其规范的名称。</p></blockquote><h4 id="4-8-4-测试"><a href="#4-8-4-测试" class="headerlink" title="4.8.4 测试"></a>4.8.4 测试</h4><p>protobuf的使用方法是将数据结构写入到 .proto文件中，使用 protoc编译器编译(间接使用了插件）得到一个新的go包，里面包含 go中可以使用的数据结构和一些辅助方法。</p><ul><li><p>编写 test.proto文件</p><ul><li><p>$GOPATH/src/创建 myproto文件夹</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> <span class="variable">$GOPATH</span>/src/</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkdir myproto</span></span></pre></td></tr></table></figure></li><li><p>myproto文件夹中创建 test.proto文件 (protobuf协议文件)</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">$ vim test.proto</span></pre></td></tr></table></figure></li><li><p>文件内容</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">"proto3"</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> myproto;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Test</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> name = <span class="number">1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">int32</span> stature = <span class="number">2</span> ;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">repeated</span> <span class="built_in">int64</span> weight = <span class="number">3</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> motto = <span class="number">4</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure></li></ul></li><li><p>编译 :执行</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">$ protoc --go_out=./ *.proto </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成 test.pb.go文件</span></span></pre></td></tr></table></figure></li><li><p>使用 protobuf 做数据格式转换</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="string">"fmt"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="string">"github.com/golang/protobuf/proto"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="string">"myproto"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">) </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">test := &amp;myproto.Test&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">Name : <span class="string">"panda"</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">Stature : <span class="number">180</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">Weight : []<span class="keyword">int64</span>&#123;<span class="number">120</span>,<span class="number">125</span>,<span class="number">198</span>,<span class="number">180</span>,<span class="number">150</span>,<span class="number">180</span>&#125;,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">Motto : <span class="string">"天行健，地势坤"</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">&#125; </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">//将Struct test 转换成 protobuf</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">data,err:= proto.Marshal(test)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> err!=<span class="literal">nil</span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">fmt.Println(<span class="string">"转码失败"</span>,err)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">&#125; </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">//得到一个新的Test结构体 newTest</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">newtest:= &amp;myproto.Test&#123;&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">//将data转换为test结构体</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">err = proto.Unmarshal(data,newtest)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> err!=<span class="literal">nil</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">fmt.Println(<span class="string">"转码失败"</span>,err)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">&#125; </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">    fmt.Println(newtest.String())</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//得到name字段</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">fmt.Println(<span class="string">"newtest-&gt;name"</span>,newtest.GetName())</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">fmt.Println(<span class="string">"newtest-&gt;Stature"</span>,newtest.GetStature())</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">fmt.Println(<span class="string">"newtest-&gt;Weight"</span>,newtest.GetWeight())</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">fmt.Println(<span class="string">"newtest-&gt;Motto"</span>,newtest.GetMotto())</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;** protobuf：** &amp;lt;Excerpt in index | 首页摘要&amp;gt;&lt;/p&gt;
&lt;p&gt;微服务之protobuf&lt;/p&gt;
    
    </summary>
    
    
      <category term="microServices" scheme="https://alexbrucelu.github.io/categories/microServices/"/>
    
    
      <category term="微服务" scheme="https://alexbrucelu.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>基础语法</title>
    <link href="https://alexbrucelu.github.io/2019/12/09/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    <id>https://alexbrucelu.github.io/2019/12/09/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</id>
    <published>2019-12-09T07:14:27.742Z</published>
    <updated>2019-12-09T07:14:27.742Z</updated>
    
    <content type="html"><![CDATA[<p>** 基础语法：** &lt;Excerpt in index | 首页摘要&gt;</p><p>go语言养成记之基础语法</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;** 基础语法：** &amp;lt;Excerpt in index | 首页摘要&amp;gt;&lt;/p&gt;
&lt;p&gt;go语言养成记之基础语法&lt;/p&gt;
    
    </summary>
    
    
      <category term="golang" scheme="https://alexbrucelu.github.io/categories/golang/"/>
    
    
      <category term="golang" scheme="https://alexbrucelu.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>Micro</title>
    <link href="https://alexbrucelu.github.io/2019/12/09/%E6%88%BF%E5%B1%8B%E7%A7%9F%E8%B5%81/"/>
    <id>https://alexbrucelu.github.io/2019/12/09/%E6%88%BF%E5%B1%8B%E7%A7%9F%E8%B5%81/</id>
    <published>2019-12-09T07:14:27.742Z</published>
    <updated>2019-12-09T07:14:27.742Z</updated>
    
    <content type="html"><![CDATA[<p>** Micro：** &lt;Excerpt in index | 首页摘要&gt;</p><p>基于go-micro的微服务之房屋租赁</p><a id="more"></a><p>[TOC]</p><h1 id="房屋租赁"><a href="#房屋租赁" class="headerlink" title="房屋租赁"></a>房屋租赁</h1><h2 id="1-项目简述"><a href="#1-项目简述" class="headerlink" title="1. 项目简述"></a>1. 项目简述</h2><h2 id="2-项目启动"><a href="#2-项目启动" class="headerlink" title="2. 项目启动"></a>2. 项目启动</h2><h3 id="2-1-拆分原则"><a href="#2-1-拆分原则" class="headerlink" title="2.1 拆分原则"></a>2.1 拆分原则</h3><ol><li>单一职责</li><li>服务粒度适中</li><li>考虑团队结构</li><li>以业务模型切入</li><li>演进式拆分</li><li>避免环形依赖和双向依赖 </li></ol><h3 id="2-2-前期准备工作"><a href="#2-2-前期准备工作" class="headerlink" title="2.2 前期准备工作"></a>2.2 前期准备工作</h3><h4 id="2-2-1-单机版的-consul-启动"><a href="#2-2-1-单机版的-consul-启动" class="headerlink" title="2.2.1 单机版的 consul 启动"></a>2.2.1 单机版的 consul 启动</h4><p>项目开始之前首先要启动单机版的consul </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> consul agent -dev</span></span></pre></td></tr></table></figure><h4 id="2-2-2-数据库的创建"><a href="#2-2-2-数据库的创建" class="headerlink" title="2.2.2 数据库的创建"></a>2.2.2 数据库的创建</h4><p>在mysql中创建一个项目所用数据库 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mysql -uroot -p</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> create database <span class="keyword">if</span> not exists house default charset utf8 collate utf8_general_ci;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看数据库</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> show databases;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">+--------------------+</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">| Database           |</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">+--------------------+</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">| cms                |</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">| house              |</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">| information_schema |</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">| mysql              |</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">| performance_schema |</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">| sdrms              |</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">| sys                |</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">+--------------------+</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">7 rows in set (0.85 sec)</span></pre></td></tr></table></figure><ul><li><p>创建表的关系逻辑图</p><p><img src="https://github.com/AlexBruceLu/DAPP/wiki/user.png" alt=""></p></li></ul><h2 id="3-web-服务的创建"><a href="#3-web-服务的创建" class="headerlink" title="3. web 服务的创建"></a>3. web 服务的创建</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> micro new --<span class="built_in">type</span> <span class="string">"web"</span> micro/houseWeb</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 以GOPATH/src 问基准的局对路径 <span class="variable">$GOPATH</span>/src/micro/houseWeb</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">.</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">├── Dockerfile</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">├── handler</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">│   └── handler.go</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">├── main.go</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">├── Makefile</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">├── plugin.go</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">└── README.md</span></pre></td></tr></table></figure><h3 id="3-1-创建工具函数文件夹"><a href="#3-1-创建工具函数文件夹" class="headerlink" title="3.1 创建工具函数文件夹"></a>3.1 创建工具函数文件夹</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">创建工具函数文件夹</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkdir utils</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 进入文件夹创建文件</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> utils</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 配置文件读取函数文件</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> touch config.go</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 错误码文件</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> touch error.go</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 字符串拼接文件</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> touch misc.go</span></span></pre></td></tr></table></figure><h3 id="3-2-创建数据库文件"><a href="#3-2-创建数据库文件" class="headerlink" title="3.2 创建数据库文件"></a>3.2 创建数据库文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkdir models</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">创建数据库文件</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> vim models.go</span></span></pre></td></tr></table></figure><h3 id="3-3-运行服务并且创建表单"><a href="#3-3-运行服务并且创建表单" class="headerlink" title="3.3 运行服务并且创建表单"></a>3.3 运行服务并且创建表单</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">创建conf文件夹用来存放配置文件</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkdir conf</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">创建data.sql文件</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> vim data.sql</span></span></pre></td></tr></table></figure><p>data.sql 内容</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`area`</span>(<span class="string">`name`</span>) <span class="keyword">VALUES</span> (<span class="string">'东城区'</span>),(<span class="string">'西城区'</span>),(<span class="string">'朝阳区'</span>),(<span class="string">'海淀区'</span>),(<span class="string">'昌平区'</span>),(<span class="string">'丰台区'</span>),(<span class="string">'房山区'</span>),(<span class="string">'通州区'</span>),(<span class="string">'顺义区'</span>),(<span class="string">'大兴区'</span>),(<span class="string">'怀柔区'</span>),(<span class="string">'平谷区'</span>),(<span class="string">'密云区'</span>),(<span class="string">'延庆区'</span>),(<span class="string">'石景山区'</span>),(<span class="string">'天津'</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`facility`</span>(<span class="string">`name`</span>) <span class="keyword">VALUES</span>(<span class="string">'无线网络'</span>),(<span class="string">'热水淋浴'</span>),(<span class="string">'空调'</span>),(<span class="string">'暖气'</span>),(<span class="string">'允许吸烟'</span>),(<span class="string">'饮水设备'</span>),(<span class="string">'牙具'</span>),(<span class="string">'香皂'</span>),(<span class="string">'拖鞋'</span>),(<span class="string">'手纸'</span>),(<span class="string">'毛巾'</span>),(<span class="string">'沐浴露、洗发露'</span>),(<span class="string">'冰箱'</span>),(<span class="string">'洗衣机'</span>),(<span class="string">'电梯'</span>),(<span class="string">'允许做饭'</span>),(<span class="string">'允许带宠物'</span>),(<span class="string">'允许聚会'</span>),(<span class="string">'门禁系统'</span>),(<span class="string">'停车位'</span>),(<span class="string">'有线网络'</span>),(<span class="string">'电视'</span>),(<span class="string">'浴缸'</span>),(<span class="string">'吃鸡'</span>),(<span class="string">'打台球'</span>),(<span class="string">'游泳'</span>);</span></pre></td></tr></table></figure><p><strong><code>data.sql</code></strong>内容的导入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> houseWeb/</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> <span class="built_in">source</span> ./conf/data.sql;</span></span></pre></td></tr></table></figure><h2 id="4-获取地区信息"><a href="#4-获取地区信息" class="headerlink" title="4. 获取地区信息"></a>4. 获取地区信息</h2><h3 id="4-1-创建服务"><a href="#4-1-创建服务" class="headerlink" title="4.1 创建服务"></a>4.1 创建服务</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> micro new --<span class="built_in">type</span> <span class="string">"srv"</span> micro/getArea</span></span></pre></td></tr></table></figure><h3 id="4-2-业务逻辑示意图"><a href="#4-2-业务逻辑示意图" class="headerlink" title="4.2 业务逻辑示意图"></a>4.2 业务逻辑示意图</h3><p><img src="https://github.com/AlexBruceLu/DAPP/wiki/area.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;** Micro：** &amp;lt;Excerpt in index | 首页摘要&amp;gt;&lt;/p&gt;
&lt;p&gt;基于go-micro的微服务之房屋租赁&lt;/p&gt;
    
    </summary>
    
    
      <category term="microServices" scheme="https://alexbrucelu.github.io/categories/microServices/"/>
    
    
      <category term="微服务" scheme="https://alexbrucelu.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>Go语言内存分配</title>
    <link href="https://alexbrucelu.github.io/2019/12/09/%E5%9B%BE%E8%A7%A3Go%E8%AF%AD%E8%A8%80%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/"/>
    <id>https://alexbrucelu.github.io/2019/12/09/%E5%9B%BE%E8%A7%A3Go%E8%AF%AD%E8%A8%80%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/</id>
    <published>2019-12-09T07:14:27.742Z</published>
    <updated>2019-12-09T07:14:27.742Z</updated>
    
    <content type="html"><![CDATA[<p>** Go语言内存分配：** &lt;Excerpt in index | 首页摘要&gt;</p><p>go语言养成记之Go语言内存分配</p><a id="more"></a><p>[TOC]</p><p>Go语言内置运行时（就是runtime），抛弃了传统的内存分配方式，改为自主管理。这样可以自主地实现更好的内存使用模式，比如内存池、预分配等等。这样，不会每次内存分配都需要进行系统调用。</p><p>Golang运行时的内存分配算法主要源自 Google 为 C 语言开发的<code>TCMalloc算法</code>，全称<code>Thread-Caching Malloc</code>。核心思想就是把内存分为多级管理，从而降低锁的粒度。它将可用的堆内存采用二级分配的方式进行管理：每个线程都会自行维护一个独立的内存池，进行内存分配时优先从该内存池中分配，当内存池不足时才会向全局内存池申请，以避免不同线程对全局内存池的频繁竞争。</p><h1 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h1><p>Go在程序启动的时候，会先向操作系统申请一块内存（注意这时还只是一段虚拟的地址空间，并不会真正地分配内存），切成小块后自己进行管理。</p><p>申请到的内存块被分配了三个区域，在X64上分别是512MB，16GB，512GB大小。</p><p><img src="https://user-images.githubusercontent.com/7698088/54165891-9e6cde80-449d-11e9-8947-14e6f75f4089.png" alt="堆区总览"></p><p><code>arena区域</code>就是我们所谓的堆区，Go动态分配的内存都是在这个区域，它把内存分割成<code>8KB</code>大小的页，一些页组合起来称为<code>mspan</code>。</p><p><code>bitmap区域</code>标识<code>arena</code>区域哪些地址保存了对象，并且用<code>4bit</code>标志位表示对象是否包含指针、<code>GC</code>标记信息。<code>bitmap</code>中一个<code>byte</code>大小的内存对应<code>arena</code>区域中4个指针大小（指针大小为 8B ）的内存，所以<code>bitmap</code>区域的大小是<code>512GB/(4*8B)=16GB</code>。</p><p><img src="https://user-images.githubusercontent.com/7698088/54197565-3a7b0200-44ff-11e9-92e2-34185ee3e0bc.png" alt="bitmap arena"></p><p><img src="https://user-images.githubusercontent.com/7698088/54197295-85484a00-44fe-11e9-9c77-9836120b8454.png" alt="bitmap arena"></p><p>从上图其实还可以看到bitmap的高地址部分指向arena区域的低地址部分，也就是说bitmap的地址是由高地址向低地址增长的。</p><p><code>spans区域</code>存放<code>mspan</code>（也就是一些<code>arena</code>分割的页组合起来的内存管理基本单元，后文会再讲）的指针，每个指针对应一页，所以<code>spans</code>区域的大小就是<code>512GB/8KB*8B=512MB</code>。除以8KB是计算<code>arena</code>区域的页数，而最后乘以8是计算<code>spans</code>区域所有指针的大小。创建<code>mspan</code>的时候，按页填充对应的<code>spans</code>区域，在回收<code>object</code>时，根据地址很容易就能找到它所属的<code>mspan</code>。</p><h1 id="内存管理单元"><a href="#内存管理单元" class="headerlink" title="内存管理单元"></a>内存管理单元</h1><p><code>mspan</code>：Go中内存管理的基本单元，是由一片连续的<code>8KB</code>的页组成的大块内存。注意，这里的页和操作系统本身的页并不是一回事，它一般是操作系统页大小的几倍。一句话概括：<code>mspan</code>是一个包含起始地址、<code>mspan</code>规格、页的数量等内容的双端链表。</p><p>每个<code>mspan</code>按照它自身的属性<code>Size Class</code>的大小分割成若干个<code>object</code>，每个<code>object</code>可存储一个对象。并且会使用一个位图来标记其尚未使用的<code>object</code>。属性<code>Size Class</code>决定<code>object</code>大小，而<code>mspan</code>只会分配给和<code>object</code>尺寸大小接近的对象，当然，对象的大小要小于<code>object</code>大小。还有一个概念：<code>Span Class</code>，它和<code>Size Class</code>的含义差不多，</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">Size_Class = Span_Class / <span class="number">2</span></span></pre></td></tr></table></figure><p>这是因为其实每个 <code>Size Class</code>有两个<code>mspan</code>，也就是有两个<code>Span Class</code>。其中一个分配给含有指针的对象，另一个分配给不含有指针的对象。这会给垃圾回收机制带来利好，之后的文章再谈。</p><p>如下图，<code>mspan</code>由一组连续的页组成，按照一定大小划分成<code>object</code>。</p><p><img src="https://user-images.githubusercontent.com/7698088/54070690-0b198a80-429e-11e9-8838-eef9cd160f5c.png" alt="page mspan"></p><p>Go1.9.2里<code>mspan</code>的<code>Size Class</code>共有67种，每种<code>mspan</code>分割的object大小是8*2n的倍数，这个是写死在代码里的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// path: /usr/local/go/src/runtime/sizeclasses.go</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> _NumSizeClasses = <span class="number">67</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> class_to_size = [_NumSizeClasses]<span class="keyword">uint16</span>&#123;<span class="number">0</span>, <span class="number">8</span>, <span class="number">16</span>, <span class="number">32</span>, <span class="number">48</span>, <span class="number">64</span>, <span class="number">80</span>, <span class="number">96</span>, <span class="number">112</span>, <span class="number">128</span>, <span class="number">144</span>, <span class="number">160</span>, <span class="number">176</span>, <span class="number">192</span>, <span class="number">208</span>, <span class="number">224</span>, <span class="number">240</span>, <span class="number">256</span>, <span class="number">288</span>, <span class="number">320</span>, <span class="number">352</span>, <span class="number">384</span>, <span class="number">416</span>, <span class="number">448</span>, <span class="number">480</span>, <span class="number">512</span>, <span class="number">576</span>, <span class="number">640</span>, <span class="number">704</span>, <span class="number">768</span>, <span class="number">896</span>, <span class="number">1024</span>, <span class="number">1152</span>, <span class="number">1280</span>, <span class="number">1408</span>, <span class="number">1536</span>,<span class="number">1792</span>, <span class="number">2048</span>, <span class="number">2304</span>, <span class="number">2688</span>, <span class="number">3072</span>, <span class="number">3200</span>, <span class="number">3456</span>, <span class="number">4096</span>, <span class="number">4864</span>, <span class="number">5376</span>, <span class="number">6144</span>, <span class="number">6528</span>, <span class="number">6784</span>, <span class="number">6912</span>, <span class="number">8192</span>, <span class="number">9472</span>, <span class="number">9728</span>, <span class="number">10240</span>, <span class="number">10880</span>, <span class="number">12288</span>, <span class="number">13568</span>, <span class="number">14336</span>, <span class="number">16384</span>, <span class="number">18432</span>, <span class="number">19072</span>, <span class="number">20480</span>, <span class="number">21760</span>, <span class="number">24576</span>, <span class="number">27264</span>, <span class="number">28672</span>, <span class="number">32768</span>&#125;</span></pre></td></tr></table></figure><p>根据<code>mspan</code>的<code>Size Class</code>可以得到它划分的<code>object</code>大小。 比如<code>Size Class</code>等于3，<code>object</code>大小就是32B。 32B大小的object可以存储对象大小范围在17B~32B的对象。而对于微小对象（小于16B），分配器会将其进行合并，将几个对象分配到同一个<code>object</code>中。</p><p>数组里最大的数是32768，也就是32KB，超过此大小就是大对象了，它会被特别对待，这个稍后会再介绍。顺便提一句，类型<code>Size Class</code>为0表示大对象，它实际上直接由堆内存分配，而小对象都要通过<code>mspan</code>来分配。</p><p>对于mspan来说，它的<code>Size Class</code>会决定它所能分到的页数，这也是写死在代码里的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// path: /usr/local/go/src/runtime/sizeclasses.go</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> _NumSizeClasses = <span class="number">67</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> class_to_allocnpages = [_NumSizeClasses]<span class="keyword">uint8</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">10</span>, <span class="number">7</span>, <span class="number">4</span>&#125;</span></pre></td></tr></table></figure><p>比如当我们要申请一个<code>object</code>大小为<code>32B</code>的<code>mspan</code>的时候，在class_to_size里对应的索引是3，而索引3在<code>class_to_allocnpages</code>数组里对应的页数就是1。</p><p><code>mspan</code>结构体定义：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// path: /usr/local/go/src/runtime/mheap.go</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> mspan <span class="keyword">struct</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">//链表前向指针，用于将span链接起来</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    next *mspan </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">//链表前向指针，用于将span链接起来</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    prev *mspan </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 起始地址，也即所管理页的地址</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    startAddr <span class="keyword">uintptr</span> </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 管理的页数</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    npages <span class="keyword">uintptr</span> </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 块个数，表示有多少个块可供分配</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    nelems <span class="keyword">uintptr</span> </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">//分配位图，每一位代表一个块是否已分配</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">    allocBits *gcBits </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 已分配块的个数</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">    allocCount <span class="keyword">uint16</span> </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// class表中的class ID，和Size Classs相关</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">    spanclass spanClass  </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// class表中的对象大小，也即块大小</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">    elemsize <span class="keyword">uintptr</span> </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>我们将<code>mspan</code>放到更大的视角来看：</p><p><img src="https://user-images.githubusercontent.com/7698088/54192326-a440df00-44f2-11e9-950a-bbdfb7c36e62.png" alt="mspan更大视角"></p><p>上图可以看到有两个<code>S</code>指向了同一个<code>mspan</code>，因为这两个<code>S</code>指向的<code>P</code>是同属一个<code>mspan</code>的。所以，通过<code>arena</code>上的地址可以快速找到指向它的<code>S</code>，通过<code>S</code>就能找到<code>mspan</code>，回忆一下前面我们说的<code>mspan</code>区域的每个指针对应一页。</p><p>假设最左边第一个<code>mspan</code>的<code>Size Class</code>等于10，根据前面的<code>class_to_size</code>数组，得出这个<code>msapn</code>分割的<code>object</code>大小是144B，算出可分配的对象个数是<code>8KB/144B=56.89</code>个，取整56个，所以会有一些内存浪费掉了，Go的源码里有所有<code>Size Class</code>的<code>mspan</code>浪费的内存的大小；再根据<code>class_to_allocnpages</code>数组，得到这个<code>mspan</code>只由1个<code>page</code>组成；假设这个<code>mspan</code>是分配给无指针对象的，那么<code>spanClass</code>等于20。</p><p><code>startAddr</code>直接指向<code>arena</code>区域的某个位置，表示这个<code>mspan</code>的起始地址，<code>allocBits</code>指向一个位图，每位代表一个块是否被分配了对象；<code>allocCount</code>则表示总共已分配的对象个数。</p><p>这样，左起第一个<code>mspan</code>的各个字段参数就如下图所示：</p><p><img src="https://user-images.githubusercontent.com/7698088/54210478-87200680-451a-11e9-98dc-2e5adbb43d4a.png" alt="左起第一个mspan具体值"></p><h1 id="内存管理组件"><a href="#内存管理组件" class="headerlink" title="内存管理组件"></a>内存管理组件</h1><p>内存分配由内存分配器完成。分配器由3种组件构成：<code>mcache</code>, <code>mcentral</code>, <code>mheap</code>。</p><h2 id="mcache"><a href="#mcache" class="headerlink" title="mcache"></a>mcache</h2><p><code>mcache</code>：每个工作线程都会绑定一个mcache，本地缓存可用的<code>mspan</code>资源，这样就可以直接给Goroutine分配，因为不存在多个Goroutine竞争的情况，所以不会消耗锁资源。</p><p><code>mcache</code>的结构体定义：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//path: /usr/local/go/src/runtime/mcache.go</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> mcache <span class="keyword">struct</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    alloc [numSpanClasses]*mspan</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">numSpanClasses = _NumSizeClasses &lt;&lt; <span class="number">1</span></span></pre></td></tr></table></figure><p><code>mcache</code>用<code>Span Classes</code>作为索引管理多个用于分配的<code>mspan</code>，它包含所有规格的<code>mspan</code>。它是<code>_NumSizeClasses</code>的2倍，也就是<code>67*2=134</code>，为什么有一个两倍的关系，前面我们提到过：为了加速之后内存回收的速度，数组里一半的<code>mspan</code>中分配的对象不包含指针，另一半则包含指针。</p><p>对于无指针对象的<code>mspan</code>在进行垃圾回收的时候无需进一步扫描它是否引用了其他活跃的对象。 后面的垃圾回收文章会再讲到，这次先到这里。</p><p><img src="https://user-images.githubusercontent.com/7698088/54191324-a86bfd00-44f0-11e9-9039-3b64d39036d9.png" alt="mcache"></p><p><code>mcache</code>在初始化的时候是没有任何<code>mspan</code>资源的，在使用过程中会动态地从<code>mcentral</code>申请，之后会缓存下来。当对象小于等于32KB大小时，使用<code>mcache</code>的相应规格的<code>mspan</code>进行分配。</p><h2 id="mcentral"><a href="#mcentral" class="headerlink" title="mcentral"></a>mcentral</h2><p><code>mcentral</code>：为所有<code>mcache</code>提供切分好的<code>mspan</code>资源。每个<code>central</code>保存一种特定大小的全局<code>mspan</code>列表，包括已分配出去的和未分配出去的。 每个<code>mcentral</code>对应一种<code>mspan</code>，而<code>mspan</code>的种类导致它分割的<code>object</code>大小不同。当工作线程的<code>mcache</code>中没有合适（也就是特定大小的）的<code>mspan</code>时就会从<code>mcentral</code>获取。</p><p><code>mcentral</code>被所有的工作线程共同享有，存在多个Goroutine竞争的情况，因此会消耗锁资源。结构体定义：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//path: /usr/local/go/src/runtime/mcentral.go</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> mcentral <span class="keyword">struct</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 互斥锁</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    lock mutex </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 规格</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    sizeclass <span class="keyword">int32</span> </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 尚有空闲object的mspan链表</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    nonempty mSpanList </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 没有空闲object的mspan链表，或者是已被mcache取走的msapn链表</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    empty mSpanList </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 已累计分配的对象个数</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    nmalloc <span class="keyword">uint64</span> </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p><img src="https://user-images.githubusercontent.com/7698088/54211962-2219e000-451d-11e9-85e1-0e8200925fa5.png" alt="mcentral"></p><p><code>empty</code>表示这条链表里的<code>mspan</code>都被分配了<code>object</code>，或者是已经被<code>cache</code>取走了的<code>mspan</code>，这个<code>mspan</code>就被那个工作线程独占了。而<code>nonempty</code>则表示有空闲对象的<code>mspan</code>列表。每个<code>central</code>结构体都在<code>mheap</code>中维护。</p><p>简单说下<code>mcache</code>从<code>mcentral</code>获取和归还<code>mspan</code>的流程：</p><ul><li>获取<br>加锁；从<code>nonempty</code>链表找到一个可用的<code>mspan</code>；并将其从<code>nonempty</code>链表删除；将取出的<code>mspan</code>加入到<code>empty</code>链表；将<code>mspan</code>返回给工作线程；解锁。</li><li>归还<br>加锁；将<code>mspan</code>从<code>empty</code>链表删除；将<code>mspan</code>加入到<code>nonempty</code>链表；解锁。</li></ul><h2 id="mheap"><a href="#mheap" class="headerlink" title="mheap"></a>mheap</h2><p><code>mheap</code>：代表Go程序持有的所有堆空间，Go程序使用一个<code>mheap</code>的全局对象<code>_mheap</code>来管理堆内存。</p><p>当<code>mcentral</code>没有空闲的<code>mspan</code>时，会向<code>mheap</code>申请。而<code>mheap</code>没有资源时，会向操作系统申请新内存。<code>mheap</code>主要用于大对象的内存分配，以及管理未切割的<code>mspan</code>，用于给<code>mcentral</code>切割成小对象。</p><p>同时我们也看到，<code>mheap</code>中含有所有规格的<code>mcentral</code>，所以，当一个<code>mcache</code>从<code>mcentral</code>申请<code>mspan</code>时，只需要在独立的<code>mcentral</code>中使用锁，并不会影响申请其他规格的<code>mspan</code>。</p><p><code>mheap</code>结构体定义：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//path: /usr/local/go/src/runtime/mheap.go</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> mheap <span class="keyword">struct</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    lock mutex</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// spans: 指向mspans区域，用于映射mspan和page的关系</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    spans []*mspan </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 指向bitmap首地址，bitmap是从高地址向低地址增长的</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    bitmap <span class="keyword">uintptr</span> </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 指示arena区首地址</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    arena_start <span class="keyword">uintptr</span> </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 指示arena区已使用地址位置</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    arena_used  <span class="keyword">uintptr</span> </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 指示arena区末地址</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">    arena_end   <span class="keyword">uintptr</span> </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">    central [<span class="number">67</span>*<span class="number">2</span>]<span class="keyword">struct</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">        mcentral mcentral</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">        pad [sys.CacheLineSize - unsafe.Sizeof(mcentral&#123;&#125;)%sys.CacheLineSize]<span class="keyword">byte</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p><img src="https://user-images.githubusercontent.com/7698088/54213273-1cbd9500-451f-11e9-93e4-28f39615b6a2.png" alt="mheap"></p><p>上图我们看到，bitmap和arena_start指向了同一个地址，这是因为bitmap的地址是从高到低增长的，所以他们指向的内存位置相同。</p><h1 id="内存分配流程"><a href="#内存分配流程" class="headerlink" title="内存分配流程"></a>内存分配流程</h1><p>上一篇文章<a href="https://www.cnblogs.com/qcrao-2018/p/10453260.html" target="_blank" rel="noopener">《Golang之变量去哪儿》</a>中我们提到了，变量是在栈上分配还是在堆上分配，是由逃逸分析的结果决定的。通常情况下，编译器是倾向于将变量分配到栈上的，因为它的开销小，最极端的就是”zero garbage”，所有的变量都会在栈上分配，这样就不会存在内存碎片，垃圾回收之类的东西。</p><p>Go的内存分配器在分配对象时，根据对象的大小，分成三类：小对象（小于等于16B）、一般对象（大于16B，小于等于32KB）、大对象（大于32KB）。</p><p>大体上的分配流程：</p><ul><li><blockquote><p>32KB 的对象，直接从mheap上分配；</p></blockquote></li><li><p>&lt;=16B 的对象使用mcache的tiny分配器分配；</p></li><li><p>(16B,32KB] 的对象，首先计算对象的规格大小，然后使用mcache中相应规格大小的mspan分配；</p><ul><li>如果mcache没有相应规格大小的mspan，则向mcentral申请</li><li>如果mcentral没有相应规格大小的mspan，则向mheap申请</li><li>如果mheap中也没有合适大小的mspan，则向操作系统申请</li></ul></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Go语言的内存分配非常复杂，它的一个原则就是能复用的一定要复用。源码很难追，后面可能会再来一篇关于内存分配的源码阅读相关的文章。简单总结一下本文吧。</p><p>文章从一个比较粗的角度来看Go的内存分配，并没有深入细节。一般而言，了解它的原理，到这个程度也可以了。</p><ul><li>Go在程序启动时，会向操作系统申请一大块内存，之后自行管理。</li><li>Go内存管理的基本单元是mspan，它由若干个页组成，每种mspan可以分配特定大小的object。</li><li>mcache, mcentral, mheap是Go内存管理的三大组件，层层递进。mcache管理线程在本地缓存的mspan；mcentral管理全局的mspan供所有线程使用；mheap管理Go的所有动态分配内存。</li><li>极小对象会分配在一个object中，以节省资源，使用tiny分配器分配内存；一般小对象通过mspan分配内存；大对象则直接由mheap分配内存。</li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://yq.aliyun.com/articles/652551" target="_blank" rel="noopener">简单易懂，非常清晰</a></p><p><a href="https://www.jianshu.com/p/47691d870756" target="_blank" rel="noopener">内存分配器的初始化过程，分配流程图很详细</a></p><p><a href="https://swanspouse.github.io/2018/08/22/golang-memory-model/" target="_blank" rel="noopener">全局的图</a></p><p><a href="https://github.com/qyuhen/book" target="_blank" rel="noopener">雨痕 Go1.5源码阅读</a></p><p><a href="https://www.jianshu.com/p/47691d870756" target="_blank" rel="noopener">图不错</a></p><p><a href="https://juejin.im/post/59f2e19f5188253d6816d504" target="_blank" rel="noopener">整体感</a></p><p><a href="http://legendtkl.com/2017/04/02/golang-alloc/" target="_blank" rel="noopener">源码解读</a></p><p><a href="https://www.linuxzen.com/go-memory-allocator-visual-guide.html" target="_blank" rel="noopener">重点推荐 深入到晶体管了 图很好</a></p><p><a href="http://gocode.cc/project/4/article/103" target="_blank" rel="noopener">总体描述对象分配流程</a></p><p><a href="https://mikespook.com/2014/12/%E7%90%86%E8%A7%A3-go-%E8%AF%AD%E8%A8%80%E7%9A%84%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8/" target="_blank" rel="noopener">实际Linux命令</a></p><p><a href="http://blog.newbmiao.com/2018/08/20/go-source-analysis-of-memory-alloc.html" target="_blank" rel="noopener">整体流程图 对象分配函数调用链路</a></p><p><a href="https://www.cnblogs.com/zkweb/p/7880099.html" target="_blank" rel="noopener">源码讲解 非常细致</a></p><p><a href="https://zhuanlan.zhihu.com/p/34930748" target="_blank" rel="noopener">源码阅读</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;** Go语言内存分配：** &amp;lt;Excerpt in index | 首页摘要&amp;gt;&lt;/p&gt;
&lt;p&gt;go语言养成记之Go语言内存分配&lt;/p&gt;
    
    </summary>
    
    
      <category term="golang" scheme="https://alexbrucelu.github.io/categories/golang/"/>
    
    
      <category term="golang" scheme="https://alexbrucelu.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>测试与性能调优</title>
    <link href="https://alexbrucelu.github.io/2019/12/09/%E6%B5%8B%E8%AF%95%E4%B8%8E%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/"/>
    <id>https://alexbrucelu.github.io/2019/12/09/%E6%B5%8B%E8%AF%95%E4%B8%8E%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/</id>
    <published>2019-12-09T07:14:27.742Z</published>
    <updated>2019-12-09T07:14:27.742Z</updated>
    
    <content type="html"><![CDATA[<p>** 测试与性能调优：** &lt;Excerpt in index | 首页摘要&gt;</p><p>go语言养成记之测试与性能调优</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;** 测试与性能调优：** &amp;lt;Excerpt in index | 首页摘要&amp;gt;&lt;/p&gt;
&lt;p&gt;go语言养成记之测试与性能调优&lt;/p&gt;
    
    </summary>
    
    
      <category term="golang" scheme="https://alexbrucelu.github.io/categories/golang/"/>
    
    
      <category term="golang" scheme="https://alexbrucelu.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>数据结构入门</title>
    <link href="https://alexbrucelu.github.io/2019/12/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>https://alexbrucelu.github.io/2019/12/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</id>
    <published>2019-12-09T07:14:27.742Z</published>
    <updated>2019-12-09T07:14:27.742Z</updated>
    
    <content type="html"><![CDATA[<p>** 数据结构入门：** &lt;Excerpt in index | 首页摘要&gt;</p><p>常见的数据结构基础</p><a id="more"></a><h2 id="数据结构基础理论"><a href="#数据结构基础理论" class="headerlink" title="数据结构基础理论"></a>数据结构基础理论</h2><h3 id="什么是数据？"><a href="#什么是数据？" class="headerlink" title="什么是数据？"></a>什么是数据？</h3><p>数据：是描述客观事物的符号，是计算机中可以操作的对象，是能被计算机识别，并输入给计算机处理的符号集合。数据不仅仅包括整型、实型等数值类型，还包括字符及声音、图像、视频等非数值类型。 </p><h3 id="数据结构的概念"><a href="#数据结构的概念" class="headerlink" title="数据结构的概念"></a>数据结构的概念</h3><p>数据结构是计算机存储、组织数据的方式。数据结构是指相互之间存在一种或多种特定关系的数据元素的集合。通常情况下，精心选择的数据结构可以带来更高的运行或者存储效率。数据结构往往同高效的检索算法和索引技术有关。 </p><blockquote><p><font color="red">数据结构是计算机存储、组织数据的方式。是相互之间存在一种或多种特定关系的数据元素集合 </font></p></blockquote><h3 id="算法的概念"><a href="#算法的概念" class="headerlink" title="算法的概念"></a>算法的概念</h3><p>算法：<font color="red">特定问题求解不走的描述，</font>在计算机中表现为<strong>指令的有限序列</strong>，算法是独立存在的一种解决问题的方法和思想。<strong>对于算法来说，语言不重要，重要的是思想。</strong></p><h4 id="算法和数据结构的区别"><a href="#算法和数据结构的区别" class="headerlink" title="算法和数据结构的区别"></a>算法和数据结构的区别</h4><p>数据结构只是静态的描述了数据元素之间的关系，高效的程序需要在数据结构的基础上设计和选择算法。</p><ul><li><font color="red">算法是为了解决实际问题而设计的</font></li><li><font color="red">数据结构是算法需要处理的问题的载体</font></li><li>数据结构与算法相符相成</li></ul><h4 id="算法的比较"><a href="#算法的比较" class="headerlink" title="算法的比较"></a>算法的比较</h4><p>假设求解1 + 2 + … + 100 的结果，写程序会怎么写</p><ul><li><p><strong>方法一：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">sum := <span class="number">0</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">n := <span class="number">100</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    sum += i</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">fmt.Println(<span class="string">"%d"</span>,sum)</span></pre></td></tr></table></figure></li><li><p><strong>方法二：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">sum := <span class="number">0</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">n := <span class="number">100</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">sum = (<span class="number">1</span> + n) * n / <span class="number">2</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">fmt.Println(<span class="string">"%d"</span>,sum)</span></pre></td></tr></table></figure></li></ul><p><strong>上述两段代码，第二种算法会比较高效，这就是一个好的算法对程序高效性的体现。</strong></p><h4 id="算法的特性"><a href="#算法的特性" class="headerlink" title="算法的特性"></a>算法的特性</h4><p>算法的五大基本特性：<strong>输入、输出、有穷性、确定性和可行性。</strong></p><p><strong>输入、输出：</strong>算法具有零个或多个输入，至少有一个或多个输出。</p><p><strong>有穷性：</strong>指算法在执行有限的步骤之后，自动结束而不会出现无限循环，并且每一个步骤在可接受的时间内完成。</p><p><strong>确定性：</strong>算法的每一步骤都有确定的含义，不会出现二义性。</p><p><strong>可行性：</strong>算法的每一步都必须是可行的，换言之，每一步都能通过执行有限次数完成。</p><h3 id="数据结构分类"><a href="#数据结构分类" class="headerlink" title="数据结构分类"></a>数据结构分类</h3><p>按照视点的不同，可以把数据结构分为<strong>逻辑结构、物理结构。</strong></p><h4 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h4><h5 id="集合结构"><a href="#集合结构" class="headerlink" title="集合结构"></a>集合结构</h5><p>集合结构中的数据元素除了同属于一个集合外，它们本身之间并没有关系。各个数据元素是平等的。它们共同属于同一个集合，数据结构中的集合关系类似于数学中的集合，如下图：</p><p><img src="https://github.com/AlexBruceLu/DAPP/wiki/data1.png" alt=""></p><h5 id="线性结构"><a href="#线性结构" class="headerlink" title="线性结构"></a>线性结构</h5><p>线性结构中的数据元素之间是一一对应关系。如下图：</p><p><img src="https://github.com/AlexBruceLu/DAPP/wiki/data2.png" alt=""></p><h5 id="树形结构"><a href="#树形结构" class="headerlink" title="树形结构"></a>树形结构</h5><p>树形结构中是数据元素之间存在一种一对多的层次关系，如下图：</p><p><img src="https://github.com/AlexBruceLu/DAPP/wiki/data3.png" alt=""></p><h5 id="图形结构"><a href="#图形结构" class="headerlink" title="图形结构"></a>图形结构</h5><p>图形结构中的数据元素之间是存在多对多的关系，如图：</p><p><img src="https://github.com/AlexBruceLu/DAPP/wiki/data4.png" alt=""></p><h4 id="物理结构"><a href="#物理结构" class="headerlink" title="物理结构"></a>物理结构</h4><p><strong>物理结构：</strong>是指数据的逻辑结构在计算机中的存储形式，共分为两种：顺序存储和链式存储。</p><h5 id="顺序存储"><a href="#顺序存储" class="headerlink" title="顺序存储"></a>顺序存储</h5><p>是把数据元素存放在地址连续的存储单元里，其数据的逻辑关系和物理关系是一致的，如图：</p><p><img src="https://github.com/AlexBruceLu/DAPP/wiki/data5.png" alt=""></p><blockquote><p>如果所有的数据结构都很简单且有规律，就比较易于操作。可往往实际情况，数据结构中的元素总会遇到增、删、改、查的操作。面对市场变化的数据结构，运用以上顺序存储是不科学的。</p></blockquote><h5 id="链式存储"><a href="#链式存储" class="headerlink" title="链式存储"></a>链式存储</h5><p>是把数据元素存放在任意的存储单元里，这组存储单元可以是连续的，也可以是不连续的。数据存储的关系并不能反映其逻辑关系，因此需要用一个指针存放数据元素的地址，这样通过地址就可以找到相关数据的位置，如下图：</p><p><img src="https://github.com/AlexBruceLu/DAPP/wiki/data6.png" alt=""></p><h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><h3 id="线性表基础概念"><a href="#线性表基础概念" class="headerlink" title="线性表基础概念"></a>线性表基础概念</h3><p>线性表是一种最简单的且常用的数据结构。数据结构的基本特点是节点之间满足线性关系。动态数组、栈、队列都属于线性结构。它们的共同之处，是节点中有且只有一个开始节点和终端节点。这种关系，可以把它们的所有节点排成一个线性序列。但是，它们分别属于几种不同的抽象数据类型实现，它们之间的区别，主要就是操作的不同。</p><p>线性表是零个或多个数据元素的有限序列，数据元素之间是有顺序的，数据元素个数是有限的，数据元素的类型必须相同。</p><p><img src="https://github.com/AlexBruceLu/DAPP/wiki/data7.png" alt=""></p><p>线性表的性质：</p><ul><li><p>a0 为线性表的第一个元素，只有一个后继；</p></li><li><p>an 为线性表的最后一个元素，只有一个前驱；</p></li><li><p>除了 a0 和 an 外的其他元素 ai ，既有一个前驱又有一个后继；</p></li><li><p>线性表能够逐项访问和顺序存取；</p><blockquote><p><strong>线性表的抽象数据类型定义：</strong> </p><p>ADT 线性表（ List） </p><p>Data<br>线性表的数据对象集合为{ a0, a1, ……, an }，每个元素的类型均为 DataType。其中，除第一个元素 a0外，每个元素有且只有一个直接前驱元素，除了最后一个元素 an 外，每个元素有且只有一个直接后继元素。数据元素之间的关系是一一对应的。 </p><p>peration（操作）<br>// 初始化，建立一个空的线性表 L。<br>InitList(*L);<br>// 若线性表为空，返回 true，否则返回 false<br>ListEmpty(L);<br>// 将线性表清空 </p><p>ClearList(<em>L);<br>// 将线性表 L 中的第 i 个位置的元素返回给 e<br>GetElem(L, i, *e);<br>// 在线性表 L 中的第 i 个位置插入新元素 e<br>ListInsert(</em>L, i, e);<br>// 删除线性表 L 中的第 i 个位置元素，并用 e 返回其值<br>ListDelete(<em>L, i, *e);<br>// 返回线性表 L 的元素个数<br>ListLength(L);<br>// 销毁线性表<br>DestroyList(</em>L); </p></blockquote></li></ul><h3 id="线性表的顺序存储"><a href="#线性表的顺序存储" class="headerlink" title="线性表的顺序存储"></a>线性表的顺序存储</h3><p>通常线性表可以采用顺序存储和链式存储。</p><p>采用顺序存储是表示线性表最简单的方法，具体做法是：将线性表中的元素一个接一个的存储在一块连续的存储区域中，这种顺序表示的线性表也称为顺序表。</p><h4 id="线性表顺内需存储（动态数组）的设计与实现"><a href="#线性表顺内需存储（动态数组）的设计与实现" class="headerlink" title="线性表顺内需存储（动态数组）的设计与实现"></a>线性表顺内需存储（动态数组）的设计与实现</h4><p><font color="red"><strong>操作要点：</strong></font></p><ul><li><p>插入元素操作</p><ul><li>判断线性表是否合法</li><li>判断插入位置是否合法</li><li>判断空间是否满足</li><li>把最后一个与元素到插入位置的元素后移一位</li><li>将新元素插入</li><li>线性表长度加1</li></ul></li><li><p>获取元素操作</p><ul><li>判断线性表是否合法</li><li>判断位置是否合法</li><li>直接通过元素的下表方式获取元素</li></ul></li><li><p>删除元素的操作</p><ul><li>判断线性表是否合法</li><li>判断删除位置是否合法</li><li>将元素取出</li><li>将删除位置后的元素分别向前移动一个位置</li><li>线性表长度减1</li></ul></li><li><p>元素的插入</p><p><img src="!%5B%5D(https://github.com/AlexBruceLu/DAPP/wiki/data8.png" alt=""></p></li><li><p>元素的删除</p><p><img src="!%5B%5D(https://github.com/AlexBruceLu/DAPP/wiki/data9.png" alt=""></p><p><font color="red"><strong>注意：</strong></font>链表的容量和链表的长度是两个不同的概念</p></li></ul><h4 id="优点和缺点"><a href="#优点和缺点" class="headerlink" title="优点和缺点"></a>优点和缺点</h4><p><font color="red"><strong>优点</strong></font></p><ul><li>无需为线性表中的逻辑关系增加额外的空间</li><li>可以快速的获取表中合法位置的元素</li></ul><p><font color="red"><strong>缺点</strong></font></p><ul><li>插入和删除操作需要移动大量的元素</li></ul><h3 id="线性表的链式存储"><a href="#线性表的链式存储" class="headerlink" title="线性表的链式存储"></a>线性表的链式存储</h3><p>链表为了表示每个元素与其直接后继元素之间的逻辑关系，每个元素除了存储本身的信息外，还需要存储指示其直接后继的信息。</p><p><img src="!%5B%5D(https://github.com/AlexBruceLu/DAPP/wiki/data10.png" alt=""></p><ul><li><p>单链表</p><ul><li><p>线性表的链式存储结构中，每个节点中只包含一个指针域，这样的链表叫做单链表</p></li><li><p>通过每个节点的指针域将线性表的数据元素按其逻辑次序链接在一起</p><p><img src="!%5B%5D(https://github.com/AlexBruceLu/DAPP/wiki/data11.png" alt=""></p></li></ul></li><li><p>概念解释</p><ul><li><p>表头节点</p><ul><li>链表中的第一个节点，包含指向第一个数据元素的指针以及链表自身的一些信息</li></ul></li><li><p>数据节点</p><ul><li>链表中代表数据元素的节点，包含指向下一个数据元素的指针和数据元素的信息</li></ul></li><li><p>尾节点</p><ul><li>链表中的最后一个数据节点，下一个元素指针为空，表示无后继元素</li></ul><p><img src="https://github.com/AlexBruceLu/DAPP/wiki/data12.png" alt=""></p></li></ul></li></ul><h4 id="线性表的链式存储（单项链表）的设计与实现"><a href="#线性表的链式存储（单项链表）的设计与实现" class="headerlink" title="线性表的链式存储（单项链表）的设计与实现"></a>线性表的链式存储（单项链表）的设计与实现</h4><ul><li><p><strong>插入操作</strong></p><p><img src="https://github.com/AlexBruceLu/DAPP/wiki/data13.png" alt=""></p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">node -&gt; next &#x3D; current -&gt; next;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">current -&gt; next &#x3D; node;</span></pre></td></tr></table></figure><ul><li><p>删除操作</p><p><img src="https://github.com/AlexBruceLu/DAPP/wiki/data14.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">current-&gt;next &#x3D; ret-&gt;next;</span></pre></td></tr></table></figure></li></ul><h4 id="优点和缺点-1"><a href="#优点和缺点-1" class="headerlink" title="优点和缺点"></a>优点和缺点</h4><ul><li><font color="red"><strong>优点</strong></font><ul><li>无需一次性定制链表的容量 </li><li>插入和删除操作无需移动数据元素 </li></ul></li><li><font color="red"><strong>缺点</strong></font><ul><li>数据元素必须保存后继元素的位置信息 </li><li>获取指定数据的元素操作需要顺序访问之前的元素 </li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;** 数据结构入门：** &amp;lt;Excerpt in index | 首页摘要&amp;gt;&lt;/p&gt;
&lt;p&gt;常见的数据结构基础&lt;/p&gt;
    
    </summary>
    
    
      <category term="others" scheme="https://alexbrucelu.github.io/categories/others/"/>
    
    
      <category term="数据结构" scheme="https://alexbrucelu.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>常见的共识算法</title>
    <link href="https://alexbrucelu.github.io/2019/12/09/%E5%B8%B8%E8%A7%81%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/"/>
    <id>https://alexbrucelu.github.io/2019/12/09/%E5%B8%B8%E8%A7%81%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/</id>
    <published>2019-12-09T07:14:27.742Z</published>
    <updated>2019-12-09T07:14:27.742Z</updated>
    
    <content type="html"><![CDATA[<p>** 常见的共识算法：** &lt;Excerpt in index | 首页摘要&gt;</p><p>PoS、PoW、DPoS</p><a id="more"></a><p>本文是对区块链技术中涉及的共识算法的学习总结整理。 其中PBFT和Raft是联盟链和私有链常用的共识算法，而PoW（比特币采用）和PoS是公有链常用的共识算法。</p><blockquote><p>建议对区块链的学习，要分成是公有链还是联盟链，这两种链中一般采用的共识算法是有较大不同的，P2P网络等也有较大的不同。传统的共识算法一般不适用于公有链，而一定程度上适用于联盟链。</p></blockquote><h2 id="实用拜占庭容错系统PBFT（联盟链中常用）"><a href="#实用拜占庭容错系统PBFT（联盟链中常用）" class="headerlink" title="实用拜占庭容错系统PBFT（联盟链中常用）"></a>实用拜占庭容错系统PBFT（联盟链中常用）</h2><p>拜占庭容错技术（Byzantine Fault Tolerance,BFT）是一类分布式计算领域的容错技术，是一种解决分布式系统容错问题的通用方案。实用拜占庭容错系统（Practical Byzantine Fault Tolerance，PBFT）使拜占庭协议的运行复杂度从指数级别降低到多项式级别，使拜占庭协议在分布式系统中应用成为可能。</p><h3 id="拜占庭将军问题"><a href="#拜占庭将军问题" class="headerlink" title="拜占庭将军问题"></a>拜占庭将军问题</h3><p>拜占庭将军（Byzantine Generals Problem）问题，是 Leslie Lamport 1982 年提出用来解释一致性问题的一个虚构模型。拜占庭是古代东罗马帝国的首都，由于地域宽广，守卫边境的多个将军（系统中的多个节点）需要通过信使来传递消息，达成某些一致的决定。但由于将军中可能存在叛徒（系统中节点出错），这些叛徒将努力向不同的将军发送不同的消息，试图会干扰一致性的达成。拜占庭问题即为在此情况下，如何让忠诚的将军们能达成行动的一致。</p><h3 id="拜占庭容错系统"><a href="#拜占庭容错系统" class="headerlink" title="拜占庭容错系统"></a>拜占庭容错系统</h3><p>拜占庭容错系统是指：在一个拥有nn台节点的系统，整个系统，对每个请求满足如下条件：</p><p>所有非拜占庭节点使用相同的输入信息，产生同样的结果；<br>如果输入的信息正确，那么所有非拜占庭节点必须接收这个信息，并计算相应的结果。<br>与此同时,在拜占庭系统的实际运行过程中一般假设系统中拜占庭节点不超过mm台，并且对每个请求满足2个指标：</p><p>安全性——任何已经完成的请求都不会被更改，它可以在以后请求看到；<br>活性——可以接受并且执行非拜占庭客户端的请求，不会被任何因素影响而导致非拜占庭客户端的请求不能执行。<br>拜占庭系统目前普遍采用的假设条件包括: </p><p>1) 拜占庭节点的行为可以是任意的，拜占庭节点之间可以共谋；<br>2) 节点之间的错误是不相关的；<br>3) 节点之间通过异步网络连接，网络中的消息可能丢失、乱序、延时到达；<br>4) 服务器之间传递的信息,第三方可以知晓 ,但是不能窜改、伪造信息的内容和验证信息的完整性；</p><p>（发生故障的节点称为拜占庭节点；正常的节点为非拜占庭节点。）</p><h3 id="状态机拜占庭系统"><a href="#状态机拜占庭系统" class="headerlink" title="状态机拜占庭系统"></a>状态机拜占庭系统</h3><h4 id="状态机拜占庭系统的特点"><a href="#状态机拜占庭系统的特点" class="headerlink" title="状态机拜占庭系统的特点"></a>状态机拜占庭系统的特点</h4><p>状态机拜占庭系统的特点是整个系统共同维护一个状态,所有节点采取一致的行动,一般包括 3 种协议：一致性协议、 检查点协议和视图更换协议。系统正常运行在一致性协议和检查点协议下，视图更换协议则是只有在主节点出错或者运行缓慢的情况下才会启动，负责维系系统继续执行客户端请求的能力。</p><h4 id="状态机拜占庭系统的核心协议"><a href="#状态机拜占庭系统的核心协议" class="headerlink" title="状态机拜占庭系统的核心协议"></a>状态机拜占庭系统的核心协议</h4><h5 id="一、一致性协议"><a href="#一、一致性协议" class="headerlink" title="一、一致性协议"></a>一、一致性协议</h5><p>一致性协议的目标是使来自客户端的请求在每个服务器上都按照一个确定的顺序执行。在协议中，一般有一个服务器被称作主节点，负责将客户端的请求排序；其余的服务器称作从节点，按照主节点提供的顺序执行请求。所有的服务器都在相同的配置信息下工作，这个配置信息称作view，每更换一次主节点，view就会随之变化。</p><p>一致性协议至少包含3个阶段：发送请求、序号分配和返回结果。根据协议设计的不同，可能包含相互交互、序号确认等阶段。</p><p>一致性协议解决一致性的方法主要有：<br>1）服务器之间两两交互，服务器通过将自己获得的信息传递给其他的服务器；<br>2）由客户端收集服务器的信息，将收集的信息制作成证明文件再发送给服务器。对于一个包含3m+13m+1台服务器的拜占庭系统，需要收集到2m+12m+1台服务器发送的一致信息，才能保证达成一致的非拜占庭服务器数量大于拜占庭服务器数量。</p><p>引申思考： </p><ol><li>部署一个采用PBFT共识算法的区块链，至少需要几个节点呢？ </li><li>PBFT共识算法的区块链，最佳节点数量问题，采用PBFT共识算法的区块链系统节点数量的下限和上限？</li></ol><h5 id="二、检查点协议"><a href="#二、检查点协议" class="headerlink" title="二、检查点协议"></a>二、检查点协议</h5><p>拜占庭系统每执行一个请求，服务器需要记录日志。如果日志得不到及时的清理，就会导致系统资源被大量的日志所占用，影响系统性能及可用性。另一方面，由于拜占庭服务器的存在，一致性协议并不能保证每一台服务器都执行了相同的请求，所以，不同服务器状态可能不一致。例如，某些服务器可能由于网络延时导致从某个序号开始，之后的请求都没有执行。因此，拜占庭系统中设置周期性的检查点协议，将系统中的服务器同步到某一个相同的状态。因此，周期性的检查点协议可以定期地处理日志，节约资源，同时及时纠正服务器状态。</p><p>处理日志主要解决的问题就是区分那些日志可以清理，那些日志仍然需要保留。如果一个请求已经被m+1m+1台非拜占庭服务器执行，并且某一服务器ii能够向其他的服务器证明这一点，那么ii就可以将关于这个请求的日志删除。目前，协议普遍采用的方式是服务器每执行一定数量的请求，就将自己的状态发送给所有服务器并且执行一个该协议，如果某台服务器接收到2m+12m+1台服务器的状态，那么其中一致的部分就是至少有m+1m+1非拜占庭服务器经历过的状态，因此，这部分的日志就可以删除，同时将自己状态更新只较新状态。</p><h5 id="三、视图更换"><a href="#三、视图更换" class="headerlink" title="三、视图更换"></a>三、视图更换</h5><p>在一致性协议里，已经知道主节点在整个系统中拥有序号分配，请求转发等核心能力，支配着这个系统的运行行为。然而一旦主节点自身发生错误，就可能导致从节点接收到具有相同序号的不同请求，或者同一个请求被分配多个序号等问题，这将直接导致请求不能被正确执行。视图更换协议的作用就是在主节点不能继续履行职责时，将其用一个从节点替换掉，并且保证已经被非拜占庭服务器执行的请求不会被篡改。</p><p>视图更换协议一般有两种触发方式：<br>1）只由服务器触发，这一类触发方式中，判断服务器一致性是否达成的工作是由服务器自身负责，客户端不能从请求的整个执行过程中获得服务器运行状况的信息；<br>2）客户端触发，这一类触发方式中，客户端一般负责判断服务器是否达成一致，如果不达成一致，那么就能判断服务器运行出现问题，如果是主节点的问题就会要求服务器更换主节点。</p><p>视图更换协议需要解决的问题是如何保证已经被非拜占庭服务器执行的请求不被更改。由于系统达成一致性之后至少有m+1m+1台非拜占庭服务器执行了请求，所以目前采用的方法是：由新的主节点收集至少2m+12m+1台服务器的状态信息，这些状态信息中一定包含所有执行过的请求；然后，新主节点将这些状态信息发送给所有的服务器，服务器按照相同的原则将在上一个主节点完成的请求同步一遍.同步之后,所有的节点都处于相同的状态,这时就可以开始执行新的请求。</p><h4 id="实用拜占庭容错系统PBFT详解"><a href="#实用拜占庭容错系统PBFT详解" class="headerlink" title="实用拜占庭容错系统PBFT详解"></a>实用拜占庭容错系统PBFT详解</h4><p>实用拜占庭容错系统（Practical Byzantine Fault Tolerance，PBFT），是一类状态机拜占庭系统。</p><p>PBFT的一致性协议如下：PBFT系统通常假设故障节点数为mm个，而整个服务节点数为3m+13m+1个。每一个客户端的请求需要经过5个阶段，通过采用两次两两交互的方式在服务器达成一致之后再执行客户端的请求。由于客户端不能从服务器端获取任何服务器运行的状态信息，PBFT中主节点是否发生错误只能由服务器监测。如果服务器在一段时间内都不能完成客户端的请求，则会触发视图更换协议。 </p><p><img src="https://github.com/AlexBruceLu/DAPP/wiki/ddd.png" alt=""></p><p>上图显示了一个简化的PBFT的协议通信模式，其中CC为客户端，N0N0~N3N3表示服务节点，特别的，N0N0为主节点，N3N3为故障节点。整个协议的基本过程如下：<br>1）客户端发送请求，激活主节点的服务操作；<br>2）当主节点接收请求后，启动三阶段的协议以向各从节点广播请求；</p><p>序号分配阶段，主节点给请求赋值一个序号nn，广播序号分配消息和客户端的请求消息mm，并将构造pre-prepare消息给各从节点；<br>交互阶段，从节点接收pre-prepare消息，向其他服务节点广播prepare消息；<br>序号确认阶段，各节点对视图内的请求和次序进行验证后，广播commit消息，执行收到的客户端的请求并给客户端响应。<br>3）客户端等待来自不同节点的响应，若有m+1m+1个响应相同，则该响应即为运算的结果；</p><h3 id="Raft协议"><a href="#Raft协议" class="headerlink" title="Raft协议"></a>Raft协议</h3><p>Raft是在非拜占庭故障下达成共识的强一致协议。在区块链系统中，使用Raft实现记账共识的过程可以描述如下：首先选举一个leader，接着赋予leader完全的权利管理记账。leader从客户端接收记账请求，完成记账操作，生成区块，并复制到其他记账节点。有了leader简化了记账操作的管理。如果leader失效或与其他节点失去联系，这时，系统就会选出新的leader。</p><h4 id="Raft基础"><a href="#Raft基础" class="headerlink" title="Raft基础"></a>Raft基础</h4><p>一个Raft集群通常包含5个服务器，允许系统有2个故障服务器。每个服务器处于3个状态之一：leader、follower或candidate。正常操作状态下，仅有一个leader，其他的服务器均为follower。follower是被动的，不会对自身发出的请求而是对来自leader和candidate的请求做出响应。leader处理所有的客户端请求（若客户端联系follower，则该follower将转发给leader)。candidate状态用来选举leader。</p><p>Raft阶段主要分为两个，首先是leader选举过程，然后在选举出来的leader基础上进行正常操作，比如日志复制、记账等。</p><h4 id="leader选举"><a href="#leader选举" class="headerlink" title="leader选举"></a>leader选举</h4><p>当follower在选举超时时间内未收到leader的心跳消息，则转换为candidate状态。为了避免选举冲突，这个超时时间是一个150~300ms之间的随机数。</p><p>一般而言，在Raft系统中：<br>1）任何一个服务器都可以成为一个候选者candidate，它向其他服务器follower发出要求选举自己的请求。<br>2）其他服务器同意了，发出OK。如果在这个过程中，有一个follower宕机，没有收到请求选举的要求，此时候选者可以自己选自己，只要达到N/2+1N/2+1的大多数票，候选人还是可以成为leader。<br>3）这样这个候选者就成为了leader领导人，它可以向follower发出指令，比如进行记账。<br>4）以后可以通过心跳进行记账的通知。<br>5）一旦这个leader崩溃了，那么follower中有一个成为候选者，并发出邀票选举。<br>6）follower同意后，其成为leader，继续承担记账等指导工作。</p><h4 id="记账过程"><a href="#记账过程" class="headerlink" title="记账过程"></a>记账过程</h4><p>Raft的记账过程按以下步骤完成：<br>1）假设leader领导人已经选出，这时客户端发出增加一个日志的要求；<br>2）leader要求follower遵从他的指令，都将这个新的日志内容追加到他们各自日志中；<br>3）大多数follower服务器将交易记录写入账本后，确认追加成功，发出确认成功消息；<br>4）在下一个心跳中，leader会通知所有follower更新确认的项目。<br>对于每个新的交易记录，重复上述过程。</p><p>如果在这一过程中，发生了网络通信故障，使得leader不能访问大多数follower，那么leader只能正常更新它能访问的那些follower服务器。而大多数的服务器follower因为没有了leader，它们将重新选举一个候选者作为leader，然后这个leader作为代表与外界打交道，如果外界要求其添加新的交易记录，这个新的leader就按上述步骤通知大多数follower，如果这时网络故障修复了，那么原先的leader就变成follower，在失联阶段，这个老leader的任何更新都不能算确认，都回滚，接收新的leader的新更新。</p><p>如果想更直观的理解Raft协议，可以看动画演示。<br>论文原文：In Search of an Understandable Consensus Algorithm<br>学习参考：The Raft Consensus Algorithm</p><h2 id="PoW"><a href="#PoW" class="headerlink" title="PoW"></a>PoW</h2><p>PoW的原理可参看这篇博文中哈希函数难题友好性这一节：<a href="http://blog.csdn.net/s_lisheng/article/details/77937202，理解了难题友好性，就基本理解了PoW机制的原理。结合比特币去理解PoW。比特币PoW的过程，就是将不同的nonce值作为输入，尝试进行SHA256哈希运算，找出满足给定数量前导0的哈希值的过程。要求的前导0的个数越多，代表难度越大。比特币节点求解工作量证明问题的步骤归纳如下：" target="_blank" rel="noopener">http://blog.csdn.net/s_lisheng/article/details/77937202，理解了难题友好性，就基本理解了PoW机制的原理。结合比特币去理解PoW。比特币PoW的过程，就是将不同的nonce值作为输入，尝试进行SHA256哈希运算，找出满足给定数量前导0的哈希值的过程。要求的前导0的个数越多，代表难度越大。比特币节点求解工作量证明问题的步骤归纳如下：</a></p><p>1）生成铸币交易，并与其他所有准备打包进区块的交易组成交易列表，通过Merkle树算法生成Merkle跟哈希；<br>2）把Merkle根哈希及其他相关字段组装成区块头，将区块头的80字节数据作为工作量证明的输入；<br>3）不停地变更区块头中的随机数nonce，并对每次变更后的区块头做双重SHA256运算，将结果值与当前网络的目标难度做比对，如果满足难度条件，则解题成功，工作量证明完成。</p><h2 id="PoS"><a href="#PoS" class="headerlink" title="PoS"></a>PoS</h2><p>PoW存在以下弊端：</p><p>矿池的出现，一定程度上违背了去中心化的初衷，同时也使得51%攻击成为可能，影响其安全性。<br>PoW存在巨大的算力浪费，看看矿池用掉多少电就知道了。<br>PoS（权益证明，Proof of Stake）的出现很大程度上是因为PoW的缺陷而提出的。采用PoS的币中不同币的PoS不完全相同，权益证明要求用户证明拥有某些数量的货币（即对货币的权益），下面以点点币为例，理解PoS的思想。</p><p>点点币在SHA-256的哈希运算的难度方便引入了币龄的概念，使得难度与交易输入的币龄成反比。在点点币中，币龄被定义为币的数量与币所拥有的天数的乘积。点点币的权益证明机制结合了随机化与币龄的概念，未使用至少30天的币可以参与竞争下一区块，越久和越大的币集有更大的可能去签名下一区块。而一旦币的权益被用于签名一个区块，则币龄将清为零，这样必须等待至少30日才能签署另一个区块。同时，为防止非常老或非常大的权益控制区块链，寻找下一区块的最大概率在90天后达到最大值，这一过程保护了网络，并随着时间逐渐成为新的币而无需消耗大量的计算能力。</p><h2 id="DPoS"><a href="#DPoS" class="headerlink" title="DPoS"></a>DPoS</h2><p>PoS机制虽然考虑了PoW的不足，但也有缺点：依据权益结余来选择，会导致首富账户的权力更大，有可能支配记账权。股份授权证明机制（Delegated Proof of Stake，DPoS），是对PoW、PoS不足的提出的。下面以比特股为例，理解DPoS的思想。</p><p>比特股引入了见证人这个概念，见证人可以生成区块，每一个持有比特股的人都可以投票选举见证人。得到总同意票数中的前NN个（NN通常定义为101）候选者可以当选为见证人，当选见证人的个数需满足：至少一半的参与投票者相信NN已经充分地去中心化。见证人的候选名单每个维护周期（1天）更新一次。见证人然后随机排列，每个见证人按序有2秒的权限时间生成区块，若见证人在给定的时间片不能生成区块，区块生成权限交给下一时间片对应的见证人。如果见证人提供的算力不稳定或计算机宕机等，持股人可以随时通过投票更换这些见证人。</p><p>可以看到，其核心思想是通过缩小参与核心共识过程的节点数量，以提高共识效率。（这里可以认为选举见证人的过程为非核心共识过程，而见证人按序生成区块可以认为是核心共识过程）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;** 常见的共识算法：** &amp;lt;Excerpt in index | 首页摘要&amp;gt;&lt;/p&gt;
&lt;p&gt;PoS、PoW、DPoS&lt;/p&gt;
    
    </summary>
    
    
      <category term="others" scheme="https://alexbrucelu.github.io/categories/others/"/>
    
    
      <category term="共识算法" scheme="https://alexbrucelu.github.io/tags/%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>类型断言</title>
    <link href="https://alexbrucelu.github.io/2019/12/09/%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80/"/>
    <id>https://alexbrucelu.github.io/2019/12/09/%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80/</id>
    <published>2019-12-09T07:14:27.742Z</published>
    <updated>2019-12-09T07:14:27.742Z</updated>
    
    <content type="html"><![CDATA[<p>** 类型断言：** &lt;Excerpt in index | 首页摘要&gt;</p><p>go语言养成记之类型断言</p><a id="more"></a><p>[TOC]</p><h2 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h2><h3 id="引出类型断言的需求案例"><a href="#引出类型断言的需求案例" class="headerlink" title="引出类型断言的需求案例"></a>引出类型断言的需求案例</h3><p>如何将一个接口变量，赋值给自定义类型的变量？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Point <span class="keyword">struct</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    x <span class="keyword">int</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    y <span class="keyword">int</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">var</span> a <span class="keyword">interface</span>&#123;&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">var</span> point Point = Point&#123;<span class="number">1</span>,<span class="number">2</span>&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    a = point <span class="comment">// ok</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 如何将a赋给一个Point变量</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">var</span> b Point</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    b = a <span class="comment">// 可以吗 =&gt; error</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// cannot use a (type interface &#123;&#125;) as type Point in assignment: need type assertion</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    fmt.Println(b)  </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>可以转换为以下代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">var</span> a <span class="keyword">interface</span>&#123;&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">var</span> point Point = Point&#123;<span class="number">1</span>,<span class="number">2</span>&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    a = point</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">var</span> b Point</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    b = a.(Point) <span class="comment">// 类型断言</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    fmt.Println(b)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行结果</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// &#123;1 2&#125;</span></span></pre></td></tr></table></figure><p>代码说明：<code>b = a.(Point)</code>就是类型断言，表示判断<code>a</code>是否指向<code>Point</code>类型的变量，如果是就转化为<code>Point</code>类型并赋值给<code>b</code>变量，否则报错。</p><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>类型断言，有接口是一般类型，不知道具体类型，如果要转成具体类型，就需要使用类型断言，具体如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="keyword">interface</span>&#123;&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> b2 <span class="keyword">float32</span> = <span class="number">1.1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">x = b2</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">y := x.(<span class="keyword">float32</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">fmt.Printf(<span class="string">"y 的类型是 %T 值是 = %v"</span>,y,y)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行结果</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// y 的类型是 float32 值是 = 1.1</span></span></pre></td></tr></table></figure><p><font color="red"><strong>对上面代码的说明：</strong></font></p><p>在进行类型断言时，如果类型不匹配，就会报<code>panic</code>，因此，进行类型断言时，要确保原来的空接口指向的就是断言的类型。</p><p><font color="red"><strong>如何在进行断言时，带上检测机制，如果成功就ok，否则也不要报<code>panic</code></strong></font></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="keyword">interface</span>&#123;&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> b2 <span class="keyword">float32</span> = <span class="number">1.1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">x = b2</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>y,ok := x.(<span class="keyword">float32</span>); ok &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    fmt.Println(<span class="string">"convert success"</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    fmt.Printf(<span class="string">"y 的类型是 %T 值是 = %v"</span>,y,y)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">&#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    fmt.Println(<span class="string">"convert fail"</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">fmt.Println(<span class="string">"继续执行。。。"</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行结果</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// convert success</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// y 的类型是 float32 值是 = 1.1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 继续执行。。。</span></span></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;** 类型断言：** &amp;lt;Excerpt in index | 首页摘要&amp;gt;&lt;/p&gt;
&lt;p&gt;go语言养成记之类型断言&lt;/p&gt;
    
    </summary>
    
    
      <category term="golang" scheme="https://alexbrucelu.github.io/categories/golang/"/>
    
    
      <category term="golang" scheme="https://alexbrucelu.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>Go语言unsafe</title>
    <link href="https://alexbrucelu.github.io/2019/12/09/%E6%B7%B1%E5%BA%A6%E8%A7%A3%E5%AF%86Go%E8%AF%AD%E8%A8%80%E4%B9%8Bunsafe/"/>
    <id>https://alexbrucelu.github.io/2019/12/09/%E6%B7%B1%E5%BA%A6%E8%A7%A3%E5%AF%86Go%E8%AF%AD%E8%A8%80%E4%B9%8Bunsafe/</id>
    <published>2019-12-09T07:14:27.742Z</published>
    <updated>2019-12-09T07:14:27.742Z</updated>
    
    <content type="html"><![CDATA[<p>** Go语言unsafe：** &lt;Excerpt in index | 首页摘要&gt;</p><p>go语言养成记之深度解密Go语言unsafe</p><a id="more"></a><p>[TOC]</p><p>上一篇<a href="https://mp.weixin.qq.com/s/2CDpE5wfoiNXm1agMAq4wA" target="_blank" rel="noopener">文章</a>我们详细分析了 map 的底层实现，如果你也跟着阅读了源码，那一定对 <code>unsafe.Pointer</code> 不陌生，map 对 key 进行定位的时候，大量使用。</p><p><code>unsafe.Pointer</code> 位于 <code>unsafe 包</code>，这篇文章，我们来深入研究 unsafe 包。先说明一下，本文没有之前那么长了，你可以比较轻松地读完，这样的时候不是太多。</p><p>上次发布文章的时候，包括代码超过 5w 字，后台编辑器的体验非常差，一度让我怀疑人生。我之前说过，像 map 那样的长文，估计能读完的不超过 <code>1 %</code>。像下面这几位同学的评价，并不多见。</p><p><img src="https://user-images.githubusercontent.com/7698088/58759953-7eacfa00-8564-11e9-9d92-9974ffe7f8d7.png" alt="wechat"></p><p>个人认为，学习本身并不是一件轻松愉快的事情，寓教于乐是个美好的愿望。想要深刻地领悟，就得付出别人看不见的努力。学习从来都不会是一件轻松的事情，枯燥是正常的。耐住性子，深入研究某个问题，读书、看文章、写博客都可以，浮躁时代做个专注的人！</p><h1 id="指针类型"><a href="#指针类型" class="headerlink" title="指针类型"></a>指针类型</h1><p>在正式介绍 unsafe 包之前，需要着重介绍 Go 语言中的指针类型。</p><p>我本科开始学编程的时候，第一门语言就是 C。之后又陆续学过 C++，Java，Python，这些语言都挺强大的，但是没了 C 语言那么“单纯”。直到我开始接触 Go 语言，又找到了那种感觉。Go 语言的作者之一 Ken Thompson 也是 C 语言的作者。所以，Go 可以看作 C 系语言，它的很多特性都和 C 类似，指针就是其中之一。</p><p>然而，Go 语言的指针相比 C 的指针有很多限制。这当然是为了安全考虑，要知道像 Java/Python 这些现代语言，生怕程序员出错，哪有什么指针（这里指的是显式的指针）？更别说像 C/C++ 还需要程序员自己清理“垃圾”。所以对于 Go 来说，有指针已经很不错了，仅管它有很多限制。</p><p>为什么需要指针类型呢？参考文献 go101.org 里举了这样一个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">double</span><span class="params">(x <span class="keyword">int</span>)</span></span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    x += x</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">var</span> a = <span class="number">3</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    double(a)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    fmt.Println(a) <span class="comment">// 3</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>非常简单，我想在 double 函数里将 a 翻倍，但是例子中的函数却做不到。为什么？因为 Go 语言的函数传参都是<code>值传递</code>。double 函数里的 x 只是实参 a 的一个拷贝，在函数内部对 x 的操作不能反馈到实参 a。</p><p>如果这时，有一个指针就可以解决问题了！这也是我们常用的“伎俩”。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">double</span><span class="params">(x *<span class="keyword">int</span>)</span></span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    *x += *x</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    x = <span class="literal">nil</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">var</span> a = <span class="number">3</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    double(&amp;a)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    fmt.Println(a) <span class="comment">// 6</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    p := &amp;a</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    double(p)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    fmt.Println(a, p == <span class="literal">nil</span>) <span class="comment">// 12 false</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>很常规的操作，不用多解释。唯一可能有些疑惑的在这一句：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">x = <span class="literal">nil</span></span></pre></td></tr></table></figure><p>这得稍微思考一下，才能得出这一行代码根本不影响的结论。因为是值传递，所以 x 也只是对 &amp;a 的一个拷贝。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">*x += *x</span></pre></td></tr></table></figure><p>这一句把 x 指向的值（也就是 &amp;a 指向的值，即变量 a）变为原来的 2 倍。但是对 x 本身（一个指针）的操作却不会影响外层的 a，所以 <code>x = nil</code> 掀不起任何大风大浪。</p><p>下面的这张图可以“自证清白”：</p><p><img src="https://user-images.githubusercontent.com/7698088/58675362-96c72280-8386-11e9-89a6-f37204648b03.png" alt="pointer copy"></p><p>然而，相比于 C 语言中指针的灵活，Go 的指针多了一些限制。但这也算是 Go 的成功之处：既可以享受指针带来的便利，又避免了指针的危险性。</p><p>限制一：<code>Go 的指针不能进行数学运算</code>。</p><p>来看一个简单的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">a := <span class="number">5</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">p := &amp;a</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">p++</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">p = &amp;a + <span class="number">3</span></span></pre></td></tr></table></figure><p>上面的代码将不能通过编译，会报编译错误：<code>invalid operation</code>，也就是说不能对指针做数学运算。</p><p>限制二：<code>不同类型的指针不能相互转换</code>。</p><p>例如下面这个简短的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    a := <span class="keyword">int</span>(<span class="number">100</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">var</span> f *<span class="keyword">float64</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    f = &amp;a</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>也会报编译错误：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">cannot use &amp;a (<span class="built_in">type</span> *int) as <span class="built_in">type</span> *float64 <span class="keyword">in</span> assignment</span></pre></td></tr></table></figure><p>关于两个指针能否相互转换，参考资料中 go 101 相关文章里写得非常细，这里我不想展开。个人认为记住这些没有什么意义，有完美主义的同学可以去阅读原文。当然我也有完美主义，但我有时会克制，嘿嘿。</p><p>限制三：<code>不同类型的指针不能使用 == 或 != 比较</code>。</p><p>只有在两个指针类型相同或者可以相互转换的情况下，才可以对两者进行比较。另外，指针可以通过 <code>==</code> 和 <code>!=</code> 直接和 <code>nil</code> 作比较。</p><p>限制四：<code>不同类型的指针变量不能相互赋值</code>。</p><p>这一点同限制三。</p><h1 id="什么是-unsafe"><a href="#什么是-unsafe" class="headerlink" title="什么是 unsafe"></a>什么是 unsafe</h1><p>前面所说的指针是类型安全的，但它有很多限制。Go 还有非类型安全的指针，这就是 unsafe 包提供的 unsafe.Pointer。在某些情况下，它会使代码更高效，当然，也更危险。</p><p>unsafe 包用于 Go 编译器，在编译阶段使用。从名字就可以看出来，它是不安全的，官方并不建议使用。我在用 unsafe 包的时候会有一种不舒服的感觉，可能这也是语言设计者的意图吧。</p><p>但是高阶的 Gopher，怎么能不会使用 unsafe 包呢？它可以绕过 Go 语言的类型系统，直接操作内存。例如，一般我们不能操作一个结构体的未导出成员，但是通过 unsafe 包就能做到。unsafe 包让我可以直接读写内存，还管你什么导出还是未导出。</p><h1 id="为什么有-unsafe"><a href="#为什么有-unsafe" class="headerlink" title="为什么有 unsafe"></a>为什么有 unsafe</h1><p>Go 语言类型系统是为了安全和效率设计的，有时，安全会导致效率低下。有了 unsafe 包，高阶的程序员就可以利用它绕过类型系统的低效。因此，它就有了存在的意义，阅读 Go 源码，会发现有大量使用 unsafe 包的例子。</p><h1 id="unsafe-实现原理"><a href="#unsafe-实现原理" class="headerlink" title="unsafe 实现原理"></a>unsafe 实现原理</h1><p>我们来看源码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ArbitraryType <span class="keyword">int</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Pointer *ArbitraryType</span></pre></td></tr></table></figure><p>从命名来看，<code>Arbitrary</code> 是任意的意思，也就是说 Pointer 可以指向任意类型，实际上它类似于 C 语言里的 <code>void*</code>。</p><p>unsafe 包还有其他三个函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sizeof</span><span class="params">(x ArbitraryType)</span> <span class="title">uintptr</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Offsetof</span><span class="params">(x ArbitraryType)</span> <span class="title">uintptr</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Alignof</span><span class="params">(x ArbitraryType)</span> <span class="title">uintptr</span></span></span></pre></td></tr></table></figure><p><code>Sizeof</code> 返回类型 x 所占据的字节数，但不包含 x 所指向的内容的大小。例如，对于一个指针，函数返回的大小为 8 字节（64位机上），一个 slice 的大小则为 slice header 的大小。</p><p><code>Offsetof</code> 返回结构体成员在内存中的位置离结构体起始处的字节数，所传参数必须是结构体的成员。</p><p><code>Alignof</code> 返回 m，m 是指当类型进行内存对齐时，它分配到的内存地址能整除 m。</p><p>注意到以上三个函数返回的结果都是 uintptr 类型，这和 unsafe.Pointer 可以相互转换。三个函数都是在编译期间执行，它们的结果可以直接赋给 <code>const 型变量</code>。另外，因为三个函数执行的结果和操作系统、编译器相关，所以是不可移植的。</p><p>综上所述，unsafe 包提供了 2 点重要的能力：</p><blockquote><ol><li>任何类型的指针和 unsafe.Pointer 可以相互转换。</li><li>uintptr 类型和 unsafe.Pointer 可以相互转换。</li></ol></blockquote><p><img src="https://user-images.githubusercontent.com/7698088/58747453-1dbaee80-849e-11e9-8c75-2459f76792d2.png" alt="type pointer uintptr"></p><p>pointer 不能直接进行数学运算，但可以把它转换成 uintptr，对 uintptr 类型进行数学运算，再转换成 pointer 类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// uintptr 是一个整数类型，它足够大，可以存储</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="keyword">uintptr</span> <span class="keyword">uintptr</span></span></pre></td></tr></table></figure><p>还有一点要注意的是，uintptr 并没有指针的语义，意思就是 uintptr 所指向的对象会被 gc 无情地回收。而 unsafe.Pointer 有指针语义，可以保护它所指向的对象在“有用”的时候不会被垃圾回收。</p><p>unsafe 包中的几个函数都是在编译期间执行完毕，毕竟，编译器对内存分配这些操作“了然于胸”。在 <code>/usr/local/go/src/cmd/compile/internal/gc/unsafe.go</code> 路径下，可以看到编译期间 Go 对 unsafe 包中函数的处理。</p><p>更深层的原理需要去研究编译器的源码，这里就不去深究了。我们重点关注它的用法，接着往下看。</p><h1 id="unsafe-如何使用"><a href="#unsafe-如何使用" class="headerlink" title="unsafe 如何使用"></a>unsafe 如何使用</h1><h2 id="获取-slice-长度"><a href="#获取-slice-长度" class="headerlink" title="获取 slice 长度"></a>获取 slice 长度</h2><p>通过前面关于 slice 的<a href="https://mp.weixin.qq.com/s/MTZ0C9zYsNrb8wyIm2D8BA" target="_blank" rel="noopener">文章</a>，我们知道了 slice header 的结构体定义：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// runtime/slice.go</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    array unsafe.Pointer <span class="comment">// 元素指针</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">len</span>   <span class="keyword">int</span> <span class="comment">// 长度 </span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">cap</span>   <span class="keyword">int</span> <span class="comment">// 容量</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>调用 make 函数新建一个 slice，底层调用的是 makeslice 函数，返回的是 slice 结构体：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeslice</span><span class="params">(et *_type, <span class="built_in">len</span>, <span class="built_in">cap</span> <span class="keyword">int</span>)</span> <span class="title">slice</span></span></span></pre></td></tr></table></figure><p>因此我们可以通过 unsafe.Pointer 和 uintptr 进行转换，得到 slice 的字段值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    s := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">9</span>, <span class="number">20</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">var</span> Len = *(*<span class="keyword">int</span>)(unsafe.Pointer(<span class="keyword">uintptr</span>(unsafe.Pointer(&amp;s)) + <span class="keyword">uintptr</span>(<span class="number">8</span>)))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    fmt.Println(Len, <span class="built_in">len</span>(s)) <span class="comment">// 9 9</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">var</span> Cap = *(*<span class="keyword">int</span>)(unsafe.Pointer(<span class="keyword">uintptr</span>(unsafe.Pointer(&amp;s)) + <span class="keyword">uintptr</span>(<span class="number">16</span>)))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    fmt.Println(Cap, <span class="built_in">cap</span>(s)) <span class="comment">// 20 20</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>Len，cap 的转换流程如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">Len: &amp;s &#x3D;&gt; pointer &#x3D;&gt; uintptr &#x3D;&gt; pointer &#x3D;&gt; *int &#x3D;&gt; int</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">Cap: &amp;s &#x3D;&gt; pointer &#x3D;&gt; uintptr &#x3D;&gt; pointer &#x3D;&gt; *int &#x3D;&gt; int</span></pre></td></tr></table></figure><h2 id="获取-map-长度"><a href="#获取-map-长度" class="headerlink" title="获取 map 长度"></a>获取 map 长度</h2><p>再来看一下上篇文章我们讲到的 map：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> hmap <span class="keyword">struct</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    count     <span class="keyword">int</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    flags     <span class="keyword">uint8</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    B         <span class="keyword">uint8</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    noverflow <span class="keyword">uint16</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    hash0     <span class="keyword">uint32</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    buckets    unsafe.Pointer</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    oldbuckets unsafe.Pointer</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    nevacuate  <span class="keyword">uintptr</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    extra *mapextra</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>和 slice 不同的是，makemap 函数返回的是 hmap 的指针，注意是指针：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makemap</span><span class="params">(t *maptype, hint <span class="keyword">int64</span>, h *hmap, bucket unsafe.Pointer)</span> *<span class="title">hmap</span></span></span></pre></td></tr></table></figure><p>我们依然能通过 unsafe.Pointer 和 uintptr 进行转换，得到 hamp 字段的值，只不过，现在 count 变成二级指针了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    mp := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    mp[<span class="string">"qcrao"</span>] = <span class="number">100</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    mp[<span class="string">"stefno"</span>] = <span class="number">18</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    count := **(**<span class="keyword">int</span>)(unsafe.Pointer(&amp;mp))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    fmt.Println(count, <span class="built_in">len</span>(mp)) <span class="comment">// 2 2</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>count 的转换过程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&amp;mp &#x3D;&gt; pointer &#x3D;&gt; **int &#x3D;&gt; int</span></pre></td></tr></table></figure><h2 id="map-源码中的应用"><a href="#map-源码中的应用" class="headerlink" title="map 源码中的应用"></a>map 源码中的应用</h2><p>在 map 源码中，mapaccess1、mapassign、mapdelete 函数中，需要定位 key 的位置，会先对 key 做哈希运算。</p><p>例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">b := (*bmap)(unsafe.Pointer(<span class="keyword">uintptr</span>(h.buckets) + (hash&amp;m)*<span class="keyword">uintptr</span>(t.bucketsize)))</span></pre></td></tr></table></figure><p><code>h.buckets</code> 是一个 <code>unsafe.Pointer</code>，将它转换成 <code>uintptr</code>，然后加上 <code>(hash&amp;m)*uintptr(t.bucketsize)</code>，二者相加的结果再次转换成 <code>unsafe.Pointer</code>，最后，转换成 <code>bmap 指针</code>，得到 key 所落入的 bucket 位置。如果不熟悉这个公式，可以看看上一篇文章，浅显易懂。</p><p>上面举的例子相对简单，来看一个关于赋值的更难一点的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// store new key/value at insert position</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> t.indirectkey &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    kmem := newobject(t.key)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    *(*unsafe.Pointer)(insertk) = kmem</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    insertk = kmem</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> t.indirectvalue &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    vmem := newobject(t.elem)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    *(*unsafe.Pointer)(val) = vmem</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">typedmemmove(t.key, insertk, key)</span></pre></td></tr></table></figure><p>这段代码是在找到了 key 要插入的位置后，进行“赋值”操作。insertk 和 val 分别表示 key 和 value 所要“放置”的地址。如果 t.indirectkey 为真，说明 bucket 中存储的是 key 的指针，因此需要将 insertk 看成<code>指针的指针</code>，这样才能将 bucket 中的相应位置的值设置成指向真实 key 的地址值，也就是说 key 存放的是指针。</p><p>下面这张图展示了设置 key 的全部操作：</p><p><img src="https://user-images.githubusercontent.com/7698088/58756044-c1e67900-8522-11e9-9dda-72ba2a731acf.png" alt="map assign"></p><p>obj 是真实的 key 存放的地方。第 4 号图，obj 表示执行完 <code>typedmemmove</code> 函数后，被成功赋值。</p><h2 id="Offsetof-获取成员偏移量"><a href="#Offsetof-获取成员偏移量" class="headerlink" title="Offsetof 获取成员偏移量"></a>Offsetof 获取成员偏移量</h2><p>对于一个结构体，通过 offset 函数可以获取结构体成员的偏移量，进而获取成员的地址，读写该地址的内存，就可以达到改变成员值的目的。</p><p>这里有一个内存分配相关的事实：结构体会被分配一块连续的内存，结构体的地址也代表了第一个成员的地址。</p><p>我们来看一个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="string">"fmt"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="string">"unsafe"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Programmer <span class="keyword">struct</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    name <span class="keyword">string</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    language <span class="keyword">string</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    p := Programmer&#123;<span class="string">"stefno"</span>, <span class="string">"go"</span>&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    fmt.Println(p)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    name := (*<span class="keyword">string</span>)(unsafe.Pointer(&amp;p))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">    *name = <span class="string">"qcrao"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">    lang := (*<span class="keyword">string</span>)(unsafe.Pointer(<span class="keyword">uintptr</span>(unsafe.Pointer(&amp;p)) + unsafe.Offsetof(p.language)))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">    *lang = <span class="string">"Golang"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">    fmt.Println(p)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>运行代码，输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&#123;stefno go&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">&#123;qcrao Golang&#125;</span></pre></td></tr></table></figure><p>name 是结构体的第一个成员，因此可以直接将 &amp;p 解析成 *string。这一点，在前面获取 map 的 count 成员时，用的是同样的原理。</p><p>对于结构体的私有成员，现在有办法可以通过 unsafe.Pointer 改变它的值了。</p><p>我把 Programmer 结构体升级，多加一个字段：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Programmer <span class="keyword">struct</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    name <span class="keyword">string</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    age <span class="keyword">int</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    language <span class="keyword">string</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>并且放在其他包，这样在 main 函数中，它的三个字段都是私有成员变量，不能直接修改。但我通过 unsafe.Sizeof() 函数可以获取成员大小，进而计算出成员的地址，直接修改内存。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    p := Programmer&#123;<span class="string">"stefno"</span>, <span class="number">18</span>, <span class="string">"go"</span>&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    fmt.Println(p)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    lang := (*<span class="keyword">string</span>)(unsafe.Pointer(<span class="keyword">uintptr</span>(unsafe.Pointer(&amp;p)) + unsafe.Sizeof(<span class="keyword">int</span>(<span class="number">0</span>)) + unsafe.Sizeof(<span class="keyword">string</span>(<span class="string">""</span>))))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    *lang = <span class="string">"Golang"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    fmt.Println(p)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&#123;stefno 18 go&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">&#123;stefno 18 Golang&#125;</span></pre></td></tr></table></figure><h2 id="string-和-slice-的相互转换"><a href="#string-和-slice-的相互转换" class="headerlink" title="string 和 slice 的相互转换"></a>string 和 slice 的相互转换</h2><p>这是一个非常精典的例子。实现字符串和 bytes 切片之间的转换，要求是 <code>zero-copy</code>。想一下，一般的做法，都需要遍历字符串或 bytes 切片，再挨个赋值。</p><p>完成这个任务，我们需要了解 slice 和 string 的底层数据结构：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> StringHeader <span class="keyword">struct</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    Data <span class="keyword">uintptr</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    Len  <span class="keyword">int</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> SliceHeader <span class="keyword">struct</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    Data <span class="keyword">uintptr</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    Len  <span class="keyword">int</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    Cap  <span class="keyword">int</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>上面是反射包下的结构体，路径：src/reflect/value.go。只需要共享底层 []byte 数组就可以实现 <code>zero-copy</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">string2bytes</span><span class="params">(s <span class="keyword">string</span>)</span> []<span class="title">byte</span></span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    stringHeader := (*reflect.StringHeader)(unsafe.Pointer(&amp;s))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    bh := reflect.SliceHeader&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        Data: stringHeader.Data,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        Len:  stringHeader.Len,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        Cap:  stringHeader.Len,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> *(*[]<span class="keyword">byte</span>)(unsafe.Pointer(&amp;bh))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bytes2string</span><span class="params">(b []<span class="keyword">byte</span>)</span> <span class="title">string</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&amp;b))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    sh := reflect.StringHeader&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">        Data: sliceHeader.Data,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">        Len:  sliceHeader.Len,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> *(*<span class="keyword">string</span>)(unsafe.Pointer(&amp;sh))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>代码比较简单，不作详细解释。通过构造 slice header 和 string header，来完成 string 和 byte slice 之间的转换。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>unsafe 包绕过了 Go 的类型系统，达到直接操作内存的目的，使用它有一定的风险性。但是在某些场景下，使用 unsafe 包提供的函数会提升代码的效率，Go 源码中也是大量使用 unsafe 包。</p><p>unsafe 包定义了 Pointer 和三个函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ArbitraryType <span class="keyword">int</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Pointer *ArbitraryType</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sizeof</span><span class="params">(x ArbitraryType)</span> <span class="title">uintptr</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Offsetof</span><span class="params">(x ArbitraryType)</span> <span class="title">uintptr</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Alignof</span><span class="params">(x ArbitraryType)</span> <span class="title">uintptr</span></span></span></pre></td></tr></table></figure><p>通过三个函数可以获取变量的大小、偏移、对齐等信息。</p><p>uintptr 可以和 unsafe.Pointer 进行相互转换，uintptr 可以进行数学运算。这样，通过 uintptr 和 unsafe.Pointer 的结合就解决了 Go 指针不能进行数学运算的限制。</p><p>通过 unsafe 相关函数，可以获取结构体私有成员的地址，进而对其做进一步的读写操作，突破 Go 的类型安全限制。关于 unsafe 包，我们更多关注它的用法。</p><p>顺便说一句，unsafe 包用多了之后，也不觉得它的名字有多么地不“美观”了。相反，因为使用了官方并不提倡的东西，反而觉得有点酷炫。这就是叛逆的感觉吧。</p><p>最后，点击<a href="https://github.com/qcrao/Go-Questions" target="_blank" rel="noopener">阅读原文</a>，你将参与见证一个千星项目的成长，你值得拥有！</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.flysnow.org/2017/07/06/go-in-action-unsafe-pointer.html" target="_blank" rel="noopener">飞雪无情的博客</a></p><p><a href="https://gocn.vip/question/371" target="_blank" rel="noopener">译文 unsafe包详解</a></p><p><a href="https://golang.org/pkg/unsafe/" target="_blank" rel="noopener">官方文档</a></p><p><a href="http://www.opscoder.info/golang_unsafe.html" target="_blank" rel="noopener">例子</a></p><p><a href="https://segmentfault.com/a/1190000017389782" target="_blank" rel="noopener">煎鱼大佬的博客</a></p><p><a href="https://www.kancloud.cn/wizardforcel/gopl-zh/106477" target="_blank" rel="noopener">go语言圣经</a></p><p><a href="https://blog.gopheracademy.com/advent-2017/unsafe-pointer-and-system-calls/" target="_blank" rel="noopener">pointer and system calls</a></p><p><a href="https://my.oschina.net/xinxingegeya/blog/729673" target="_blank" rel="noopener">pointer and uintptr</a></p><p><a href="https://go101.org/article/unsafe.html" target="_blank" rel="noopener">unsafe.pointer</a></p><p><a href="https://go101.org/article/pointer.html" target="_blank" rel="noopener">go 指针类型</a></p><p><a href="https://juejin.im/post/5c189dce5188256b2e71e79b" target="_blank" rel="noopener">码洞 快学Go语言 unsafe</a></p><p><a href="https://golang.org/pkg/unsafe/" target="_blank" rel="noopener">官方文档</a></p><p><a href="http://www.opscoder.info/golang_unsafe.html" target="_blank" rel="noopener">jasper 的小窝</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;** Go语言unsafe：** &amp;lt;Excerpt in index | 首页摘要&amp;gt;&lt;/p&gt;
&lt;p&gt;go语言养成记之深度解密Go语言unsafe&lt;/p&gt;
    
    </summary>
    
    
      <category term="golang" scheme="https://alexbrucelu.github.io/categories/golang/"/>
    
    
      <category term="golang" scheme="https://alexbrucelu.github.io/tags/golang/"/>
    
  </entry>
  
</feed>
