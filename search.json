[{"title":"Docker的安装与简介","url":"/2018/11/25/Docker的安装与简介/","content":"\n** {{ title }}：** <Excerpt in index | 首页摘要>\n\nDocker养成记之安装与简介\n\n<!-- more -->","tags":["Docker"],"categories":["docker"]},{"title":"MySQL的安装与简介","url":"/2018/11/25/MySQL的安装与简介/","content":"\n** {{ title }}：** <Excerpt in index | 首页摘要>\n\nMySQL养成记之安装与简介\n\n<!-- more -->","tags":["MySQL"],"categories":["database"]},{"title":"MongoDB的安装与简介","url":"/2018/11/25/MongoDB的安装与简介/","content":"\n** {{ title }}：** <Excerpt in index | 首页摘要>\n\nMongoDB养成记之安装与简介\n\n<!-- more -->","tags":["MongoDB"],"categories":["database"]},{"title":"gorountine","url":"/2018/11/25/gorountine/","content":"\n** {{ title }}：** <Excerpt in index | 首页摘要>\n\ngo语言养成记之gorountine\n\n<!-- more -->","tags":["golang"],"categories":["golang"]},{"title":"channel","url":"/2018/11/25/channel/","content":"\n** {{ title }}：** <Excerpt in index | 首页摘要>\n\ngo语言养成记之channel\n\n<!-- more -->","tags":["golang"],"categories":["golang"]},{"title":"http及其标准库","url":"/2018/11/25/http及其标准库/","content":"\n** {{ title }}：** <Excerpt in index | 首页摘要>\n\ngo语言养成记之http及其标准库\n\n<!-- more -->","tags":["golang"],"categories":["golang"]},{"title":"内建容器","url":"/2018/11/25/内建容器/","content":"\n** {{ title }}：** <Excerpt in index | 首页摘要>\n\ngo语言养成记之内建容器\n\n<!-- more -->\n## 1. 数组 Array\n\n### 1.1 为什么使用数组\n\n- 传统的方法不利于数据管理与维护，使用数组也容易扩展数据。\n- **注：**<font color=\"red\">Go语言中的数组是之拷贝的传递</font>\n\n### 1.2 数组的四种初始化方法\n\n```go\narr := [3]int{1,2,3}\nvar arr [3]int = [3]int{1,2,3}\narr := [...]int{8,9,7}\narr := [...]int{1:800,2:1000,3:900}\n```\n\n### 1.3 数组的遍历\n\n```go\nfor index,value := range arr{\n    ...\n}\nfor index := range arr{\n    ...\n}\n```\n\n注：1. index 为数组元素的下标，value 为下标所对应的值\n\n \t2. index,value 只能在该for 循环内使用\n \t3. 可以用 \"_\" 来忽略index 或 value，当只有一个返回值时为index\n\n### 1.4 数组使用时的注意事项\n\n1. 数组是定长的相同类型的数据集合\n2. 数组中的数据类型可以是任意数据类型，值类型、引用类型，但是不能混用\n3. 数组声明后若没有初始化，则元素的为声明是数据类型的默认零值(0，nil,\"\")\n4. 使用步骤：声明数据开辟空间 -> 初始化值/赋值 -> 使用\n5. 数组的下标是从0开始的，要注意下标越界\n6. 数组是值类型，数据传递为值拷贝\n7. 长度不同数据类型相同的两个数组是不同类型的数组\n8. 若要修改原来的数组值，则需要引用传递，即取地址\n\n## 2. 切片 Slice\n\n## 3. map\n\n## 4. 字符和字符串处理\n\n### 4.1 字符串常用的系统函数","tags":["golang"],"categories":["golang"]},{"title":"面向接口","url":"/2018/11/25/面向接口/","content":"\n** {{ title }}：** <Excerpt in index | 首页摘要>\n\ngo语言养成记之面向接口\n\n<!-- more -->\n## 1. duck typing 的概念\n\n> \"当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子。\"\n>\n> 在鸭子类型中，关注的不是对象的类型本身，而是它是如何使用的。\n>\n> <font color=\"blue\">鸭子本来不是人，但是实现了某些人的方法就会被认为是人。</font>\n\n- 描述事物的外部行为而非内部结构\n\n- 其他语言中的duck typing\n\n  - Python\n\n  ```python\n  def download(retriever): // download 是duck typing 的使用者\n      return retriever.get(\"666\") // retriever是duck typing的对象(实现者)\n  ```\n\n  **注 ：**编译时才知道传入的retriever 有没有get\n\n  - C++\n\n    ```c\n    template <class R>\n        \n    string download(const R& retriever) {\n        return retriever.get(\"666\");\n    }\n    ```\n\n    **注 ：**1. 编译时才知道传入的retriever 有没有get\n\n    ​\t2. 需要注释来说明接口\n\n  - Java\n\n    ```java\n    <R extends Retriever>\n    String download(R r) {\n    \treturn retriever.get(\"666\");\n    }\n    ```\n\n    **注：**传入的参数必须实现Retrieve 接口，并不是duck typing；不需要注释说明接口\n\n    <font color=\"red\">go语言中的duck typing，具有灵活性和类型检查的严格性</font>\n\n\n## 2. 接口的定义和实现\n\n### 2.1 基本介绍\n\n- golang 中多态的特性主要通过接口来实现的\n- interface 类型可以定义一组方法，但并需要实现。并且，interface 不能包含任何变量。到某个自定义类型要使用的时候，根据具体的情况再把这些方法实现出来\n\n- 基本语法\n\n  ```go\n  type 接口名 interface {\n      method1(参数列表) 返回值列表\n      method2(参数列表) 返回值列表\n      ...\n  }\n  \n  func (t 自定义类型) method1(参数列表) 返回值列表{\n      // 具体实现\n  }\n  \n  func (t 自定义类型) method2(参数列表) 返回值列表{\n      // 具体实现\n  }\n  ```\n\n  - 接口里的所有的方法都没有方法体，即<font color=\"red\">接口的方法都是没有实现的方法</font>。接口体现了程序设计的<font color=\"red\">多态和高内聚低耦合</font>的思想\n  - 接口不需要显式的实现，只要有一个变量，含有接口的所有方法，那么这个变量就实现了这个接口\n\n### 2.2 一个例子\n\n```go\npackage main\n\nimport \"fmt\"\n\ntype Retriever interface {\n    Get(url string) string\n}\n\nfunc download(r Retriever) string{\n    return r.Get(\"http://www.baidu.com\")\n}\n\nfunc main() {\n    var r Retriever\n    r = demo.Retriever{}\n    fmt.Println(download(r))\n}\n```\n\n```go\npackage demo\n\nimport (\n\t\"time\"\n    \"net/http\"\n)\n\ntype Retriver struct {\n    UserAgent string\n    TimeOut time.Duration\n}\n\nfunc (r Retriver) Get(url string) string{\n    resp,err := http.Get(url)\n    if err != nil {\n        panic(err)\n    }\n    result,err := httputil.DumpResponse(resp,true)\n    resp.Body.Close()\n    if err != nil {\n        panic(err)\n    }\n    return string(result)\n}\n```\n\n**输出结果**：baidu.com 的网页信息\n\n## 3. 接口的值类型\n\n## 4. 接口的组合\n\n## 5. 常用的系统接口","tags":["golang"],"categories":["golang"]},{"title":"面向对象","url":"/2018/11/25/面向对象/","content":"\n** {{ title }}：** <Excerpt in index | 首页摘要>\n\ngo语言养成记之面向对象\n\n<!-- more -->\n## 面向对象编程\n\n### 1. 说明\n\n1. golang 支持面向对象编程，与传统的面向对象编程语言有区别\n\n2. golang 没有class 类的，面向对象编程是基于struct 结构体来实现的\n\n3. golang 去掉了继承关键字、方法重载、构造函数和析构函数、隐藏的this 指针\n\n4. golang 通过匿名字段来实现继承，多态和封装的特性仍然具备\n\n5. 通过接口关联能实现低耦合、高灵活度\n\n\n### 2. 结构体与结构体变量(实例/对象)的说明\n\n> - 结构体是自定义数据类型，代表一类事物\n> - 结构体变量(实例)是具体的、实际的代表一个具体的变量\n\n### 3. 如何声明结构体\n\n#### 3.1 基本语法\n\n```go\ntype 结构体名称 struct {\n    field1 type\n    field2 type\n}\n\n//------------------------------\n\ntype Student struct {\n    Name string\n    Age int\n    Score float32\n}\n```\n\n#### 3.2 字段、属性\n\n- ​    从概念上或者叫法上看：结构体字段 = 属性 =field\n\n- 字段是结构体的一个组成部分，一般是**基本数据类型、数组**，也可以是引用类型。\n\n- 注意事项和细节说明\n  - 字段声明语法同变量，例：字段名 字段类型\n  - 字段类型可以为：基本类型、数组或引用类型\n  - 在创建一个结构体变量后，如果没有给该字段赋值，则默认为该数据类型的零值(bool false，int 0...)\n  - 结构体是值类型，不同的结构体字段是独立的，互不影响。一个结构体变量字段的更改，不影响另外一个\n  - 结构体成员变量的访问都使用 person.name 用\" . \"来访问\n  - 结构体的所有字段在内存中是<font color=\"red\">连续的</font>\n  - 结构体类型是用户单独定义的类型，和其他类型进行转换时需要有完全相同的字段(名字、个数、类型)\n\n  ```go\n  type A struct {\n      num int\n  }\n  type B struct {\n      num int\n  }\n  \n  func main(){\n      var a A\n      var b B\n      a = A(b)\n      fmt.Println(a,b)\n  }\n  ```\n\n  - 重新定义相当于区别名，在golang 中认为是新的数据类型，但二者之间可以相互强转\n\n  ```go\n  type A struct {\n      num int\n  }\n  type Num A\n  \n  func main(){\n      var a A\n      var num Num\n      a = A(num)\n      fmt.Println(a,num)\n  }\n  ```\n\n  - struct 的每个字段上，可以写一个tag ，该tag 可以通过反射机制获取，常见的使用场景就是序列化和反序列化\n\n  ```go\n  type Monster struct {\n      Name string `json:\"name\"` // `json:\"name\"`就是 struct tag\n      Age int `json:\"age\"`\n  }\n  ```\n\n\n\n\n\n  ### 4. 方法\n\n  1. 基本介绍\n\n     > 在某些情况下，我们需要声明(定义)方法。比如：Person 结构体除了有一些字段外，Person结构体还有一些行为，比如：说话、跑步、学习，这时候就要用到方法才能实现。\n\n  2. 方法的声明和调用\n\n     ```go\n     type A struct {\n         Num int\n     }\n     \n     func (a A)test(){\n         fmt.Println(a.Num)\n     }\n     ```\n\n     - `func (a A)test (){ }`表示A结构体有一方法，方法名为同test\n     - ` (a A)`体现test方法是和A类型绑定的\n     - `test`方法只能通过`A`变量来调，而不能直接调用\n\n  3. 方法快速入门\n\n     - 给Persion 结构添加speak方法，输出xxx是个好人\n\n       ```go\n       type Persion struct {\n           Name string\n           Age int\n       }\n       \n       func (p Persion) speak() {\n           fmt.Println(p.Name,\"is a good man\")\n       }\n       ```\n\n     - 给Persion 结构添加sum方法，输出1+2+...+1000 的结果\n\n       ```go\n       type Persion struct {\n           Name string\n           Age int\n       }\n       \n       func (p Persion) sum() {\n           res := 0\n           for i := 1,i < 1000; i++ {\n               res += i\n           }\n           fmt.Println(p.Name,\"get sum result is \",res)\n       }\n       ```\n\n  4. 方法的调用和传参机制\n\n     > 方法的调用和传参机制和函数基本一致，不一样的是方法调用时，会将调用方法的变量，当做实参也传递给方法。如果是值类型就进行值拷贝，如果是引用类型，进行地址传递。\n\n### 5. 方法和函数的区别\n\n1. 调用方式不一样\n\n   > 函数的调用方式：函数名（实参列表）\n   >\n   > 方法的调用方式：变量.方法名（实参列表）\n\n2. 对于普通函数，接受者为值类型时，不能将指针类型的数据直接传递，反之亦然\n\n3. 对于方法，接受者为值类型时，可以直接用指针类型的变量调用方法，反之亦然\n\n### 6. 面向对象编程步骤\n\n1. 声明（定义）结构体，确定结构体名\n2. 编写结构体字段\n3. 编写结构体的方法\n\n### 7. 包和封装\n\n- 包 ：每一目录一个包\n\n- main包，包含可执行入口\n\n- 为结构体定义的包必须放在同一个目录下，可以是不同文件\n\n- 工厂模式\n\n  - 说明\n\n    > go 的结构体没有构造函数，通常使用工厂模式来解决这个问题\n\n  - 解决问题\n\n    > 如果当前文件需要引入别的包的结构体变量，当别的包的结构体变量首字母并没有大写时，不能直接引入，可以用工厂模式解决。\n\n```go\n// model 包文件\npackage model\n\ntype student struct {\n    Name string\n    Score float64\n}\n\nfunc NewStudent (n string,s float64) *student {\n    return &student{\n        Name: n,\n        Score: s\n    }\n}\n\n//----------------------main.go--------------------\npackage main\n\nimport(\n\t\"model\"\n    \"fmt\"\n)\n\nfunc main() {\n    stu := model.NewStudent(\"jerry\",68.2)\n    fmt.Println(*stu)\n}\n```\n\n- 封装\n\n  - 基本介绍\n\n    > 封装就是把抽象出的字段和对字段的操作封装在一起，数据被保护在内部，程序的其它包只有通过被授权的操作（方法），才能对字段进行操作。\n\n  - 封装的理解和好处\n\n    > 1. 隐藏实现细节\n    > 2. 可以对数据进行验证，保证安全合理\n\n  - 如何体现封装\n\n    > 1. 对结构体中的属性进行封装\n    > 2. 通过方法、包实现封装\n\n  - 封装的实现方法\n\n    > 1. 将结构体、字段（属性）的首字母小写（不能导出，被其他包所使用，类似于private）\n    >\n    > 2. 给结构体所在的包提供一个工厂模式的函数，首字母大写。类似于一个构造函数\n    >\n    > 3. 提供一个首字母大写的Set方法（类似于public），用于属性判断并赋值\n    >\n    >    ```go\n    >    func (var 结构体类型名) SetXXX(参数列表) (返回值列表){\n    >        // 加入数据验证业务逻辑\n    >        var.字段 = 参数\n    >    }\n    >    ```\n    >\n    > 4. 提供一个首字母大写的Get方法（类似于public），用于获取属性的值\n    >\n    >    ```go\n    >    func (var 结构体类型名) GetXxx() {\n    >        return var.age\n    >    }\n    >    ```\n\n  - 实例\n\n    > 对于隐私信息，工资、年龄保密，输入年龄进行验证。\n    >\n    > ```go\n    > package model\n    > \n    > import \"fmt\"\n    > \n    > type person struct{\n    >     name string\n    >     age int\n    >     sal float64\n    > }\n    > \n    > func NewPerson(name string) *person {\n    >     retrun &person{\n    >         name: name\n    >     }\n    > }\n    > \n    > func (p *person) SetAge(age int) {\n    >     if age > 0 && age < 150 {\n    >         p.age = age\n    >     }else {\n    >         return\n    >     }\n    > }\n    > \n    > func (p *person) GetAge() int {\n    >     return p.Age\n    > }\n    > \n    > func (p *person) SetSel(sel float64) {\n    >     p.sel = sel\n    > }\n    > \n    > func (p *person) GetSel () float64 {\n    >     return p.sel\n    > }\n    > ```\n\n  - 扩充系统类型或者别人的类型\n\n    > 1. 定义别名\n    > 2. 使用组合\n\n  ```go\n  package queue \n  \n  type Queue []int\n  \n  func (q *Queue) Push (v int){\n      *q = append(*q,v)\n  }\n  \n  func (q *Queue) Pop() int {\n      head := (*q)[0]\n      *q = (*q)[1:]\n      return head\n  }\n  ```\n\n  ```go\n  package main\n  \n  import (\n  \t\"queue\"\n      \"fmt\"\n  )\n  \n  func main() {\n      q := queue.Queue{1}\n      q.Push(2)\n      q.Push(3)\n      fmt.Println(q.pop())\n      fmt.Println(q.pop())\n  }\n  ```\n\n\n","tags":["golang"],"categories":["golang"]},{"title":"基础语法","url":"/2018/11/25/基础语法/","content":"\n** {{ title }}：** <Excerpt in index | 首页摘要>\n\ngo语言养成记之基础语法\n\n<!-- more -->","tags":["golang"],"categories":["golang"]},{"title":"函数式编程","url":"/2018/11/25/函数式编程/","content":"\n** {{ title }}：** <Excerpt in index | 首页摘要>\n\ngo语言养成记之函数式编程\n\n<!-- more -->","tags":["golang"],"categories":["golang"]},{"title":"错误处理及资源管理","url":"/2018/11/25/错误处理及资源管理/","content":"\n** {{ title }}：** <Excerpt in index | 首页摘要>\n\ngo语言养成记之错误处理及资源管理\n\n<!-- more -->","tags":["golang"],"categories":["golang"]},{"title":"测试与性能调优","url":"/2018/11/25/测试与性能调优/","content":"\n** {{ title }}：** <Excerpt in index | 首页摘要>\n\ngo语言养成记之测试与性能调优\n\n<!-- more -->","tags":["golang"],"categories":["golang"]},{"title":"Consul","url":"/2018/11/25/consul/","content":"\n** {{ title }}：** <Excerpt in index | 首页摘要>\n\n微服务之Consul\n\n<!-- more -->\n\n\n# Consul\n\n## 1. Consul的介绍\n\n### 1.1 Consul是什么\n\nConsul是HashiCorp公司推出的开源工具，用于实现分布式系统的服务发现与配置。 Consul是分布式的、高可用的、可横向扩展的。它具备以下特性 :\n\n- service discovery：consul通过DNS或者HTTP接口使服务注册和服务发现变的很容易，一些外部服务，例如saas提供的也可以一样注册。\n- health checking：健康检测使consul可以快速的告警在集群中的操作。和服务发现的集成，可以防止服务转发到故障的服务上面。\n- key/value storage：一个用来存储动态配置的系统。提供简单的HTTP接口，可以在任何地方操作。\n- multi-datacenter：无需复杂的配置，即可支持任意数量的区域。\n\n**举例说明**\n\n> 邮递员去某公司一栋大楼投递快件，向门卫询问员工甲在哪一个房间，门卫拿起桌上的通讯录查询，告知邮递员员工甲在具体什么位置。假如公司来了一个员工乙，他想让邮递员送过来，就要先让门卫知道自己在哪一个房间，需要去门卫那边登记，员工乙登记后，当邮递员向门卫询问时，门卫就可以告诉邮递员员工乙的具体位置。门卫知道员工乙的具体位置的过程就是服务发现，员工乙的位置信息可以被看作服务信息，门卫的通讯录就是上文中提到的数据交换格式，此例中员工乙就是上文的已方，门卫就是服务发现的提供者。\n\n### 1.2 什么是服务发现\n\n微服务的框架体系中，服务发现是不能不提的一个模块。相信了解或者熟悉微服务的童鞋应该都知道它的重要性。我们看下面的一幅图片：\n\n![](https://github.com/AlexBruceLu/DAPP/wiki/uber5.png)\n\n客户端的一个接口，需要调用服务A-N。客户端必须要知道所有服务的网络位置的，以往的做法是配置文件中，或者有些配置在数据库中。这里就带出几个问题：\n\n- 需要配置N个服务的网络位置，加大配置的复杂性\n- 服务的网络位置变化，都需要改变每个调用者的配置\n- 集群的情况下，难以做负载（反向代理的方式除外）\n\n- <font color=\"red\">总结起来一句话：服务多了，配置很麻烦，问题多多</font>\n\n![](https://github.com/AlexBruceLu/DAPP/wiki/uber6.png)\n\n与上图不同的是，加了个服务发现模块。图比较简单，这边文字描述下。服务A-N把当前自己的网络位置注册到服务发现模块（这里注册的意思就是告诉），服务发现就以K-V的方式记录下，K一般是服务名，V就是IP:PORT。服务发现模块定时的轮询查看这些服务能不能访问的了（这就是健康检查）。客户端在调用服务A-N的时候，就跑去服务发现模块问下它们的网络位置，然后再调用它们的服务。这样的方式是不是就可以解决上面的问题了呢？客户端完全不需要记录这些服务网络位置，客户端和服务端完全解耦！\n\n## 2. Consul的安装\n\nConsul用Golang实现，因此具有天然可移植性 (支持 Linux、windows和macOS)。安装包仅包含一个可执行文件。 Consul安装非常简单，只需要下载对应系统的软件包并解压后就可使用。\n\n### 2.1 下载安装\n\n```shell\n# 这里以 Linux系统为例：\n$ wget https://releases.hashicorp.com/consul/1.2.0/consul_1.2.0_linux_amd64.zip\n$ unzip consul_1.2.0_linux_amd64.zip\n$ mv consul /usr/local/bin/\n```\n\n[其他系统](https://www.consul.io/downloads.html)\n\n### 2.2 验证安装\n\n安装 Consul后，通过执行 consul命令，你可以看到命令列表的输出\n\n```shell\n$ consul # 出现下图内容证明安装成功\n```\n\n![](https://github.com/AlexBruceLu/DAPP/wiki/uber7.png)\n\n## 3. Consul主要作用\n\n- client: 客户端, 无状态, 将 HTTP 和 DNS 接口请求转发给局域网内的服务端集群.\n- server: 服务端, 保存配置信息, 高可用集群, 在局域网内与本地客户端通讯, 通过广域网与其他数据中心通讯. 每个数据中心的 server 数量推荐为 3 个或是 5 个\n\n### 3.1 运行 Consul代理\n\nConsul是典型的 C/S架构，可以运行服务模式或客户模式。每一个数据中心必须有至少一个服务节点， 3到5个服务节点最好。非常不建议只运行一个服务节点，因为在节点失效的情况下数据有极大的丢失风险。\n\n### 3.2 运行Agent\n\n完成Consul的安装后,必须运行agent. agent可以运行为server或client模式.每个数据中心至少必须拥有一台server. 建议在一个集群中有3或者5个server.部署单一的server,在出现失败时会不可避免的造成数据丢失.其他的agent运行为client模式.一个client是一个非常轻量级的进程.用于注册服务,运行健康检查和转发对server的查询.agent必须在集群中的每个主机上运行.\n\n### 3.3 启动 Consul Server\n\n```shell\n#node1:\n$ consul agent -server -bootstrap-expect 2 -data-dir /tmp/consul -node=n1 -\nbind=192.168.110.123 -ui -config-dir /etc/consul.d -rejoin -join 192.168.110.123 -\nclient 0.0.0.0\n#运行cosnul agent以server模式\n-server ： 定义agent运行在server模式\n-bootstrap-expect ：在一个datacenter中期望提供的server节点数目，当该值提供的时候，consul一直等到达到指定sever数目的时候才会引导整个集群，该标记不能和bootstrap共用\n-data-dir：提供一个目录用来存放agent的状态，所有的agent允许都需要该目录，该目录必须是稳定的，系统重启后都继续存在\n-node：节点在集群中的名称，在一个集群中必须是唯一的，默认是该节点的主机名\n-bind：该地址用来在集群内部的通讯，集群内的所有节点到地址都必须是可达的，默认是0.0.0.0\n-ui： 启动web界面\n-config-dir：：配置文件目录，里面所有以.json结尾的文件都会被加载\n-rejoin：使consul忽略先前的离开，在再次启动后仍旧尝试加入集群中。\n-client：consul服务侦听地址，这个地址提供HTTP、DNS、RPC等服务，默认是127.0.0.1所以不对外提供服务，如果你要对外提供服务改成0.0.0.0\n```\n\n```shell\n#node2:\n$ consul agent -server -bootstrap-expect 2 -data-dir /tmp/consul -node=n2 -\nbind=192.168.110.148 -ui -rejoin -join 192.168.110.123\n-server ： 定义agent运行在server模式\n-bootstrap-expect ：在一个datacenter中期望提供的server节点数目，当该值提供的时候，consul一直等到达到指定sever数目的时候才会引导整个集群，该标记不能和bootstrap共用\n-bind：该地址用来在集群内部的通讯，集群内的所有节点到地址都必须是可达的，默认是0.0.0.0\n-node：节点在集群中的名称，在一个集群中必须是唯一的，默认是该节点的主机名\n-ui： 启动web界面\n-rejoin：使consul忽略先前的离开，在再次启动后仍旧尝试加入集群中。\n-config-dir：：配置文件目录，里面所有以.json结尾的文件都会被加载\n-client：consul服务侦听地址，这个地址提供HTTP、DNS、RPC等服务，默认是127.0.0.1所以不对外提供服务，如果你要对外提供服务改成0.0.0.0\n-join 192.168.110.121 ： 启动时加入这个集群\n```\n\n### 3.4 启动 Consul Client\n\n```shell\n#node3：\n$ consul agent -data-dir /tmp/consul -node=n3 -bind=192.168.110.124 -config-dir/etc/consul.d -rejoin -join 192.168.110.123\n运行cosnul agent以client模式，-join 加入到已有的集群中去。\n```\n\n- 查看集群成员\n  - **新开一个终端窗口运行consul members, 你可以看到Consul集群的成员**\n\n```shell\n$ consul members\n#节点 网络地址 状态 类型 版本 协议 数据中心 分管部分\nNode Address Status Type Build Protocol DC Segment\nn1 192.168.110.7:8301 alive server 1.1.0 2 dc1 <all>\nn2 192.168.110.121:8301 alive server 1.1.0 2 dc1 <all>\nn3 192.168.110.122:8301 alive client 1.1.0 2 dc1 <default>\n```\n\n### 3.5 停止Agent\n\n可以使用Ctrl-C 优雅的关闭Agent. 中断Agent之后你可以看到他离开了集群并关闭.\n\n在退出中,Consul提醒其他集群成员,这个节点离开了.如果你强行杀掉进程.集群的其他成员应该能检测到这个节点失效了.当一个成员离开,他的服务和检测也会从目录中移除.当一个成员失效了,他的健康状况被简单的标记为危险,但是不会从目录中移除.Consul会自动尝试对失效的节点进行重连.允许他从某些网络条件下恢复过来.离开的节点则不会再继续联系.\n\n此外,如果一个agent作为一个服务器,一个优雅的离开是很重要的,可以避免引起潜在的可用性故障影响达成一致性协议. consul优雅的退出\n\n```shell\n$ consul leave\n```\n\n## 4. 注册服务\n\n搭建好conusl集群后，用户或者程序就能到consul中去查询或者注册服务。可以通过提供服务定义文件或者调用HTTP API来注册一个服务.\n\n- 首先,为Consul配置创建一个目录.Consul会载入配置文件夹里的所有配置文件.在Unix系统中通常类似/etc/consul.d (.d 后缀意思是这个路径包含了一组配置文件).\n\n  ```shell\n  $ mkdir /etc/consul.d\n  ```\n\n- 然后,我们将编写服务定义配置文件.假设我们有一个名叫web的服务运行在 10000端口.另外,我们将给他设置一个标签.这样我们可以使用他作为额外的查询方式:\n\n  ```json\n  {\n  \t\"service\": { //服务\n  \t\t\"name\": \"web\", //名称\n  \t\t\"tags\": [\"master\"], //标记\n  \t\t\"address\": \"127.0.0.1\", //ip\n  \t\t\"port\": 10000, //端口\n  \t\t\"checks\": [\n  \t\t\t{\n  \t\t\t\t\"http\": \"http://localhost:10000/health\",\n  \t\t\t\t\"interval\": \"10s\" //检查时间\n  \t\t\t}\n  \t\t]\n  \t}\n  }\n  ```\n\n- 测试程序\n\n  ```go\n  package main\n  \n  import (\n  \t\"fmt\"\n  \t\"net/http\"\n  ) \n  \n  func handler(w http.ResponseWriter, r *http.Request) {\n  \tfmt.Println(\"hello Web3! This is n3或者n2\")\n  \tfmt.Fprintf(w, \"Hello Web3! This is n3或者n2\")\n  } \n  \n  func healthHandler(w http.ResponseWriter, r *http.Request) {\n  \tfmt.Println(\"health check! n3或者n2\")\n  } \n  \n  func main() {\n  \thttp.HandleFunc(\"/\", handler)\n  \thttp.HandleFunc(\"/health\", healthHandler)\n  \thttp.ListenAndServe(\":10000\", nil)\n  }\n  ```\n\n## 5. 查询服务\n\n一旦agent启动并且服务同步了.我们可以通过DNS或者HTTP的API来查询服务.\n\n- DNS API\n\n  > 让我们首先使用DNS API来查询.在DNS API中,服务的DNS名字是 NAME.service.consul. 虽然是可配置的,但默认的所有DNS名字会都在consul命名空间下.这个子域告诉Consul,我们在查询服务,NAME则是服务的名称.\n  > 对于我们上面注册的Web服务.它的域名是 web.service.consul :\n\n  ```shell\n  $ dig @127.0.0.1 -p 8600 web.service.consul\n  ```\n\n- 有也可用使用 DNS API 来接收包含 地址和端口的 SRV记录:\n\n  ```shell\n  $ dig @127.0.0.1 -p 8600 web.service.consul SRV\n  ```\n\n## 6. Consul架构\n\n![](https://github.com/AlexBruceLu/DAPP/wiki/uber8.png)\n\n我们只看数据中心1，可以看出consul的集群是由N个SERVER，加上M个CLIENT组成的。而不管是`SERVER`还是`CLIENT`，都是consul的一个节点，所有的服务都可以注册到这些节点上，正是通过这些节点实现服务注册信息的共享。除了这两个，还有一些小细节，一一简单介绍。\n\n` CLIENT` CLIENT表示consul的client模式，就是客户端模式。是consul节点的一种模式，这种模式下，所有注册到当前节点的服务会被转发到SERVER【通过HTTP和DNS接\n口请求server】，本身是`不持久化`这些信息。 \n\n`SERVER `SERVER表示consul的server模式，表明这个consul是个server，这种模式下，功能和CLIENT都一样，唯一不同的是，它会把所有的信息持久化的本地，这样遇到故障，信息是可以被保留的 `SERVER-LEADER` 中间那个SERVER下面有LEADER的字眼，表明这个SERVER是它们的老大，它和其它SERVER不一样的一点是，它需要负责同步注册的信息给其它的SERVER，同时也要负责各个节点的健康监测。\n\n- Consul的client mode把请求转向server，那么client的作用是什么？\n\n  > consul可以用来实现分布式系统的服务发现与配置。client把服务请求传递给server，server负责提供服务以及和其他数据中心交互。题主的问题是，既然server端提供了所有服务，那为何还需要多此一举地用client端来接收一\n  > 次服务请求。我想，采用这种架构有以下几种理由： \n  >\n  > 首先server端的网络连接资源有限。对于一个分布式系统，一般情况下访问量是很大的。如果用户能不通过client直接地访问数据中心，那么数据中心必然要为每个用户提供一个单独的连接资源(线程，端口号等等)，那么server端的负担会非常大。所以很有必要用大量的client端来分散用户的连接请求，在client端先统一整合用户的服务请求，然后一次性地通过一个单一的链接发送大量的请求给server端，能够大量减少server端的网络负担。 \n  >\n  > 其次，在client端可以对用户的请求进行一些处理来提高服务的效率，比如将相同的请求合并成同一个查询，再比如将之前的查询通过cookie的形式缓存下来。但是这些功能都需要消耗不少的计算和存储资源。如果在server端提供这些功能，必然加重server端的负担，使得server端更加不稳定。而通过client端来进行这些服务就没有这些问题了，因为client端不提供实际服务，有很充足的计算资源来进行这些处理这些工作。 最后还有一点，consul规定只要接入一个client就能将自己注册到一个服务网络当中。这种架构使得系统的可扩展性非常的强，网络的拓扑变化可以特别的灵活。这也是依赖于client—server结构的。如果系统中只有几个数据中心存在，那网络的扩张也无从谈起了。\n\n- Consul资料：\n- [http://www.liangxiansen.cn/2017/04/06/consul/](http://www.liangxiansen.cn/2017/04/06/consul/)\n- [https://blog.csdn.net/yuanyuanispeak/article/details/54880743](https://blog.csdn.net/yuanyuanispeak/article/details/54880743)\n\n","tags":["微服务"],"categories":["microServices"]},{"title":"GRPC","url":"/2018/11/25/GRPC/","content":"\n** {{ title }}：** <Excerpt in index | 首页摘要>\n\n微服务之GRPC\n\n<!-- more -->\n# GRPC\n\n## 1. 什么是GRPC\n\n![](https://github.com/AlexBruceLu/DAPP/wiki/Uber2.png)\n\n> GRPC 是一个高性能、开源和通用的 RPC 框架，面向移动和 HTTP/2 设计。GRPC基于 HTTP/2标准设计，带来诸如双向流、流控、头部压缩、单 TCP连接上的多复用请求等特。这些特性使得其在移动设备上表现更好，更省电和节省空间占用。\n>\n> 在 GRPC里客户端应用可以像调用本地对象一样直接调用另一台不同的机器上服务端应用的方法，使得您能够更容易地创建分布式应用和服务。与许多 RPC系统类似， GRPC也是基于以下理念：定义一个服务，指定其能够被远程调用的方法（包含参数和返回类型）。在服务端实现这个接口，并运行一个GRPC服务器来处理客户端调用。在客户端拥有一个存根能够像服务端一样的方法。 GRPC客户端和服务端可以在多种环境中运行和交互 -从 google内部的服务器到你自己的笔记本，并且可以用任何 GRPC支持的语言 来编写。所以，你可以很容易地用 Java创建一个GRPC服务端，用 Go、 Python、Ruby来创建客户端。此外， Google最新 API将有 GRPC版本的接口，使你很容易地将 Google的功能集成到你的应用里。\n\n## 2. RPC\n\nRPC（Remote Procedure Call Protocol）\n\n> 远程过程调用协议，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。\n>\n> 简单来说，就是跟远程访问或者web请求差不多，都是一个client向远端服务器请求服务返回结果，但是web请求使用的网络协议是http高层协议，而rpc所使用的协议多为TCP，是网络层协议，减少了信息的包装，加快了处理速度。\n\ngolang本身有rpc包，可以方便的使用，来构建自己的rpc服务，示例如下：\n\n![](https://github.com/AlexBruceLu/DAPP/wiki/uber3.png)\n\n1. 调用客户端句柄；执行传送参数 \n\n2. 调用本地系统内核发送网络消息 \n\n3. 消息传送到远程主机 \n\n4. 服务器句柄得到消息并取得参数 \n\n5. 执行远程过程 \n\n6. 执行的过程将结果返回服务器句柄\n\n7. 服务器句柄返回结果，调用远程系统内核 \n\n8. 消息传回本地主机 \n\n9. 客户句柄由内核接收消息 \n\n10. 客户接收句柄返回的数据\n\n### 2.1 服务端\n\n```go\npackage main\n\nimport (\n\t\"net/http\"\n\t\"net/rpc\"\n\t\"net\"\n\t\"github.com/astaxie/beego\"\n\t\"io\"\n) \n\n//- 方法是导出的\n//- 方法有两个参数，都是导出类型或内建类型\n//- 方法的第二个参数是指针\n//- 方法只有一个error接口类型的返回值\n\n//func (t *T) MethodName(argType T1, replyType *T2) error\ntype Panda int;\n\nfunc (this *Panda)Getinfo(argType int, replyType *int) error {\n\tbeego.Info(argType)\n\t*replyType =1 +argType\n    return nil\n} \n\nfunc main() {\n\t//注册1个页面请求\n\thttp.HandleFunc(\"/panda\",pandatext)\n\t//new 一个对象\n\tpd :=new(Panda)\n\t//注册服务\n\t//Register在默认服务中注册并公布 接收服务 pd对象 的方法\n\trpc.Register(pd)\n\trpc.HandleHTTP()\n\t//建立网络监听\n\tln , err :=net.Listen(\"tcp\",\"127.0.0.1:10086\")\n\tif err != nil{\n\t\tbeego.Info(\"网络连接失败\")\n\t} \n    beego.Info(\"正在监听10086\")\n\t//service接受侦听器l上传入的HTTP连接，\n\thttp.Serve(ln,nil)\n} \n\n//用来现实网页的web函数\nfunc pandatext(w http.ResponseWriter, r *http.Request) {\n\tio.WriteString(w,\"panda\")\n}\n```\n\n### 2.2 客户端\n\n```go\npackage main\nimport (\n\t\"net/rpc\"\n\t\"github.com/astaxie/beego\"\n) \n\nfunc main() {\n\t//rpc的与服务端建立网络连接\n\tcli,err := rpc.DialHTTP(\"tcp\",\"127.0.0.1:10086\")\n\tif err !=nil {\n\t\tbeego.Info(\"网络连接失败\")\n\t} \n    var val int\n\t//远程调用函数（被调用的方法，传入的参数 ，返回的参数）\n\terr =cli.Call(\"Panda.Getinfo\",123,&val)\n\tif err!=nil{\n    \tbeego.Info(\"打call失败\")\n\t} \n    beego.Info(\"返回结果\",val)\n}\n```\n\n## 3. GRPC使用 protocol buffers\n\nGRPC默认使用protobuf，这是 Google开源的一套成熟的结构数据序列化机制（当然也可以使用其他数据格式如\nJSON）。正如你将在下方例子里所看到的，你用 proto files创建 GRPC服务，用 protoBuf消息类型来定义方法参\n数和返回类型。你可以在 Protocol Buffers文档找到更多关于 protoBuf的资料。 虽然你可以使用 proto2 (当前默\n认的 protocol buffers版本 )，我们通常建议你在 GRPC里使用 proto3，因为这样你可以使用 GRPC支持全部范围的语言，并且能避免 proto2客户端与 proto3服务端交互时出现的兼容性问题，反之亦然。\n\n![](https://github.com/AlexBruceLu/DAPP/wiki/uber4.png)\n\n## 4. Hello GRPC\n\n了解GRPC工作机制最简单的方法是看一个简单的例子。 Hello World将带领你创建一个简单的客户端 —— 服务端应用，向你展示： 通过一个protoBuf模式，定义一个简单的带有 Hello World方法的RPC服务。 用你最喜欢的语言 (如果可用的话 )来创建一个实现了这个接口的服务端。 用大家最喜欢的 (或者其他你愿意的 )语言来访问你的服务端。这个例子完整的代码在我们 GitHub源码库的 examples目录下。我们使用 Git版本系统来进行源码管理，但是除了如何安装和运行一些 Git命令外，你没必要知道其他关于 Git的任何事情。需要注意的是，并不是所有 GRPC支持的语言都可以编写我们例子的服务端代码，比如 PHP和 Objective-C仅支持创建客户端。比起针对于特定语言的复杂教程，这更像是一个介绍性的例子。你可以在本站找到更有深度的教程，GRPC支持的语言的参考文档很快就会全部开放。\n\n### 4.1 环境搭建\n\n```shell\n#将x.zip 解压到 $GOPATH/src/golang.org/x 目录下\n$ unzip x.zip -d $GOPATH/src/golang.org/x\n#-d 是指定解压目录地址\n#/home/itcast/go/src/golang.org\n#文件名为x\n#将google.golang.org.zip 解压到 $GOPATH/src/google.golang.org 目录下\n```\n\n### 4.2 启动服务端\n\n```shell\n$ cd $GOPATH/src/google.golang.org/grpc/examples/helloworld/greeter_server\n$ go run main.go\n```\n\n### 4.3 启动客户端\n\n```shell\n$ cd $GOPATH/src/google.golang.org/grpc/examples/helloworld/greeter_client\n$ go run main.go\n```\n\n### 4.4 客户端代码介绍\n\n```go\npackage main\nimport (\n\t\"log\"\n\t\"os\"\n\t\"golang.org/x/net/context\"\n\t\"google.golang.org/grpc\"\n\tpb \"google.golang.org/grpc/examples/helloworld/helloworld\"\n\t//这是引用编译好的protobuf\n) \n\nconst (\n\taddress = \"localhost:50051\"\n\tdefaultName = \"world\"\n) \n\nfunc main() {\n\t// 建立到服务器的连接。\n\tconn, err := grpc.Dial(address, grpc.WithInsecure())\n\tif err != nil {\n\t\tlog.Fatalf(\"did not connect: %v\", err)\n\t}\n\t//延迟关闭连接\n\tdefer conn.Close()\n\t//调用protobuf的函数创建客户端连接句柄\n\tc := pb.NewGreeterClient(conn)\n\t// 联系服务器并打印它的响应。\n\tname := defaultName\n\tif len(os.Args) > 1 {\n\t\tname = os.Args[1]\n\t} \n    //调用protobuf的sayhello函数\n\tr, err := c.SayHello(context.Background(), &pb.HelloRequest{Name: name})\n\tif err != nil {\n\t\tlog.Fatalf(\"could not greet: %v\", err)\n    } \n    //打印结果\n\tlog.Printf(\"Greeting: %s\", r.Message)\n}\n```\n\n### 4.5 服务端代码介绍\n\n```go\npackage main\nimport (\n\t\"log\"\n\t\"net\"\n\t\"golang.org/x/net/context\"\n\t\"google.golang.org/grpc\"\n\tpb \"google.golang.org/grpc/examples/helloworld/helloworld\"\n\t\"google.golang.org/grpc/reflection\"\n)\n\nconst (\n\tport = \":50051\"\n)\n\n// 服务器用于实现helloworld.GreeterServer。\ntype server struct{}\n\n// SayHello实现helloworld.GreeterServer\nfunc (s *server) SayHello(ctx context.Context, in *pb.HelloRequest) (*pb.HelloReply, error) {\n\treturn &pb.HelloReply{Message: \"Hello \" + in.Name}, nil\n} \n\nfunc main() {\n\t//监听\n\tlis, err := net.Listen(\"tcp\", port)\n\tif err != nil {\n\t\tlog.Fatalf(\"failed to listen: %v\", err)\n\t} \n    //new服务对象\n\ts := grpc.NewServer()\n\t//注册服务\n\tpb.RegisterGreeterServer(s, &server{})\n\t// 在gRPC服务器上注册反射服务。\n\treflection.Register(s)\n\tif err := s.Serve(lis); err != nil {\n\t\tlog.Fatalf(\"failed to serve: %v\", err)\n\t}\n}\n```\n\n## 5. go语言实现GRPC远程调用\n\n### 5.1 protobuf协议定义\n\n创建一个 protobuf package,如： my_rpc_proto;\n在 $GOPATH/src/下创建 /my_grpc_proto/ 文件夹\n里面创建 protobuf 协议文件 helloServer.proto\n\n```shell\n#到工作目录\n$ CD $GOPATH/src/\n#创建目录\n$ mkdir grpc/myproto\n#进入目录\n$ cd grpc/myproto\n#创建proto文件\n$ vim helloServer.proto\n```\n\n- 文件内容\n\n  ```protobuf\n  syntax = \"proto3\";\n  package my_grpc_proto;\n  \n  service HelloServer{\n  \t// 创建第一个接口\n  \trpc SayHello(HelloRequest)returns(HelloReplay){}\n  \t// 创建第二个接口\n  \trpc GetHelloMsg(HelloRequest)returns(HelloMessage){}\n  } \n  \n  message HelloRequest{\n  \tstring name = 1 ;\n  } \n  \n  message HelloReplay{\n  \tstring message = 1;\n  } \n  \n  message HelloMessage{\n  \tstring msg = 1;\n  }\n  ```\n\n- 在当前文件下，编译 helloServer.proto文件\n\n  ```shell\n  $ protoc --go_out=./ *.proto #不加grpc插件\n  $ protoc --go_out=plugins=grpc:./ *.proto #添加grpc插件\n  #对比发现内容增加\n  #得到 helloServer.pb.go文件\n  ```\n\n- GRPC-Server编写\n\n  ```go\n  package main\n  import (\n  \t\"net\"\n  \t\"fmt\"\n  \t\"google.golang.org/grpc\"\n  \tpt \"demo/grpc/proto\"\n  \t\"context\"\n  ) \n  \n  const (\n  \tpost = \"127.0.0.1:18881\"\n  ) \n  \n  //对象要和proto内定义的服务一样\n  type server struct{}\n  //实现RPC SayHello 接口\n  func(this *server)SayHello(ctx context.Context,in *pt.HelloRequest)(*pt.HelloReplay, error){\n  \treturn &pt.HelloReplay{Message:\"hello\"+in.Name},nil\n  } \n  \n  //实现RPC GetHelloMsg 接口\n  func (this *server) GetHelloMsg(ctx context.Context, in *pt.HelloRequest)(*pt.HelloMessage, error) {\n  \treturn &pt.HelloMessage{Msg: \"this is from server HAHA!\"}, nil\n  } \n  \n  func main() {\n  \t//监听网络\n  \tln ,err :=net.Listen(\"tcp\",post)\n  \tif err!=nil {\n  \t\tfmt.Println(\"网络异常\",err)\n  \t}\n  \t// 创建一个grpc的句柄\n  \tsrv:= grpc.NewServer()\n  \t//将server结构体注册到 grpc服务中\n  \tpt.RegisterHelloServerServer(srv,&server{})\n  \t//监听grpc服务\n      err= srv.Serve(ln)\n      if err!=nil {\n  \t\tfmt.Println(\"网络启动异常\",err)\n  \t}\n  }\n  ```\n\n- GRPC-Client编写\n\n  ```go\n  package main\n  \n  import (\n  \t\"google.golang.org/grpc\"\n  \tpt \"demo/grpc/proto\"\n  \t\"fmt\"\n  \t\"context\"\n  ) \n  \n  const (\n  \tpost = \"127.0.0.1:18881\"\n  ) \n  \n  func main() {\n  \t// 客户端连接服务器\n  \tconn,err:=grpc.Dial(post,grpc.WithInsecure())\n  \tif err!=nil {\n  \t\tfmt.Println(\"连接服务器失败\",err)\n  \t} \n      defer conn.Close()\n  \t//获得grpc句柄\n  \tc:=pt.NewHelloServerClient(conn)\n      // 远程调用 SayHello接口\n      //远程调用 SayHello接口\n  \tr1, err := c.SayHello(context.Background(), \t&pt.HelloRequest{Name: \"panda\"})\n  \tif err != nil {\n  \t\tfmt.Println(\"cloud not get Hello server ..\", err)\n  \t\treturn\n  \t} \n      fmt.Println(\"HelloServer resp: \", r1.Message)\n  \t//远程调用 GetHelloMsg接口\n      r2, err := c.GetHelloMsg(context.Background(), &pt.HelloRequest{Name: \"panda\"})\n  \tif err != nil {\n  \t\tfmt.Println(\"cloud not get hello msg ..\", err)\n  \t\treturn\n  \t} \n      fmt.Println(\"HelloServer resp: \", r2.Msg)\n  }\n  ```\n\n- 运行结果\n\n  ```shell\n  #先运行 server，后运行 client\n  #得到以下输出结果\n  HelloServer resp: hellopanda\n  HelloServer resp: this is from server HAHA!\n  #如果反之则会报错\n  ```\n","tags":["微服务"],"categories":["microServices"]},{"title":"Micro","url":"/2018/11/25/micro/","content":"\n** {{ title }}：** <Excerpt in index | 首页摘要>\n\n微服务之Micro\n\n<!-- more -->\n# Micro\n\n## 1. Micro的介绍\n\nMicro解决了构建云本地系统的关键需求。它采用了微服务体系结构模式，并将其转换为一组工具，作为可伸缩平台的构建块。Micro隐藏了分布式系统的复杂性，并为开发人员提供了很好的理解概念。\n\nMicro是一个专注于简化分布式系统开发的微服务生态系统。是一个工具集合, 通过将微服务架构抽象成一组工具。隐藏了分布式系统的复杂性，为开发人员提供了更简洁的概念。\n\n## 2. Micro的安装\n\n### 2.1 下载micro\n\n```shell\n$ go get -u -v github.com/go-log/log\n$ go get -u -v github.com/gorilla/handlers\n$ go get -u -v github.com/gorilla/mux\n$ go get -u -v github.com/gorilla/websocket\n$ go get -u -v github.com/mitchellh/hashstructure\n$ go get -u -v github.com/nlopes/slack\n$ go get -u -v github.com/pborman/uuid\n$ go get -u -v github.com/pkg/errors\n$ go get -u -v github.com/serenize/snaker\n# hashicorp_consul.zip包解压在github.com/hashicorp/consul\n$ unzip hashicorp_consul.zip -d github.com/hashicorp/consul\n# miekg_dns.zip 包解压在github.com/miekg/dns\n$ unzip miekg_dns.zip -d github.com/miekg/dns\n$ go get github.com/micro/micro\n```\n\n### 2.2 编译安装micro\n\n```shell\n$ cd $GOPATH/src/github.com/micro/micro\n$ go build -o micro main.go\n$ sudo cp micro /bin/\n```\n\n### 2.3 插件安装\n\n```shell\n$ go get -u github.com/golang/protobuf/{proto,protoc-gen-go}\n$ go get -u github.com/micro/protoc-gen-micro\n```\n\n## 3. Micro的基本演示\n\n### 3.1 创建微服务命令说明\n\n```shell\nnew Create a new Micro service by specifying a directory path relative to your $GOPATH\n#创建 通过指定相对于$GOPATH的目录路径，创建一个新的微服务。\nUSAGE:\n#用法\nmicro new [command options][arguments...]\n--namespace \"go.micro\" Namespace for the service e.g com.example\n#服务的命名空间\n--type \"srv\" Type of service e.g api, fnc, srv, web\n#服务类型\n--fqdn FQDN of service e.g com.example.srv.service (defaults to\nnamespace.type.alias)\n#服务的正式定义全面\n--alias Alias is the short name used as part of combined name if\nspecified\n#别名是在指定时作为组合名的一部分使用的短名称\nrun Run the micro runtime\n#运行 运行这个微服务时间\n```\n\n### 3.2 创建2个服务\n\n```shell\n$micro new --type \"srv\" micro/rpc/srv\n#\"srv\" 是表示当前创建的微服务类型\n#sss是相对于go/src下的文件夹名称 可以根据项目进行设置\n#srv是当前创建的微服务的文件名\nCreating service go.micro.srv.srv in /home/itcast/go/src/micro/rpc/srv\n. #\n主函数\n├── main.go\n#插件\n├── plugin.go\n#被调用函数\n├── handler\n│ └── example.go\n#订阅服务\n├── subscriber\n│ └── example.go\n#proto协议\n├── proto/example\n│ └── example.proto\n#docker生成文件\n├── Dockerfile\n├── Makefile\n└──README.md\ndownload protobuf for micro:\n\nbrew install protobuf\n$ go get -u github.com/golang/protobuf/{proto,protoc-gen-go}\n$ go get -u github.com/micro/protoc-gen-micro\ncompile the proto file example.proto:\n$ cd /home/itcast/go/src/micro/rpc/srv\nprotoc --proto_path=. --go_out=. --micro_out=. proto/example/example.proto\n#使用创建srv时给的protobuf命令保留用来将proto文件进行编译\nmicro new --type \"web\" micro/rpc/web\nCreating service go.micro.web.web in /home/itcast/go/src/micro/rpc/web\n. #\n主函数\n├── main.go\n#插件文件\n├── plugin.go\n#被调用处理函数\n├── handler\n│ └── handler.go\n#前端页面\n├── html\n│ └── index.html\n#docker生成文件\n├── Dockerfile\n├── Makefile\n└──README.md\n#编译后将web端呼叫srv端的客户端连接内容修改为srv的内容\n#需要进行调通\n```\n\n### 3.3 启动consul进行监管\n\n```shell\n$ consul agent -dev\n```\n\n### 3.4 对srv服务进行的操作\n\n```shell\n#根据提示将proto文件生成为.go文件\n$ cd /home/itcast/go/src/micro/rpc/srv\nprotoc --proto_path=. --go_out=. --micro_out=. proto/example/example.proto\n#如果报错就按照提示将包进行下载\n$ go get -u github.com/golang/protobuf/{proto,protoc-gen-go}\n$ go get -u github.com/micro/protoc-gen-micro\n#如果还不行就把以前的包删掉从新下载\n```\n\n### 3.5 对web服务进行的操作\n\n#### 3.5.1 main文件\n\n```go\npackage main\n\nimport (\n    \"github.com/micro/go-log\"\n    \"net/http\"\n    \"github.com/micro/go-web\"\n    \"micro/rpc/web/handler\"\n) \n\nfunc main() {\n    // 创建1个web服务\n    service := web.NewService(\n        //注册服务名\n        web.Name(\"go.micro.web.web\"),\n        //服务的版本号\n        web.Version(\"latest\"),\n        //！添加端口\n        web.Address(\":8080\"),\n\t)\n\n    //服务进行初始化\n\tif err := service.Init(); err != nil {\n\t\tlog.Fatal(err)\n\t}\n    //处理请求 / 的路由 //当前这个web微服务的 html文件进行映射\n    service.Handle(\"/\", http.FileServer(http.Dir(\"html\")))\n    //处理请求 /example/call 的路由 这个相应函数 在当前项目下的handler\n    service.HandleFunc(\"/example/call\", handler.ExampleCall)\n    //运行服务\n\tif err := service.Run(); err != nil {\n\t\tlog.Fatal(err)\n\t}\n}\n```\n\n***将准备好的`html`文件替换掉原有的文件***\n\n#### 3.5.2 handler文件\n\n```go\npackage handler\n\nimport (\n    \"context\"\n    \"encoding/json\"\n    \"net/http\"\n    \"time\"\n    \"github.com/micro/go-micro/client\"\n    //将srv中的proto的文件导入进来进行通信的使用\n    example \"micro/rpc/srv/proto/example\"\n) \n\n//相应请求的业务函数\nfunc ExampleCall(w http.ResponseWriter, r *http.Request) {\n\t// 将传入的请求解码为json\n\tvar request map[string]interface{}\n\tif err := json.NewDecoder(r.Body).Decode(&request); err != nil{\n\t\thttp.Error(w, err.Error(), 500)\n\t\treturn\n\t} \n    \n    // 调用服务\n\t//替换掉原有的服务名\n\t//通过服务名和\n\texampleClient := example.NewExampleService(\"go.micro.srv.srv\",\n\tclient.DefaultClient)\n\trsp, err := exampleClient.Call(context.TODO(), &example.Request{\n\t\tName: request[\"name\"].(string),\n\t})\n\tif err != nil {\n\t\thttp.Error(w, err.Error(), 500)\n    return\n\t} \n    \n    // we want to augment the response\n\tresponse := map[string]interface{}{\n\t\t\"msg\": rsp.Msg,\n    \t\"ref\": time.Now().UnixNano(),\n\t} \n    \n    // encode and write the response as json\n\tif err := json.NewEncoder(w).Encode(response); err != nil {\n\t\thttp.Error(w, err.Error(), 500)\n\t\treturn\n\t}\n}\n```\n\n#### 3.5.3 升级成为grpc的版本\n\n- 重新生成proto文件、srv的main.go\n\n```go\npackage main\nimport (\n    \"github.com/micro/go-log\"\n    \"github.com/micro/go-micro\"\n    \"micro/grpc/srv/handler\"\n    \"micro/grpc/srv/subscriber\"\n    example \"micro/grpc/srv/proto/example\"\n    \"github.com/micro/go-grpc\"\n) \n\nfunc main() {\n    // New Service\n    service := grpc.NewService(\n    \tmicro.Name(\"go.micro.srv.srv\"),\n    \tmicro.Version(\"latest\"),\n\t) \n    \n    // Initialise service\n    service.Init()\n    // Register Handler\n  \texample.RegisterExampleHandler(service.Server(),\nnew(handler.Example))\n\t// Register Struct as Subscriber\n\tmicro.RegisterSubscriber(\"go.micro.srv.srv\", service.Server(),\nnew(subscriber.Example))\n\t// Register Function as Subscriber\n\tmicro.RegisterSubscriber(\"go.micro.srv.srv\", service.Server(),\nsubscriber.Handler)\n\t// Run service\n\tif err := service.Run(); err != nil {\n\t\tlog.Fatal(err)\n\t}\n}\n```\n\n- srv的example.go\n\n  ```go\n  package handler\n  \n  import (\n      \"context\"\n      \"github.com/micro/go-log\"\n      example \"micro/grpc/srv/proto/example\"\n  ) \n  \n  type Example struct{}\n  \n  // Call is a single request handler called via client.Call or the generated client code\n  func (e *Example) Call(ctx context.Context, req *example.Request, rsp *example.Response) error {\n  \tlog.Log(\"Received Example.Call request\")\n  \trsp.Msg = \"Hello \" + req.Name\n  \treturn nil\n  }\n  \n  // Stream is a server side stream handler called via client.Stream or the generated client code\n  func (e *Example) Stream(ctx context.Context, req *example.StreamingRequest, stream example.Example_StreamStream) error {\n  \tlog.Logf(\"Received Example.Stream request with count: %d\", req.Count)\n  \tfor i := 0; i < int(req.Count); i++ {\n  \t\tlog.Logf(\"Responding: %d\", i)\n  \t\tif err := stream.Send(&example.StreamingResponse{\n  \t\t\tCount: int64(i),\n  \t\t}); err != nil {\n  \t\t\treturn err\n  \t\t}\n  \t} \n      return nil\n  } \n  \n  // PingPong is a bidirectional stream handler called via client.Stream or the generated client code\n  func (e *Example) PingPong(ctx context.Context, stream\n  example.Example_PingPongStream) error {\n  \tfor {\n  \t\treq, err := stream.Recv()\n  \t\tif err != nil {\n  \t\t\treturn err\n  \t\t} \n      \tlog.Logf(\"Got ping %v\", req.Stroke)\n  \t\tif err := stream.Send(&example.Pong{Stroke: req.Stroke}); err != nil {\n  \t\t\treturn err\n  \t\t}\n  \t}\n  }\n  ```\n\n- 修改web的main.go\n\n  ```go\n  package main\n  import (\n      \"github.com/micro/go-log\"\n      \"net/http\"\n      \"github.com/micro/go-web\"\n  \t\"micro/grpc/web/handler\"\n  ) \n  \n  func main() {\n      // create new web service\n      service := web.NewService(\n      \tweb.Name(\"go.micro.web.web\"),\n      \tweb.Version(\"latest\"),\n      \tweb.Address(\":8080\"),\n      )\n  \t// initialise service\n  \tif err := service.Init(); err != nil {\n  \t\tlog.Fatal(err)\n  \t}\n  \t// register html handler\n  \tservice.Handle(\"/\", http.FileServer(http.Dir(\"html\")))\n  \t// register call handler\n  \tservice.HandleFunc(\"/example/call\", handler.ExampleCall)\n  \t// run service\n  \tif err := service.Run(); err != nil {\n  \t\tlog.Fatal(err)\n  \t}\n  }\n  ```\n\n- 修改web的handler.go\n\n  ```go\n  package handler\n  \n  import (\n  \t\"context\"\n      \"encoding/json\"\n      \"net/http\"\n      \"time\"\n      example \"micro/grpc/srv/proto/example\"\n      \"github.com/micro/go-grpc\"\n  ) \n  \n  func ExampleCall(w http.ResponseWriter, r *http.Request) {\n      server :=grpc.NewService()\n      server.Init()\n      // decode the incoming request as json\n      var request map[string]interface{}\n      if err := json.NewDecoder(r.Body).Decode(&request); err != nil {\n  \t\thttp.Error(w, err.Error(), 500)\n  \t\treturn\n  \t} \n      \n      // call the backend service\n  \t//exampleClient := example.NewExampleService(\"go.micro.srv.srv\",client.DefaultClient)\n  \texampleClient := example.NewExampleService(\"go.micro.srv.srv\", server.Client())\n  \trsp, err := exampleClient.Call(context.TODO(), &example.Request{\n  \t\tName: request[\"name\"].(string),\n  })\n  \tif err != nil {\n     \t\thttp.Error(w, err.Error(), 500)\n  \t\treturn\n  \t} \n      \n      // we want to augment the response\n  \tresponse := map[string]interface{}{\n  \t\t\"msg\": rsp.Msg,\n  \t\t\"ref\": time.Now().UnixNano(),\n  \t} \n      // encode and write the response as json\n  \tif err := json.NewEncoder(w).Encode(response); err != nil {\n  \t\thttp.Error(w, err.Error(), 500)\n  \t\treturn\n  \t}\n  }\n  ```\n\n## 4. 关于插件化\n\nGo Micro跟其他工具最大的不同是它是插件化的架构，这让上面每个包的具体实现都可以切换出去。举个例子，默认的服务发现的机制是通过Consul，但是如果想切换成`etcd`或者`zookeeper `或者任何你实现的方案，都是非常便利的","tags":["微服务"],"categories":["microServices"]},{"title":"protobuf","url":"/2018/11/25/protobuf/","content":"\n** {{ title }}：** <Excerpt in index | 首页摘要>\n\n微服务之protobuf\n\n<!-- more -->\n# protobuf\n\n## 1. protobuf 简介\n\n> <font color=\"red\">Google Protocol Buffer(简称 Protobuf)</font>是一种轻便高效的结构化数据格式，无关平台、无关语言、可扩展，用于通讯协议和数据存储等领域。\n\n### 1.1 protobuf 的优点\n\n> protobuf 有如XML，不过它更小、更快、规范、更简单。可以自定义自己的数据结构，然后使用代码生成器的代码来读写这个数据结构。甚至可以在无需重新部署程序的情况下更新数据结构。只需使用protobuf 对数据结构进行一次描述，即可利用各种不同的语言或从各种不同数据流中对结构化的数据轻松读写。\n>\n> protobuf 向后兼容性好，不必破坏已经部署的“老”数据格式的程序就可以对数据结构进行升级。\n>\n> protobuf 语义更清晰，无需类似XML 解析器的东西（因为protobuf 编译器会将.proto 文件编译生成对应的数据，访问类似于对protobuf 数据进行序列化、反序列化操作）。\n>\n> protobuf 的编程模式比较友好，无需学习复杂的文档对象模型，简单易学。\n\n### 1.2 protobuf 的缺点\n\n> protobuf 与 XML 相比的不足之处有以下几点：\n>\n> - 功能简单，无法用来表示复杂的概念\n> - XML 已经成为多种行业的标准编写工具，protobuf 只是Google 内部使用的工具，在通用性上差很多\n> - 文本并不适合描述数据结构，所以 protobuf 不适合用来对基于文本的标记文档（如HTML）建模\n> - 由于XML具有某种程度的字自解释性，它可以被人直接读取编辑，protobuf不行，它以二进制的方式存储，除非有 .proto 定义，否则无法直接读出 protobuf 的任何内容\n\n## 2. 常见数据交互的格式比较\n\n1. json：一般的web项目中，最流行的主要还是json，因为浏览器对于json数据支持非常好，有很多内建函数的支持。\n\n2. XML：在 WebService 中应用最为广泛，但相比json 更加冗余，因为需要成对的闭合标签，而json 使用了 键值对的方式，不仅压缩了一定的数据空间，而且具有一定的可读性\n\n3. protobuf：是谷歌开源的一种数据格式，适合高性能，对响应速度有要求的传输数据场景。protobuf 是二进制数据，需要编码和解码，数据本身并不具有可读性，只有对其进行反序列化之后才能得到可读的数据\n\n   > 对于其他数据格式，protobuf的优势\n   >\n   > 1. 序列化之后体积相对于json 和 XML 很小，适合网络传输\n   > 2. 支持跨平台多语言\n   > 3. 消息格式升级兼容性好\n   > 4. 序列化、反序列化的速度快，快于json的处理速度\n\n## 3. protobuf 的安装\n\n### 3.1 安装 protobuf\n\n```shell\n# 下载 protobuf\n$ git clone https://github.com/protocolbuffers/protobuf.git\n\n# 下载依赖库\n$ sudo apt-get install autoconf automake libtool curl make g++ unzip libffidev -y\n\n# 安装\n$ cd protobuf/\n$ ./autogen.sh\n$ ./configure\n$ make\n$ sudo make install\n$ sudo ldconfig # 刷新共享库（重要）\n$ protoc -h\n# 出现帮助列表说明protobuf 安装成功\n```\n\n### 3.2 获取 proto 包\n\n```shell\n$ go get -v -u github.com/golang/protobuf/protoc\n```\n\n### 3.3 安装 protoc-gen-go 插件\n\n```shell\n# 安装\n$ go get -v -u github.com/golang/protobuf/protoc-gen-go\n# 编译\n$ cd $GOPATH/src/github.com/golang/protobuf/protoc-gen-go\n$ go build\n# 将生成的 protoc-gen-go 可执行文件放在/bin 目录下\n$ sudo cp protoc-gen-go /bin/\n```\n\n## 4. protobuf 的语法\n\n### 4.1 定义一个消息\n\n要想使用 protobuf 必须先得定义 proto 文件，所以先得 熟悉消息定义的相关语法\n\n```protobuf\nsyntax = \"proto3\";\n\nmessage BruceRequest {\n    string name = 1;\n    int32 height = 2;\n    repeated int32 weight = 3；\n}\n```\n\n- **BruceRequest** 消息格式有三个字段，在消息中承载的数据分别对应于每一个字段，其中每一个字段都有一个名字和一种类型\n\n- 文件第一行是指定了使用`proto3` 语法，如果没有指定，默认`proto2` 语法。指定语法行，必须是非空、非注释的第一行\n- ` repeated` 关键字表示重复的，在go语言中用切片进行代表\n- 在消息定义中每个字段都有一个唯一的标识符\n\n### 4.3 定义一个消息类型\n\n在一个 .proto 文件中可以定义多个消息类型。在定义多个相关的消息的时候，这一点特别有用——例如，如果想定义与 SearchResponse 消息类型对应的回复消息格式的话，你可以将它添加到相同的 .proto 文件中\n\n```protobuf\nsyntax = \"proto3\";\n\nmessage BruceRequest {\n    string name = 1;\n    int32 height = 2;\n    repeated int32 weight = 3；\n}\n\nmessage AlexRequest {\n    ...\n}\n```\n\n### 4.4 添加注释 \n\n如一般的编程语言一直使用 '//'\n\n```protobuf\nsyntax = \"proto3\";\n\nmessage BruceRequest {\n    string name = 1; // 姓名\n    int32 height = 2; // 身高\n    repeated int32 weight = 3；// 体重\n}\n\nmessage AlexRequest {\n    ...\n}\n```\n\n### 4.5 .proto 文件生成文件\n\n当用protocol buffer编译器来运行.proto文件时，编译器将生成所选择语言的代码，这些代码可以操作在.proto文件中定义的消息类型，包括获取、设置字段值，将消息序列化到一个输出流中，以及从一个输入流中解析消息。\n\n> 对C++来说，编译器会为每个.proto文件生成一个.h文件和一个.cc文件，.proto文件中的每一个消息有一个对应的类。 对Python来说，有点不太一样——Python编译器为.proto文件中的每个消息类型生成一个含有静态描述符的模块，，该模块与一个元类（metaclass）在运行时（runtime）被用来创建所需的Python数据访问类。 对go来说，编译器会为每个消息类型生成了一个.pd.go文件。\n\n### 4.6 标准数据类型\n\n一个标量消息字段可以含有一个如下的类型:\n\n> 该表格展示了定义于.proto文件中的类型，以及与之对应的、在自动生成的访问类中定义的类型\n\n|  .proto  |                            Notes                             |  C++   |   Python    |   Go    |\n| :------: | :----------------------------------------------------------: | :----: | :---------: | :-----: |\n|  double  |                                                              | double |    float    | float64 |\n|  float   |                                                              | float  |    float    | float32 |\n|  int32   | 使用变长编码，对于负值的效率很低,如果你的域有可能有负值，请使用sint64替代 | int32  |     int     |  int32  |\n|  uint32  |                         使用变长编码                         | uint32 |  int/long   | uint32  |\n|  uint64  |                         使用变长编码                         | uint64 |  int/long   | uint64  |\n|  sint32  |        使用变长编码，这些编码在负值时比int32高效的多         | int32  |     int     |  int32  |\n|  sint64  |    使用变长编码，有符号的整型值。编码时比通常的int64高效     | int64  |  int/long   |  int64  |\n| fixed32  | 总是4个字节，如果数值总是比总是比228大的话，这个类型会比uint32高效 | uint32 |     int     | uint32  |\n| fixed64  | 总是8个字节，如果数值总是比总是比256大的话，这个类型会比uint64高效 | uint64 |  int/long   | uint64  |\n| sfixed32 |                         总是4个字节                          | int32  |     int     |  int32  |\n| sfixed32 |                         总是4个字节                          | int32  |     int     |  int32  |\n| sfixed64 |                         总是8个字节                          | int64  |  int/long   |  int64  |\n|   bool   |                                                              |  bool  |    bool     |  bool   |\n|  string  |      一个字符串必须是UTF-8编码或者7-bit ASCII编码的文本      | string | str/unicode | string  |\n|  bytes   |                  可能包含任意顺序的字节数据                  | string |     str     | []byte  |\n\n#### 4.6.1 默认值\n\n当一个消息被解析的时候，如果被编码的信息不包含一个特定的元素，被解析的对象锁对应的域被设置位一个默认值，对于不同类型指定如下： \n\n- 对于strings，默认是一个空string \n- 对于bytes，默认是一个空的bytes \n- 对于bool，默认是false \n- 对于数值类型，默认是0\n\n### 4.7 使用其他消息类型\n\n可以将其他消息类型用作字段类型。\n\n> 例如，假设在每一个PersonInfo消息中包含Person消息，此时可以在相同的 .proto 文件中定义一个Result消息类型，然后在PersonInfo消息中指定一个Person类型的字段\n\n```protobuf\nsyntax = \"proto3\";\n\nmessage BruceRequest {\n    string name = 1;\n    int32 height = 2;\n    repeated int32 weight = 3；\n}\n```\n\n### 4.8 使用proto2消息类型\n\n在你的proto3消息中导入proto2的消息类型也是可以的，反之亦然，然后proto2枚举不可以直接在proto3的标识符中使用（如果仅仅在proto2消息中使用是可以的）。\n\n#### 4.8.1 嵌套类型\n\n你可以在其他消息类型中定义、使用消息类型，在下面的例子中，Person消息就定义在PersonInfo消息内，如：\n\n```protobuf\nmessage PersonInfo {\n\tmessage Person {\n\t\tstring name = 1;\n\t\tint32 shengao = 2;\n\t\trepeated int32 tizhong = 3;\n\t} \n\trepeated Person info = 1;\n}\n```\n\n如果你想在它的父消息类型的外部重用这个消息类型，你需要以PersonInfo.Person的形式使用它，如：\n\n```protobuf\nmessage PersonMessage {\n\tPersonInfo.Person info = 1;\n}\n```\n\n当然，你也可以将消息嵌套任意多层，如：\n\n```protobuf\nmessage Grandpa { // Level 0\n\tmessage Father { // Level 1\n\t\tmessage son { // Level 2\n\t\t\tstring name = 1;\n\t\t\tint32 age = 2;\n\t\t}\n\t} \n\n\tmessage Uncle { // Level 1\n\t\tmessage Son { // Level 2\n\t\t\tstring name = 1;\n\t\t\tint32 age = 2;\n\t\t}\n\t}\n}\n```\n\n#### 4.8.2 定义服务(Service)\n\n果想要将消息类型用在RPC(远程方法调用)系统中，可以在.proto文件中定义一个RPC服务接口，protocol buffer编译器将会根据所选择的不同语言生成服务接口代码及存根。如，想要定义一个RPC服务并具有一个方法，该方法能够接收 SearchRequest并返回一个SearchResponse，此时可以在.proto文件中进行如下定义：\n\n```protobuf\nservice SearchService {\n\t//rpc 服务的函数名 （传入参数）返回（返回参数）\n\trpc Search (SearchRequest) returns (SearchResponse);\n}\n```\n\n最直观的使用protocol buffer的RPC系统是gRPC一个由谷歌开发的语言和平台中的开源的RPC系统，gRPC在使用protocl buffer时非常有效，如果使用特殊的protocol buffer插件可以直接为您从.proto文件中产生相关的RPC代码。\n\n如果你不想使用gRPC，也可以使用protocol buffer用于自己的RPC实现，你可以从proto2语言指南中找到更多信息\n\n#### 4.8.3 生成访问类\n\n可以通过定义好的.proto文件来生成Java,Python,C++, Ruby, JavaNano, Objective-C,或者C# 代码，需要基于.proto文件运行protocol buffer编译器protoc。如果你没有安装编译器，下载安装包并遵照README安装。对于Go,你还需要安装一个特殊的代码生成器件。你可以通过GitHub上的protobuf库找到安装过程\n通过如下方式调用protocol编译器:\n\n```shell\n$ protoc --proto_path=IMPORT_PATH --cpp_out=DST_DIR --python_out=DST_DIR --go_out=DST_DIR path/to/file.proto\n```\n\nIMPORT_PATH声明了一个.proto文件所在的解析import具体目录。如果忽略该值，则使用当前目录。如果有多个目录则可以多次调用--proto_path，它们将会顺序的被访问并执行导入。-I=IMPORT_PATH是--proto_path的简化形式。\n\n**当然也可以提供一个或多个输出路径：**\n\n --cpp_out 在目标目录DST_DIR中产生C++代码，可以在C++代码生成参考中查看更多。 \n\n--python_out 在目标目录 DST_DIR 中产生Python代码，可以在Python代码生成参考中查看更多。\n\n--go_out 在目标目录 DST_DIR 中产生Go代码，可以在GO代码生成参考中查看更多。\n\n> 作为一个方便的拓展，如果DST_DIR以.zip或者.jar结尾，编译器会将输出写到一个ZIP格式文件或者符合JAR标准的.jar文件中。注意如果输出已经存在则会被覆盖，编译器还没有智能到可以追加文件。 - 你必须提议一个或多个.proto文件作为输入，多\n> 个.proto文件可以只指定一次。虽然文件路径是相对于当前目录的，每个文件必须位于其IMPORT_PATH下，以便每个文件可以确定其规范的名称。\n\n#### 4.8.4 测试\n\nprotobuf的使用方法是将数据结构写入到 .proto文件中，使用 protoc编译器编译(间接使用了插件）得到一个新的go包，里面包含 go中可以使用的数据结构和一些辅助方法。\n\n- 编写 test.proto文件\n\n  - $GOPATH/src/创建 myproto文件夹\n\n    ```shell\n    $ cd $GOPATH/src/\n    $ mkdir myproto\n    ```\n\n  - myproto文件夹中创建 test.proto文件 (protobuf协议文件)\n\n    ```sh\n    $ vim test.proto\n    ```\n\n  - 文件内容\n\n    ```protobuf\n    syntax = \"proto3\";\n    package myproto;\n    \n    message Test {\n    \tstring name = 1;\n    \tint32 stature = 2 ;\n    \trepeated int64 weight = 3;\n    \tstring motto = 4;\n    }\n    ```\n\n- 编译 :执行\n\n  ```sh\n  $ protoc --go_out=./ *.proto \n  # 生成 test.pb.go文件\n  ```\n\n- 使用 protobuf 做数据格式转换\n\n  ```go\n  package main\n  \n  import (\n  \t\"fmt\"\n  \t\"github.com/golang/protobuf/proto\"\n  \t\"myproto\"\n  ) \n  \n  func main() {\n  \ttest := &myproto.Test{\n  \t\tName : \"panda\",\n  \t\tStature : 180,\n  \t\tWeight : []int64{120,125,198,180,150,180},\n  \t\tMotto : \"天行健，地势坤\",\n  \t} \n      //将Struct test 转换成 protobuf\n  \tdata,err:= proto.Marshal(test)\n  \tif err!=nil{\n  \t\tfmt.Println(\"转码失败\",err)\n  \t} \n      //得到一个新的Test结构体 newTest\n  \tnewtest:= &myproto.Test{}\n      //将data转换为test结构体\n  \terr = proto.Unmarshal(data,newtest)\n  \tif err!=nil {\n  \t\tfmt.Println(\"转码失败\",err)\n  \t} \n      fmt.Println(newtest.String())\n  \t//得到name字段\n  \tfmt.Println(\"newtest->name\",newtest.GetName())\n  \tfmt.Println(\"newtest->Stature\",newtest.GetStature())\n  \tfmt.Println(\"newtest->Weight\",newtest.GetWeight())\n  \tfmt.Println(\"newtest->Motto\",newtest.GetMotto())\n  }\n  ```\n\n\n\n\n\n\n","tags":["微服务"],"categories":["microServices"]},{"title":"微服务基础简介","url":"/2018/11/25/01/","content":"\n** {{ title }}：** <Excerpt in index | 首页摘要>\n\n微服务基础概念简介\n\n<!-- more -->\n\n\n\n# 一、微服务（microServices）\n\n## 1. 什么是微服务？\n\n在介绍微服务时，首先得先理解什么是微服务，顾名思义，微服务得从两个方面去理解，什么是\"微\"、什么是\"服\n务\"？ 微（micro） 狭义来讲就是体积小，著名的\"2 pizza 团队\"很好的诠释了这一解释（2 pizza 团队最早是亚马\n逊 CEO Bezos提出来的，意思是说单个服务的设计，所有参与人从设计、开发、测试、运维所有人加起来 只需要2个披萨就够了 ）。 服务（service） 一定要区别于系统，服务一个或者一组相对较小且独立的功能单元，是用户\n可以感知最小功能集。\n\n那么广义上来讲，微服务是一种分布式系统解决方案，推动细粒度服务的使用，这些服务协同工作。\n\n## 2. 为什么需要微服务？\n\n### 2.1 开发单体式应用的不足之处\n\n- **单体式打车软件的架构示意图**\n\n![示意图](https://github.com/AlexBruceLu/DAPP/wiki/Uber0.png)\n\n\n\n- **三层架构（MVC）的具体内容如下：**\n\n  - **表示层（view）**： 用户使用应用程序时，看到的、听见的、输入的或者交互的部分。\n\n  - **业务逻辑层（controller）**： 根据用户输入的信息，进行逻辑计算或者业务处理的部分。\n\n  - **数据访问层（model）**： 关注有效地操作原始数据的部分，如将数据存储到存储介质（如数据库、文件系统）及从存储介质中读取数据等。\n\n    > <font color=\"green\">虽然现在程序被分成了三层，但只是逻辑上的分层，并不是物理上的分层。也就是说，对不同层的代码而言，经过编译、打包和部署后，所有的代码最终还是运行在同一个进程中。而这，就是所谓的单块架构。</font>\n\n- **随着业务的不断扩大，不断暴露出的问题**\n\n  - 复杂性逐渐变高\n\n    > 比如有的项目有几十万行代码，各个模块之间区别比较模糊，逻辑比较混乱，代码越多复杂性越高，越难解决遇到的问题。\n\n  - 技术债务逐渐上升\n\n    > 公司的人员流动是再正常不过的事情，有的员工在离职之前，疏于代码质量的自我管束，导致留下来很多坑，由于单体项目代码量庞大的惊人，留下的坑很难被发觉，这就给新来的员工带来很大的烦恼，人员流动越大所留下的坑越多，也就是所谓的技术债务越来越多。\n\n  - 维护成本大\n\n    > 当应用程序的功能越来越多、团队越来越大时，沟通成本、管理成本显著增加。当出现 bug 时，可能引起 bug 的原因组合越来越多，导致分析、定位和修复的成本增加；并且在对全局功能缺乏深度理解的情况下，容易在修复bug 时引入新的 bug。\n\n  - 持续交付周期长\n\n    > 构建和部署时间会随着功能的增多而增加，任何细微的修改都会触发部署流水线。新人培养周期长：新成员了解背景、熟悉业务和配置环境的时间越来越长。 技术选型成本高 单块架构倾向于采用统一的技术平台或方案来解决所有问题，如果后续想引入新的技术或框架，成本和风险都很大。\n\n  - 可扩展性差\n\n    > 随着功能的增加，垂直扩展的成本将会越来越大；而对于水平扩展而言，因为所有代码都运行在同一个进程，没办法做到针对应用程序的部分功能做独立的扩展。\n\n### 2.2 微服务的优点\n\n- **微服务架构示意图**\n\n![](https://github.com/AlexBruceLu/DAPP/wiki/Uber1.png)\n\n- <font color=\"red\">**微服务架构的特性**</font>\n\n  - 职责单一\n\n    > 微服务架构中的每个服务，都是具有业务逻辑的，符合高内聚、低耦合原则以及单一职责原则的单元，不同的服务通过“管道”的方式灵活组合，从而构建出庞大的系统。\n\n  - 轻量级通信\n\n    > 服务之间通过轻量级的通信机制实现互通互联，而所谓的轻量级，通常指语言无关、平台无关的交互方式。对于轻量级通信的格式而言，我们熟悉的 XML 和 JSON，它们是语言无关、平台无关的；对于通信的协议而言，通常基于 HTTP，能让服务间的通信变得标准化、无状态化。目前大家熟悉的 REST（Representational State Transfer）是实现服务间互相协作的轻量级通信机制之一。使用轻量级通信机制，可以让团队选择更适合的语言、工具或者平台来开发服务本身。\n    >\n    > <font color=\"red\">问：REST是什么和restful一样吗？</font>\n    > 答：REST 指的是一组架构约束条件和原则。满足这些约束条件和原则的应用程序或设计就RESTful。\n\n  - 独立性\n\n    > 在微服务架构中，每个服务都是独立的业务单元，与其他服务高度解耦，只需要改变当前服务本身，就可以完成独立的开发、测试和部署。\n\n  - 进程隔离\n\n    > 在微服务架构中，应用程序由多个服务组成，每个服务都是高度自治的独立业务实体，可以运行在独立的进程中，不同的服务能非常容易地部署到不同的主机上。\n\n### 2.3 微服务的缺点\n\n- 运维要求较高\n\n  > 对于单体架构来讲，我们只需要维护好这一个项目就可以了，但是对于微服务架构来讲，由于项目是由多个微服务构成的，每个模块出现问题都会造成整个项目运行出现异常，想要知道是哪个模块造成的问题往往是不容易的，因为我们无法一步一步通过debug的方式来跟踪，这就对运维人员提出了很高的要求。\n\n- 分布式的复杂性\n\n  > 对于单体架构来讲，我们可以不使用分布式，但是对于微服务架构来说，分布式几乎是必会用的技术，由于分布式本身的复杂性，导致微服务架构也变得复杂起来。\n  >\n\n- 接口调整成本高\n\n  > 比如，用户微服务是要被订单微服务和电影微服务所调用的，一旦用户微服务的接口发生大的变动，那么所有依赖它的微服务都要做相应的调整，由于微服务可能非常多，那么调整接口所造成的成本将会明显提高。\n\n- 重复劳动\n\n  > 对于单体架构来讲，如果某段业务被多个模块所共同使用，我们便可以抽象成一个工具类，被所有模块直接调用，但是微服务却无法这样做，因为这个微服务的工具类是不能被其它微服务所直接调用的，从而我们便不得不在每个微服务上都建这么一个工具类，从而导致代码的重复。\n\n## 3. 传统单体架构与分布式微服务架构的区别\n\n|                |    **传统单体架构**    |              **分布式微服务化架构**              |\n| :------------: | :--------------------: | :----------------------------------------------: |\n| **新功能开发** |        需要时间        |                  容易开发和实线                  |\n|    **部署**    |   不经常而且容易部署   |                经常发布，部署复杂                |\n|   **隔离性**   |     故障影响范围大     |                  故障影响范围小                  |\n|  **架构设计**  |   初期设计选型难度大   |                  设计逻辑难度大                  |\n|  **系统性能**  |  响应时间快，吞吐量小  |               响应时间慢，吞吐量大               |\n|  **系统运维**  |        运维简单        |                     运维复杂                     |\n|  **新人上手**  | 学习曲线大（应用逻辑） |              学习曲线大（架构逻辑）              |\n|    **技术**    |    技术单一而且封闭    |                 技术多样而且开发                 |\n| **测试和差错** |          简单          | 复杂（每个服务都要进行单独测试，还需要集群测试） |\n| **系统扩展性** |        扩展性差        |                     扩展性好                     |\n|  **系统管理**  |    重点在于开发成本    |              重点在于服务治理和调度              |\n\n## 4. 为什么使用微服务架构\n\n- 开发简单\n\n  > 微服务架构将复杂系统进行拆分之后，让每个微服务应用都开放变得非常简单，没有太多的累赘。对于每一个开发者来说，这无疑是一种解脱，因为再也不用进行繁重的劳动了，每天都在一种轻松愉快的氛围中工作，其效率也会整备地提高\n\n- 快速响应需求变化\n\n  > 一般的需求变化来自于举步功能的变化，这种变化落实到每个微服务上，而每个微服务的功能相对来说都非常简单，更改起来非常容易，所以微服务非常适合敏捷开发方式，能够快速的影响业务的需求变化。\n\n- 随时随地更新\n\n  > 一方面，微服务的部署和更新并不会影响全局系统的正常运行；\n  >\n  > 另一方面，使用多实例的部署方法，可以做到一个服务的重启和更新在不易察觉的情况下进行，所以每个服务任何时候都可以进行更新部署。\n\n- 系统更加稳定可靠\n\n  > 微服务运行在一个高可用的分布式环境之中，有配套的监控和调度管理机制，并且还可以提供自由伸缩的管理，充分保证了系统的稳定性和可靠性。\n\n","tags":["微服务"],"categories":["microServices"]}]