[{"title":"程序员的自我修养--注重时效的哲学","url":"/2019/12/10/程序员的自我修养01/","content":"\n","tags":["编程"],"categories":["阅读","编程"]},{"title":"git commit 规范","url":"/2019/12/10/git_commit规范/","content":"\n@[TOC]\n\n# Git commit message 规范\n\n\n\n![img](../img/16b.jepg)\n\n\n\n> git是现在市面上最流行的版本控制工具，书写良好的commit message能大大提高代码维护的效率。但是在日常开发中由于缺少对于commit message的约束，导致填写内容随意、质量参差不齐，可读性低亦难以维护。在项目中引入commit message规范已是迫在眉睫。\n\n## 用什么规范？\n\n现在市面上比较流行的方案是`约定式提交规范`（`Conventional Commits`），它受到了`Angular提交准则`的启发，并在很大程度上以其为依据。`约定式提交规范`是一种基于提交消息的轻量级约定。 它提供了一组用于创建清晰的提交历史的简单规则；这使得编写基于规范的自动化工具变得更容易。这个约定与`SemVer`相吻合，在提交信息中描述新特性、bug 修复和破坏性变更。它的 message 格式如下:\n\n```\n<类型>[可选的作用域]: <描述>\n\n[可选的正文]\n\n[可选的脚注]\n复制代码\n```\n\n## Quick Start\n\n### 1. 全局安装commitizen & cz-conventional-changelog\n\n`commitizen`是一个撰写合格`commit message`的工具，用于代替`git commit` 指令，而`cz-conventional-changelog`适配器提供[conventional-changelog](https://github.com/conventional-changelog/conventional-changelog)标准（约定式提交标准）。基于不同需求，也可以使用不同适配器。\n\n```\nnpm install -g commitizen cz-conventional-changelog\necho '{ \"path\": \"cz-conventional-changelog\" }' > ~/.czrc\n复制代码\n```\n\n安装完毕后，可直接使用`git cz`来取代`git commit`。\n\n全局模式下，需要 `~/.czrc` 配置文件, 为`commitizen`指定`Adapter`。\n\n### 2. 项目内安装commitlint & husky\n\n`commitlint`负责用于对`commit message`进行格式校验，`husky`负责提供更易用的`git hook`。\n\n```\nUse npm\nnpm i -D husky @commitlint/config-conventional @commitlint/cli\n复制代码\nUse yarn\nyarn add husky @commitlint/config-conventional @commitlint/cli -D\n复制代码\n```\n\n`commitlint`只能做格式规范，无法触及内容。对于内容质量的把控只能靠我们自己。\n\n### 3. 添加相应配置\n\n创建`commitlint.config.js`\n\n```\n# In the same path as package.json\n\necho 'module.exports = {extends: [\"@commitlint/config-conventional\"]};' > ./commitlint.config.js\n复制代码\n```\n\n引入`husky`\n\n```\n# package.json\n\n...,\n\"husky\": {\n    \"hooks\": {\n      \"commit-msg\": \"commitlint -e $GIT_PARAMS\"\n    }\n}\n复制代码\n```\n\n### 4. 使用\n\n执行`git cz`进入interactive模式，根据提示依次填写\n\n```\n1.Select the type of change that you're committing 选择改动类型 (<type>)\n\n2.What is the scope of this change (e.g. component or file name)? 填写改动范围 (<scope>)\n\n3.Write a short, imperative tense description of the change: 写一个精简的描述 (<subject>)\n\n4.Provide a longer description of the change: (press enter to skip) 对于改动写一段长描述 (<body>)\n\n5.Are there any breaking changes? (y/n) 是破坏性修改吗？默认n (<footer>)\n\n6.Does this change affect any openreve issues? (y/n) 改动修复了哪个问题？默认n (<footer>)\n复制代码\n```\n\n生成的commit message格式如下：\n\n```\n<type>(<scope>): <subject>\n<BLANK LINE>\n<body>\n<BLANK LINE>\n<footer>\n复制代码\n```\n\n填写完毕后，`husky`会调用`commitlint`对message进行格式校验，默认规定`type`及`subject`为必填项。\n\n任何`git commit`指令的`option`都能用在 `git cz`指令上, 例如`git cz -a`\n\n## Commit message规范在rrd-fe落地使用情况\n\n针对团队目前使用的情况，我们讨论后拟定了`commit message`每一部分的填写规则。\n\n### 1. type\n\n`type`为必填项，用于指定commit的类型，约定了`feat`、`fix`两个`主要type`，以及docs、style、build、refactor、revert五个`特殊type`，`其余type`暂不使用。\n\n```\n# 主要type\nfeat:     增加新功能\nfix:      修复bug\n\n# 特殊type\ndocs:     只改动了文档相关的内容\nstyle:    不影响代码含义的改动，例如去掉空格、改变缩进、增删分号\nbuild:    构造工具的或者外部依赖的改动，例如webpack，npm\nrefactor: 代码重构时使用\nrevert:   执行git revert打印的message\n\n# 暂不使用type\ntest:     添加测试或者修改现有测试\nperf:     提高性能的改动\nci:       与CI（持续集成服务）有关的改动\nchore:    不修改src或者test的其余修改，例如构建过程或辅助工具的变动\n复制代码\n```\n\n当一次改动包括`主要type`与`特殊type`时，统一采用`主要type`。\n\n### 2. scope\n\n`scope`也为必填项，用于描述改动的范围，格式为项目名/模块名，例如： `node-pc/common` `rrd-h5/activity`，而`we-sdk`不需指定模块名。如果一次commit修改多个模块，建议拆分成多次commit，以便更好追踪和维护。\n\n### 3. body\n\n`body`填写详细描述，主要描述`改动之前的情况`及`修改动机`，对于小的修改不作要求，但是重大需求、更新等必须添加body来作说明。\n\n### 4. break changes\n\n`break changes`指明是否产生了破坏性修改，涉及break changes的改动必须指明该项，类似版本升级、接口参数减少、接口删除、迁移等。\n\n### 5. affect issues\n\n`affect issues`指明是否影响了某个问题。例如我们使用jira时，我们在`commit message`中可以填写其影响的`JIRA_ID`，若要开启该功能需要先打通`jira`与`gitlab`。参考文档：[docs.gitlab.com/ee/user/pro…](https://docs.gitlab.com/ee/user/project/integrations/jira.html)\n\n填写方式例如：\n\n```\nre #JIRA_ID\nfix #JIRA_ID\n复制代码\n```\n\n## 示例\n\n- 完整的commit message示例\n\n  ![img](../img/16b7.jepg)\n\n- 相应的git log\n\n  ![img](../img/16b73.jepg)\n\n## 扩展阅读\n\n[conventional commits](https://www.conventionalcommits.org/zh/v1.0.0-beta.3/) `必读` 介绍约定式提交标准。\n\n[Angular规范](https://github.com/angular/angular/blob/22b96b9/CONTRIBUTING.md#-commit-message-guidelines) `必读` 介绍Angular标准每个部分该写什么、该怎么写。\n\n[@commitlint/config-conventional](https://github.com/conventional-changelog/commitlint/tree/master/%40commitlint/config-conventional#type-enum) `必读` 介绍commitlint的校验规则config-conventional，以及一些常见passes/fails情况。","tags":["git"],"categories":["工具","git"]},{"title":"毒丸计划：防止恶意收购","url":"/2019/12/10/毒丸计划/","content":"\n@[TOC]\n\n","tags":["金融"],"categories":["阅读","金融"]},{"title":"杠杆收购：华尔街黄金游戏","url":"/2019/12/10/杠杆收购/","content":"\n@[TOC]\n\n","tags":["金融"],"categories":["阅读","金融"]},{"title":"Ubuntu 16.04 安装 CUDA","url":"/2019/12/09/Ubuntu_16.04安装cuda不同版本/","content":"\n@[TOC]\n\n## **一、操作系统:**\n\n研发工程师默认都是台式机，安装ubuntu16.04操作系统，默认我们安装好cuda和显卡驱动相关软件。如果需要重装系统请联系各属地IT，目前采用USB自动安装的方式，10分钟内可以安装完成\n\n## **二、卸载原有的驱动和cuda:**\n\nsudo su root\n\nservice lightdm stop\n\nnvidia-uninstall\n\napt-get install autoremove --purge nvidia*\n\n/usr/local/cuda-8.0/bin/uninstall_cuda-8.0.pl(根据版本号有差别，此处以8.0为例子)\n\nrm -rf /usr/local/cuda-8.0(!!!执行这一步时切勿误操作，否则容易导致系统崩溃)\n\n## **三、cuda安装：包含显卡驱动和相关软件包**\n\n### 1.下载cuda软件\n\n**（8.0版本）** wget https://developer.nvidia.com/compute/cuda/8.0/Prod2/local_installers/cuda_8.0.61_375.26_linux-run\n\n**（9.0版本）** wget https://developer.nvidia.com/compute/cuda/9.0/Prod/local_installers/cuda_9.0.176_384.81_linux-run\n\n**（10.0版本）**wget https://developer.nvidia.com/compute/cuda/10.0/Prod/local_installers/cuda_10.0.130_410.48_linux\n\n**（10.1版本）** \n\n​\t\twget http://developer.download.nvidia.com/compute/cuda/10.1/Prod/local_installers/cuda_10.1.243_418.87.00_linux.run\n\n**（10.2版本）**\n\n​\t\t wget http://developer.download.nvidia.com/compute/cuda/10.2/Prod/local_installers/cuda_10.2.89_440.33.01_linux.run\n\n### 2.下载NVIDIA显卡驱动\n\nwget http://cn.download.nvidia.com/XFree86/Linux-x86_64/440.36/NVIDIA-Linux-x86_64-440.36.run\n\n### 3.添加安装程序的可执行权限：\n\nchmod +x *.run\n\n### 4.禁用默认的nouveau开源显卡驱动：\n\necho \"blacklist nouveau\" >> /etc/modprobe.d/blacklist-nouveau.conf\n\n之后建议重启下系统\n\n### 5.关闭系统图形界面，显卡驱动安装过程需要在命令行模式下进行（Ctrl + Alt + F2 进入命令行模式）\n\n```\nsudo su root\n\nservice lightdm stop\n```\n\n### 6.安装显卡驱动程序，命令：\n\n```\n./NVIDIA-Linux-x86_64-410.78.run -a -s -Z --no-opengl-files\n```\n\n### 7.安装CUDA-9.0 驱动（请把cuda安装程序和安装目标目录替换为自己需要安装的对应版本）\n\n```\n./cuda_9.0.176_384.81_linux.run --no-opengl-libs --toolkit --samples --samplespath=/usr/local/cuda-9.0 -silent\n```\n\n### 8.添加安装的环境变量（将红色部分替换为自己安装的对应版本）:\n\n```\necho 'export LD_LIBRARY_PATH=/usr/local/cuda/lib:/usr/local/cuda/lib64/:/usr/local/cuda-9.0/lib:/usr/local/cuda-9.0/lib64/:$LD_LIBRARY_PATH' >> /etc/profile\necho 'export PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/cuda-9.0/bin:/usr/local/cuda/bin:$PATH' >> /etc/profile\necho '/usr/local/cuda/lib64' >> /etc/ld.so.conf.d/cuda.conf\n\nldconfig\n```\n\n### 9.下载cudnn\n\n- **Download cuDNN v7.6.5 (November 18th, 2019), for CUDA 10.2**\n\n  ```bash\n   wget https://developer.nvidia.com/compute/machine-learning/cudnn/secure/7.6.5.32/Production/10.2_20191118/cudnn-10.2-linux-x64-v7.6.5.32.tgz\n  ```\n\n- **Download cuDNN v7.6.5 (November 5th, 2019), for CUDA 10.1**\n\n  ```\n  wget https://developer.nvidia.com/compute/machine-learning/cudnn/secure/7.6.5.32/Production/10.1_20191031/cudnn-10.1-linux-x64-v7.6.5.32.tgz\n  ```\n\n- **Download cuDNN v7.6.4 (September 27, 2019), for CUDA 10.0**\n\n  ```\n  wget https://developer.nvidia.com/compute/machine-learning/cudnn/secure/7.6.4.38/Production/10.0_20190923/cudnn-10.0-linux-x64-v7.6.4.38.tgz\n  ```\n\n- **Download cuDNN v7.6.3 (August 23, 2019), for CUDA 9.0**\n\n  ```\n  wget https://developer.nvidia.com/compute/machine-learning/cudnn/secure/7.6.3.30/Production/9.0_20190822/cudnn-9.0-linux-x64-v7.6.3.30.tgz\n  ```\n\n- **Download cuDNN v7.1.3 (April 17, 2018), for CUDA 8.0**\n\n  ```\n  wget https://developer.nvidia.com/compute/machine-learning/cudnn/secure/v7.1.3/prod/8.0_20180414/cudnn-8.0-linux-x64-v7.1\n  ```\n\n### 10.安装cudnn\n\n```\ntar xf cudnn-9.0-linux-x64-v7.tar\nmv cuda/lib64/libcudnn* /usr/local/cuda-9.0/lib64/\nmv cuda/include/cudnn.h /usr/local/cuda-9.0/include/\n```","tags":["ubuntu","CUDA"],"categories":["Linux","NVIDIA"]},{"title":"go mod 基础篇","url":"/2019/12/09/go_mod基础篇/","content":"\n@[TOC]\n\n## 准备\n\n### 开启go mod\n\n1. 把 golang 升级到 1.11（现在1.13 已经发布了，建议使用1.13）\n2. 设置 `GO111MODULE`\n\nGO111MODULE\n\n`GO111MODULE` 有三个值：`off`, `on`和`auto（默认值）`。\n\n- `GO111MODULE=off`，go命令行将不会支持module功能，寻找依赖包的方式将会沿用旧版本那种通过vendor目录或者GOPATH模式来查找。\n- `GO111MODULE=on`，go命令行会使用modules，而一点也不会去GOPATH目录下查找。\n- `GO111MODULE=auto`，默认值，go命令行将会根据当前目录来决定是否启用module功能。这种情况下可以分为两种情形：\n  - 当前目录在GOPATH/src之外且该目录包含go.mod文件\n  - 当前文件在包含go.mod文件的目录下面。\n\n> 当modules 功能启用时，依赖包的存放位置变更为`$GOPATH/pkg`，允许同一个package多个版本并存，且多个项目可以共享缓存的 module。\n\n```bash\nexport GO111MODULE=on\n```\n\n### go mod常用命令\n\ngolang 提供了 `go mod`命令来管理包。\n\ngo mod 有以下命令：\n\n| 命令     | 说明                                                         |\n| -------- | ------------------------------------------------------------ |\n| download | download modules to local cache(下载依赖包)                  |\n| edit     | edit go.mod from tools or scripts（编辑go.mod                |\n| graph    | print module requirement graph (打印模块依赖图)              |\n| init     | initialize new module in current directory（在当前目录初始化mod） |\n| tidy     | add missing and remove unused modules(拉取缺少的模块，移除不用的模块) |\n| vendor   | make vendored copy of dependencies(将依赖复制到vendor下)     |\n| verify   | verify dependencies have expected content (验证依赖是否正确） |\n| why      | explain why packages or modules are needed(解释为什么需要依赖) |\n\n## 在项目中使用\n\n### 示例一：创建一个新项目\n\n1. 在`GOPATH 目录之外`新建一个目录，并使用`go mod init` 初始化生成`go.mod` 文件\n\n```\n➜  ~ mkdir hello\n➜  ~ cd hello\n➜  hello go mod init hello\ngo: creating new go.mod: module hello\n➜  hello ls\ngo.mod\n➜  hello cat go.mod\nmodule hello\n\ngo 1.12\n```\n\n> go.mod文件一旦创建后，它的内容将会被go toolchain全面掌控。go toolchain会在各类命令执行时，比如go get、go build、go mod等修改和维护go.mod文件。\n\ngo.mod 提供了`module`, `require`、`replace`和`exclude` 四个命令\n\n- `module` 语句指定包的名字（路径）\n- `require` 语句指定的依赖项模块\n- `replace` 语句可以替换依赖项模块\n- `exclude` 语句可以忽略依赖项模块\n\n1. 添加依赖\n\n新建一个 server.go 文件，写入以下代码：\n\n```\npackage main\n\nimport (\n    \"net/http\"\n    \n    \"github.com/labstack/echo\"\n)\n\nfunc main() {\n    e := echo.New()\n    e.GET(\"/\", func(c echo.Context) error {\n        return c.String(http.StatusOK, \"Hello, World!\")\n    })\n    e.Logger.Fatal(e.Start(\":1323\"))\n}\n```\n\n执行 `go run server.go` 运行代码会发现 go mod 会自动查找依赖自动下载：\n\n```\n$ go run server.go\ngo: finding github.com/labstack/echo v3.3.10+incompatible\ngo: downloading github.com/labstack/echo v3.3.10+incompatible\ngo: extracting github.com/labstack/echo v3.3.10+incompatible\ngo: finding github.com/labstack/gommon/color latest\ngo: finding github.com/labstack/gommon/log latest\ngo: finding github.com/labstack/gommon v0.2.8\n# 此处省略很多行\n...\n\n   ____    __\n  / __/___/ /  ___\n / _// __/ _ \\/ _ \\\n/___/\\__/_//_/\\___/ v3.3.10-dev\nHigh performance, minimalist Go web framework\nhttps://echo.labstack.com\n____________________________________O/_______\n                                    O\\\n⇨ http server started on [::]:1323\n```\n\n现在查看go.mod 内容：\n\n```\n$ cat go.mod\n\nmodule hello\n\ngo 1.12\n\nrequire (\n    github.com/labstack/echo v3.3.10+incompatible // indirect\n    github.com/labstack/gommon v0.2.8 // indirect\n    github.com/mattn/go-colorable v0.1.1 // indirect\n    github.com/mattn/go-isatty v0.0.7 // indirect\n    github.com/valyala/fasttemplate v1.0.0 // indirect\n    golang.org/x/crypto v0.0.0-20190313024323-a1f597ede03a // indirect\n)\n```\n\ngo module 安装 package 的原則是先拉最新的 release tag，若无tag则拉最新的commit，详见 [Modules官方介绍](https://github.com/golang/go/wiki/Modules)。 go 会自动生成一个 go.sum 文件来记录 dependency tree：\n\n```\n$ cat go.sum\ngithub.com/labstack/echo v3.3.10+incompatible h1:pGRcYk231ExFAyoAjAfD85kQzRJCRI8bbnE7CX5OEgg=\ngithub.com/labstack/echo v3.3.10+incompatible/go.mod h1:0INS7j/VjnFxD4E2wkz67b8cVwCLbBmJyDaka6Cmk1s=\ngithub.com/labstack/gommon v0.2.8 h1:JvRqmeZcfrHC5u6uVleB4NxxNbzx6gpbJiQknDbKQu0=\ngithub.com/labstack/gommon v0.2.8/go.mod h1:/tj9csK2iPSBvn+3NLM9e52usepMtrd5ilFYA+wQNJ4=\ngithub.com/mattn/go-colorable v0.1.1 h1:G1f5SKeVxmagw/IyvzvtZE4Gybcc4Tr1tf7I8z0XgOg=\ngithub.com/mattn/go-colorable v0.1.1/go.mod h1:FuOcm+DKB9mbwrcAfNl7/TZVBZ6rcnceauSikq3lYCQ=\n... 省略很多行\n```\n\n1. 再次执行脚本 `go run server.go` 发现跳过了检查并安装依赖的步骤。\n2. 可以使用命令 `go list -m -u all` 来检查可以升级的package，使用`go get -u need-upgrade-package` 升级后会将新的依赖版本更新到go.mod\n   - 也可以使用 `go get -u` 升级所有依赖\n\n#### go get 升级\n\n- 运行 go get -u 将会升级到最新的次要版本或者修订版本(x.y.z, z是修订版本号， y是次要版本号)\n- 运行 go get -u=patch 将会升级到最新的修订版本\n- 运行 go get package@version 将会升级到指定的版本号version\n- 运行go get如果有版本的更改，那么go.mod文件也会更改\n\n### 示例二：改造现有项目(helloword)\n\n项目目录为：\n\n```\n$ tree\n.\n├── api\n│   └── apis.go\n└── server.go\n\n1 directory, 2 files\n```\n\nserver.go 源码为：\n\n```\npackage main\n\nimport (\n    api \"./api\"  // 这里使用的是相对路径\n    \"github.com/labstack/echo\"\n)\n\nfunc main() {\n    e := echo.New()\n    e.GET(\"/\", api.HelloWorld)\n    e.Logger.Fatal(e.Start(\":1323\"))\n}\n```\n\napi/apis.go 源码为：\n\n```\npackage api\n\nimport (\n    \"net/http\"\n\n    \"github.com/labstack/echo\"\n)\n\nfunc HelloWorld(c echo.Context) error {\n    return c.JSON(http.StatusOK, \"hello world\")\n}\n```\n\n1. 使用 `go mod init ***` 初始化go.mod\n\n```\n$ go mod init helloworld\ngo: creating new go.mod: module helloworld\n```\n\n1. 运行 `go run server.go`\n\n```\ngo: finding github.com/labstack/gommon/color latest\ngo: finding github.com/labstack/gommon/log latest\ngo: finding golang.org/x/crypto/acme/autocert latest\ngo: finding golang.org/x/crypto/acme latest\ngo: finding golang.org/x/crypto latest\nbuild command-line-arguments: cannot find module for path _/home/gs/helloworld/api\n```\n\n首先还是会查找并下载安装依赖，然后运行脚本 `server.go`，这里会抛出一个错误：\n\n```\nbuild command-line-arguments: cannot find module for path _/home/gs/helloworld/api\n```\n\n但是`go.mod` 已经更新：\n\n```\n$ cat go.mod\nmodule helloworld\n\ngo 1.12\n\nrequire (\n        github.com/labstack/echo v3.3.10+incompatible // indirect\n        github.com/labstack/gommon v0.2.8 // indirect\n        github.com/mattn/go-colorable v0.1.1 // indirect\n        github.com/mattn/go-isatty v0.0.7 // indirect\n        github.com/valyala/fasttemplate v1.0.0 // indirect\n        golang.org/x/crypto v0.0.0-20190313024323-a1f597ede03a // indirect\n)\n```\n\n#### 那为什么会抛出这个错误呢？\n\n这是因为 server.go 中使用 internal package 的方法跟以前已经不同了，由于 go.mod会扫描同工作目录下所有 package 并且`变更引入方法`，必须将 helloworld当成路径的前缀，也就是需要写成 import helloworld/api，以往 GOPATH/dep 模式允许的 import ./api 已经失效，详情可以查看这个 [issue](https://github.com/golang/go/issues/26645)。\n\n1. 更新旧的package import 方式\n\n所以server.go 需要改写成：\n\n```\npackage main\n\nimport (\n    api \"helloworld/api\"  // 这是更新后的引入方法\n    \"github.com/labstack/echo\"\n)\n\nfunc main() {\n    e := echo.New()\n    e.GET(\"/\", api.HelloWorld)\n    e.Logger.Fatal(e.Start(\":1323\"))\n}\n```\n\n> `一个小坑`：开始在golang1.11 下使用go mod 遇到过 `go build github.com/valyala/fasttemplate: module requires go 1.12` [这种错误](https://github.com/golang/go/issues/27565)，遇到类似这种需要升级到1.12 的问题，直接升级golang1.12 就好了。幸亏是在1.12 发布后才尝试的`go mod` 🤷‍♂️\n\n1. 到这里就和新创建一个项目没什么区别了\n\n#### 使用replace替换无法直接获取的package\n\n由于某些已知的原因，并不是所有的package都能成功下载，比如：`golang.org`下的包。\n\nmodules 可以通过在 go.mod 文件中使用 replace 指令替换成github上对应的库，比如：\n\n```\nreplace (\n    golang.org/x/crypto v0.0.0-20190313024323-a1f597ede03a => github.com/golang/crypto v0.0.0-20190313024323-a1f597ede03a\n)\n```\n\n或者\n\n```\nreplace golang.org/x/crypto v0.0.0-20190313024323-a1f597ede03a => github.com/golang/crypto v0.0.0-20190313024323-a1f597ede03a\n```\n\n## 参考链接\n\n- [Modules官方介绍](https://github.com/golang/go/wiki/Modules)\n- [Golang 1.11 新功能介紹 – Modules](https://www.lightblue.asia/golang-1-11-new-festures-modules/?doing_wp_cron=1552464864.6369309425354003906250)\n- [What are Go modules and how do I use them?](https://talks.godoc.org/github.com/myitcv/talks/2018-08-15-glug-modules/main.slide#1)\n- [go mod doesn't work for github.com/gomarkdown/markdown/html](https://github.com/golang/go/issues/27565)\n- [再探go modules：使用与细节](https://www.cnblogs.com/apocelipes/p/10295096.html)\n- [初窥Go module](https://tonybai.com/2018/07/15/hello-go-module/)\n\n#### References\n\n[1] Modules官方介绍: [https://github.com/golang/go/...](https://github.com/golang/go/wiki/Modules)\n[2] issue: [https://github.com/golang/go/...](https://github.com/golang/go/issues/26645)\n[3] 这种错误: [https://github.com/golang/go/...](https://github.com/golang/go/issues/27565)\n[4] Modules官方介绍: [https://github.com/golang/go/...](https://github.com/golang/go/wiki/Modules)\n[5] Golang 1.11 新功能介紹 – Modules: [https://www.lightblue.asia/go...](https://www.lightblue.asia/golang-1-11-new-festures-modules/?doing_wp_cron=1552464864.6369309425354003906250)\n[6] What are Go modules and how do I use them?: [https://talks.godoc.org/githu...](https://talks.godoc.org/github.com/myitcv/talks/2018-08-15-glug-modules/main.slide#1)\n[7] go mod doesn't work for github.com/gomarkdown/markdown/html : [https://github.com/golang/go/...](https://github.com/golang/go/issues/27565)\n[8] 再探go modules：使用与细节: [https://www.cnblogs.com/apoce...](https://www.cnblogs.com/apocelipes/p/10295096.html)\n[9] 初窥Go module: [https://tonybai.com/2018/07/1...](https://tonybai.com/2018/07/15/hello-go-module/)","tags":["go","go mod"],"categories":["编程语言","GO"]},{"title":"git 新建仓库，添加远程分之到本地","url":"/2019/12/09/git新建仓库/","content":"\n@[TOC]\n\n### 本地不存在仓库拉取远程分之\n\n\n\n```\necho \"# gin-web\" >> README.md\ngit init\ngit add README.md\ngit commit -m \"first commit\"\ngit remote add origin https://github.com/AlexBruceLu/gin-web.git\ngit push -u origin master\n```\n\n### 本地已有的仓库添加到远程\n\n\n\n```\ngit remote add origin https://github.com/AlexBruceLu/gin-web.git\ngit push -u origin master\n```","tags":["git"],"categories":["工具","git"]},{"title":"Ubuntu 16.04 升级最新版本 nvidia-docker","url":"/2019/12/09/Ubuntu16.04升级最新版本nvidia-docker/","content":"\n@[TOC]\n\n### Uninstall old versions\n\nOlder versions of Docker were called `docker`, `docker.io `, or `docker-engine`. If these are installed, uninstall them:\n\n```\n$ sudo apt-get remove docker docker-engine docker.io containerd runc\n```\n\nIt’s OK if `apt-get` reports that none of these packages are installed.\n\nThe contents of `/var/lib/docker/`, including images, containers, volumes, and networks, are preserved. The Docker Engine - Community package is now called `docker-ce`.\n\n### Supported storage drivers\n\nDocker Engine - Community on Ubuntu supports `overlay2`, `aufs` and `btrfs` storage drivers.\n\n> **Note**: In Docker Engine - Enterprise, `btrfs` is only supported on SLES. See the documentation on [btrfs](https://docs.docker.com/engine/userguide/storagedriver/btrfs-driver/) for more details.\n\nFor new installations on version 4 and higher of the Linux kernel, `overlay2` is supported and preferred over `aufs`. Docker Engine - Community uses the `overlay2` storage driver by default. If you need to use `aufs` instead, you need to configure it manually. See [aufs](https://docs.docker.com/engine/userguide/storagedriver/aufs-driver/)\n\n### Install Docker Engine - Community\n\nYou can install Docker Engine - Community in different ways, depending on your needs:\n\n- Most users [set up Docker’s repositories](https://docs.docker.com/install/linux/docker-ce/ubuntu/#install-using-the-repository) and install from them, for ease of installation and upgrade tasks. This is the recommended approach.\n- Some users download the DEB package and [install it manually](https://docs.docker.com/install/linux/docker-ce/ubuntu/#install-from-a-package) and manage upgrades completely manually. This is useful in situations such as installing Docker on air-gapped systems with no access to the internet.\n- In testing and development environments, some users choose to use automated [convenience scripts](https://docs.docker.com/install/linux/docker-ce/ubuntu/#install-using-the-convenience-script) to install Docker.\n\n### Install using the repository\n\nBefore you install Docker Engine - Community for the first time on a new host machine, you need to set up the Docker repository. Afterward, you can install and update Docker from the repository.\n\n#### SET UP THE REPOSITORY\n\n1. Update the `apt` package index:\n\n   ```\n   $ sudo apt-get update\n   ```\n\n2. Install packages to allow `apt` to use a repository over HTTPS:\n\n   ```\n   $ sudo apt-get install \\\n       apt-transport-https \\\n       ca-certificates \\\n       curl \\\n       gnupg-agent \\\n       software-properties-common\n   ```\n\n3. Add Docker’s official GPG key:\n\n   ```\n   $ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -\n   ```\n\n   Verify that you now have the key with the fingerprint `9DC8 5822 9FC7 DD38 854A E2D8 8D81 803C 0EBF CD88`, by searching for the last 8 characters of the fingerprint.\n\n   ```\n   $ sudo apt-key fingerprint 0EBFCD88\n\n   pub   rsa4096 2017-02-22 [SCEA]\n         9DC8 5822 9FC7 DD38 854A  E2D8 8D81 803C 0EBF CD88\n   uid           [ unknown] Docker Release (CE deb) <docker@docker.com>\n   sub   rsa4096 2017-02-22 [S]\n   ```\n\n4. Use the following command to set up the **stable** repository. To add the **nightly** or **test** repository, add the word `nightly` or `test` (or both) after the word `stable` in the commands below. [Learn about **nightly** and **test** channels](https://docs.docker.com/install/).\n\n   > **Note**: The `lsb_release -cs` sub-command below returns the name of your Ubuntu distribution, such as `xenial`. Sometimes, in a distribution like Linux Mint, you might need to change `$(lsb_release -cs)` to your parent Ubuntu distribution. For example, if you are using `Linux Mint Tessa`, you could use `bionic`. Docker does not offer any guarantees on untested and unsupported Ubuntu distributions.\n\n\n\n   - - x86_64 / amd64\n     - armhf\n     - arm64\n     - ppc64le (IBM Power)\n     - s390x (IBM Z)\n\n\n\n   ```\n   $ sudo add-apt-repository \\\n      \"deb [arch=amd64] https://download.docker.com/linux/ubuntu \\\n      $(lsb_release -cs) \\\n      stable\"\n   ```\n\n\n\n#### INSTALL DOCKER ENGINE - COMMUNITY\n\n1. Update the `apt` package index.\n\n   ```\n   $ sudo apt-get update\n   ```\n\n2. Install the *latest version* of Docker Engine - Community and containerd, or go to the next step to install a specific version:\n\n   ```\n   $ sudo apt-get install docker-ce docker-ce-cli containerd.io\n   ```\n\n   > **** Got multiple Docker repositories?\n   >\n   > If you have multiple Docker repositories enabled, installing or updating without specifying a version in the `apt-get install` or `apt-get update` command always installs the highest possible version, which may not be appropriate for your stability needs.\n\n3. To install a *specific version* of Docker Engine - Community, list the available versions in the repo, then select and install:\n\n   a. List the versions available in your repo:\n\n   ```\n   $ apt-cache madison docker-ce\n\n     docker-ce | 5:18.09.1~3-0~ubuntu-xenial | https://download.docker.com/linux/ubuntu  xenial/stable amd64 Packages\n     docker-ce | 5:18.09.0~3-0~ubuntu-xenial | https://download.docker.com/linux/ubuntu  xenial/stable amd64 Packages\n     docker-ce | 18.06.1~ce~3-0~ubuntu       | https://download.docker.com/linux/ubuntu  xenial/stable amd64 Packages\n     docker-ce | 18.06.0~ce~3-0~ubuntu       | https://download.docker.com/linux/ubuntu  xenial/stable amd64 Packages\n     ...\n   ```\n\n   b. Install a specific version using the version string from the second column, for example, `5:18.09.1~3-0~ubuntu-xenial`.\n\n   ```\n   $ sudo apt-get install docker-ce=<VERSION_STRING> docker-ce-cli=<VERSION_STRING> containerd.io\n   ```\n\n4. Verify that Docker Engine - Community is installed correctly by running the `hello-world` image.\n\n   ```shell\n   $ sudo docker run hello-world\n   ```","tags":["ubuntu","nvidia-docker"],"categories":["Linux","docker"]}]