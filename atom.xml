<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>AlexBruce</title>
  
  <subtitle>消遣阁</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://alexbrucelu.github.io/"/>
  <updated>2020-01-07T07:46:23.686Z</updated>
  <id>https://alexbrucelu.github.io/</id>
  
  <author>
    <name>AlexBruce Lu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>kubernetes组件</title>
    <link href="https://alexbrucelu.github.io/2020/01/07/kubernetes%E7%BB%84%E4%BB%B6/"/>
    <id>https://alexbrucelu.github.io/2020/01/07/kubernetes%E7%BB%84%E4%BB%B6/</id>
    <published>2020-01-07T07:10:58.000Z</published>
    <updated>2020-01-07T07:46:23.686Z</updated>
    
    <content type="html"><![CDATA[<p>@[TOC]</p><h1 id="kubernetes组件"><a href="#kubernetes组件" class="headerlink" title="kubernetes组件"></a>kubernetes组件</h1><h2 id="Master组件"><a href="#Master组件" class="headerlink" title="Master组件"></a>Master组件</h2><p><code>master</code>组件提供集群管理控制中心。</p><p><code>master</code>组件可以在集群任意节点运行。但是为了简单起见，通常在一台VM/机器上启动所有Master组件，并且不会在此VM/机器上运行用户容器。请参考 <a href="https://kubernetes.io/docs/admin/high-availability" target="_blank" rel="noopener">构建高可用群集</a>以来构建multi-master-VM。</p><h3 id="kube-apiserver"><a href="#kube-apiserver" class="headerlink" title="kube-apiserver"></a>kube-apiserver</h3><p><a href="https://kubernetes.io/docs/admin/kube-apiserver" target="_blank" rel="noopener">kube-apiserver</a>用于暴露Kubernetes API。任何的资源请求/调用操作都是通过kube-apiserver提供的接口进行。请参阅<a href="https://kubernetes.io/docs/admin/high-availability" target="_blank" rel="noopener">构建高可用群集</a>。</p><h3 id="ETCD"><a href="#ETCD" class="headerlink" title="ETCD"></a>ETCD</h3><p><a href="https://kubernetes.io/docs/admin/etcd" target="_blank" rel="noopener">etcd</a>是Kubernetes提供默认的存储系统，保存所有集群数据，使用时需要为etcd数据提供备份计划。</p><h3 id="kube-controller-manager"><a href="#kube-controller-manager" class="headerlink" title="kube-controller-manager"></a>kube-controller-manager</h3><p><a href="https://kubernetes.io/docs/admin/kube-controller-manager" target="_blank" rel="noopener">kube-controller-manager</a>运行管理控制器，它们是集群中处理常规任务的后台线程。逻辑上，每个控制器是一个单独的进程，但为了降低复杂性，它们都被编译成单个二进制文件，并在单个进程中运行。</p><p>这些控制器包括：</p><ul><li><a href="http://docs.kubernetes.org.cn/304.html" target="_blank" rel="noopener">节点（Node）控制器</a>。</li><li>副本（Replication）控制器：负责维护系统中每个副本中的pod。</li><li>端点（Endpoints）控制器：填充Endpoints对象（即连接Services＆Pods）。</li><li><a href="http://docs.kubernetes.org.cn/84.html" target="_blank" rel="noopener">Service Account</a>和Token控制器：为新的<a href="http://docs.kubernetes.org.cn/242.html" target="_blank" rel="noopener">Namespace</a> 创建默认帐户访问API Token。</li></ul><h3 id="cloud-controller-manager"><a href="#cloud-controller-manager" class="headerlink" title="cloud-controller-manager"></a>cloud-controller-manager</h3><p>云控制器管理器负责与底层云提供商的平台交互。云控制器管理器是Kubernetes版本1.6中引入的，目前还是Alpha的功能。</p><p>云控制器管理器仅运行云提供商特定的（controller loops）控制器循环。可以通过将<code>--cloud-provider</code> flag设置为external启动kube-controller-manager ，来禁用控制器循环。</p><p><code>cloud-controller-manager</code> 具体功能：</p><ul><li>节点（Node）控制器</li><li>路由（Route）控制器</li><li>Service控制器</li><li>卷（Volume）控制器</li></ul><h3 id="kube-scheduler"><a href="#kube-scheduler" class="headerlink" title="kube-scheduler"></a>kube-scheduler</h3><p><code>kube-scheduler</code> 监视新创建没有分配到<a href="http://docs.kubernetes.org.cn/304.html" target="_blank" rel="noopener">Node</a>的<a href="http://docs.kubernetes.org.cn/312.html" target="_blank" rel="noopener">Pod</a>，为Pod选择一个Node。</p><h3 id="插件addons"><a href="#插件addons" class="headerlink" title="插件addons"></a>插件addons</h3><p>插件（addon）是实现集群pod和Services功能的 。Pod由<a href="http://docs.kubernetes.org.cn/317.html" target="_blank" rel="noopener">Deployments</a>，ReplicationController等进行管理。Namespace 插件对象是在kube-system Namespace中创建。</p><h4 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h4><p>虽然不严格要求使用插件，但Kubernetes集群都应该具有集群 DNS。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                群集 DNS是一个DNS服务器，能够为 Kubernetes services提供 DNS记录。由Kubernetes启动的容器自动将这个DNS服务器包含在他们的DNS searches中。</p><p>了解<a href="https://www.kubernetes.org.cn/542.html" target="_blank" rel="noopener">更多详情</a></p><h4 id="用户界面"><a href="#用户界面" class="headerlink" title="用户界面"></a>用户界面</h4><p>kube-ui提供集群状态基础信息查看。更多详细信息，请参阅<a href="https://kubernetes.io/docs/tasks/access-kubernetes-api/http-proxy-access-api/" target="_blank" rel="noopener">使用HTTP代理访问Kubernetes API</a></p><h4 id="容器资源监测"><a href="#容器资源监测" class="headerlink" title="容器资源监测"></a>容器资源监测</h4><p><a href="https://kubernetes.io/docs/user-guide/monitoring" target="_blank" rel="noopener">容器资源监控</a>提供一个UI浏览监控数据。</p><h4 id="cluster-level-logging"><a href="#cluster-level-logging" class="headerlink" title="cluster-level logging"></a>cluster-level logging</h4><p><a href="https://kubernetes.io/docs/user-guide/logging/overview" target="_blank" rel="noopener">Cluster-level logging</a>，负责保存容器日志，搜索/查看日志。<a href="https://kubernetes.io/docs/user-guide/logging/overview" target="_blank" rel="noopener">Cluster-level logging</a>，负责保存容器日志，搜索/查看日志。</p><h2 id="Node组件"><a href="#Node组件" class="headerlink" title="Node组件"></a>Node组件</h2><p>节点组件运行在<a href="http://docs.kubernetes.org.cn/304.html" target="_blank" rel="noopener">Node</a>，提供Kubernetes运行时环境，以及维护Pod。</p><h3 id="kubelet"><a href="#kubelet" class="headerlink" title="kubelet"></a>kubelet</h3><p><a href="https://kubernetes.io/docs/admin/kubelet" target="_blank" rel="noopener">kubelet</a>是主要的节点代理，它会监视已分配给节点的pod，具体功能：</p><ul><li>安装Pod所需的volume。</li><li>下载Pod的Secrets。</li><li>Pod中运行的 docker（或experimentally，rkt）容器。</li><li>定期执行容器健康检查。</li><li>Reports the status of the pod back to the rest of the system, by creating a <em>mirror pod</em> if necessary.</li><li>Reports the status of the node back to the rest of the system.                                                                                                                                                                                                                                                                                                                                                                                                                            </li></ul><h3 id="kube-proxy"><a href="#kube-proxy" class="headerlink" title="kube-proxy"></a>kube-proxy</h3><p><a href="https://kubernetes.io/docs/admin/kube-proxy" target="_blank" rel="noopener">kube-proxy</a>通过在主机上维护网络规则并执行连接转发来实现Kubernetes服务抽象。</p><h3 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h3><p>docker用于运行容器。</p><h3 id="RKT"><a href="#RKT" class="headerlink" title="RKT"></a>RKT</h3><p>rkt运行容器，作为docker工具的替代方案。</p><h3 id="supervisord"><a href="#supervisord" class="headerlink" title="supervisord"></a>supervisord</h3><p>supervisord是一个轻量级的监控系统，用于保障kubelet和docker运行。</p><h3 id="fluentd"><a href="#fluentd" class="headerlink" title="fluentd"></a>fluentd</h3><p>fluentd是一个守护进程，可提供<a href="https://kubernetes.io/docs/concepts/overview/components/#cluster-level-logging" target="_blank" rel="noopener">cluster-level logging</a>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;@[TOC]&lt;/p&gt;
&lt;h1 id=&quot;kubernetes组件&quot;&gt;&lt;a href=&quot;#kubernetes组件&quot; class=&quot;headerlink&quot; title=&quot;kubernetes组件&quot;&gt;&lt;/a&gt;kubernetes组件&lt;/h1&gt;&lt;h2 id=&quot;Master组件&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://alexbrucelu.github.io/categories/Linux/"/>
    
      <category term="k8s" scheme="https://alexbrucelu.github.io/categories/Linux/k8s/"/>
    
    
      <category term="kubernetes" scheme="https://alexbrucelu.github.io/tags/kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>kubernetes</title>
    <link href="https://alexbrucelu.github.io/2020/01/07/kubernetes/"/>
    <id>https://alexbrucelu.github.io/2020/01/07/kubernetes/</id>
    <published>2020-01-07T05:32:49.000Z</published>
    <updated>2020-01-07T07:09:39.618Z</updated>
    
    <content type="html"><![CDATA[<p>@[TOC]</p><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><h2 id="k8s是什么"><a href="#k8s是什么" class="headerlink" title="k8s是什么"></a>k8s是什么</h2><p><code>kubernetes</code> 的名字来自希腊语，意思是“舵手”或者“领航员”。k8s是将<code>kubernetes</code> 中间8个字母<code>ubernete</code>替换为8的缩写。</p><p><code>kubernetes</code> 是容器集群管理系统，是一个开源的平台，可以实现容器集群化的自动化部署、自动扩缩容、维护等功能。通过<code>kubernetes</code> 你可以实现：</p><ol><li>快速部署应用</li><li>快速扩展应用</li><li>无缝对接新的应用功能</li><li>节省资源，优化硬件资源的使用</li></ol><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ol><li><font color=red><strong>可移植：</strong></font> 支持公有云、私有云、混合云、多重云（multi-cloud）</li><li><font color=red><strong>可扩展：</strong></font> 模块化、插件化、可挂载、可组合</li><li><font color=red><strong>自动化：</strong></font> 自动化部署，自动重启，自动复制，自动伸缩、扩展</li></ol><h2 id="为什么要使用容器"><a href="#为什么要使用容器" class="headerlink" title="为什么要使用容器"></a>为什么要使用容器</h2><p><img src="https://raw.githubusercontent.com/wiki/AlexBruceLu/AlexBruceLu.github.io/k8s/why_containers.jpg" alt=""></p><p>传统的应用部署方式是通过脚本或者插件来安装应用。这样的缺点是应用的运运行、配置、管理、所有生存周期将与当前操作系统绑定，这样做并不利于升级、回滚等操作。当然也可以使用创建虚拟机的方式来实现某些功能，但是虚拟机是非常重，并不具有可移植性。</p><p>新的方式是通过部署容器的方式来实现，每个容器之间相互隔离，每一个容器都有自己的文件系统，容器之间的进程互不影响，能区分计算资源。相对虚拟机，容器能够快速部署。由于容器与底层设施、机器文件之间是解耦的，所以能在不同云、不同操作系统之间进行迁移。</p><p>容器占用资源少，部署快。每个应用都可以被打包成一个镜像。使得应用与镜像之间是一一对应关系，这也让容器更加具有优势。使用容器可以在<code>build</code>或者<code>release</code>的阶段，为应用创建容器镜像，因为每个应用不需要与其他的应用堆栈组合，也不依赖于 生产环境基础结构，这就能保证开发、测试环境的一致性。同时容器比虚拟机更加的”透明“，方便监控和管理。</p><blockquote><p><strong><font color=red>容器的优势总结：</font></strong></p><ol><li><strong>快速创建、部署应用：</strong>与虚拟机相比容器的创建更加容易</li><li><strong>持续开发、集成和部署：</strong>提供可靠且频繁的容器镜像构建、部署，并使用快速和简单的回滚（由于镜像的不可变性）。</li><li><strong>开发和运行相分离：</strong> 在build或者release阶段创建容器镜像，使得应用和基础设施解耦。</li><li><strong>开发测试环境的一致性：</strong>在本地或者外网运行一致性</li><li><strong>支持云平台、或其他操作系统：</strong>可以在<code>Ubuntu</code>、<code>RHEL</code>、<code>CoreOS</code>、<code>on-prem</code>、<code>Google Container Engine</code>或其它任何环境中运行。</li><li><strong>Lossely coupled，分布式，弹性，微服务化：</strong>应用程序分为更小更独立的部件，可以动态部署和管理。</li><li><strong>资源隔离：</strong>每个容器之间相互隔离，都有独立的文件系统、互不影响</li><li><strong>资源利用：</strong>更高效</li></ol></blockquote><h2 id="能做什么"><a href="#能做什么" class="headerlink" title="能做什么"></a>能做什么</h2><p>可以在物理机或者虚拟机的kubernetes集群上运行容器化应用，kubernetes能提供一个”以容器为中心的基础架构“，满足生产环境中运行应用的常见需求：</p><blockquote><ol><li>多个进程（作为容器运行）协同工作（pod）</li><li>储存系统挂载</li><li>Distributing secrets</li><li>应用健康检测</li><li>应用实例的复制</li><li>pod自动伸缩、扩展</li><li>Naming and discovering</li><li>负载均衡</li><li>滚动更新</li><li>资源监控</li><li>日志访问</li><li>调试应用程序</li><li>提供认证和授权</li></ol></blockquote><h2 id="不是什么"><a href="#不是什么" class="headerlink" title="不是什么"></a>不是什么</h2><ol><li>Kubernetes并不是传统的PaaS（平台即服务）系统。</li><li>Kubernetes不限制支持应用的类型，不限制应用框架。不限制受支持的语言runtimes (例如, Java, Python, Ruby)，满足<a href="https://12factor.net/" target="_blank" rel="noopener">12-factor applications</a> 。不区分 “apps” 或者“services”。 Kubernetes支持不同负载应用，包括有状态、无状态、数据处理类型的应用。只要这个应用可以在容器里运行，那么就能很好的运行在Kubernetes上。</li><li>Kubernetes不提供中间件（如message buses）、数据处理框架（如Spark）、数据库(如Mysql)或者集群存储系统(如Ceph)作为内置服务。但这些应用都可以运行在Kubernetes上面。</li><li>Kubernetes不部署源码不编译应用。持续集成的 (CI)工作流方面，不同的用户有不同的需求和偏好的区域，因此，提供分层的 CI工作流，但并不定义它应该如何工作。</li><li>Kubernetes允许用户选择自己的日志、监控和报警系统。</li><li>Kubernetes不提供或授权一个全面的应用程序配置 语言/系统（例如，<a href="https://github.com/google/jsonnet" target="_blank" rel="noopener">jsonnet</a>）。</li><li>Kubernetes不提供任何机器配置、维护、管理或者自修复系统。</li></ol><blockquote><p>另一方面，大量的Paas系统都可以运行在Kubernetes上，比如Openshift、Deis、Gondor。可以构建自己的Paas平台，与自己选择的CI系统集成。</p><p>由于Kubernetes运行在应用级别而不是硬件级，因此提供了普通的Paas平台提供的一些通用功能，比如部署，扩展，负载均衡，日志，监控等。这些默认功能是可选的。</p><p>另外，Kubernetes不仅仅是一个“编排系统”；它消除了编排的需要。“编排”的定义是指执行一个预定的工作流：先执行A，之B，然C。相反，Kubernetes由一组独立的可组合控制进程组成。怎么样从A到C并不重要，达到目的就好。当然集中控制也是必不可少，方法更像排舞的过程。这使得系统更加易用、强大、弹性和可扩展。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;@[TOC]&lt;/p&gt;
&lt;h1 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h1&gt;&lt;h2 id=&quot;k8s是什么&quot;&gt;&lt;a href=&quot;#k8s是什么&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://alexbrucelu.github.io/categories/Linux/"/>
    
      <category term="k8s" scheme="https://alexbrucelu.github.io/categories/Linux/k8s/"/>
    
    
      <category term="kubernetes" scheme="https://alexbrucelu.github.io/tags/kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>cuda常见问题解决办法</title>
    <link href="https://alexbrucelu.github.io/2019/12/18/cuda%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
    <id>https://alexbrucelu.github.io/2019/12/18/cuda%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</id>
    <published>2019-12-18T03:25:36.000Z</published>
    <updated>2019-12-18T09:05:18.510Z</updated>
    
    <content type="html"><![CDATA[<p>@[TOC]</p><h3 id="1-libnvinfer-so-5-cannot-open-shared-object-file-No-such-file-or-directory"><a href="#1-libnvinfer-so-5-cannot-open-shared-object-file-No-such-file-or-directory" class="headerlink" title="1. libnvinfer.so.5: cannot open shared object file: No such file or directory"></a>1. libnvinfer.so.5: cannot open shared object file: No such file or directory</h3><pre><code class="bash"># Add NVIDIA package repositories# Add HTTPS support for apt-keysudo apt-get install gnupg-curlwget https://developer.download.nvidia.com/compute/cuda/repos/ubuntu1604/x86_64/cuda-repo-ubuntu1604_10.0.130-1_amd64.debsudo dpkg -i cuda-repo-ubuntu1604_10.0.130-1_amd64.debsudo apt-key adv --fetch-keys https://developer.download.nvidia.com/compute/cuda/repos/ubuntu1604/x86_64/7fa2af80.pubsudo apt-get updatewget http://developer.download.nvidia.com/compute/machine-learning/repos/ubuntu1604/x86_64/nvidia-machine-learning-repo-ubuntu1604_1.0.0-1_amd64.debsudo apt install ./nvidia-machine-learning-repo-ubuntu1604_1.0.0-1_amd64.debsudo apt-get update# Install NVIDIA driver# Issue with driver install requires creating /usr/lib/nvidiasudo mkdir /usr/lib/nvidiasudo apt-get install --no-install-recommends nvidia-418# Reboot. Check that GPUs are visible using the command: nvidia-smi# Install development and runtime libraries (~4GB)sudo apt-get install --no-install-recommends \    cuda-10-0 \    libcudnn7=7.6.2.24-1+cuda10.0  \    libcudnn7-dev=7.6.2.24-1+cuda10.0# Install TensorRT. Requires that libcudnn7 is installed above.sudo apt-get install -y --no-install-recommends libnvinfer5=5.1.5-1+cuda10.0 \    libnvinfer-dev=5.1.5-1+cuda10.0</code></pre><p>GPU support</p><p><strong>Note:</strong> GPU support is available for Ubuntu and Windows with CUDA®-enabled cards.</p><p>TensorFlow GPU support requires an assortment of drivers and libraries. To simplify installation and avoid library conflicts, we recommend using a <a href="https://www.tensorflow.org/install/docker" target="_blank" rel="noopener">TensorFlow Docker image with GPU support</a> (Linux only). This setup only requires the <a href="https://www.nvidia.com/drivers" target="_blank" rel="noopener">NVIDIA® GPU drivers</a>.</p><p>These install instructions are for the latest release of TensorFlow. See the <a href="https://www.tensorflow.org/install/source#linux" target="_blank" rel="noopener">tested build configurations</a> for CUDA and cuDNN versions to use with older TensorFlow releases.</p><p>Pip package</p><p>See the <a href="https://www.tensorflow.org/install/pip" target="_blank" rel="noopener">pip install guide</a> for available packages, systems requirements, and instructions. To <code>pip</code> install a TensorFlow package with GPU support, choose a stable or development package:</p><pre><code class="bash">pip install tensorflow-gpu  # stablepip install tf-nightly      # preview</code></pre><p>Older versions of TensorFlow</p><p>For the 1.15 release, CPU and GPU support are included in a single package:</p><pre><code class="bsh">pip install --pre &quot;tensorflow==1.15.*&quot;</code></pre><p>For releases 1.14 and older, CPU and GPU packages are separate:</p><pre><code class="bsh">pip install tensorflow==1.14      # CPUpip install tensorflow-gpu==1.14  # GPU</code></pre><p>Hardware requirements</p><p>The following GPU-enabled devices are supported:</p><ul><li>NVIDIA® GPU card with CUDA® Compute Capability 3.5 or higher. See the list of <a href="https://developer.nvidia.com/cuda-gpus" target="_blank" rel="noopener">CUDA-enabled GPU cards</a>.</li></ul><p>Software requirements</p><p>The following NVIDIA® software must be installed on your system:</p><ul><li><a href="https://www.nvidia.com/drivers" target="_blank" rel="noopener">NVIDIA® GPU drivers</a> —CUDA 10.0 requires 410.x or higher.</li><li><a href="https://developer.nvidia.com/cuda-toolkit-archive" target="_blank" rel="noopener">CUDA® Toolkit</a> —TensorFlow supports CUDA 10.0 (TensorFlow &gt;= 1.13.0)</li><li><a href="http://docs.nvidia.com/cuda/cupti/" target="_blank" rel="noopener">CUPTI</a> ships with the CUDA Toolkit.</li><li><a href="https://developer.nvidia.com/cudnn" target="_blank" rel="noopener">cuDNN SDK</a> (&gt;= 7.4.1)</li><li><em>(Optional)</em> <a href="https://docs.nvidia.com/deeplearning/sdk/tensorrt-install-guide/index.html" target="_blank" rel="noopener">TensorRT 5.0</a> to improve latency and throughput for inference on some models.</li></ul><p>Linux setup</p><p>The <code>apt</code> instructions below are the easiest way to install the required NVIDIA software on Ubuntu. However, if <a href="https://www.tensorflow.org/install/source" target="_blank" rel="noopener">building TensorFlow from source</a>, manually install the software requirements listed above, and consider using a <code>-devel</code> <a href="https://www.tensorflow.org/install/docker" target="_blank" rel="noopener">TensorFlow Docker image</a> as a base.</p><p>Install <a href="http://docs.nvidia.com/cuda/cupti/" target="_blank" rel="noopener">CUPTI</a> which ships with the CUDA® Toolkit. Append its installation directory to the <code>$LD_LIBRARY_PATH</code> environmental variable:</p><pre><code>export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/local/cuda/extras/CUPTI/lib64</code></pre><p>For a GPU with CUDA Compute Capability 3.0, or different versions of the NVIDIA libraries, see the <a href="https://www.tensorflow.org/install/source" target="_blank" rel="noopener">Linux build from source</a> guide.</p><p>Install CUDA with apt</p><p>This section shows how to install CUDA 10 (TensorFlow &gt;= 1.13.0) and CUDA 9 for Ubuntu 16.04 and 18.04. These instructions may work for other Debian-based distros.</p><p><strong>Caution:</strong> <a href="https://wiki.ubuntu.com/UEFI/SecureBoot" target="_blank" rel="noopener">Secure Boot</a> complicates installation of the NVIDIA driver and is beyond the scope of these instructions.</p><p>Ubuntu 18.04 (CUDA 10)</p><pre><code class="bsh"># Add NVIDIA package repositorieswget https://developer.download.nvidia.com/compute/cuda/repos/ubuntu1804/x86_64/cuda-repo-ubuntu1804_10.0.130-1_amd64.debsudo dpkg -i cuda-repo-ubuntu1804_10.0.130-1_amd64.debsudo apt-key adv --fetch-keys https://developer.download.nvidia.com/compute/cuda/repos/ubuntu1804/x86_64/7fa2af80.pubsudo apt-get updatewget http://developer.download.nvidia.com/compute/machine-learning/repos/ubuntu1804/x86_64/nvidia-machine-learning-repo-ubuntu1804_1.0.0-1_amd64.debsudo apt install ./nvidia-machine-learning-repo-ubuntu1804_1.0.0-1_amd64.debsudo apt-get update# Install NVIDIA driversudo apt-get install --no-install-recommends nvidia-driver-418# Reboot. Check that GPUs are visible using the command: nvidia-smi# Install development and runtime libraries (~4GB)sudo apt-get install --no-install-recommends \    cuda-10-0 \    libcudnn7=7.6.2.24-1+cuda10.0  \    libcudnn7-dev=7.6.2.24-1+cuda10.0# Install TensorRT. Requires that libcudnn7 is installed above.sudo apt-get install -y --no-install-recommends libnvinfer5=5.1.5-1+cuda10.0 \    libnvinfer-dev=5.1.5-1+cuda10.0</code></pre><p>Ubuntu 16.04 (CUDA 10)</p><pre><code class="bsh"># Add NVIDIA package repositories# Add HTTPS support for apt-keysudo apt-get install gnupg-curlwget https://developer.download.nvidia.com/compute/cuda/repos/ubuntu1604/x86_64/cuda-repo-ubuntu1604_10.0.130-1_amd64.debsudo dpkg -i cuda-repo-ubuntu1604_10.0.130-1_amd64.debsudo apt-key adv --fetch-keys https://developer.download.nvidia.com/compute/cuda/repos/ubuntu1604/x86_64/7fa2af80.pubsudo apt-get updatewget http://developer.download.nvidia.com/compute/machine-learning/repos/ubuntu1604/x86_64/nvidia-machine-learning-repo-ubuntu1604_1.0.0-1_amd64.debsudo apt install ./nvidia-machine-learning-repo-ubuntu1604_1.0.0-1_amd64.debsudo apt-get update# Install NVIDIA driver# Issue with driver install requires creating /usr/lib/nvidiasudo mkdir /usr/lib/nvidiasudo apt-get install --no-install-recommends nvidia-418# Reboot. Check that GPUs are visible using the command: nvidia-smi# Install development and runtime libraries (~4GB)sudo apt-get install --no-install-recommends \    cuda-10-0 \    libcudnn7=7.6.2.24-1+cuda10.0  \    libcudnn7-dev=7.6.2.24-1+cuda10.0# Install TensorRT. Requires that libcudnn7 is installed above.sudo apt-get install -y --no-install-recommends libnvinfer5=5.1.5-1+cuda10.0 \    libnvinfer-dev=5.1.5-1+cuda10.0</code></pre><p>Ubuntu 16.04 (CUDA 9.0 for TensorFlow &lt; 1.13.0)</p><pre><code class="bash"># Add NVIDIA package repositorysudo apt-key adv --fetch-keys http://developer.download.nvidia.com/compute/cuda/repos/ubuntu1604/x86_64/7fa2af80.pubwget http://developer.download.nvidia.com/compute/cuda/repos/ubuntu1604/x86_64/cuda-repo-ubuntu1604_9.1.85-1_amd64.debsudo apt install ./cuda-repo-ubuntu1604_9.1.85-1_amd64.debwget http://developer.download.nvidia.com/compute/machine-learning/repos/ubuntu1604/x86_64/nvidia-machine-learning-repo-ubuntu1604_1.0.0-1_amd64.debsudo apt install ./nvidia-machine-learning-repo-ubuntu1604_1.0.0-1_amd64.debsudo apt update# Install the NVIDIA driver# Issue with driver install requires creating /usr/lib/nvidiasudo mkdir /usr/lib/nvidiasudo apt-get install --no-install-recommends nvidia-410# Reboot. Check that GPUs are visible using the command: nvidia-smi# Install CUDA and tools. Include optional NCCL 2.xsudo apt install cuda9.0 cuda-cublas-9-0 cuda-cufft-9-0 cuda-curand-9-0 \        cuda-cusolver-9-0 cuda-cusparse-9-0 libcudnn7=7.2.1.38-1+cuda9.0 \        libnccl2=2.2.13-1+cuda9.0 cuda-command-line-tools-9-0# Optional: Install the TensorRT runtime (must be after CUDA install)sudo apt updatesudo apt install libnvinfer4=4.1.2-1+cuda9.0</code></pre><p>Windows setup</p><p>See the <a href="https://www.tensorflow.org/install/gpu#hardware_requirements" target="_blank" rel="noopener">hardware requirements</a> and <a href="https://www.tensorflow.org/install/gpu#software_requirements" target="_blank" rel="noopener">software requirements</a> listed above. Read the <a href="https://docs.nvidia.com/cuda/cuda-installation-guide-microsoft-windows/" target="_blank" rel="noopener">CUDA® install guide for Windows</a>.</p><p>Make sure the installed NVIDIA software packages match the versions listed above. In particular, TensorFlow will not load without the <code>cuDNN64_7.dll</code> file. To use a different version, see the <a href="https://www.tensorflow.org/install/source_windows" target="_blank" rel="noopener">Windows build from source</a> guide.</p><p>Add the CUDA, CUPTI, and cuDNN installation directories to the <code>%PATH%</code> environmental variable. For example, if the CUDA Toolkit is installed to <code>C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v10.0</code> and cuDNN to <code>C:\tools\cuda</code>, update your <code>%PATH%</code> to match:</p><pre><code>SET PATH=C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v10.0\bin;%PATH% SET PATH=C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v10.0\extras\CUPTI\libx64;%PATH% SET PATH=C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v10.0\include;%PATH% SET PATH=C:\tools\cuda\bin;%PATH%</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;@[TOC]&lt;/p&gt;
&lt;h3 id=&quot;1-libnvinfer-so-5-cannot-open-shared-object-file-No-such-file-or-directory&quot;&gt;&lt;a href=&quot;#1-libnvinfer-so-5-cannot-open-sh
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://alexbrucelu.github.io/categories/Linux/"/>
    
      <category term="NVIDIA" scheme="https://alexbrucelu.github.io/categories/Linux/NVIDIA/"/>
    
    
      <category term="CUDA" scheme="https://alexbrucelu.github.io/tags/CUDA/"/>
    
  </entry>
  
  <entry>
    <title>golang Runtime</title>
    <link href="https://alexbrucelu.github.io/2019/12/13/golangRuntime/"/>
    <id>https://alexbrucelu.github.io/2019/12/13/golangRuntime/</id>
    <published>2019-12-13T06:29:45.000Z</published>
    <updated>2019-12-13T07:28:45.991Z</updated>
    
    <content type="html"><![CDATA[<p>@[TOC]</p><h1 id="Golang-Runtime"><a href="#Golang-Runtime" class="headerlink" title="Golang Runtime"></a>Golang Runtime</h1><h2 id="什么是Golang-Runtime"><a href="#什么是Golang-Runtime" class="headerlink" title="什么是Golang Runtime"></a>什么是Golang Runtime</h2><blockquote><p>Golang Runtime 是go语言运行时所需要的基础设施</p><ol><li>协程调度、内存分配、GC</li><li>操作系统和CPU相关操作的封装（信号处理、系统调用、寄存器操作、原子操作等）、CGO</li><li>pprof、trace、race检测的支持</li><li>map、channel、string等内置类型及反射的实现</li></ol></blockquote><h3 id="与其他语言的不同"><a href="#与其他语言的不同" class="headerlink" title="与其他语言的不同"></a>与其他语言的不同</h3><ol><li><p>Go是没有虚拟机的概念的，所以runtime也被直接编译成native code</p></li><li><p>go 语言<code>Runtime</code> 代码和<code>用户代码</code> 是直接打包在一个可执行文件中</p></li><li><p><code>Runtime</code> 代码和<code>用户代码</code>在执行的时候并没有明显的界限，就是函数调用关系</p></li><li><p>go对系统调用的函数进行了封装，可不依赖于glibc</p></li><li><p>一些go的关键字被编译器编译成了runtime包下的函数</p><table><thead><tr><th>关键字</th><th>函数</th></tr></thead><tbody><tr><td>go</td><td>newproc</td></tr><tr><td>new</td><td>newobject</td></tr><tr><td>&lt;-        -&gt;</td><td>chansend1，chanrecv1</td></tr></tbody></table></li></ol><h3 id="协程结构体和切换函数"><a href="#协程结构体和切换函数" class="headerlink" title="协程结构体和切换函数"></a>协程结构体和切换函数</h3><pre><code class="go">type g struct {    goid   int64  // 协程id    status uint32 // 协程状态    stack  struct {        lo uintptr // 该协程拥有的栈低位        hi uintptr // 该协程拥有的栈高位    }    sched     gobuf   // 切换时保存的上下文信息    startfunc uintptr // 程序地址}type gobuf struct {    sp uintptr // 栈指针位置    pc uintptr // 运行到的程序位置}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;@[TOC]&lt;/p&gt;
&lt;h1 id=&quot;Golang-Runtime&quot;&gt;&lt;a href=&quot;#Golang-Runtime&quot; class=&quot;headerlink&quot; title=&quot;Golang Runtime&quot;&gt;&lt;/a&gt;Golang Runtime&lt;/h1&gt;&lt;h2 id=&quot;什么是
      
    
    </summary>
    
    
      <category term="编程语言" scheme="https://alexbrucelu.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="GO" scheme="https://alexbrucelu.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/GO/"/>
    
    
      <category term="go" scheme="https://alexbrucelu.github.io/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>ini配置库评析</title>
    <link href="https://alexbrucelu.github.io/2019/12/13/ini%E9%85%8D%E7%BD%AE%E5%BA%93%E8%AF%84%E6%9E%90/"/>
    <id>https://alexbrucelu.github.io/2019/12/13/ini%E9%85%8D%E7%BD%AE%E5%BA%93%E8%AF%84%E6%9E%90/</id>
    <published>2019-12-13T06:12:03.000Z</published>
    <updated>2019-12-13T06:12:03.613Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>cuda多版本切换可能会出现的问题</title>
    <link href="https://alexbrucelu.github.io/2019/12/11/cuda%E5%A4%9A%E7%89%88%E6%9C%AC%E5%88%87%E6%8D%A2%E5%8F%AF%E8%83%BD%E4%BC%9A%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>https://alexbrucelu.github.io/2019/12/11/cuda%E5%A4%9A%E7%89%88%E6%9C%AC%E5%88%87%E6%8D%A2%E5%8F%AF%E8%83%BD%E4%BC%9A%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98/</id>
    <published>2019-12-11T03:45:00.000Z</published>
    <updated>2019-12-11T06:07:06.787Z</updated>
    
    <content type="html"><![CDATA[<p>@[TOC]</p><h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><h3 id="1-找不到libcuda-so-1"><a href="#1-找不到libcuda-so-1" class="headerlink" title="1. 找不到libcuda.so.1"></a>1. 找不到libcuda.so.1</h3><blockquote><p>error while loading shared libraries: libcuda.so.1: cannot open shared object file: No such file or director</p></blockquote><p>solution：</p><pre><code class="bash">find / -name libcuda.so.1 #寻找该动态库的位置# Ubuntu 下一般会在/usr/lib/x86_64-linux-gnu/libcuda.so.1# 添加路径sudo echo &#39;/usr/lib/x86_64-linux-gnu/libcuda.so.1&#39; &gt;&gt; /etc/ld.so.conf.d/cuda.confsudo ldconfig</code></pre><h3 id="2-不同版本之间的切换"><a href="#2-不同版本之间的切换" class="headerlink" title="2. 不同版本之间的切换"></a>2. 不同版本之间的切换</h3><blockquote><p>​    fatal error: cuda.h: No such file or directory</p><p><strong><font color=red>可能是要切换版本的环境变量没有添加，所以首先添加环境变量</font></strong></p></blockquote><p>solution：</p><pre><code class="bash">#添加环境变量 export PATH=/usr/local/cuda-8.0/bin:/usr/local/cuda-10.0/bin:/usr/local/cuda/bin:$PATHexport LD_LIBRARY_PATH=/usr/local/cuda/lib64/:/usr/local/cuda-8.0/lib64/:/usr/local/cuda-10.0/lib64/:$LD_LIBRARY_PATH#在切换cuda版本时rm -rf /usr/local/cuda#删除之前创建的软链接sudo ln -s /usr/local/cuda-8.0/ /usr/local/cuda/nvcc --version #查看当前 cuda 版本nvcc: NVIDIA (R) Cuda compiler driverCopyright (c) 2005-2016 NVIDIA CorporationBuilt on Mon_Jan_23_12:24:11_CST_2017Cuda compilation tools, release 8.0, V8.0.62#cuda8.0 切换到 cuda9.0 rm -rf /usr/local/cudasudo ln -s /usr/local/cuda-9.0/ /usr/local/cuda/nvcc --version</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;@[TOC]&lt;/p&gt;
&lt;h2 id=&quot;Q-amp-A&quot;&gt;&lt;a href=&quot;#Q-amp-A&quot; class=&quot;headerlink&quot; title=&quot;Q&amp;amp;A&quot;&gt;&lt;/a&gt;Q&amp;amp;A&lt;/h2&gt;&lt;h3 id=&quot;1-找不到libcuda-so-1&quot;&gt;&lt;a href=&quot;#1-
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://alexbrucelu.github.io/categories/Linux/"/>
    
      <category term="NVIDIA" scheme="https://alexbrucelu.github.io/categories/Linux/NVIDIA/"/>
    
    
      <category term="CUDA" scheme="https://alexbrucelu.github.io/tags/CUDA/"/>
    
  </entry>
  
  <entry>
    <title>程序员的自我修养--注重时效的哲学</title>
    <link href="https://alexbrucelu.github.io/2019/12/10/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB01/"/>
    <id>https://alexbrucelu.github.io/2019/12/10/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB01/</id>
    <published>2019-12-10T08:25:56.000Z</published>
    <updated>2019-12-10T08:49:54.795Z</updated>
    
    <content type="html"><![CDATA[<p>@[TOC]</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;@[TOC]&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="阅读" scheme="https://alexbrucelu.github.io/categories/%E9%98%85%E8%AF%BB/"/>
    
      <category term="编程" scheme="https://alexbrucelu.github.io/categories/%E9%98%85%E8%AF%BB/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="编程" scheme="https://alexbrucelu.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>git commit 规范</title>
    <link href="https://alexbrucelu.github.io/2019/12/10/git_commit%E8%A7%84%E8%8C%83/"/>
    <id>https://alexbrucelu.github.io/2019/12/10/git_commit%E8%A7%84%E8%8C%83/</id>
    <published>2019-12-10T05:29:36.000Z</published>
    <updated>2019-12-10T05:44:51.816Z</updated>
    
    <content type="html"><![CDATA[<p>@[TOC]</p><h1 id="Git-commit-message-规范"><a href="#Git-commit-message-规范" class="headerlink" title="Git commit message 规范"></a>Git commit message 规范</h1><p><img src="../img/16b.jepg" alt="img"></p><blockquote><p>git是现在市面上最流行的版本控制工具，书写良好的commit message能大大提高代码维护的效率。但是在日常开发中由于缺少对于commit message的约束，导致填写内容随意、质量参差不齐，可读性低亦难以维护。在项目中引入commit message规范已是迫在眉睫。</p></blockquote><h2 id="用什么规范？"><a href="#用什么规范？" class="headerlink" title="用什么规范？"></a>用什么规范？</h2><p>现在市面上比较流行的方案是<code>约定式提交规范</code>（<code>Conventional Commits</code>），它受到了<code>Angular提交准则</code>的启发，并在很大程度上以其为依据。<code>约定式提交规范</code>是一种基于提交消息的轻量级约定。 它提供了一组用于创建清晰的提交历史的简单规则；这使得编写基于规范的自动化工具变得更容易。这个约定与<code>SemVer</code>相吻合，在提交信息中描述新特性、bug 修复和破坏性变更。它的 message 格式如下:</p><pre><code>&lt;类型&gt;[可选的作用域]: &lt;描述&gt;[可选的正文][可选的脚注]复制代码</code></pre><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="1-全局安装commitizen-amp-cz-conventional-changelog"><a href="#1-全局安装commitizen-amp-cz-conventional-changelog" class="headerlink" title="1. 全局安装commitizen &amp; cz-conventional-changelog"></a>1. 全局安装commitizen &amp; cz-conventional-changelog</h3><p><code>commitizen</code>是一个撰写合格<code>commit message</code>的工具，用于代替<code>git commit</code> 指令，而<code>cz-conventional-changelog</code>适配器提供<a href="https://github.com/conventional-changelog/conventional-changelog" target="_blank" rel="noopener">conventional-changelog</a>标准（约定式提交标准）。基于不同需求，也可以使用不同适配器。</p><pre><code>npm install -g commitizen cz-conventional-changelogecho &#39;{ &quot;path&quot;: &quot;cz-conventional-changelog&quot; }&#39; &gt; ~/.czrc复制代码</code></pre><p>安装完毕后，可直接使用<code>git cz</code>来取代<code>git commit</code>。</p><p>全局模式下，需要 <code>~/.czrc</code> 配置文件, 为<code>commitizen</code>指定<code>Adapter</code>。</p><h3 id="2-项目内安装commitlint-amp-husky"><a href="#2-项目内安装commitlint-amp-husky" class="headerlink" title="2. 项目内安装commitlint &amp; husky"></a>2. 项目内安装commitlint &amp; husky</h3><p><code>commitlint</code>负责用于对<code>commit message</code>进行格式校验，<code>husky</code>负责提供更易用的<code>git hook</code>。</p><pre><code>Use npmnpm i -D husky @commitlint/config-conventional @commitlint/cli复制代码Use yarnyarn add husky @commitlint/config-conventional @commitlint/cli -D复制代码</code></pre><p><code>commitlint</code>只能做格式规范，无法触及内容。对于内容质量的把控只能靠我们自己。</p><h3 id="3-添加相应配置"><a href="#3-添加相应配置" class="headerlink" title="3. 添加相应配置"></a>3. 添加相应配置</h3><p>创建<code>commitlint.config.js</code></p><pre><code># In the same path as package.jsonecho &#39;module.exports = {extends: [&quot;@commitlint/config-conventional&quot;]};&#39; &gt; ./commitlint.config.js复制代码</code></pre><p>引入<code>husky</code></p><pre><code># package.json...,&quot;husky&quot;: {    &quot;hooks&quot;: {      &quot;commit-msg&quot;: &quot;commitlint -e $GIT_PARAMS&quot;    }}复制代码</code></pre><h3 id="4-使用"><a href="#4-使用" class="headerlink" title="4. 使用"></a>4. 使用</h3><p>执行<code>git cz</code>进入interactive模式，根据提示依次填写</p><pre><code>1.Select the type of change that you&#39;re committing 选择改动类型 (&lt;type&gt;)2.What is the scope of this change (e.g. component or file name)? 填写改动范围 (&lt;scope&gt;)3.Write a short, imperative tense description of the change: 写一个精简的描述 (&lt;subject&gt;)4.Provide a longer description of the change: (press enter to skip) 对于改动写一段长描述 (&lt;body&gt;)5.Are there any breaking changes? (y/n) 是破坏性修改吗？默认n (&lt;footer&gt;)6.Does this change affect any openreve issues? (y/n) 改动修复了哪个问题？默认n (&lt;footer&gt;)复制代码</code></pre><p>生成的commit message格式如下：</p><pre><code>&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;&lt;BLANK LINE&gt;&lt;body&gt;&lt;BLANK LINE&gt;&lt;footer&gt;复制代码</code></pre><p>填写完毕后，<code>husky</code>会调用<code>commitlint</code>对message进行格式校验，默认规定<code>type</code>及<code>subject</code>为必填项。</p><p>任何<code>git commit</code>指令的<code>option</code>都能用在 <code>git cz</code>指令上, 例如<code>git cz -a</code></p><h2 id="Commit-message规范在rrd-fe落地使用情况"><a href="#Commit-message规范在rrd-fe落地使用情况" class="headerlink" title="Commit message规范在rrd-fe落地使用情况"></a>Commit message规范在rrd-fe落地使用情况</h2><p>针对团队目前使用的情况，我们讨论后拟定了<code>commit message</code>每一部分的填写规则。</p><h3 id="1-type"><a href="#1-type" class="headerlink" title="1. type"></a>1. type</h3><p><code>type</code>为必填项，用于指定commit的类型，约定了<code>feat</code>、<code>fix</code>两个<code>主要type</code>，以及docs、style、build、refactor、revert五个<code>特殊type</code>，<code>其余type</code>暂不使用。</p><pre><code># 主要typefeat:     增加新功能fix:      修复bug# 特殊typedocs:     只改动了文档相关的内容style:    不影响代码含义的改动，例如去掉空格、改变缩进、增删分号build:    构造工具的或者外部依赖的改动，例如webpack，npmrefactor: 代码重构时使用revert:   执行git revert打印的message# 暂不使用typetest:     添加测试或者修改现有测试perf:     提高性能的改动ci:       与CI（持续集成服务）有关的改动chore:    不修改src或者test的其余修改，例如构建过程或辅助工具的变动复制代码</code></pre><p>当一次改动包括<code>主要type</code>与<code>特殊type</code>时，统一采用<code>主要type</code>。</p><h3 id="2-scope"><a href="#2-scope" class="headerlink" title="2. scope"></a>2. scope</h3><p><code>scope</code>也为必填项，用于描述改动的范围，格式为项目名/模块名，例如： <code>node-pc/common</code> <code>rrd-h5/activity</code>，而<code>we-sdk</code>不需指定模块名。如果一次commit修改多个模块，建议拆分成多次commit，以便更好追踪和维护。</p><h3 id="3-body"><a href="#3-body" class="headerlink" title="3. body"></a>3. body</h3><p><code>body</code>填写详细描述，主要描述<code>改动之前的情况</code>及<code>修改动机</code>，对于小的修改不作要求，但是重大需求、更新等必须添加body来作说明。</p><h3 id="4-break-changes"><a href="#4-break-changes" class="headerlink" title="4. break changes"></a>4. break changes</h3><p><code>break changes</code>指明是否产生了破坏性修改，涉及break changes的改动必须指明该项，类似版本升级、接口参数减少、接口删除、迁移等。</p><h3 id="5-affect-issues"><a href="#5-affect-issues" class="headerlink" title="5. affect issues"></a>5. affect issues</h3><p><code>affect issues</code>指明是否影响了某个问题。例如我们使用jira时，我们在<code>commit message</code>中可以填写其影响的<code>JIRA_ID</code>，若要开启该功能需要先打通<code>jira</code>与<code>gitlab</code>。参考文档：<a href="https://docs.gitlab.com/ee/user/project/integrations/jira.html" target="_blank" rel="noopener">docs.gitlab.com/ee/user/pro…</a></p><p>填写方式例如：</p><pre><code>re #JIRA_IDfix #JIRA_ID复制代码</code></pre><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><ul><li><p>完整的commit message示例</p><p><img src="../img/16b7.jepg" alt="img"></p></li><li><p>相应的git log</p><p><img src="../img/16b73.jepg" alt="img"></p></li></ul><h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><p><a href="https://www.conventionalcommits.org/zh/v1.0.0-beta.3/" target="_blank" rel="noopener">conventional commits</a> <code>必读</code> 介绍约定式提交标准。</p><p><a href="https://github.com/angular/angular/blob/22b96b9/CONTRIBUTING.md#-commit-message-guidelines" target="_blank" rel="noopener">Angular规范</a> <code>必读</code> 介绍Angular标准每个部分该写什么、该怎么写。</p><p><a href="https://github.com/conventional-changelog/commitlint/tree/master/%40commitlint/config-conventional#type-enum" target="_blank" rel="noopener">@commitlint/config-conventional</a> <code>必读</code> 介绍commitlint的校验规则config-conventional，以及一些常见passes/fails情况。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;@[TOC]&lt;/p&gt;
&lt;h1 id=&quot;Git-commit-message-规范&quot;&gt;&lt;a href=&quot;#Git-commit-message-规范&quot; class=&quot;headerlink&quot; title=&quot;Git commit message 规范&quot;&gt;&lt;/a&gt;Git commi
      
    
    </summary>
    
    
      <category term="工具" scheme="https://alexbrucelu.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="git" scheme="https://alexbrucelu.github.io/categories/%E5%B7%A5%E5%85%B7/git/"/>
    
    
      <category term="git" scheme="https://alexbrucelu.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>毒丸计划：防止恶意收购</title>
    <link href="https://alexbrucelu.github.io/2019/12/10/%E6%AF%92%E4%B8%B8%E8%AE%A1%E5%88%92/"/>
    <id>https://alexbrucelu.github.io/2019/12/10/%E6%AF%92%E4%B8%B8%E8%AE%A1%E5%88%92/</id>
    <published>2019-12-10T02:25:17.000Z</published>
    <updated>2019-12-10T02:25:36.844Z</updated>
    
    <content type="html"><![CDATA[<p>@[TOC]</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;@[TOC]&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="阅读" scheme="https://alexbrucelu.github.io/categories/%E9%98%85%E8%AF%BB/"/>
    
      <category term="金融" scheme="https://alexbrucelu.github.io/categories/%E9%98%85%E8%AF%BB/%E9%87%91%E8%9E%8D/"/>
    
    
      <category term="金融" scheme="https://alexbrucelu.github.io/tags/%E9%87%91%E8%9E%8D/"/>
    
  </entry>
  
  <entry>
    <title>杠杆收购：华尔街黄金游戏</title>
    <link href="https://alexbrucelu.github.io/2019/12/10/%E6%9D%A0%E6%9D%86%E6%94%B6%E8%B4%AD/"/>
    <id>https://alexbrucelu.github.io/2019/12/10/%E6%9D%A0%E6%9D%86%E6%94%B6%E8%B4%AD/</id>
    <published>2019-12-10T02:23:43.000Z</published>
    <updated>2019-12-10T02:25:39.748Z</updated>
    
    <content type="html"><![CDATA[<p>@[TOC]</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;@[TOC]&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="阅读" scheme="https://alexbrucelu.github.io/categories/%E9%98%85%E8%AF%BB/"/>
    
      <category term="金融" scheme="https://alexbrucelu.github.io/categories/%E9%98%85%E8%AF%BB/%E9%87%91%E8%9E%8D/"/>
    
    
      <category term="金融" scheme="https://alexbrucelu.github.io/tags/%E9%87%91%E8%9E%8D/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu 16.04 安装 CUDA</title>
    <link href="https://alexbrucelu.github.io/2019/12/09/Ubuntu_16.04%E5%AE%89%E8%A3%85cuda%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%AC/"/>
    <id>https://alexbrucelu.github.io/2019/12/09/Ubuntu_16.04%E5%AE%89%E8%A3%85cuda%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%AC/</id>
    <published>2019-12-09T11:05:23.000Z</published>
    <updated>2019-12-09T11:42:54.768Z</updated>
    
    <content type="html"><![CDATA[<p>@[TOC]</p><h2 id="一、操作系统"><a href="#一、操作系统" class="headerlink" title="一、操作系统:"></a><strong>一、操作系统:</strong></h2><p>研发工程师默认都是台式机，安装ubuntu16.04操作系统，默认我们安装好cuda和显卡驱动相关软件。如果需要重装系统请联系各属地IT，目前采用USB自动安装的方式，10分钟内可以安装完成</p><h2 id="二、卸载原有的驱动和cuda"><a href="#二、卸载原有的驱动和cuda" class="headerlink" title="二、卸载原有的驱动和cuda:"></a><strong>二、卸载原有的驱动和cuda:</strong></h2><p>sudo su root</p><p>service lightdm stop</p><p>nvidia-uninstall</p><p>apt-get install autoremove –purge nvidia*</p><p>/usr/local/cuda-8.0/bin/uninstall_cuda-8.0.pl(根据版本号有差别，此处以8.0为例子)</p><p>rm -rf /usr/local/cuda-8.0(!!!执行这一步时切勿误操作，否则容易导致系统崩溃)</p><h2 id="三、cuda安装：包含显卡驱动和相关软件包"><a href="#三、cuda安装：包含显卡驱动和相关软件包" class="headerlink" title="三、cuda安装：包含显卡驱动和相关软件包"></a><strong>三、cuda安装：包含显卡驱动和相关软件包</strong></h2><h3 id="1-下载cuda软件"><a href="#1-下载cuda软件" class="headerlink" title="1.下载cuda软件"></a>1.下载cuda软件</h3><p><strong>（8.0版本）</strong> wget <a href="https://developer.nvidia.com/compute/cuda/8.0/Prod2/local_installers/cuda_8.0.61_375.26_linux-run" target="_blank" rel="noopener">https://developer.nvidia.com/compute/cuda/8.0/Prod2/local_installers/cuda_8.0.61_375.26_linux-run</a></p><p><strong>（9.0版本）</strong> wget <a href="https://developer.nvidia.com/compute/cuda/9.0/Prod/local_installers/cuda_9.0.176_384.81_linux-run" target="_blank" rel="noopener">https://developer.nvidia.com/compute/cuda/9.0/Prod/local_installers/cuda_9.0.176_384.81_linux-run</a></p><p><strong>（10.0版本）</strong>wget <a href="https://developer.nvidia.com/compute/cuda/10.0/Prod/local_installers/cuda_10.0.130_410.48_linux" target="_blank" rel="noopener">https://developer.nvidia.com/compute/cuda/10.0/Prod/local_installers/cuda_10.0.130_410.48_linux</a></p><p><strong>（10.1版本）</strong> </p><p>​        wget <a href="http://developer.download.nvidia.com/compute/cuda/10.1/Prod/local_installers/cuda_10.1.243_418.87.00_linux.run" target="_blank" rel="noopener">http://developer.download.nvidia.com/compute/cuda/10.1/Prod/local_installers/cuda_10.1.243_418.87.00_linux.run</a></p><p><strong>（10.2版本）</strong></p><p>​         wget <a href="http://developer.download.nvidia.com/compute/cuda/10.2/Prod/local_installers/cuda_10.2.89_440.33.01_linux.run" target="_blank" rel="noopener">http://developer.download.nvidia.com/compute/cuda/10.2/Prod/local_installers/cuda_10.2.89_440.33.01_linux.run</a></p><h3 id="2-下载NVIDIA显卡驱动"><a href="#2-下载NVIDIA显卡驱动" class="headerlink" title="2.下载NVIDIA显卡驱动"></a>2.下载NVIDIA显卡驱动</h3><p>wget <a href="http://cn.download.nvidia.com/XFree86/Linux-x86_64/440.36/NVIDIA-Linux-x86_64-440.36.run" target="_blank" rel="noopener">http://cn.download.nvidia.com/XFree86/Linux-x86_64/440.36/NVIDIA-Linux-x86_64-440.36.run</a></p><h3 id="3-添加安装程序的可执行权限："><a href="#3-添加安装程序的可执行权限：" class="headerlink" title="3.添加安装程序的可执行权限："></a>3.添加安装程序的可执行权限：</h3><p>chmod +x *.run</p><h3 id="4-禁用默认的nouveau开源显卡驱动："><a href="#4-禁用默认的nouveau开源显卡驱动：" class="headerlink" title="4.禁用默认的nouveau开源显卡驱动："></a>4.禁用默认的nouveau开源显卡驱动：</h3><p>echo “blacklist nouveau” &gt;&gt; /etc/modprobe.d/blacklist-nouveau.conf</p><p>之后建议重启下系统</p><h3 id="5-关闭系统图形界面，显卡驱动安装过程需要在命令行模式下进行（Ctrl-Alt-F2-进入命令行模式）"><a href="#5-关闭系统图形界面，显卡驱动安装过程需要在命令行模式下进行（Ctrl-Alt-F2-进入命令行模式）" class="headerlink" title="5.关闭系统图形界面，显卡驱动安装过程需要在命令行模式下进行（Ctrl + Alt + F2 进入命令行模式）"></a>5.关闭系统图形界面，显卡驱动安装过程需要在命令行模式下进行（Ctrl + Alt + F2 进入命令行模式）</h3><pre><code>sudo su rootservice lightdm stop</code></pre><h3 id="6-安装显卡驱动程序，命令："><a href="#6-安装显卡驱动程序，命令：" class="headerlink" title="6.安装显卡驱动程序，命令："></a>6.安装显卡驱动程序，命令：</h3><pre><code>./NVIDIA-Linux-x86_64-410.78.run -a -s -Z --no-opengl-files</code></pre><h3 id="7-安装CUDA-9-0-驱动（请把cuda安装程序和安装目标目录替换为自己需要安装的对应版本）"><a href="#7-安装CUDA-9-0-驱动（请把cuda安装程序和安装目标目录替换为自己需要安装的对应版本）" class="headerlink" title="7.安装CUDA-9.0 驱动（请把cuda安装程序和安装目标目录替换为自己需要安装的对应版本）"></a>7.安装CUDA-9.0 驱动（请把cuda安装程序和安装目标目录替换为自己需要安装的对应版本）</h3><pre><code>./cuda_9.0.176_384.81_linux.run --no-opengl-libs --toolkit --samples --samplespath=/usr/local/cuda-9.0 -silent</code></pre><h3 id="8-添加安装的环境变量（将红色部分替换为自己安装的对应版本）"><a href="#8-添加安装的环境变量（将红色部分替换为自己安装的对应版本）" class="headerlink" title="8.添加安装的环境变量（将红色部分替换为自己安装的对应版本）:"></a>8.添加安装的环境变量（将红色部分替换为自己安装的对应版本）:</h3><pre><code>echo &#39;export LD_LIBRARY_PATH=/usr/local/cuda/lib:/usr/local/cuda/lib64/:/usr/local/cuda-9.0/lib:/usr/local/cuda-9.0/lib64/:$LD_LIBRARY_PATH&#39; &gt;&gt; /etc/profileecho &#39;export PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/cuda-9.0/bin:/usr/local/cuda/bin:$PATH&#39; &gt;&gt; /etc/profileecho &#39;/usr/local/cuda/lib64&#39; &gt;&gt; /etc/ld.so.conf.d/cuda.confldconfig</code></pre><h3 id="9-下载cudnn"><a href="#9-下载cudnn" class="headerlink" title="9.下载cudnn"></a>9.下载cudnn</h3><ul><li><p><strong>Download cuDNN v7.6.5 (November 18th, 2019), for CUDA 10.2</strong></p><pre><code class="bash"> wget https://developer.nvidia.com/compute/machine-learning/cudnn/secure/7.6.5.32/Production/10.2_20191118/cudnn-10.2-linux-x64-v7.6.5.32.tgz</code></pre></li><li><p><strong>Download cuDNN v7.6.5 (November 5th, 2019), for CUDA 10.1</strong></p><pre><code>wget https://developer.nvidia.com/compute/machine-learning/cudnn/secure/7.6.5.32/Production/10.1_20191031/cudnn-10.1-linux-x64-v7.6.5.32.tgz</code></pre></li><li><p><strong>Download cuDNN v7.6.4 (September 27, 2019), for CUDA 10.0</strong></p><pre><code>wget https://developer.nvidia.com/compute/machine-learning/cudnn/secure/7.6.4.38/Production/10.0_20190923/cudnn-10.0-linux-x64-v7.6.4.38.tgz</code></pre></li><li><p><strong>Download cuDNN v7.6.3 (August 23, 2019), for CUDA 9.0</strong></p><pre><code>wget https://developer.nvidia.com/compute/machine-learning/cudnn/secure/7.6.3.30/Production/9.0_20190822/cudnn-9.0-linux-x64-v7.6.3.30.tgz</code></pre></li><li><p><strong>Download cuDNN v7.1.3 (April 17, 2018), for CUDA 8.0</strong></p><pre><code>wget https://developer.nvidia.com/compute/machine-learning/cudnn/secure/v7.1.3/prod/8.0_20180414/cudnn-8.0-linux-x64-v7.1</code></pre></li></ul><h3 id="10-安装cudnn"><a href="#10-安装cudnn" class="headerlink" title="10.安装cudnn"></a>10.安装cudnn</h3><pre><code>tar xf cudnn-9.0-linux-x64-v7.tarmv cuda/lib64/libcudnn* /usr/local/cuda-9.0/lib64/mv cuda/include/cudnn.h /usr/local/cuda-9.0/include/</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;@[TOC]&lt;/p&gt;
&lt;h2 id=&quot;一、操作系统&quot;&gt;&lt;a href=&quot;#一、操作系统&quot; class=&quot;headerlink&quot; title=&quot;一、操作系统:&quot;&gt;&lt;/a&gt;&lt;strong&gt;一、操作系统:&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;研发工程师默认都是台式机，安装ubuntu
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://alexbrucelu.github.io/categories/Linux/"/>
    
      <category term="NVIDIA" scheme="https://alexbrucelu.github.io/categories/Linux/NVIDIA/"/>
    
    
      <category term="ubuntu" scheme="https://alexbrucelu.github.io/tags/ubuntu/"/>
    
      <category term="CUDA" scheme="https://alexbrucelu.github.io/tags/CUDA/"/>
    
  </entry>
  
  <entry>
    <title>go mod 基础篇</title>
    <link href="https://alexbrucelu.github.io/2019/12/09/go_mod%E5%9F%BA%E7%A1%80%E7%AF%87/"/>
    <id>https://alexbrucelu.github.io/2019/12/09/go_mod%E5%9F%BA%E7%A1%80%E7%AF%87/</id>
    <published>2019-12-09T10:56:13.000Z</published>
    <updated>2019-12-10T05:51:50.348Z</updated>
    
    <content type="html"><![CDATA[<p>@[TOC]</p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><h3 id="开启go-mod"><a href="#开启go-mod" class="headerlink" title="开启go mod"></a>开启go mod</h3><ol><li>把 golang 升级到 1.11（现在1.13 已经发布了，建议使用1.13）</li><li>设置 <code>GO111MODULE</code></li></ol><p>GO111MODULE</p><p><code>GO111MODULE</code> 有三个值：<code>off</code>, <code>on</code>和<code>auto（默认值）</code>。</p><ul><li><code>GO111MODULE=off</code>，go命令行将不会支持module功能，寻找依赖包的方式将会沿用旧版本那种通过vendor目录或者GOPATH模式来查找。</li><li><code>GO111MODULE=on</code>，go命令行会使用modules，而一点也不会去GOPATH目录下查找。</li><li><code>GO111MODULE=auto</code>，默认值，go命令行将会根据当前目录来决定是否启用module功能。这种情况下可以分为两种情形：<ul><li>当前目录在GOPATH/src之外且该目录包含go.mod文件</li><li>当前文件在包含go.mod文件的目录下面。</li></ul></li></ul><blockquote><p>当modules 功能启用时，依赖包的存放位置变更为<code>$GOPATH/pkg</code>，允许同一个package多个版本并存，且多个项目可以共享缓存的 module。</p></blockquote><pre><code class="bash">export GO111MODULE=on</code></pre><h3 id="go-mod常用命令"><a href="#go-mod常用命令" class="headerlink" title="go mod常用命令"></a>go mod常用命令</h3><p>golang 提供了 <code>go mod</code>命令来管理包。</p><p>go mod 有以下命令：</p><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>download</td><td>download modules to local cache(下载依赖包)</td></tr><tr><td>edit</td><td>edit go.mod from tools or scripts（编辑go.mod</td></tr><tr><td>graph</td><td>print module requirement graph (打印模块依赖图)</td></tr><tr><td>init</td><td>initialize new module in current directory（在当前目录初始化mod）</td></tr><tr><td>tidy</td><td>add missing and remove unused modules(拉取缺少的模块，移除不用的模块)</td></tr><tr><td>vendor</td><td>make vendored copy of dependencies(将依赖复制到vendor下)</td></tr><tr><td>verify</td><td>verify dependencies have expected content (验证依赖是否正确）</td></tr><tr><td>why</td><td>explain why packages or modules are needed(解释为什么需要依赖)</td></tr></tbody></table><h2 id="在项目中使用"><a href="#在项目中使用" class="headerlink" title="在项目中使用"></a>在项目中使用</h2><h3 id="示例一：创建一个新项目"><a href="#示例一：创建一个新项目" class="headerlink" title="示例一：创建一个新项目"></a>示例一：创建一个新项目</h3><ol><li>在<code>GOPATH 目录之外</code>新建一个目录，并使用<code>go mod init</code> 初始化生成<code>go.mod</code> 文件</li></ol><pre><code>➜  ~ mkdir hello➜  ~ cd hello➜  hello go mod init hellogo: creating new go.mod: module hello➜  hello lsgo.mod➜  hello cat go.modmodule hellogo 1.12</code></pre><blockquote><p>go.mod文件一旦创建后，它的内容将会被go toolchain全面掌控。go toolchain会在各类命令执行时，比如go get、go build、go mod等修改和维护go.mod文件。</p></blockquote><p>go.mod 提供了<code>module</code>, <code>require</code>、<code>replace</code>和<code>exclude</code> 四个命令</p><ul><li><code>module</code> 语句指定包的名字（路径）</li><li><code>require</code> 语句指定的依赖项模块</li><li><code>replace</code> 语句可以替换依赖项模块</li><li><code>exclude</code> 语句可以忽略依赖项模块</li></ul><ol><li>添加依赖</li></ol><p>新建一个 server.go 文件，写入以下代码：</p><pre><code>package mainimport (    &quot;net/http&quot;    &quot;github.com/labstack/echo&quot;)func main() {    e := echo.New()    e.GET(&quot;/&quot;, func(c echo.Context) error {        return c.String(http.StatusOK, &quot;Hello, World!&quot;)    })    e.Logger.Fatal(e.Start(&quot;:1323&quot;))}</code></pre><p>执行 <code>go run server.go</code> 运行代码会发现 go mod 会自动查找依赖自动下载：</p><pre><code>$ go run server.gogo: finding github.com/labstack/echo v3.3.10+incompatiblego: downloading github.com/labstack/echo v3.3.10+incompatiblego: extracting github.com/labstack/echo v3.3.10+incompatiblego: finding github.com/labstack/gommon/color latestgo: finding github.com/labstack/gommon/log latestgo: finding github.com/labstack/gommon v0.2.8# 此处省略很多行...   ____    __  / __/___/ /  ___ / _// __/ _ \/ _ \/___/\__/_//_/\___/ v3.3.10-devHigh performance, minimalist Go web frameworkhttps://echo.labstack.com____________________________________O/_______                                    O\⇨ http server started on [::]:1323</code></pre><p>现在查看go.mod 内容：</p><pre><code>$ cat go.modmodule hellogo 1.12require (    github.com/labstack/echo v3.3.10+incompatible // indirect    github.com/labstack/gommon v0.2.8 // indirect    github.com/mattn/go-colorable v0.1.1 // indirect    github.com/mattn/go-isatty v0.0.7 // indirect    github.com/valyala/fasttemplate v1.0.0 // indirect    golang.org/x/crypto v0.0.0-20190313024323-a1f597ede03a // indirect)</code></pre><p>go module 安装 package 的原則是先拉最新的 release tag，若无tag则拉最新的commit，详见 <a href="https://github.com/golang/go/wiki/Modules" target="_blank" rel="noopener">Modules官方介绍</a>。 go 会自动生成一个 go.sum 文件来记录 dependency tree：</p><pre><code>$ cat go.sumgithub.com/labstack/echo v3.3.10+incompatible h1:pGRcYk231ExFAyoAjAfD85kQzRJCRI8bbnE7CX5OEgg=github.com/labstack/echo v3.3.10+incompatible/go.mod h1:0INS7j/VjnFxD4E2wkz67b8cVwCLbBmJyDaka6Cmk1s=github.com/labstack/gommon v0.2.8 h1:JvRqmeZcfrHC5u6uVleB4NxxNbzx6gpbJiQknDbKQu0=github.com/labstack/gommon v0.2.8/go.mod h1:/tj9csK2iPSBvn+3NLM9e52usepMtrd5ilFYA+wQNJ4=github.com/mattn/go-colorable v0.1.1 h1:G1f5SKeVxmagw/IyvzvtZE4Gybcc4Tr1tf7I8z0XgOg=github.com/mattn/go-colorable v0.1.1/go.mod h1:FuOcm+DKB9mbwrcAfNl7/TZVBZ6rcnceauSikq3lYCQ=... 省略很多行</code></pre><ol><li>再次执行脚本 <code>go run server.go</code> 发现跳过了检查并安装依赖的步骤。</li><li>可以使用命令 <code>go list -m -u all</code> 来检查可以升级的package，使用<code>go get -u need-upgrade-package</code> 升级后会将新的依赖版本更新到go.mod<ul><li>也可以使用 <code>go get -u</code> 升级所有依赖</li></ul></li></ol><h4 id="go-get-升级"><a href="#go-get-升级" class="headerlink" title="go get 升级"></a>go get 升级</h4><ul><li>运行 go get -u 将会升级到最新的次要版本或者修订版本(x.y.z, z是修订版本号， y是次要版本号)</li><li>运行 go get -u=patch 将会升级到最新的修订版本</li><li>运行 go get package@version 将会升级到指定的版本号version</li><li>运行go get如果有版本的更改，那么go.mod文件也会更改</li></ul><h3 id="示例二：改造现有项目-helloword"><a href="#示例二：改造现有项目-helloword" class="headerlink" title="示例二：改造现有项目(helloword)"></a>示例二：改造现有项目(helloword)</h3><p>项目目录为：</p><pre><code>$ tree.├── api│   └── apis.go└── server.go1 directory, 2 files</code></pre><p>server.go 源码为：</p><pre><code>package mainimport (    api &quot;./api&quot;  // 这里使用的是相对路径    &quot;github.com/labstack/echo&quot;)func main() {    e := echo.New()    e.GET(&quot;/&quot;, api.HelloWorld)    e.Logger.Fatal(e.Start(&quot;:1323&quot;))}</code></pre><p>api/apis.go 源码为：</p><pre><code>package apiimport (    &quot;net/http&quot;    &quot;github.com/labstack/echo&quot;)func HelloWorld(c echo.Context) error {    return c.JSON(http.StatusOK, &quot;hello world&quot;)}</code></pre><ol><li>使用 <code>go mod init ***</code> 初始化go.mod</li></ol><pre><code>$ go mod init helloworldgo: creating new go.mod: module helloworld</code></pre><ol><li>运行 <code>go run server.go</code></li></ol><pre><code>go: finding github.com/labstack/gommon/color latestgo: finding github.com/labstack/gommon/log latestgo: finding golang.org/x/crypto/acme/autocert latestgo: finding golang.org/x/crypto/acme latestgo: finding golang.org/x/crypto latestbuild command-line-arguments: cannot find module for path _/home/gs/helloworld/api</code></pre><p>首先还是会查找并下载安装依赖，然后运行脚本 <code>server.go</code>，这里会抛出一个错误：</p><pre><code>build command-line-arguments: cannot find module for path _/home/gs/helloworld/api</code></pre><p>但是<code>go.mod</code> 已经更新：</p><pre><code>$ cat go.modmodule helloworldgo 1.12require (        github.com/labstack/echo v3.3.10+incompatible // indirect        github.com/labstack/gommon v0.2.8 // indirect        github.com/mattn/go-colorable v0.1.1 // indirect        github.com/mattn/go-isatty v0.0.7 // indirect        github.com/valyala/fasttemplate v1.0.0 // indirect        golang.org/x/crypto v0.0.0-20190313024323-a1f597ede03a // indirect)</code></pre><h4 id="那为什么会抛出这个错误呢？"><a href="#那为什么会抛出这个错误呢？" class="headerlink" title="那为什么会抛出这个错误呢？"></a>那为什么会抛出这个错误呢？</h4><p>这是因为 server.go 中使用 internal package 的方法跟以前已经不同了，由于 go.mod会扫描同工作目录下所有 package 并且<code>变更引入方法</code>，必须将 helloworld当成路径的前缀，也就是需要写成 import helloworld/api，以往 GOPATH/dep 模式允许的 import ./api 已经失效，详情可以查看这个 <a href="https://github.com/golang/go/issues/26645" target="_blank" rel="noopener">issue</a>。</p><ol><li>更新旧的package import 方式</li></ol><p>所以server.go 需要改写成：</p><pre><code>package mainimport (    api &quot;helloworld/api&quot;  // 这是更新后的引入方法    &quot;github.com/labstack/echo&quot;)func main() {    e := echo.New()    e.GET(&quot;/&quot;, api.HelloWorld)    e.Logger.Fatal(e.Start(&quot;:1323&quot;))}</code></pre><blockquote><p><code>一个小坑</code>：开始在golang1.11 下使用go mod 遇到过 <code>go build github.com/valyala/fasttemplate: module requires go 1.12</code> <a href="https://github.com/golang/go/issues/27565" target="_blank" rel="noopener">这种错误</a>，遇到类似这种需要升级到1.12 的问题，直接升级golang1.12 就好了。幸亏是在1.12 发布后才尝试的<code>go mod</code> 🤷‍♂️</p></blockquote><ol><li>到这里就和新创建一个项目没什么区别了</li></ol><h4 id="使用replace替换无法直接获取的package"><a href="#使用replace替换无法直接获取的package" class="headerlink" title="使用replace替换无法直接获取的package"></a>使用replace替换无法直接获取的package</h4><p>由于某些已知的原因，并不是所有的package都能成功下载，比如：<code>golang.org</code>下的包。</p><p>modules 可以通过在 go.mod 文件中使用 replace 指令替换成github上对应的库，比如：</p><pre><code>replace (    golang.org/x/crypto v0.0.0-20190313024323-a1f597ede03a =&gt; github.com/golang/crypto v0.0.0-20190313024323-a1f597ede03a)</code></pre><p>或者</p><pre><code>replace golang.org/x/crypto v0.0.0-20190313024323-a1f597ede03a =&gt; github.com/golang/crypto v0.0.0-20190313024323-a1f597ede03a</code></pre><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://github.com/golang/go/wiki/Modules" target="_blank" rel="noopener">Modules官方介绍</a></li><li><a href="https://www.lightblue.asia/golang-1-11-new-festures-modules/?doing_wp_cron=1552464864.6369309425354003906250" target="_blank" rel="noopener">Golang 1.11 新功能介紹 – Modules</a></li><li><a href="https://talks.godoc.org/github.com/myitcv/talks/2018-08-15-glug-modules/main.slide#1" target="_blank" rel="noopener">What are Go modules and how do I use them?</a></li><li><a href="https://github.com/golang/go/issues/27565" target="_blank" rel="noopener">go mod doesn’t work for github.com/gomarkdown/markdown/html</a></li><li><a href="https://www.cnblogs.com/apocelipes/p/10295096.html" target="_blank" rel="noopener">再探go modules：使用与细节</a></li><li><a href="https://tonybai.com/2018/07/15/hello-go-module/" target="_blank" rel="noopener">初窥Go module</a></li></ul><h4 id="References"><a href="#References" class="headerlink" title="References"></a>References</h4><p>[1] Modules官方介绍: <a href="https://github.com/golang/go/wiki/Modules" target="_blank" rel="noopener">https://github.com/golang/go/…</a><br>[2] issue: <a href="https://github.com/golang/go/issues/26645" target="_blank" rel="noopener">https://github.com/golang/go/…</a><br>[3] 这种错误: <a href="https://github.com/golang/go/issues/27565" target="_blank" rel="noopener">https://github.com/golang/go/…</a><br>[4] Modules官方介绍: <a href="https://github.com/golang/go/wiki/Modules" target="_blank" rel="noopener">https://github.com/golang/go/…</a><br>[5] Golang 1.11 新功能介紹 – Modules: <a href="https://www.lightblue.asia/golang-1-11-new-festures-modules/?doing_wp_cron=1552464864.6369309425354003906250" target="_blank" rel="noopener">https://www.lightblue.asia/go…</a><br>[6] What are Go modules and how do I use them?: <a href="https://talks.godoc.org/github.com/myitcv/talks/2018-08-15-glug-modules/main.slide#1" target="_blank" rel="noopener">https://talks.godoc.org/githu…</a><br>[7] go mod doesn’t work for github.com/gomarkdown/markdown/html : <a href="https://github.com/golang/go/issues/27565" target="_blank" rel="noopener">https://github.com/golang/go/…</a><br>[8] 再探go modules：使用与细节: <a href="https://www.cnblogs.com/apocelipes/p/10295096.html" target="_blank" rel="noopener">https://www.cnblogs.com/apoce…</a><br>[9] 初窥Go module: <a href="https://tonybai.com/2018/07/15/hello-go-module/" target="_blank" rel="noopener">https://tonybai.com/2018/07/1…</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;@[TOC]&lt;/p&gt;
&lt;h2 id=&quot;准备&quot;&gt;&lt;a href=&quot;#准备&quot; class=&quot;headerlink&quot; title=&quot;准备&quot;&gt;&lt;/a&gt;准备&lt;/h2&gt;&lt;h3 id=&quot;开启go-mod&quot;&gt;&lt;a href=&quot;#开启go-mod&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
    
      <category term="编程语言" scheme="https://alexbrucelu.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="GO" scheme="https://alexbrucelu.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/GO/"/>
    
    
      <category term="go" scheme="https://alexbrucelu.github.io/tags/go/"/>
    
      <category term="go mod" scheme="https://alexbrucelu.github.io/tags/go-mod/"/>
    
  </entry>
  
  <entry>
    <title>git 新建仓库，添加远程分之到本地</title>
    <link href="https://alexbrucelu.github.io/2019/12/09/git%E6%96%B0%E5%BB%BA%E4%BB%93%E5%BA%93/"/>
    <id>https://alexbrucelu.github.io/2019/12/09/git%E6%96%B0%E5%BB%BA%E4%BB%93%E5%BA%93/</id>
    <published>2019-12-09T10:40:43.000Z</published>
    <updated>2019-12-16T11:44:41.406Z</updated>
    
    <content type="html"><![CDATA[<p>@[TOC]</p><h3 id="本地不存在仓库拉取远程分之"><a href="#本地不存在仓库拉取远程分之" class="headerlink" title="本地不存在仓库拉取远程分之"></a>本地不存在仓库拉取远程分之</h3><pre><code class="bash">$ echo &quot;# gin-web&quot; &gt;&gt; README.md$ git init$ git add README.md$ git commit -m &quot;first commit&quot;$ git remote add origin https://github.com/AlexBruceLu/gin-web.git$ git push -u origin master</code></pre><h3 id="本地已有的仓库添加到远程"><a href="#本地已有的仓库添加到远程" class="headerlink" title="本地已有的仓库添加到远程"></a>本地已有的仓库添加到远程</h3><pre><code class="bash">$ git remote add origin https://github.com/AlexBruceLu/gin-web.git$ git push -u origin master</code></pre><h3 id="git本地分支和远程分支改名"><a href="#git本地分支和远程分支改名" class="headerlink" title="git本地分支和远程分支改名"></a>git本地分支和远程分支改名</h3><pre><code class="bash">#1 将本地分支进行改名$ git branch -m old_branch new_branch#2 将远程分支的老分支删除$ git push origin :old_branch#3 将改名后的分支push到远程$ git push origin new_branch</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;@[TOC]&lt;/p&gt;
&lt;h3 id=&quot;本地不存在仓库拉取远程分之&quot;&gt;&lt;a href=&quot;#本地不存在仓库拉取远程分之&quot; class=&quot;headerlink&quot; title=&quot;本地不存在仓库拉取远程分之&quot;&gt;&lt;/a&gt;本地不存在仓库拉取远程分之&lt;/h3&gt;&lt;pre&gt;&lt;code clas
      
    
    </summary>
    
    
      <category term="工具" scheme="https://alexbrucelu.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="git" scheme="https://alexbrucelu.github.io/categories/%E5%B7%A5%E5%85%B7/git/"/>
    
    
      <category term="git" scheme="https://alexbrucelu.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu 16.04 升级最新版本 nvidia-docker</title>
    <link href="https://alexbrucelu.github.io/2019/12/09/Ubuntu16.04%E5%8D%87%E7%BA%A7%E6%9C%80%E6%96%B0%E7%89%88%E6%9C%ACnvidia-docker/"/>
    <id>https://alexbrucelu.github.io/2019/12/09/Ubuntu16.04%E5%8D%87%E7%BA%A7%E6%9C%80%E6%96%B0%E7%89%88%E6%9C%ACnvidia-docker/</id>
    <published>2019-12-09T09:18:48.000Z</published>
    <updated>2019-12-09T10:38:30.623Z</updated>
    
    <content type="html"><![CDATA[<p>@[TOC]</p><h3 id="Uninstall-old-versions"><a href="#Uninstall-old-versions" class="headerlink" title="Uninstall old versions"></a>Uninstall old versions</h3><p>Older versions of Docker were called <code>docker</code>, <code>docker.io</code>, or <code>docker-engine</code>. If these are installed, uninstall them:</p><pre><code>$ sudo apt-get remove docker docker-engine docker.io containerd runc</code></pre><p>It’s OK if <code>apt-get</code> reports that none of these packages are installed.</p><p>The contents of <code>/var/lib/docker/</code>, including images, containers, volumes, and networks, are preserved. The Docker Engine - Community package is now called <code>docker-ce</code>.</p><h3 id="Supported-storage-drivers"><a href="#Supported-storage-drivers" class="headerlink" title="Supported storage drivers"></a>Supported storage drivers</h3><p>Docker Engine - Community on Ubuntu supports <code>overlay2</code>, <code>aufs</code> and <code>btrfs</code> storage drivers.</p><blockquote><p><strong>Note</strong>: In Docker Engine - Enterprise, <code>btrfs</code> is only supported on SLES. See the documentation on <a href="https://docs.docker.com/engine/userguide/storagedriver/btrfs-driver/" target="_blank" rel="noopener">btrfs</a> for more details.</p></blockquote><p>For new installations on version 4 and higher of the Linux kernel, <code>overlay2</code> is supported and preferred over <code>aufs</code>. Docker Engine - Community uses the <code>overlay2</code> storage driver by default. If you need to use <code>aufs</code> instead, you need to configure it manually. See <a href="https://docs.docker.com/engine/userguide/storagedriver/aufs-driver/" target="_blank" rel="noopener">aufs</a></p><h3 id="Install-Docker-Engine-Community"><a href="#Install-Docker-Engine-Community" class="headerlink" title="Install Docker Engine - Community"></a>Install Docker Engine - Community</h3><p>You can install Docker Engine - Community in different ways, depending on your needs:</p><ul><li>Most users <a href="https://docs.docker.com/install/linux/docker-ce/ubuntu/#install-using-the-repository" target="_blank" rel="noopener">set up Docker’s repositories</a> and install from them, for ease of installation and upgrade tasks. This is the recommended approach.</li><li>Some users download the DEB package and <a href="https://docs.docker.com/install/linux/docker-ce/ubuntu/#install-from-a-package" target="_blank" rel="noopener">install it manually</a> and manage upgrades completely manually. This is useful in situations such as installing Docker on air-gapped systems with no access to the internet.</li><li>In testing and development environments, some users choose to use automated <a href="https://docs.docker.com/install/linux/docker-ce/ubuntu/#install-using-the-convenience-script" target="_blank" rel="noopener">convenience scripts</a> to install Docker.</li></ul><h3 id="Install-using-the-repository"><a href="#Install-using-the-repository" class="headerlink" title="Install using the repository"></a>Install using the repository</h3><p>Before you install Docker Engine - Community for the first time on a new host machine, you need to set up the Docker repository. Afterward, you can install and update Docker from the repository.</p><h4 id="SET-UP-THE-REPOSITORY"><a href="#SET-UP-THE-REPOSITORY" class="headerlink" title="SET UP THE REPOSITORY"></a>SET UP THE REPOSITORY</h4><ol><li><p>Update the <code>apt</code> package index:</p><pre><code>$ sudo apt-get update</code></pre></li><li><p>Install packages to allow <code>apt</code> to use a repository over HTTPS:</p><pre><code>$ sudo apt-get install \    apt-transport-https \    ca-certificates \    curl \    gnupg-agent \    software-properties-common</code></pre></li><li><p>Add Docker’s official GPG key:</p><pre><code>$ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -</code></pre><p>Verify that you now have the key with the fingerprint <code>9DC8 5822 9FC7 DD38 854A E2D8 8D81 803C 0EBF CD88</code>, by searching for the last 8 characters of the fingerprint.</p><pre><code>$ sudo apt-key fingerprint 0EBFCD88pub   rsa4096 2017-02-22 [SCEA]      9DC8 5822 9FC7 DD38 854A  E2D8 8D81 803C 0EBF CD88uid           [ unknown] Docker Release (CE deb) &lt;docker@docker.com&gt;sub   rsa4096 2017-02-22 [S]</code></pre></li><li><p>Use the following command to set up the <strong>stable</strong> repository. To add the <strong>nightly</strong> or <strong>test</strong> repository, add the word <code>nightly</code> or <code>test</code> (or both) after the word <code>stable</code> in the commands below. <a href="https://docs.docker.com/install/" target="_blank" rel="noopener">Learn about <strong>nightly</strong> and <strong>test</strong> channels</a>.</p><blockquote><p><strong>Note</strong>: The <code>lsb_release -cs</code> sub-command below returns the name of your Ubuntu distribution, such as <code>xenial</code>. Sometimes, in a distribution like Linux Mint, you might need to change <code>$(lsb_release -cs)</code> to your parent Ubuntu distribution. For example, if you are using <code>Linux Mint Tessa</code>, you could use <code>bionic</code>. Docker does not offer any guarantees on untested and unsupported Ubuntu distributions.</p></blockquote></li></ol><ul><li><ul><li>x86_64 / amd64</li><li>armhf</li><li>arm64</li><li>ppc64le (IBM Power)</li><li>s390x (IBM Z)</li></ul></li></ul><pre><code>   $ sudo add-apt-repository \      &quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu \      $(lsb_release -cs) \      stable&quot;</code></pre><h4 id="INSTALL-DOCKER-ENGINE-COMMUNITY"><a href="#INSTALL-DOCKER-ENGINE-COMMUNITY" class="headerlink" title="INSTALL DOCKER ENGINE - COMMUNITY"></a>INSTALL DOCKER ENGINE - COMMUNITY</h4><ol><li><p>Update the <code>apt</code> package index.</p><pre><code>$ sudo apt-get update</code></pre></li><li><p>Install the <em>latest version</em> of Docker Engine - Community and containerd, or go to the next step to install a specific version:</p><pre><code>$ sudo apt-get install docker-ce docker-ce-cli containerd.io</code></pre><blockquote><p><strong></strong> Got multiple Docker repositories?</p><p>If you have multiple Docker repositories enabled, installing or updating without specifying a version in the <code>apt-get install</code> or <code>apt-get update</code> command always installs the highest possible version, which may not be appropriate for your stability needs.</p></blockquote></li><li><p>To install a <em>specific version</em> of Docker Engine - Community, list the available versions in the repo, then select and install:</p><p>a. List the versions available in your repo:</p><pre><code>$ apt-cache madison docker-ce  docker-ce | 5:18.09.1~3-0~ubuntu-xenial | https://download.docker.com/linux/ubuntu  xenial/stable amd64 Packages  docker-ce | 5:18.09.0~3-0~ubuntu-xenial | https://download.docker.com/linux/ubuntu  xenial/stable amd64 Packages  docker-ce | 18.06.1~ce~3-0~ubuntu       | https://download.docker.com/linux/ubuntu  xenial/stable amd64 Packages  docker-ce | 18.06.0~ce~3-0~ubuntu       | https://download.docker.com/linux/ubuntu  xenial/stable amd64 Packages  ...</code></pre><p>b. Install a specific version using the version string from the second column, for example, <code>5:18.09.1~3-0~ubuntu-xenial</code>.</p><pre><code>$ sudo apt-get install docker-ce=&lt;VERSION_STRING&gt; docker-ce-cli=&lt;VERSION_STRING&gt; containerd.io</code></pre></li><li><p>Verify that Docker Engine - Community is installed correctly by running the <code>hello-world</code> image.</p><pre><code class="shell">$ sudo docker run hello-world</code></pre></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;@[TOC]&lt;/p&gt;
&lt;h3 id=&quot;Uninstall-old-versions&quot;&gt;&lt;a href=&quot;#Uninstall-old-versions&quot; class=&quot;headerlink&quot; title=&quot;Uninstall old versions&quot;&gt;&lt;/a&gt;Uninst
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://alexbrucelu.github.io/categories/Linux/"/>
    
      <category term="docker" scheme="https://alexbrucelu.github.io/categories/Linux/docker/"/>
    
    
      <category term="ubuntu" scheme="https://alexbrucelu.github.io/tags/ubuntu/"/>
    
      <category term="nvidia-docker" scheme="https://alexbrucelu.github.io/tags/nvidia-docker/"/>
    
  </entry>
  
</feed>
