<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://alexbrucelu.github.io/"/>
  <updated>2019-06-10T08:26:10.332Z</updated>
  <id>https://alexbrucelu.github.io/</id>
  
  <author>
    <name>AlexBruceLu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Go语言interface</title>
    <link href="https://alexbrucelu.github.io/2019/06/10/%E6%B7%B1%E5%BA%A6%E8%A7%A3%E5%AF%86Go%E8%AF%AD%E8%A8%80%E4%B9%8B%E5%85%B3%E4%BA%8E%20interface%20%E7%9A%8410%E4%B8%AA%E9%97%AE%E9%A2%98/"/>
    <id>https://alexbrucelu.github.io/2019/06/10/深度解密Go语言之关于 interface 的10个问题/</id>
    <published>2019-06-10T08:01:02.525Z</published>
    <updated>2019-06-10T08:26:10.332Z</updated>
    
    <content type="html"><![CDATA[<p><strong> Go语言interface：</strong> <excerpt in="" index="" |="" 首页摘要=""></excerpt></p><p>go语言养成记之深度解密Go语言interface</p><a id="more"></a><p>[TOC]</p><p>这次文章依然很长，基本上涵盖了 <code>interface</code> 的方方面面，有例子，有源码分析，有汇编分析，前前后后写了 20 多天。洋洋洒洒，长篇大论，依然有些东西没有涉及到，比如文章里没有写到<code>反射</code>，当然，后面会单独写一篇关于<code>反射</code>的文章，这是后话。</p><p>还是希望看你在看完文章后能有所收获，有任何问题或意见建议，欢迎在文章后面留言。</p><p>这篇文章的架构比较简单，直接抛出 10 个问题，一一解答。</p><h1 id="1-Go-语言与鸭子类型的关系"><a href="#1-Go-语言与鸭子类型的关系" class="headerlink" title="1. Go 语言与鸭子类型的关系"></a>1. Go 语言与鸭子类型的关系</h1><p>先直接来看维基百科里的定义：</p><blockquote><p>If it looks like a duck, swims like a duck, and quacks like a duck, then it probably is a duck.</p></blockquote><p>翻译过来就是：如果某个东西长得像鸭子，像鸭子一样游泳，像鸭子一样嘎嘎叫，那它就可以被看成是一只鸭子。</p><p><code>Duck Typing</code>，鸭子类型，是动态编程语言的一种对象推断策略，它更关注对象能如何被使用，而不是对象的类型本身。Go 语言作为一门静态语言，它通过通过接口的方式完美支持鸭子类型。</p><p>例如，在动态语言 python 中，定义一个这样的函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello_world</span><span class="params">(coder)</span>:</span></span><br><span class="line">    coder.say_hello()</span><br></pre></td></tr></table></figure><p>当调用此函数的时候，可以传入任意类型，只要它实现了 <code>say_hello()</code> 函数就可以。如果没有实现，运行过程中会出现错误。</p><p>而在静态语言如 Java, C++ 中，必须要显示地声明实现了某个接口，之后，才能用在任何需要这个接口的地方。如果你在程序中调用 <code>hello_world</code> 函数，却传入了一个根本就没有实现 <code>say_hello()</code> 的类型，那在编译阶段就不会通过。这也是静态语言比动态语言更安全的原因。</p><p>动态语言和静态语言的差别在此就有所体现。静态语言在编译期间就能发现类型不匹配的错误，不像动态语言，必须要运行到那一行代码才会报错。插一句，这也是我不喜欢用 <code>python</code>的一个原因。当然，静态语言要求程序员在编码阶段就要按照规定来编写程序，为每个变量规定数据类型，这在某种程度上，加大了工作量，也加长了代码量。动态语言则没有这些要求，可以让人更专注在业务上，代码也更短，写起来更快，这一点，写 python 的同学比较清楚。</p><p>Go 语言作为一门现代静态语言，是有后发优势的。它引入了动态语言的便利，同时又会进行静态语言的类型检查，写起来是非常 Happy 的。Go 采用了折中的做法：不要求类型显示地声明实现了某个接口，只要实现了相关的方法即可，编译器就能检测到。</p><p>来看个例子：</p><p>先定义一个接口，和使用此接口作为参数的函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> IGreeting <span class="keyword">interface</span> &#123;</span><br><span class="line">    sayHello()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayHello</span><span class="params">(i IGreeting)</span></span> &#123;</span><br><span class="line">    i.sayHello()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来定义两个结构体：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Go <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g Go)</span> <span class="title">sayHello</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"Hi, I am GO!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> PHP <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p PHP)</span> <span class="title">sayHello</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"Hi, I am PHP!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，在 main 函数里调用 sayHello() 函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    golang := Go&#123;&#125;</span><br><span class="line">    php := PHP&#123;&#125;</span><br><span class="line"></span><br><span class="line">    sayHello(golang)</span><br><span class="line">    sayHello(php)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hi, I am GO!</span><br><span class="line">Hi, I am PHP!</span><br></pre></td></tr></table></figure><p>在 main 函数中，调用调用 sayHello() 函数时，传入了 <code>golang, php</code> 对象，它们并没有显式地声明实现了 IGreeting 类型，只是实现了接口所规定的 sayHello() 函数。实际上，编译器在调用 sayHello() 函数时，会隐式地将 <code>golang, php</code> 对象转换成 IGreeting 类型，这也是静态语言的类型检查功能。</p><p>顺带再提一下动态语言的特点：</p><blockquote><p>变量绑定的类型是不确定的，在运行期间才能确定<br>函数和方法可以接收任何类型的参数，且调用时不检查参数类型<br>不需要实现接口</p></blockquote><p>总结一下，鸭子类型是一种动态语言的风格，在这种风格中，一个对象有效的语义，不是由继承自特定的类或实现特定的接口，而是由它”当前方法和属性的集合”决定。Go 作为一种静态语言，通过接口实现了 <code>鸭子类型</code>，实际上是 Go 的编译器在其中作了隐匿的转换工作。</p><h1 id="2-值接收者和指针接收者的区别"><a href="#2-值接收者和指针接收者的区别" class="headerlink" title="2. 值接收者和指针接收者的区别"></a>2. 值接收者和指针接收者的区别</h1><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>方法能给用户自定义的类型添加新的行为。它和函数的区别在于方法有一个接收者，给一个函数添加一个接收者，那么它就变成了方法。接收者可以是<code>值接收者</code>，也可以是<code>指针接收者</code>。</p><p>在调用方法的时候，值类型既可以调用<code>值接收者</code>的方法，也可以调用<code>指针接收者</code>的方法；指针类型既可以调用<code>指针接收者</code>的方法，也可以调用<code>值接收者</code>的方法。</p><p>也就是说，不管方法的接收者是什么类型，该类型的值和指针都可以调用，不必严格符合接收者的类型。</p><p>来看个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span> <span class="title">howOld</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> p.age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Person)</span> <span class="title">growUp</span><span class="params">()</span></span> &#123;</span><br><span class="line">    p.age += <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// qcrao 是值类型</span></span><br><span class="line">    qcrao := Person&#123;age: <span class="number">18</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 值类型 调用接收者也是值类型的方法</span></span><br><span class="line">    fmt.Println(qcrao.howOld())</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 值类型 调用接收者是指针类型的方法</span></span><br><span class="line">    qcrao.growUp()</span><br><span class="line">    fmt.Println(qcrao.howOld())</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ----------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// stefno 是指针类型</span></span><br><span class="line">    stefno := &amp;Person&#123;age: <span class="number">100</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指针类型 调用接收者是值类型的方法</span></span><br><span class="line">    fmt.Println(stefno.howOld())</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指针类型 调用接收者也是指针类型的方法</span></span><br><span class="line">    stefno.growUp()</span><br><span class="line">    fmt.Println(stefno.howOld())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上例子的输出结果是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">18</span><br><span class="line">19</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td></tr></table></figure><p>调用了 <code>growUp</code> 函数后，不管调用者是值类型还是指针类型，它的 <code>Age</code> 值都改变了。</p><p>实际上，当类型和方法的接收者类型不同时，其实是编译器在背后做了一些工作，用一个表格来呈现：</p><table><thead><tr><th>-</th><th>值接收者</th><th>指针接收者</th></tr></thead><tbody><tr><td>值类型调用者</td><td>方法会使用调用者的一个副本，类似于“传值”</td><td>使用值的引用来调用方法，上例中，<code>qcrao.growUp()</code> 实际上是 <code>(&amp;qcrao).growUp()</code></td></tr><tr><td>指针类型调用者</td><td>指针被解引用为值，上例中，<code>stefno.howOld()</code> 实际上是 <code>(*stefno).howOld()</code></td><td>实际上也是“传值”，方法里的操作会影响到调用者，类似于指针传参，拷贝了一份指针</td></tr></tbody></table><h2 id="值接收者和指针接收者"><a href="#值接收者和指针接收者" class="headerlink" title="值接收者和指针接收者"></a>值接收者和指针接收者</h2><p>前面说过，不管接收者类型是值类型还是指针类型，都可以通过值类型或指针类型调用，这里面实际上通过语法糖起作用的。</p><p>先说结论：实现了接收者是值类型的方法，相当于自动实现了接收者是指针类型的方法；而实现了接收者是指针类型的方法，不会自动生成对应接收者是值类型的方法。</p><p>来看一个例子，就会完全明白：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> coder <span class="keyword">interface</span> &#123;</span><br><span class="line">    code()</span><br><span class="line">    debug()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Gopher <span class="keyword">struct</span> &#123;</span><br><span class="line">    language <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Gopher)</span> <span class="title">code</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"I am coding %s language\n"</span>, p.language)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Gopher)</span> <span class="title">debug</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"I am debuging %s language\n"</span>, p.language)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> c coder = &amp;Gopher&#123;<span class="string">"Go"</span>&#125;</span><br><span class="line">    c.code()</span><br><span class="line">    c.debug()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码里定义了一个接口 <code>coder</code>，接口定义了两个函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">code()</span><br><span class="line">debug()</span><br></pre></td></tr></table></figure><p>接着定义了一个结构体 <code>Gopher</code>，它实现了两个方法，一个值接收者，一个指针接收者。</p><p>最后，我们在 <code>main</code> 函数里通过接口类型的变量调用了定义的两个函数。</p><p>运行一下，结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">I am coding Go language</span><br><span class="line">I am debuging Go language</span><br></pre></td></tr></table></figure><p>但是如果我们把 <code>main</code> 函数的第一条语句换一下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> c coder = Gopher&#123;<span class="string">"Go"</span>&#125;</span><br><span class="line">    c.code()</span><br><span class="line">    c.debug()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行一下，报错：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./main.go:23:6: cannot use Gopher literal (<span class="built_in">type</span> Gopher) as <span class="built_in">type</span> coder <span class="keyword">in</span> assignment:</span><br><span class="line">    Gopher does not implement coder (debug method has pointer receiver)</span><br></pre></td></tr></table></figure><p>看出这两处代码的差别了吗？第一次是将 <code>&amp;Gopher</code> 赋给了 <code>coder</code>；第二次则是将 <code>Gopher</code> 赋给了 <code>coder</code>。</p><p>第二次报错是说，<code>Gopher</code> 没有实现 <code>coder</code>。很明显了吧，因为 <code>Gopher</code> 类型并没有实现 <code>debug</code> 方法；表面上看， <code>*Gopher</code> 类型也没有实现 <code>code</code> 方法，但是因为 <code>Gopher</code> 类型实现了 <code>code</code> 方法，所以让 <code>*Gopher</code> 类型自动拥有了 <code>code</code> 方法。</p><p>当然，上面的说法有一个简单的解释：接收者是指针类型的方法，很可能在方法中会对接收者的属性进行更改操作，从而影响接收者；而对于接收者是值类型的方法，在方法中不会对接收者本身产生影响。</p><p>所以，当实现了一个接收者是值类型的方法，就可以自动生成一个接收者是对应指针类型的方法，因为两者都不会影响接收者。但是，当实现了一个接收者是指针类型的方法，如果此时自动生成一个接收者是值类型的方法，原本期望对接收者的改变（通过指针实现），现在无法实现，因为值类型会产生一个拷贝，不会真正影响调用者。</p><p>最后，只要记住下面这点就可以了：</p><blockquote><p>如果实现了接收者是值类型的方法，会隐含地也实现了接收者是指针类型的方法。</p></blockquote><h2 id="两者分别在何时使用"><a href="#两者分别在何时使用" class="headerlink" title="两者分别在何时使用"></a>两者分别在何时使用</h2><p>如果方法的接收者是值类型，无论调用者是对象还是对象指针，修改的都是对象的副本，不影响调用者；如果方法的接收者是指针类型，则调用者修改的是指针指向的对象本身。</p><p>使用指针作为方法的接收者的理由：</p><ul><li>方法能够修改接收者指向的值。</li><li>避免在每次调用方法时复制该值，在值的类型为大型结构体时，这样做会更加高效。</li></ul><p>是使用值接收者还是指针接收者，不是由该方法是否修改了调用者（也就是接收者）来决定，而是应该基于该类型的<code>本质</code>。</p><p>如果类型具备“原始的本质”，也就是说它的成员都是由 Go 语言里内置的原始类型，如字符串，整型值等，那就定义值接收者类型的方法。像内置的引用类型，如 slice，map，interface，channel，这些类型比较特殊，声明他们的时候，实际上是创建了一个 <code>header</code>， 对于他们也是直接定义值接收者类型的方法。这样，调用函数时，是直接 copy 了这些类型的 <code>header</code>，而 <code>header</code> 本身就是为复制设计的。</p><p>如果类型具备非原始的本质，不能被安全地复制，这种类型总是应该被共享，那就定义指针接收者的方法。比如 go 源码里的文件结构体（struct File）就不应该被复制，应该只有一份<code>实体</code>。</p><p>这一段说的比较绕，大家可以去看《Go 语言实战》5.3 那一节。</p><h1 id="3-iface-和-eface-的区别是什么"><a href="#3-iface-和-eface-的区别是什么" class="headerlink" title="3. iface 和 eface 的区别是什么"></a>3. iface 和 eface 的区别是什么</h1><p><code>iface</code> 和 <code>eface</code> 都是 Go 中描述接口的底层结构体，区别在于 <code>iface</code> 描述的接口包含方法，而 <code>eface</code> 则是不包含任何方法的空接口：<code>interface{}</code>。</p><p>从源码层面看一下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> iface <span class="keyword">struct</span> &#123;</span><br><span class="line">    tab  *itab</span><br><span class="line">    data unsafe.Pointer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> itab <span class="keyword">struct</span> &#123;</span><br><span class="line">    inter  *interfacetype</span><br><span class="line">    _type  *_type</span><br><span class="line">    link   *itab</span><br><span class="line">    hash   <span class="keyword">uint32</span> <span class="comment">// copy of _type.hash. Used for type switches.</span></span><br><span class="line">    bad    <span class="keyword">bool</span>   <span class="comment">// type does not implement interface</span></span><br><span class="line">    inhash <span class="keyword">bool</span>   <span class="comment">// has this itab been added to hash?</span></span><br><span class="line">    unused [<span class="number">2</span>]<span class="keyword">byte</span></span><br><span class="line">    fun    [<span class="number">1</span>]<span class="keyword">uintptr</span> <span class="comment">// variable sized</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>iface</code> 内部维护两个指针，<code>tab</code> 指向一个 <code>itab</code> 实体， 它表示接口的类型以及赋给这个接口的实体类型。<code>data</code> 则指向接口具体的值，一般而言是一个指向堆内存的指针。</p><p>再来仔细看一下 <code>itab</code> 结构体：<code>_type</code> 字段描述了实体的类型，包括内存对齐方式，大小等；<code>inter</code> 字段则描述了接口的类型。<code>fun</code> 字段放置和接口方法对应的具体数据类型的方法地址，实现接口调用方法的动态分派，一般在每次给接口赋值发生转换时会更新此表，或者直接拿缓存的 itab。</p><p>这里只会列出实体类型和接口相关的方法，实体类型的其他方法并不会出现在这里。如果你学过 C++ 的话，这里可以类比虚函数的概念。</p><p>另外，你可能会觉得奇怪，为什么 <code>fun</code> 数组的大小为 1，要是接口定义了多个方法可怎么办？实际上，这里存储的是第一个方法的函数指针，如果有更多的方法，在它之后的内存空间里继续存储。从汇编角度来看，通过增加地址就能获取到这些函数指针，没什么影响。顺便提一句，这些方法是按照函数名称的字典序进行排列的。</p><p>再看一下 <code>interfacetype</code> 类型，它描述的是接口的类型：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> interfacetype <span class="keyword">struct</span> &#123;</span><br><span class="line">    typ     _type</span><br><span class="line">    pkgpath name</span><br><span class="line">    mhdr    []imethod</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，它包装了 <code>_type</code> 类型，<code>_type</code> 实际上是描述 Go 语言中各种数据类型的结构体。我们注意到，这里还包含一个 <code>mhdr</code> 字段，表示接口所定义的函数列表， <code>pkgpath</code>记录定义了接口的包名。</p><p>这里通过一张图来看下 <code>iface</code> 结构体的全貌：</p><p><img src="https://user-images.githubusercontent.com/7698088/56564826-82527600-65e1-11e9-956d-d98a212bc863.png" alt="iface 结构体全景"></p><p>接着来看一下 <code>eface</code> 的源码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> eface <span class="keyword">struct</span> &#123;</span><br><span class="line">    _type *_type</span><br><span class="line">    data  unsafe.Pointer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相比 <code>iface</code>，<code>eface</code> 就比较简单了。只维护了一个 <code>_type</code> 字段，表示空接口所承载的具体的实体类型。<code>data</code> 描述了具体的值。</p><p><img src="https://user-images.githubusercontent.com/7698088/56565105-318f4d00-65e2-11e9-96bd-4b2e192791dc.png" alt="eface 结构体全景"></p><p>我们来看个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := <span class="number">200</span></span><br><span class="line">    <span class="keyword">var</span> any <span class="keyword">interface</span>&#123;&#125; = x</span><br><span class="line">    fmt.Println(any)</span><br><span class="line"></span><br><span class="line">    g := Gopher&#123;<span class="string">"Go"</span>&#125;</span><br><span class="line">    <span class="keyword">var</span> c coder = g</span><br><span class="line">    fmt.Println(c)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> coder <span class="keyword">interface</span> &#123;</span><br><span class="line">    code()</span><br><span class="line">    debug()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Gopher <span class="keyword">struct</span> &#123;</span><br><span class="line">    language <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Gopher)</span> <span class="title">code</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"I am coding %s language\n"</span>, p.language)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Gopher)</span> <span class="title">debug</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"I am debuging %s language\n"</span>, p.language)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行命令，打印出汇编语言：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go tool compile -S ./src/main.go</span><br></pre></td></tr></table></figure><p>可以看到，main 函数里调用了两个函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">convT2E64</span><span class="params">(t *_type, elem unsafe.Pointer)</span> <span class="params">(e eface)</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">convT2I</span><span class="params">(tab *itab, elem unsafe.Pointer)</span> <span class="params">(i iface)</span></span></span><br></pre></td></tr></table></figure><p>上面两个函数的参数和 <code>iface</code> 及 <code>eface</code> 结构体的字段是可以联系起来的：两个函数都是将参数<code>组装</code>一下，形成最终的接口。</p><p>作为补充，我们最后再来看下 <code>_type</code> 结构体：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> _type <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 类型大小</span></span><br><span class="line">    size       <span class="keyword">uintptr</span></span><br><span class="line">    ptrdata    <span class="keyword">uintptr</span></span><br><span class="line">    <span class="comment">// 类型的 hash 值</span></span><br><span class="line">    hash       <span class="keyword">uint32</span></span><br><span class="line">    <span class="comment">// 类型的 flag，和反射相关</span></span><br><span class="line">    tflag      tflag</span><br><span class="line">    <span class="comment">// 内存对齐相关</span></span><br><span class="line">    align      <span class="keyword">uint8</span></span><br><span class="line">    fieldalign <span class="keyword">uint8</span></span><br><span class="line">    <span class="comment">// 类型的编号，有bool, slice, struct 等等等等</span></span><br><span class="line">    kind       <span class="keyword">uint8</span></span><br><span class="line">    alg        *typeAlg</span><br><span class="line">    <span class="comment">// gc 相关</span></span><br><span class="line">    gcdata    *<span class="keyword">byte</span></span><br><span class="line">    str       nameOff</span><br><span class="line">    ptrToThis typeOff</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Go 语言各种数据类型都是在 <code>_type</code> 字段的基础上，增加一些额外的字段来进行管理的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> arraytype <span class="keyword">struct</span> &#123;</span><br><span class="line">    typ   _type</span><br><span class="line">    elem  *_type</span><br><span class="line">    slice *_type</span><br><span class="line">    <span class="built_in">len</span>   <span class="keyword">uintptr</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> chantype <span class="keyword">struct</span> &#123;</span><br><span class="line">    typ  _type</span><br><span class="line">    elem *_type</span><br><span class="line">    dir  <span class="keyword">uintptr</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> slicetype <span class="keyword">struct</span> &#123;</span><br><span class="line">    typ  _type</span><br><span class="line">    elem *_type</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> structtype <span class="keyword">struct</span> &#123;</span><br><span class="line">    typ     _type</span><br><span class="line">    pkgPath name</span><br><span class="line">    fields  []structfield</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些数据类型的结构体定义，是反射实现的基础。</p><h1 id="4-接口的动态类型和动态值"><a href="#4-接口的动态类型和动态值" class="headerlink" title="4. 接口的动态类型和动态值"></a>4. 接口的动态类型和动态值</h1><p>从源码里可以看到：<code>iface</code>包含两个字段：<code>tab</code> 是接口表指针，指向类型信息；<code>data</code> 是数据指针，则指向具体的数据。它们分别被称为<code>动态类型</code>和<code>动态值</code>。而接口值包括<code>动态类型</code>和<code>动态值</code>。</p><p>【引申1】接口类型和 <code>nil</code> 作比较</p><p>接口值的零值是指<code>动态类型</code>和<code>动态值</code>都为 <code>nil</code>。当仅且当这两部分的值都为 <code>nil</code> 的情况下，这个接口值就才会被认为 <code>接口值 == nil</code>。</p><p>来看个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Coder <span class="keyword">interface</span> &#123;</span><br><span class="line">    code()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Gopher <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g Gopher)</span> <span class="title">code</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"%s is coding\n"</span>, g.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> c Coder</span><br><span class="line">    fmt.Println(c == <span class="literal">nil</span>)</span><br><span class="line">    fmt.Printf(<span class="string">"c: %T, %v\n"</span>, c, c)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> g *Gopher</span><br><span class="line">    fmt.Println(g == <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">    c = g</span><br><span class="line">    fmt.Println(c == <span class="literal">nil</span>)</span><br><span class="line">    fmt.Printf(<span class="string">"c: %T, %v\n"</span>, c, c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">true</span></span><br><span class="line">c: &lt;nil&gt;, &lt;nil&gt;</span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line">c: *main.Gopher, &lt;nil&gt;</span><br></pre></td></tr></table></figure><p>一开始，<code>c</code> 的 动态类型和动态值都为 <code>nil</code>，<code>g</code> 也为 <code>nil</code>，当把 <code>g</code> 赋值给 <code>c</code> 后，<code>c</code> 的动态类型变成了 <code>*main.Gopher</code>，仅管 <code>c</code> 的动态值仍为 <code>nil</code>，但是当 <code>c</code> 和 <code>nil</code> 作比较的时候，结果就是 <code>false</code> 了。</p><p>【引申2】<br>来看一个例子，看一下它的输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyError <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i MyError)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"MyError"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    err := Process()</span><br><span class="line">    fmt.Println(err)</span><br><span class="line"></span><br><span class="line">    fmt.Println(err == <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Process</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> err *MyError = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数运行结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;nil&gt;</span><br><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure><p>这里先定义了一个 <code>MyError</code> 结构体，实现了 <code>Error</code> 函数，也就实现了 <code>error</code> 接口。<code>Process</code> 函数返回了一个 <code>error</code> 接口，这块隐含了类型转换。所以，虽然它的值是 <code>nil</code>，其实它的类型是 <code>*MyError</code>，最后和 <code>nil</code> 比较的时候，结果为 <code>false</code>。</p><p>【引申3】如何打印出接口的动态类型和值？</p><p>直接看代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"unsafe"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> iface <span class="keyword">struct</span> &#123;</span><br><span class="line">    itab, data <span class="keyword">uintptr</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a <span class="keyword">interface</span>&#123;&#125; = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> b <span class="keyword">interface</span>&#123;&#125; = (*<span class="keyword">int</span>)(<span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">    x := <span class="number">5</span></span><br><span class="line">    <span class="keyword">var</span> c <span class="keyword">interface</span>&#123;&#125; = (*<span class="keyword">int</span>)(&amp;x)</span><br><span class="line">    </span><br><span class="line">    ia := *(*iface)(unsafe.Pointer(&amp;a))</span><br><span class="line">    ib := *(*iface)(unsafe.Pointer(&amp;b))</span><br><span class="line">    ic := *(*iface)(unsafe.Pointer(&amp;c))</span><br><span class="line"></span><br><span class="line">    fmt.Println(ia, ib, ic)</span><br><span class="line"></span><br><span class="line">    fmt.Println(*(*<span class="keyword">int</span>)(unsafe.Pointer(ic.data)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码里直接定义了一个 <code>iface</code> 结构体，用两个指针来描述 <code>itab</code> 和 <code>data</code>，之后将 a, b, c 在内存中的内容强制解释成我们自定义的 <code>iface</code>。最后就可以打印出动态类型和动态值的地址。</p><p>运行结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;0 0&#125; &#123;17426912 0&#125; &#123;17426912 842350714568&#125;</span><br><span class="line">5</span><br></pre></td></tr></table></figure><p>a 的动态类型和动态值的地址均为 0，也就是 nil；b 的动态类型和 c 的动态类型一致，都是 <code>*int</code>；最后，c 的动态值为 5。</p><h1 id="5-编译器自动检测类型是否实现接口"><a href="#5-编译器自动检测类型是否实现接口" class="headerlink" title="5. 编译器自动检测类型是否实现接口"></a>5. 编译器自动检测类型是否实现接口</h1><p>经常看到一些开源库里会有一些类似下面这种奇怪的用法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _ io.Writer = (*myWriter)(<span class="literal">nil</span>)</span><br></pre></td></tr></table></figure><p>这时候会有点懵，不知道作者想要干什么，实际上这就是此问题的答案。编译器会由此检查 <code>*myWriter</code> 类型是否实现了 <code>io.Writer</code> 接口。</p><p>来看一个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"io"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> myWriter <span class="keyword">struct</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*func (w myWriter) Write(p []byte) (n int, err error) &#123;</span></span><br><span class="line"><span class="comment">    return</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 检查 *myWriter 类型是否实现了 io.Writer 接口</span></span><br><span class="line">    <span class="keyword">var</span> _ io.Writer = (*myWriter)(<span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查 myWriter 类型是否实现了 io.Writer 接口</span></span><br><span class="line">    <span class="keyword">var</span> _ io.Writer = myWriter&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释掉为 myWriter 定义的 Write 函数后，运行程序：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">src/main.go:14:6: cannot use (*myWriter)(nil) (<span class="built_in">type</span> *myWriter) as <span class="built_in">type</span> io.Writer <span class="keyword">in</span> assignment:</span><br><span class="line">    *myWriter does not implement io.Writer (missing Write method)</span><br><span class="line">src/main.go:15:6: cannot use myWriter literal (<span class="built_in">type</span> myWriter) as <span class="built_in">type</span> io.Writer <span class="keyword">in</span> assignment:</span><br><span class="line">    myWriter does not implement io.Writer (missing Write method)</span><br></pre></td></tr></table></figure><p>报错信息：*myWriter/myWriter 未实现 io.Writer 接口，也就是未实现 Write 方法。</p><p>解除注释后，运行程序不报错。</p><p>实际上，上述赋值语句会发生隐式地类型转换，在转换的过程中，编译器会检测等号右边的类型是否实现了等号左边接口所规定的函数。</p><p>总结一下，可通过在代码中添加类似如下的代码，用来检测类型是否实现了接口：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _ io.Writer = (*myWriter)(<span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">var</span> _ io.Writer = myWriter&#123;&#125;</span><br></pre></td></tr></table></figure><h1 id="6-接口的构造过程是怎样的"><a href="#6-接口的构造过程是怎样的" class="headerlink" title="6. 接口的构造过程是怎样的"></a>6. 接口的构造过程是怎样的</h1><p>我们已经看过了 <code>iface</code> 和 <code>eface</code> 的源码，知道 <code>iface</code> 最重要的是 <code>itab</code> 和 <code>_type</code>。</p><p>为了研究清楚接口是如何构造的，接下来我会拿起汇编的武器，还原背后的真相。</p><p>来看一个示例代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">interface</span> &#123;</span><br><span class="line">    growUp()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Student)</span> <span class="title">growUp</span><span class="params">()</span></span> &#123;</span><br><span class="line">    p.age += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> qcrao = Person(Student&#123;age: <span class="number">18</span>&#125;)</span><br><span class="line"></span><br><span class="line">    fmt.Println(qcrao)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go tool compile -S main.go</span><br></pre></td></tr></table></figure><p>得到 main 函数的汇编代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">0x0000 00000 (./src/main.go:30) TEXT    &quot;&quot;.main(SB), $80-0</span><br><span class="line">0x0000 00000 (./src/main.go:30) MOVQ    (TLS), CX</span><br><span class="line">0x0009 00009 (./src/main.go:30) CMPQ    SP, 16(CX)</span><br><span class="line">0x000d 00013 (./src/main.go:30) JLS     157</span><br><span class="line">0x0013 00019 (./src/main.go:30) SUBQ    $80, SP</span><br><span class="line">0x0017 00023 (./src/main.go:30) MOVQ    BP, 72(SP)</span><br><span class="line">0x001c 00028 (./src/main.go:30) LEAQ    72(SP), BP</span><br><span class="line">0x0021 00033 (./src/main.go:30) FUNCDATA$0, gclocals·69c1753bd5f81501d95132d08af04464(SB)</span><br><span class="line">0x0021 00033 (./src/main.go:30) FUNCDATA$1, gclocals·e226d4ae4a7cad8835311c6a4683c14f(SB)</span><br><span class="line">0x0021 00033 (./src/main.go:31) MOVQ    $18, &quot;&quot;..autotmp_1+48(SP)</span><br><span class="line">0x002a 00042 (./src/main.go:31) LEAQ    go.itab.&quot;&quot;.Student,&quot;&quot;.Person(SB), AX</span><br><span class="line">0x0031 00049 (./src/main.go:31) MOVQ    AX, (SP)</span><br><span class="line">0x0035 00053 (./src/main.go:31) LEAQ    &quot;&quot;..autotmp_1+48(SP), AX</span><br><span class="line">0x003a 00058 (./src/main.go:31) MOVQ    AX, 8(SP)</span><br><span class="line">0x003f 00063 (./src/main.go:31) PCDATA  $0, $0</span><br><span class="line">0x003f 00063 (./src/main.go:31) CALL    runtime.convT2I64(SB)</span><br><span class="line">0x0044 00068 (./src/main.go:31) MOVQ    24(SP), AX</span><br><span class="line">0x0049 00073 (./src/main.go:31) MOVQ    16(SP), CX</span><br><span class="line">0x004e 00078 (./src/main.go:33) TESTQ   CX, CX</span><br><span class="line">0x0051 00081 (./src/main.go:33) JEQ     87</span><br><span class="line">0x0053 00083 (./src/main.go:33) MOVQ    8(CX), CX</span><br><span class="line">0x0057 00087 (./src/main.go:33) MOVQ    $0, &quot;&quot;..autotmp_2+56(SP)</span><br><span class="line">0x0060 00096 (./src/main.go:33) MOVQ    $0, &quot;&quot;..autotmp_2+64(SP)</span><br><span class="line">0x0069 00105 (./src/main.go:33) MOVQ    CX, &quot;&quot;..autotmp_2+56(SP)</span><br><span class="line">0x006e 00110 (./src/main.go:33) MOVQ    AX, &quot;&quot;..autotmp_2+64(SP)</span><br><span class="line">0x0073 00115 (./src/main.go:33) LEAQ    &quot;&quot;..autotmp_2+56(SP), AX</span><br><span class="line">0x0078 00120 (./src/main.go:33) MOVQ    AX, (SP)</span><br><span class="line">0x007c 00124 (./src/main.go:33) MOVQ    $1, 8(SP)</span><br><span class="line">0x0085 00133 (./src/main.go:33) MOVQ    $1, 16(SP)</span><br><span class="line">0x008e 00142 (./src/main.go:33) PCDATA  $0, $1</span><br><span class="line">0x008e 00142 (./src/main.go:33) CALL    fmt.Println(SB)</span><br><span class="line">0x0093 00147 (./src/main.go:34) MOVQ    72(SP), BP</span><br><span class="line">0x0098 00152 (./src/main.go:34) ADDQ    $80, SP</span><br><span class="line">0x009c 00156 (./src/main.go:34) RET</span><br><span class="line">0x009d 00157 (./src/main.go:34) NOP</span><br><span class="line">0x009d 00157 (./src/main.go:30) PCDATA  $0, $-1</span><br><span class="line">0x009d 00157 (./src/main.go:30) CALL    runtime.morestack_noctxt(SB)</span><br><span class="line">0x00a2 00162 (./src/main.go:30) JMP     0</span><br></pre></td></tr></table></figure><p>我们从第 10 行开始看，如果不理解前面几行汇编代码的话，可以回去看看公众号前面两篇文章，这里我就省略了。</p><table><thead><tr><th>汇编行数</th><th>操作</th></tr></thead><tbody><tr><td>10-14</td><td>构造调用 <code>runtime.convT2I64(SB)</code> 的参数</td></tr></tbody></table><p>我们来看下这个函数的参数形式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">convT2I64</span><span class="params">(tab *itab, elem unsafe.Pointer)</span> <span class="params">(i iface)</span></span> &#123;</span><br><span class="line">    <span class="comment">// ……</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>convT2I64</code> 会构造出一个 <code>inteface</code>，也就是我们的 <code>Person</code> 接口。</p><p>第一个参数的位置是 <code>(SP)</code>，这里被赋上了 <code>go.itab.&quot;&quot;.Student,&quot;&quot;.Person(SB)</code> 的地址。</p><p>我们从生成的汇编找到：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">go.itab.&quot;&quot;.Student,&quot;&quot;.Person SNOPTRDATA dupok size=40</span><br><span class="line">        0x0000 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  </span><br><span class="line">        0x0010 00 00 00 00 00 00 00 00 da 9f 20 d4              </span><br><span class="line">        rel 0+8 t=1 type.&quot;&quot;.Person+0</span><br><span class="line">        rel 8+8 t=1 type.&quot;&quot;.Student+0</span><br></pre></td></tr></table></figure><p><code>size=40</code> 大小为40字节，回顾一下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> itab <span class="keyword">struct</span> &#123;</span><br><span class="line">    inter  *interfacetype <span class="comment">// 8字节</span></span><br><span class="line">    _type  *_type <span class="comment">// 8字节</span></span><br><span class="line">    link   *itab <span class="comment">// 8字节</span></span><br><span class="line">    hash   <span class="keyword">uint32</span> <span class="comment">// 4字节</span></span><br><span class="line">    bad    <span class="keyword">bool</span>   <span class="comment">// 1字节</span></span><br><span class="line">    inhash <span class="keyword">bool</span>   <span class="comment">// 1字节</span></span><br><span class="line">    unused [<span class="number">2</span>]<span class="keyword">byte</span> <span class="comment">// 2字节</span></span><br><span class="line">    fun    [<span class="number">1</span>]<span class="keyword">uintptr</span> <span class="comment">// variable sized // 8字节</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把每个字段的大小相加，<code>itab</code> 结构体的大小就是 40 字节。上面那一串数字实际上是 <code>itab</code> 序列化后的内容，注意到大部分数字是 0，从 24 字节开始的 4 个字节 <code>da 9f 20 d4</code>实际上是 <code>itab</code> 的 <code>hash</code> 值，这在判断两个类型是否相同的时候会用到。</p><p>下面两行是链接指令，简单说就是将所有源文件综合起来，给每个符号赋予一个全局的位置值。这里的意思也比较明确：前8个字节最终存储的是 <code>type.&quot;&quot;.Person</code> 的地址，对应 <code>itab</code>里的 <code>inter</code> 字段，表示接口类型；8-16 字节最终存储的是 <code>type.&quot;&quot;.Student</code> 的地址，对应 <code>itab</code> 里 <code>_type</code> 字段，表示具体类型。</p><p>第二个参数就比较简单了，它就是数字 <code>18</code> 的地址，这也是初始化 <code>Student</code> 结构体的时候会用到。</p><table><thead><tr><th>汇编行数</th><th>操作</th></tr></thead><tbody><tr><td>15</td><td>调用 <code>runtime.convT2I64(SB)</code></td></tr></tbody></table><p>具体看下代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">convT2I64</span><span class="params">(tab *itab, elem unsafe.Pointer)</span> <span class="params">(i iface)</span></span> &#123;</span><br><span class="line">    t := tab._type</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> x unsafe.Pointer</span><br><span class="line">    <span class="keyword">if</span> *(*<span class="keyword">uint64</span>)(elem) == <span class="number">0</span> &#123;</span><br><span class="line">        x = unsafe.Pointer(&amp;zeroVal[<span class="number">0</span>])</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        x = mallocgc(<span class="number">8</span>, t, <span class="literal">false</span>)</span><br><span class="line">        *(*<span class="keyword">uint64</span>)(x) = *(*<span class="keyword">uint64</span>)(elem)</span><br><span class="line">    &#125;</span><br><span class="line">    i.tab = tab</span><br><span class="line">    i.data = x</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这块代码比较简单，把 <code>tab</code> 赋给了 <code>iface</code> 的 <code>tab</code> 字段；<code>data</code> 部分则是在堆上申请了一块内存，然后将 <code>elem</code> 指向的 <code>18</code> 拷贝过去。这样 <code>iface</code> 就组装好了。</p><table><thead><tr><th>汇编行数</th><th>操作</th></tr></thead><tbody><tr><td>17</td><td>把 <code>i.tab</code> 赋给 <code>CX</code></td></tr><tr><td>18</td><td>把 <code>i.data</code> 赋给 <code>AX</code></td></tr><tr><td>19-21</td><td>检测 <code>i.tab</code> 是否是 nil，如果不是的话，把 CX 移动 8 个字节，也就是把 <code>itab</code> 的 <code>_type</code> 字段赋给了 CX，这也是接口的实体类型，最终要作为 <code>fmt.Println</code>函数的参数</td></tr></tbody></table><p>后面，就是调用 <code>fmt.Println</code> 函数及之前的参数准备工作了，不再赘述。</p><p>这样，我们就把一个 <code>interface</code> 的构造过程说完了。</p><p>【引申1】<br>如何打印出接口类型的 <code>Hash</code> 值？</p><p>这里参考曹大神翻译的一篇文章，参考资料里会写上。具体做法如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> iface <span class="keyword">struct</span> &#123;</span><br><span class="line">    tab  *itab</span><br><span class="line">    data unsafe.Pointer</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> itab <span class="keyword">struct</span> &#123;</span><br><span class="line">    inter <span class="keyword">uintptr</span></span><br><span class="line">    _type <span class="keyword">uintptr</span></span><br><span class="line">    link <span class="keyword">uintptr</span></span><br><span class="line">    hash  <span class="keyword">uint32</span></span><br><span class="line">    _     [<span class="number">4</span>]<span class="keyword">byte</span></span><br><span class="line">    fun   [<span class="number">1</span>]<span class="keyword">uintptr</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> qcrao = Person(Student&#123;age: <span class="number">18</span>&#125;)</span><br><span class="line"></span><br><span class="line">    iface := (*iface)(unsafe.Pointer(&amp;qcrao))</span><br><span class="line">    fmt.Printf(<span class="string">"iface.tab.hash = %#x\n"</span>, iface.tab.hash)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义了一个<code>山寨版</code>的 <code>iface</code> 和 <code>itab</code>，说它<code>山寨</code>是因为 <code>itab</code> 里的一些关键数据结构都不具体展开了，比如 <code>_type</code>，对比一下正宗的定义就可以发现，但是<code>山寨版</code>依然能工作，因为 <code>_type</code> 就是一个指针而已嘛。</p><p>在 <code>main</code> 函数里，先构造出一个接口对象 <code>qcrao</code>，然后强制类型转换，最后读取出 <code>hash</code> 值，非常妙！你也可以自己动手试一下。</p><p>运行结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iface.tab.hash = 0xd4209fda</span><br></pre></td></tr></table></figure><p>值得一提的是，构造接口 <code>qcrao</code> 的时候，即使我把 <code>age</code> 写成其他值，得到的 <code>hash</code> 值依然不变的，这应该是可以预料的，<code>hash</code> 值只和他的字段、方法相关。</p><h1 id="7-类型转换和断言的区别"><a href="#7-类型转换和断言的区别" class="headerlink" title="7. 类型转换和断言的区别"></a>7. 类型转换和断言的区别</h1><p>我们知道，Go 语言中不允许隐式类型转换，也就是说 <code>=</code> 两边，不允许出现类型不相同的变量。</p><p><code>类型转换</code>、<code>类型断言</code>本质都是把一个类型转换成另外一个类型。不同之处在于，类型断言是对接口变量进行的操作。</p><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>对于<code>类型转换</code>而言，转换前后的两个类型要相互兼容才行。类型转换的语法为：</p><blockquote><p>&lt;结果类型&gt; := &lt;目标类型&gt; ( &lt;表达式&gt; )</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> i <span class="keyword">int</span> = <span class="number">9</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> f <span class="keyword">float64</span></span><br><span class="line">    f = <span class="keyword">float64</span>(i)</span><br><span class="line">    fmt.Printf(<span class="string">"%T, %v\n"</span>, f, f)</span><br><span class="line"></span><br><span class="line">    f = <span class="number">10.8</span></span><br><span class="line">    a := <span class="keyword">int</span>(f)</span><br><span class="line">    fmt.Printf(<span class="string">"%T, %v\n"</span>, a, a)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// s := []int(i)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码里，我定义了一个 <code>int</code> 型和 <code>float64</code> 型的变量，尝试在它们之前相互转换，结果是成功的：<code>int</code> 型和 <code>float64</code> 是相互兼容的。</p><p>如果我把最后一行代码的注释去掉，编译器会报告类型不兼容的错误：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cannot convert i (<span class="built_in">type</span> int) to <span class="built_in">type</span> []int</span><br></pre></td></tr></table></figure><h2 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h2><p>前面说过，因为空接口 <code>interface{}</code> 没有定义任何函数，因此 Go 中所有类型都实现了空接口。当一个函数的形参是 <code>interface{}</code>，那么在函数中，需要对形参进行断言，从而得到它的真实类型。</p><p>断言的语法为：</p><blockquote><p>&lt;目标类型的值&gt;，&lt;布尔参数&gt; := &lt;表达式&gt;.( 目标类型 ) // 安全类型断言<br>&lt;目标类型的值&gt; := &lt;表达式&gt;.( 目标类型 )　　//非安全类型断言</p></blockquote><p>类型转换和类型断言有些相似，不同之处，在于类型断言是对接口进行的操作。</p><p>还是来看一个简短的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">    Age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125; = <span class="built_in">new</span>(Student)</span><br><span class="line">    s := i.(Student)</span><br><span class="line">    </span><br><span class="line">    fmt.Println(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行一下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">panic: interface conversion: interface &#123;&#125; is *main.Student, not main.Student</span><br></pre></td></tr></table></figure><p>直接 <code>panic</code> 了，这是因为 <code>i</code> 是 <code>*Student</code> 类型，并非 <code>Student</code> 类型，断言失败。这里直接发生了 <code>panic</code>，线上代码可能并不适合这样做，可以采用“安全断言”的语法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125; = <span class="built_in">new</span>(Student)</span><br><span class="line">    s, ok := i.(Student)</span><br><span class="line">    <span class="keyword">if</span> ok &#123;</span><br><span class="line">        fmt.Println(s)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，即使断言失败也不会 <code>panic</code>。</p><p>断言其实还有另一种形式，就是用在利用 <code>switch</code> 语句判断接口的类型。每一个 <code>case</code> 会被顺序地考虑。当命中一个 <code>case</code> 时，就会执行 <code>case</code> 中的语句，因此 <code>case</code> 语句的顺序是很重要的，因为很有可能会有多个 <code>case</code> 匹配的情况。</p><p>代码示例如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//var i interface&#123;&#125; = new(Student)</span></span><br><span class="line">    <span class="comment">//var i interface&#123;&#125; = (*Student)(nil)</span></span><br><span class="line">    <span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">"%p %v\n"</span>, &amp;i, i)</span><br><span class="line"></span><br><span class="line">    judge(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">judge</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"%p %v\n"</span>, &amp;v, v)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> v := v.(<span class="keyword">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="literal">nil</span>:</span><br><span class="line">        fmt.Printf(<span class="string">"%p %v\n"</span>, &amp;v, v)</span><br><span class="line">        fmt.Printf(<span class="string">"nil type[%T] %v\n"</span>, v, v)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> Student:</span><br><span class="line">        fmt.Printf(<span class="string">"%p %v\n"</span>, &amp;v, v)</span><br><span class="line">        fmt.Printf(<span class="string">"Student type[%T] %v\n"</span>, v, v)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> *Student:</span><br><span class="line">        fmt.Printf(<span class="string">"%p %v\n"</span>, &amp;v, v)</span><br><span class="line">        fmt.Printf(<span class="string">"*Student type[%T] %v\n"</span>, v, v)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        fmt.Printf(<span class="string">"%p %v\n"</span>, &amp;v, v)</span><br><span class="line">        fmt.Printf(<span class="string">"unknow\n"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">    Age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>main</code> 函数里有三行不同的声明，每次运行一行，注释另外两行，得到三组运行结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// --- var i interface&#123;&#125; = new(Student)</span><br><span class="line">0xc4200701b0 [Name: ], [Age: 0]</span><br><span class="line">0xc4200701d0 [Name: ], [Age: 0]</span><br><span class="line">0xc420080020 [Name: ], [Age: 0]</span><br><span class="line">*Student <span class="built_in">type</span>[*main.Student] [Name: ], [Age: 0]</span><br><span class="line"></span><br><span class="line">// --- var i interface&#123;&#125; = (*Student)(nil)</span><br><span class="line">0xc42000e1d0 &lt;nil&gt;</span><br><span class="line">0xc42000e1f0 &lt;nil&gt;</span><br><span class="line">0xc42000c030 &lt;nil&gt;</span><br><span class="line">*Student <span class="built_in">type</span>[*main.Student] &lt;nil&gt;</span><br><span class="line"></span><br><span class="line">// --- var i interface&#123;&#125;</span><br><span class="line">0xc42000e1d0 &lt;nil&gt;</span><br><span class="line">0xc42000e1e0 &lt;nil&gt;</span><br><span class="line">0xc42000e1f0 &lt;nil&gt;</span><br><span class="line">nil <span class="built_in">type</span>[&lt;nil&gt;] &lt;nil&gt;</span><br></pre></td></tr></table></figure><p>对于第一行语句：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125; = <span class="built_in">new</span>(Student)</span><br></pre></td></tr></table></figure><p><code>i</code> 是一个 <code>*Student</code> 类型，匹配上第三个 case，从打印的三个地址来看，这三处的变量实际上都是不一样的。在 <code>main</code> 函数里有一个局部变量 <code>i</code>；调用函数时，实际上是复制了一份参数，因此函数里又有一个变量 <code>v</code>，它是 <code>i</code> 的拷贝；断言之后，又生成了一份新的拷贝。所以最终打印的三个变量的地址都不一样。</p><p>对于第二行语句：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125; = (*Student)(<span class="literal">nil</span>)</span><br></pre></td></tr></table></figure><p>这里想说明的其实是 <code>i</code> 在这里动态类型是 <code>(*Student)</code>, 数据为 <code>nil</code>，它的类型并不是 <code>nil</code>，它与 <code>nil</code> 作比较的时候，得到的结果也是 <code>false</code>。</p><p>最后一行语句：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>这回 <code>i</code> 才是 <code>nil</code> 类型。</p><p>【引申1】<br><code>fmt.Println</code> 函数的参数是 <code>interface</code>。对于内置类型，函数内部会用穷举法，得出它的真实类型，然后转换为字符串打印。而对于自定义类型，首先确定该类型是否实现了 <code>String()</code> 方法，如果实现了，则直接打印输出 <code>String()</code> 方法的结果；否则，会通过反射来遍历对象的成员进行打印。</p><p>再来看一个简短的例子，比较简单，不要紧张：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">    Age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> s = Student&#123;</span><br><span class="line">        Name: <span class="string">"qcrao"</span>,</span><br><span class="line">        Age: <span class="number">18</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为 <code>Student</code> 结构体没有实现 <code>String()</code> 方法，所以 <code>fmt.Println</code> 会利用反射挨个打印成员变量：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;qcrao 18&#125;</span><br></pre></td></tr></table></figure><p>增加一个 <code>String()</code> 方法的实现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Student)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">"[Name: %s], [Age: %d]"</span>, s.Name, s.Age)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Name: qcrao], [Age: 18]</span><br></pre></td></tr></table></figure><p>按照我们自定义的方法来打印了。</p><p>【引申2】<br>针对上面的例子，如果改一下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Student)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">"[Name: %s], [Age: %d]"</span>, s.Name, s.Age)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意看两个函数的接受者类型不同，现在 <code>Student</code> 结构体只有一个接受者类型为 <code>指针类型</code> 的 <code>String()</code> 函数，打印结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;qcrao 18&#125;</span><br></pre></td></tr></table></figure><p>为什么？</p><blockquote><p>类型 <code>T</code> 只有接受者是 <code>T</code> 的方法；而类型 <code>*T</code> 拥有接受者是 <code>T</code> 和 <code>*T</code> 的方法。语法上 <code>T</code> 能直接调 <code>*T</code> 的方法仅仅是 <code>Go</code> 的语法糖。</p></blockquote><p>所以， <code>Student</code> 结构体定义了接受者类型是值类型的 <code>String()</code> 方法时，通过</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(s)</span><br><span class="line">fmt.Println(&amp;s)</span><br></pre></td></tr></table></figure><p>均可以按照自定义的格式来打印。</p><p>如果 <code>Student</code> 结构体定义了接受者类型是指针类型的 <code>String()</code> 方法时，只有通过</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(&amp;s)</span><br></pre></td></tr></table></figure><p>才能按照自定义的格式打印。</p><h1 id="8-接口转换的原理"><a href="#8-接口转换的原理" class="headerlink" title="8. 接口转换的原理"></a>8. 接口转换的原理</h1><p>通过前面提到的 <code>iface</code> 的源码可以看到，实际上它包含接口的类型 <code>interfacetype</code> 和 实体类型的类型 <code>_type</code>，这两者都是 <code>iface</code> 的字段 <code>itab</code> 的成员。也就是说生成一个 <code>itab</code> 同时需要接口的类型和实体的类型。</p><blockquote><p><interface 类型，="" 实体类型=""> -&gt;itable</interface></p></blockquote><p>当判定一种类型是否满足某个接口时，Go 使用类型的方法集和接口所需要的方法集进行匹配，如果类型的方法集完全包含接口的方法集，则可认为该类型实现了该接口。</p><p>例如某类型有 <code>m</code> 个方法，某接口有 <code>n</code> 个方法，则很容易知道这种判定的时间复杂度为 <code>O(mn)</code>，Go 会对方法集的函数按照函数名的字典序进行排序，所以实际的时间复杂度为 <code>O(m+n)</code>。</p><p>这里我们来探索将一个接口转换给另外一个接口背后的原理，当然，能转换的原因必然是类型兼容。</p><p>直接来看一个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> coder <span class="keyword">interface</span> &#123;</span><br><span class="line">    code()</span><br><span class="line">    run()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> runner <span class="keyword">interface</span> &#123;</span><br><span class="line">    run()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Gopher <span class="keyword">struct</span> &#123;</span><br><span class="line">    language <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g Gopher)</span> <span class="title">code</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g Gopher)</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> c coder = Gopher&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> r runner</span><br><span class="line">    r = c</span><br><span class="line">    fmt.Println(c, r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单解释下上述代码：定义了两个 <code>interface</code>: <code>coder</code> 和 <code>runner</code>。定义了一个实体类型 <code>Gopher</code>，类型 <code>Gopher</code> 实现了两个方法，分别是 <code>run()</code> 和 <code>code()</code>。main 函数里定义了一个接口变量 <code>c</code>，绑定了一个 <code>Gopher</code> 对象，之后将 <code>c</code> 赋值给另外一个接口变量 <code>r</code> 。赋值成功的原因是 <code>c</code> 中包含 <code>run()</code> 方法。这样，两个接口变量完成了转换。</p><p>执行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go tool compile -S ./src/main.go</span><br></pre></td></tr></table></figure><p>得到 main 函数的汇编命令，可以看到： <code>r = c</code> 这一行语句实际上是调用了 <code>runtime.convI2I(SB)</code>，也就是 <code>convI2I</code> 函数，从函数名来看，就是将一个 <code>interface</code> 转换成另外一个 <code>interface</code>，看下它的源代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">convI2I</span><span class="params">(inter *interfacetype, i iface)</span> <span class="params">(r iface)</span></span> &#123;</span><br><span class="line">    tab := i.tab</span><br><span class="line">    <span class="keyword">if</span> tab == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> tab.inter == inter &#123;</span><br><span class="line">        r.tab = tab</span><br><span class="line">        r.data = i.data</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    r.tab = getitab(inter, tab._type, <span class="literal">false</span>)</span><br><span class="line">    r.data = i.data</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码比较简单，函数参数 <code>inter</code> 表示接口类型，<code>i</code> 表示绑定了实体类型的接口，<code>r</code> 则表示接口转换了之后的新的 <code>iface</code>。通过前面的分析，我们又知道， <code>iface</code> 是由 <code>tab</code> 和 <code>data</code> 两个字段组成。所以，实际上 <code>convI2I</code> 函数真正要做的事，找到新 <code>interface</code> 的 <code>tab</code> 和 <code>data</code>，就大功告成了。</p><p>我们还知道，<code>tab</code> 是由接口类型 <code>interfacetype</code> 和 实体类型 <code>_type</code>。所以最关键的语句是 <code>r.tab = getitab(inter, tab._type, false)</code>。</p><p>因此，重点来看下 <code>getitab</code> 函数的源码，只看关键的地方：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getitab</span><span class="params">(inter *interfacetype, typ *_type, canfail <span class="keyword">bool</span>)</span> *<span class="title">itab</span></span> &#123;</span><br><span class="line">    <span class="comment">// ……</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据 inter, typ 计算出 hash 值</span></span><br><span class="line">    h := itabhash(inter, typ)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// look twice - once without lock, once with.</span></span><br><span class="line">    <span class="comment">// common case will be no lock contention.</span></span><br><span class="line">    <span class="keyword">var</span> m *itab</span><br><span class="line">    <span class="keyword">var</span> locked <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> locked = <span class="number">0</span>; locked &lt; <span class="number">2</span>; locked++ &#123;</span><br><span class="line">        <span class="keyword">if</span> locked != <span class="number">0</span> &#123;</span><br><span class="line">            lock(&amp;ifaceLock)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 遍历哈希表的一个 slot</span></span><br><span class="line">        <span class="keyword">for</span> m = (*itab)(atomic.Loadp(unsafe.Pointer(&amp;hash[h]))); m != <span class="literal">nil</span>; m = m.link &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果在 hash 表中已经找到了 itab（inter 和 typ 指针都相同）</span></span><br><span class="line">            <span class="keyword">if</span> m.inter == inter &amp;&amp; m._type == typ &#123;</span><br><span class="line">                <span class="comment">// ……</span></span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> locked != <span class="number">0</span> &#123;</span><br><span class="line">                    unlock(&amp;ifaceLock)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> m</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在 hash 表中没有找到 itab，那么新生成一个 itab</span></span><br><span class="line">    m = (*itab)(persistentalloc(unsafe.Sizeof(itab&#123;&#125;)+<span class="keyword">uintptr</span>(<span class="built_in">len</span>(inter.mhdr)<span class="number">-1</span>)*sys.PtrSize, <span class="number">0</span>, &amp;memstats.other_sys))</span><br><span class="line">    m.inter = inter</span><br><span class="line">    m._type = typ</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 添加到全局的 hash 表中</span></span><br><span class="line">    additab(m, <span class="literal">true</span>, canfail)</span><br><span class="line">    unlock(&amp;ifaceLock)</span><br><span class="line">    <span class="keyword">if</span> m.bad &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单总结一下：getitab 函数会根据 <code>interfacetype</code> 和 <code>_type</code> 去全局的 itab 哈希表中查找，如果能找到，则直接返回；否则，会根据给定的 <code>interfacetype</code> 和 <code>_type</code> 新生成一个 <code>itab</code>，并插入到 itab 哈希表，这样下一次就可以直接拿到 <code>itab</code>。</p><p>这里查找了两次，并且第二次上锁了，这是因为如果第一次没找到，在第二次仍然没有找到相应的 <code>itab</code> 的情况下，需要新生成一个，并且写入哈希表，因此需要加锁。这样，其他协程在查找相同的 <code>itab</code> 并且也没有找到时，第二次查找时，会被挂住，之后，就会查到第一个协程写入哈希表的 <code>itab</code>。</p><p>再来看一下 <code>additab</code> 函数的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检查 _type 是否符合 interface_type 并且创建对应的 itab 结构体 将其放到 hash 表中</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">additab</span><span class="params">(m *itab, locked, canfail <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">    inter := m.inter</span><br><span class="line">    typ := m._type</span><br><span class="line">    x := typ.uncommon()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// both inter and typ have method sorted by name,</span></span><br><span class="line">    <span class="comment">// and interface names are unique,</span></span><br><span class="line">    <span class="comment">// so can iterate over both in lock step;</span></span><br><span class="line">    <span class="comment">// the loop is O(ni+nt) not O(ni*nt).</span></span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="comment">// inter 和 typ 的方法都按方法名称进行了排序</span></span><br><span class="line">    <span class="comment">// 并且方法名都是唯一的。所以循环的次数是固定的</span></span><br><span class="line">    <span class="comment">// 只用循环 O(ni+nt)，而非 O(ni*nt)</span></span><br><span class="line">    ni := <span class="built_in">len</span>(inter.mhdr)</span><br><span class="line">    nt := <span class="keyword">int</span>(x.mcount)</span><br><span class="line">    xmhdr := (*[<span class="number">1</span> &lt;&lt; <span class="number">16</span>]method)(add(unsafe.Pointer(x), <span class="keyword">uintptr</span>(x.moff)))[:nt:nt]</span><br><span class="line">    j := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> k := <span class="number">0</span>; k &lt; ni; k++ &#123;</span><br><span class="line">        i := &amp;inter.mhdr[k]</span><br><span class="line">        itype := inter.typ.typeOff(i.ityp)</span><br><span class="line">        name := inter.typ.nameOff(i.name)</span><br><span class="line">        iname := name.name()</span><br><span class="line">        ipkg := name.pkgPath()</span><br><span class="line">        <span class="keyword">if</span> ipkg == <span class="string">""</span> &#123;</span><br><span class="line">            ipkg = inter.pkgpath.name()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> ; j &lt; nt; j++ &#123;</span><br><span class="line">            t := &amp;xmhdr[j]</span><br><span class="line">            tname := typ.nameOff(t.name)</span><br><span class="line">            <span class="comment">// 检查方法名字是否一致</span></span><br><span class="line">            <span class="keyword">if</span> typ.typeOff(t.mtyp) == itype &amp;&amp; tname.name() == iname &#123;</span><br><span class="line">                pkgPath := tname.pkgPath()</span><br><span class="line">                <span class="keyword">if</span> pkgPath == <span class="string">""</span> &#123;</span><br><span class="line">                    pkgPath = typ.nameOff(x.pkgpath).name()</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> tname.isExported() || pkgPath == ipkg &#123;</span><br><span class="line">                    <span class="keyword">if</span> m != <span class="literal">nil</span> &#123;</span><br><span class="line">                        <span class="comment">// 获取函数地址，并加入到itab.fun数组中</span></span><br><span class="line">                        ifn := typ.textOff(t.ifn)</span><br><span class="line">                        *(*unsafe.Pointer)(add(unsafe.Pointer(&amp;m.fun[<span class="number">0</span>]), <span class="keyword">uintptr</span>(k)*sys.PtrSize)) = ifn</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">goto</span> nextimethod</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ……</span></span><br><span class="line">        </span><br><span class="line">        m.bad = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    nextimethod:</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> !locked &#123;</span><br><span class="line">        throw(<span class="string">"invalid itab locking"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算 hash 值</span></span><br><span class="line">    h := itabhash(inter, typ)</span><br><span class="line">    <span class="comment">// 加到Hash Slot链表中</span></span><br><span class="line">    m.link = hash[h]</span><br><span class="line">    m.inhash = <span class="literal">true</span></span><br><span class="line">    atomicstorep(unsafe.Pointer(&amp;hash[h]), unsafe.Pointer(m))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>additab</code> 会检查 <code>itab</code> 持有的 <code>interfacetype</code> 和 <code>_type</code> 是否符合，就是看 <code>_type</code> 是否完全实现了 <code>interfacetype</code> 的方法，也就是看两者的方法列表重叠的部分就是 <code>interfacetype</code> 所持有的方法列表。注意到其中有一个双层循环，乍一看，循环次数是 <code>ni * nt</code>，但由于两者的函数列表都按照函数名称进行了排序，因此最终只执行了 <code>ni + nt</code>次，代码里通过一个小技巧来实现：第二层循环并没有从 0 开始计数，而是从上一次遍历到的位置开始。</p><p>求 hash 值的函数比较简单：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">itabhash</span><span class="params">(inter *interfacetype, typ *_type)</span> <span class="title">uint32</span></span> &#123;</span><br><span class="line">    h := inter.typ.hash</span><br><span class="line">    h += <span class="number">17</span> * typ.hash</span><br><span class="line">    <span class="keyword">return</span> h % hashSize</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>hashSize</code> 的值是 1009。</p><p>更一般的，当把实体类型赋值给接口的时候，会调用 <code>conv</code> 系列函数，例如空接口调用 <code>convT2E</code> 系列、非空接口调用 <code>convT2I</code> 系列。这些函数比较相似：</p><blockquote><ol><li>具体类型转空接口时，_type 字段直接复制源类型的 _type；调用 mallocgc 获得一块新内存，把值复制进去，data 再指向这块新内存。</li><li>具体类型转非空接口时，入参 tab 是编译器在编译阶段预先生成好的，新接口 tab 字段直接指向入参 tab 指向的 itab；调用 mallocgc 获得一块新内存，把值复制进去，data 再指向这块新内存。</li><li>而对于接口转接口，itab 调用 getitab 函数获取。只用生成一次，之后直接从 hash 表中获取。</li></ol></blockquote><h1 id="9-如何用-interface-实现多态"><a href="#9-如何用-interface-实现多态" class="headerlink" title="9. 如何用 interface 实现多态"></a>9. 如何用 interface 实现多态</h1><p><code>Go</code> 语言并没有设计诸如虚函数、纯虚函数、继承、多重继承等概念，但它通过接口却非常优雅地支持了面向对象的特性。</p><p>多态是一种运行期的行为，它有以下几个特点：</p><blockquote><ol><li>一种类型具有多种类型的能力</li><li>允许不同的对象对同一消息做出灵活的反应</li><li>以一种通用的方式对待个使用的对象</li><li>非动态语言必须通过继承和接口的方式来实现</li></ol></blockquote><p>看一个实现了多态的代码例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    qcrao := Student&#123;age: <span class="number">18</span>&#125;</span><br><span class="line">    whatJob(&amp;qcrao)</span><br><span class="line"></span><br><span class="line">    growUp(&amp;qcrao)</span><br><span class="line">    fmt.Println(qcrao)</span><br><span class="line"></span><br><span class="line">    stefno := Programmer&#123;age: <span class="number">100</span>&#125;</span><br><span class="line">    whatJob(stefno)</span><br><span class="line"></span><br><span class="line">    growUp(stefno)</span><br><span class="line">    fmt.Println(stefno)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">whatJob</span><span class="params">(p Person)</span></span> &#123;</span><br><span class="line">    p.job()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">growUp</span><span class="params">(p Person)</span></span> &#123;</span><br><span class="line">    p.growUp()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">interface</span> &#123;</span><br><span class="line">    job()</span><br><span class="line">    growUp()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Student)</span> <span class="title">job</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"I am a student."</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Student)</span> <span class="title">growUp</span><span class="params">()</span></span> &#123;</span><br><span class="line">    p.age += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Programmer <span class="keyword">struct</span> &#123;</span><br><span class="line">    age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Programmer)</span> <span class="title">job</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"I am a programmer."</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Programmer)</span> <span class="title">growUp</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 程序员老得太快 ^_^</span></span><br><span class="line">    p.age += <span class="number">10</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码里先定义了 1 个 <code>Person</code> 接口，包含两个函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">job()</span><br><span class="line">growUp()</span><br></pre></td></tr></table></figure><p>然后，又定义了 2 个结构体，<code>Student</code> 和 <code>Programmer</code>，同时，类型 <code>*Student</code>、<code>Programmer</code> 实现了 <code>Person</code> 接口定义的两个函数。注意，<code>*Student</code> 类型实现了接口， <code>Student</code> 类型却没有。</p><p>之后，我又定义了函数参数是 <code>Person</code> 接口的两个函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">whatJob</span><span class="params">(p Person)</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">growUp</span><span class="params">(p Person)</span></span></span><br></pre></td></tr></table></figure><p><code>main</code> 函数里先生成 <code>Student</code> 和 <code>Programmer</code> 的对象，再将它们分别传入到函数 <code>whatJob</code> 和 <code>growUp</code>。函数中，直接调用接口函数，实际执行的时候是看最终传入的实体类型是什么，调用的是实体类型实现的函数。于是，不同对象针对同一消息就有多种表现，<code>多态</code>就实现了。</p><p>更深入一点来说的话，在函数 <code>whatJob()</code> 或者 <code>growUp()</code> 内部，接口 <code>person</code> 绑定了实体类型 <code>*Student</code> 或者 <code>Programmer</code>。根据前面分析的 <code>iface</code> 源码，这里会直接调用 <code>fun</code> 里保存的函数，类似于： <code>s.tab-&gt;fun[0]</code>，而因为 <code>fun</code> 数组里保存的是实体类型实现的函数，所以当函数传入不同的实体类型时，调用的实际上是不同的函数实现，从而实现多态。</p><p>运行一下代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">I am a student.</span><br><span class="line">&#123;19&#125;</span><br><span class="line">I am a programmer.</span><br><span class="line">&#123;100&#125;</span><br></pre></td></tr></table></figure><h1 id="10-Go-接口与-C-接口有何异同"><a href="#10-Go-接口与-C-接口有何异同" class="headerlink" title="10. Go 接口与 C++ 接口有何异同"></a>10. Go 接口与 C++ 接口有何异同</h1><p>接口定义了一种规范，描述了类的行为和功能，而不做具体实现。</p><p>C++ 的接口是使用抽象类来实现的，如果类中至少有一个函数被声明为纯虚函数，则这个类就是抽象类。纯虚函数是通过在声明中使用 “= 0” 来指定的。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="comment">// 纯虚函数</span></span><br><span class="line">      <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">getArea</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">      <span class="built_in">string</span> name;      <span class="comment">// 名称</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>设计抽象类的目的，是为了给其他类提供一个可以继承的适当的基类。抽象类不能被用于实例化对象，它只能作为接口使用。</p><p>派生类需要明确地声明它继承自基类，并且需要实现基类中所有的纯虚函数。</p><p>C++ 定义接口的方式称为“侵入式”，而 Go 采用的是 “非侵入式”，不需要显式声明，只需要实现接口定义的函数，编译器自动会识别。</p><p>C++ 和 Go 在定义接口方式上的不同，也导致了底层实现上的不同。C++ 通过虚函数表来实现基类调用派生类的函数；而 Go 通过 <code>itab</code> 中的 <code>fun</code> 字段来实现接口变量调用实体类型的函数。C++ 中的虚函数表是在编译期生成的；而 Go 的 <code>itab</code> 中的 <code>fun</code> 字段是在运行期间动态生成的。原因在于，Go 中实体类型可能会无意中实现 N 多接口，很多接口并不是本来需要的，所以不能为类型实现的所有接口都生成一个 <code>itab</code>， 这也是“非侵入式”带来的影响；这在 C++ 中是不存在的，因为派生需要显示声明它继承自哪个基类。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://zhuanlan.zhihu.com/p/27055513" target="_blank" rel="noopener">包含反射、接口等源码分析</a></p><p><a href="https://mp.weixin.qq.com/s/jU9HeR1tOyh-ME5iEYM5-Q" target="_blank" rel="noopener">虚函数表和C++的区别</a></p><p><a href="https://tiancaiamao.gitbooks.io/go-internals/content/zh/07.2.html" target="_blank" rel="noopener">具体类型向接口赋值</a></p><p><a href="https://github.com/developer-learning/reading-go/blob/master/content/discuss/2018-08-30-understanding-go-interfaces.md" target="_blank" rel="noopener">Go夜读群的讨论</a></p><p><a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431865288798deef438d865e4c2985acff7e9fad15e3000" target="_blank" rel="noopener">廖雪峰 鸭子类型</a></p><p><a href="https://www.jianshu.com/p/5f8ecbe4f6af" target="_blank" rel="noopener">值类型和指针类型，iface源码</a></p><p><a href="http://www.codeceo.com/article/go-interface.html" target="_blank" rel="noopener">总体说明itab的生成方式、作用</a></p><p><a href="https://blog.csdn.net/zhonglinzhang/article/details/85772336" target="_blank" rel="noopener">conv系列函数的作用</a></p><p><a href="https://www.jianshu.com/p/a5e99b1d50b1" target="_blank" rel="noopener">convI2I itab作用</a></p><p><a href="http://wudaijun.com/2018/01/go-interface-implement/" target="_blank" rel="noopener">interface 源码解读 很不错 包含反射</a></p><p><a href="http://legendtkl.com/2017/06/12/understanding-golang-interface/" target="_blank" rel="noopener">what why how思路来写interface</a></p><p><a href="http://legendtkl.com/2017/07/01/golang-interface-implement/" target="_blank" rel="noopener">有汇编分析，不错</a></p><p><a href="https://www.do1618.com/archives/797/golang-interface%E5%88%86%E6%9E%90/" target="_blank" rel="noopener">第一幅图可以参考 gdb调试</a></p><p><a href="https://my.oschina.net/goal/blog/194308" target="_blank" rel="noopener">类型转换和断言</a></p><p><a href="https://my.oschina.net/goal/blog/194233" target="_blank" rel="noopener">interface 和 nil</a></p><p><a href="https://www.jianshu.com/p/5376e15966b3" target="_blank" rel="noopener">函数和方法</a></p><p><a href="https://flycode.co/archives/267357" target="_blank" rel="noopener">反射</a></p><p><a href="https://segmentfault.com/a/1190000011451232" target="_blank" rel="noopener">接口特点列表</a></p><p><a href="https://www.jianshu.com/p/b38b1719636e" target="_blank" rel="noopener">interface 全面介绍，包含C++对比</a></p><p><a href="https://github.com/ffhelicopter/Go42/blob/master/content/42_19_interface.md" target="_blank" rel="noopener">Go四十二章经 interface</a></p><p><a href="http://blog.zhaojie.me/2013/04/why-i-dont-like-go-style-interface-or-structural-typing.html" target="_blank" rel="noopener">对Go接口的反驳，有说到接口的定义</a></p><p><a href="http://fuxiaohei.me/2017/4/22/gopherchina-2017.html" target="_blank" rel="noopener">gopher 接口</a></p><p><a href="https://mp.weixin.qq.com/s/tBg8D1qXHqBr3r7oRt6iGA" target="_blank" rel="noopener">译文 还不错</a></p><p><a href="https://www.infoq.cn/article/go-interface-talk" target="_blank" rel="noopener">infoQ 文章</a></p><p><a href="https://zhuanlan.zhihu.com/p/27055513" target="_blank" rel="noopener">Go接口详解</a></p><p><a href="https://sanyuesha.com/2017/07/22/how-to-understand-go-interface/" target="_blank" rel="noopener">Go interface</a></p><p><a href="https://www.twblogs.net/a/5c245d59bd9eee16b3db561d" target="_blank" rel="noopener">getitab源码说明</a></p><p><a href="https://yami.io/golang-interface/" target="_blank" rel="noopener">浅显易懂</a></p><p><a href="https://www.jianshu.com/p/8c33f7c84509" target="_blank" rel="noopener">golang io包的妙用</a></p><p><a href="https://www.jianshu.com/p/073c09a05da7&gt;&lt;https://github.com/teh-cmc/go-internals/blob/master/chapter2_interfaces/README.md" target="_blank" rel="noopener">探索C++与Go的接口底层实现</a></p><p><a href="http://xargin.com/go-and-interface/" target="_blank" rel="noopener">汇编层面</a></p><p><a href="https://i6448038.github.io/2018/10/01/Golang-interface/" target="_blank" rel="noopener">有图</a></p><p><a href="https://mp.weixin.qq.com/s/px9BRQrTCLX6BbvXJbysCA" target="_blank" rel="noopener">图</a></p><p><a href="https://github.com/cch123/go-internals/blob/master/chapter2_interfaces/README.md" target="_blank" rel="noopener">英文开源书</a></p><p><a href="http://xargin.com/go-and-interface/" target="_blank" rel="noopener">曹大的翻译</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt; Go语言interface：&lt;/strong&gt; &lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;/excerpt&gt;&lt;/p&gt;
&lt;p&gt;go语言养成记之深度解密Go语言interface&lt;/p&gt;
    
    </summary>
    
      <category term="golang" scheme="https://alexbrucelu.github.io/categories/golang/"/>
    
    
      <category term="golang" scheme="https://alexbrucelu.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>Go语言unsafe</title>
    <link href="https://alexbrucelu.github.io/2019/06/10/%E6%B7%B1%E5%BA%A6%E8%A7%A3%E5%AF%86Go%E8%AF%AD%E8%A8%80%E4%B9%8Bunsafe/"/>
    <id>https://alexbrucelu.github.io/2019/06/10/深度解密Go语言之unsafe/</id>
    <published>2019-06-09T17:22:49.603Z</published>
    <updated>2019-06-09T17:35:00.369Z</updated>
    
    <content type="html"><![CDATA[<p><strong> Go语言unsafe：</strong> <excerpt in="" index="" |="" 首页摘要=""></excerpt></p><p>go语言养成记之深度解密Go语言unsafe</p><a id="more"></a><p>[TOC]</p><p>上一篇<a href="https://mp.weixin.qq.com/s/2CDpE5wfoiNXm1agMAq4wA" target="_blank" rel="noopener">文章</a>我们详细分析了 map 的底层实现，如果你也跟着阅读了源码，那一定对 <code>unsafe.Pointer</code> 不陌生，map 对 key 进行定位的时候，大量使用。</p><p><code>unsafe.Pointer</code> 位于 <code>unsafe 包</code>，这篇文章，我们来深入研究 unsafe 包。先说明一下，本文没有之前那么长了，你可以比较轻松地读完，这样的时候不是太多。</p><p>上次发布文章的时候，包括代码超过 5w 字，后台编辑器的体验非常差，一度让我怀疑人生。我之前说过，像 map 那样的长文，估计能读完的不超过 <code>1 %</code>。像下面这几位同学的评价，并不多见。</p><p><img src="https://user-images.githubusercontent.com/7698088/58759953-7eacfa00-8564-11e9-9d92-9974ffe7f8d7.png" alt="wechat"></p><p>个人认为，学习本身并不是一件轻松愉快的事情，寓教于乐是个美好的愿望。想要深刻地领悟，就得付出别人看不见的努力。学习从来都不会是一件轻松的事情，枯燥是正常的。耐住性子，深入研究某个问题，读书、看文章、写博客都可以，浮躁时代做个专注的人！</p><h1 id="指针类型"><a href="#指针类型" class="headerlink" title="指针类型"></a>指针类型</h1><p>在正式介绍 unsafe 包之前，需要着重介绍 Go 语言中的指针类型。</p><p>我本科开始学编程的时候，第一门语言就是 C。之后又陆续学过 C++，Java，Python，这些语言都挺强大的，但是没了 C 语言那么“单纯”。直到我开始接触 Go 语言，又找到了那种感觉。Go 语言的作者之一 Ken Thompson 也是 C 语言的作者。所以，Go 可以看作 C 系语言，它的很多特性都和 C 类似，指针就是其中之一。</p><p>然而，Go 语言的指针相比 C 的指针有很多限制。这当然是为了安全考虑，要知道像 Java/Python 这些现代语言，生怕程序员出错，哪有什么指针（这里指的是显式的指针）？更别说像 C/C++ 还需要程序员自己清理“垃圾”。所以对于 Go 来说，有指针已经很不错了，仅管它有很多限制。</p><p>为什么需要指针类型呢？参考文献 go101.org 里举了这样一个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">double</span><span class="params">(x <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    x += x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">3</span></span><br><span class="line">    double(a)</span><br><span class="line">    fmt.Println(a) <span class="comment">// 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非常简单，我想在 double 函数里将 a 翻倍，但是例子中的函数却做不到。为什么？因为 Go 语言的函数传参都是<code>值传递</code>。double 函数里的 x 只是实参 a 的一个拷贝，在函数内部对 x 的操作不能反馈到实参 a。</p><p>如果这时，有一个指针就可以解决问题了！这也是我们常用的“伎俩”。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">double</span><span class="params">(x *<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    *x += *x</span><br><span class="line">    x = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">3</span></span><br><span class="line">    double(&amp;a)</span><br><span class="line">    fmt.Println(a) <span class="comment">// 6</span></span><br><span class="line">    </span><br><span class="line">    p := &amp;a</span><br><span class="line">    double(p)</span><br><span class="line">    fmt.Println(a, p == <span class="literal">nil</span>) <span class="comment">// 12 false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很常规的操作，不用多解释。唯一可能有些疑惑的在这一句：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="literal">nil</span></span><br></pre></td></tr></table></figure><p>这得稍微思考一下，才能得出这一行代码根本不影响的结论。因为是值传递，所以 x 也只是对 &amp;a 的一个拷贝。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*x += *x</span><br></pre></td></tr></table></figure><p>这一句把 x 指向的值（也就是 &amp;a 指向的值，即变量 a）变为原来的 2 倍。但是对 x 本身（一个指针）的操作却不会影响外层的 a，所以 <code>x = nil</code> 掀不起任何大风大浪。</p><p>下面的这张图可以“自证清白”：</p><p><img src="https://user-images.githubusercontent.com/7698088/58675362-96c72280-8386-11e9-89a6-f37204648b03.png" alt="pointer copy"></p><p>然而，相比于 C 语言中指针的灵活，Go 的指针多了一些限制。但这也算是 Go 的成功之处：既可以享受指针带来的便利，又避免了指针的危险性。</p><p>限制一：<code>Go 的指针不能进行数学运算</code>。</p><p>来看一个简单的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a := <span class="number">5</span></span><br><span class="line">p := &amp;a</span><br><span class="line"></span><br><span class="line">p++</span><br><span class="line">p = &amp;a + <span class="number">3</span></span><br></pre></td></tr></table></figure><p>上面的代码将不能通过编译，会报编译错误：<code>invalid operation</code>，也就是说不能对指针做数学运算。</p><p>限制二：<code>不同类型的指针不能相互转换</code>。</p><p>例如下面这个简短的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := <span class="keyword">int</span>(<span class="number">100</span>)</span><br><span class="line">    <span class="keyword">var</span> f *<span class="keyword">float64</span></span><br><span class="line">    </span><br><span class="line">    f = &amp;a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也会报编译错误：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cannot use &amp;a (<span class="built_in">type</span> *int) as <span class="built_in">type</span> *float64 <span class="keyword">in</span> assignment</span><br></pre></td></tr></table></figure><p>关于两个指针能否相互转换，参考资料中 go 101 相关文章里写得非常细，这里我不想展开。个人认为记住这些没有什么意义，有完美主义的同学可以去阅读原文。当然我也有完美主义，但我有时会克制，嘿嘿。</p><p>限制三：<code>不同类型的指针不能使用 == 或 != 比较</code>。</p><p>只有在两个指针类型相同或者可以相互转换的情况下，才可以对两者进行比较。另外，指针可以通过 <code>==</code> 和 <code>!=</code> 直接和 <code>nil</code> 作比较。</p><p>限制四：<code>不同类型的指针变量不能相互赋值</code>。</p><p>这一点同限制三。</p><h1 id="什么是-unsafe"><a href="#什么是-unsafe" class="headerlink" title="什么是 unsafe"></a>什么是 unsafe</h1><p>前面所说的指针是类型安全的，但它有很多限制。Go 还有非类型安全的指针，这就是 unsafe 包提供的 unsafe.Pointer。在某些情况下，它会使代码更高效，当然，也更危险。</p><p>unsafe 包用于 Go 编译器，在编译阶段使用。从名字就可以看出来，它是不安全的，官方并不建议使用。我在用 unsafe 包的时候会有一种不舒服的感觉，可能这也是语言设计者的意图吧。</p><p>但是高阶的 Gopher，怎么能不会使用 unsafe 包呢？它可以绕过 Go 语言的类型系统，直接操作内存。例如，一般我们不能操作一个结构体的未导出成员，但是通过 unsafe 包就能做到。unsafe 包让我可以直接读写内存，还管你什么导出还是未导出。</p><h1 id="为什么有-unsafe"><a href="#为什么有-unsafe" class="headerlink" title="为什么有 unsafe"></a>为什么有 unsafe</h1><p>Go 语言类型系统是为了安全和效率设计的，有时，安全会导致效率低下。有了 unsafe 包，高阶的程序员就可以利用它绕过类型系统的低效。因此，它就有了存在的意义，阅读 Go 源码，会发现有大量使用 unsafe 包的例子。</p><h1 id="unsafe-实现原理"><a href="#unsafe-实现原理" class="headerlink" title="unsafe 实现原理"></a>unsafe 实现原理</h1><p>我们来看源码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ArbitraryType <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Pointer *ArbitraryType</span><br></pre></td></tr></table></figure><p>从命名来看，<code>Arbitrary</code> 是任意的意思，也就是说 Pointer 可以指向任意类型，实际上它类似于 C 语言里的 <code>void*</code>。</p><p>unsafe 包还有其他三个函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sizeof</span><span class="params">(x ArbitraryType)</span> <span class="title">uintptr</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">Offsetof</span><span class="params">(x ArbitraryType)</span> <span class="title">uintptr</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">Alignof</span><span class="params">(x ArbitraryType)</span> <span class="title">uintptr</span></span></span><br></pre></td></tr></table></figure><p><code>Sizeof</code> 返回类型 x 所占据的字节数，但不包含 x 所指向的内容的大小。例如，对于一个指针，函数返回的大小为 8 字节（64位机上），一个 slice 的大小则为 slice header 的大小。</p><p><code>Offsetof</code> 返回结构体成员在内存中的位置离结构体起始处的字节数，所传参数必须是结构体的成员。</p><p><code>Alignof</code> 返回 m，m 是指当类型进行内存对齐时，它分配到的内存地址能整除 m。</p><p>注意到以上三个函数返回的结果都是 uintptr 类型，这和 unsafe.Pointer 可以相互转换。三个函数都是在编译期间执行，它们的结果可以直接赋给 <code>const 型变量</code>。另外，因为三个函数执行的结果和操作系统、编译器相关，所以是不可移植的。</p><p>综上所述，unsafe 包提供了 2 点重要的能力：</p><blockquote><ol><li>任何类型的指针和 unsafe.Pointer 可以相互转换。</li><li>uintptr 类型和 unsafe.Pointer 可以相互转换。</li></ol></blockquote><p><img src="https://user-images.githubusercontent.com/7698088/58747453-1dbaee80-849e-11e9-8c75-2459f76792d2.png" alt="type pointer uintptr"></p><p>pointer 不能直接进行数学运算，但可以把它转换成 uintptr，对 uintptr 类型进行数学运算，再转换成 pointer 类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// uintptr 是一个整数类型，它足够大，可以存储</span></span><br><span class="line"><span class="keyword">type</span> <span class="keyword">uintptr</span> <span class="keyword">uintptr</span></span><br></pre></td></tr></table></figure><p>还有一点要注意的是，uintptr 并没有指针的语义，意思就是 uintptr 所指向的对象会被 gc 无情地回收。而 unsafe.Pointer 有指针语义，可以保护它所指向的对象在“有用”的时候不会被垃圾回收。</p><p>unsafe 包中的几个函数都是在编译期间执行完毕，毕竟，编译器对内存分配这些操作“了然于胸”。在 <code>/usr/local/go/src/cmd/compile/internal/gc/unsafe.go</code> 路径下，可以看到编译期间 Go 对 unsafe 包中函数的处理。</p><p>更深层的原理需要去研究编译器的源码，这里就不去深究了。我们重点关注它的用法，接着往下看。</p><h1 id="unsafe-如何使用"><a href="#unsafe-如何使用" class="headerlink" title="unsafe 如何使用"></a>unsafe 如何使用</h1><h2 id="获取-slice-长度"><a href="#获取-slice-长度" class="headerlink" title="获取 slice 长度"></a>获取 slice 长度</h2><p>通过前面关于 slice 的<a href="https://mp.weixin.qq.com/s/MTZ0C9zYsNrb8wyIm2D8BA" target="_blank" rel="noopener">文章</a>，我们知道了 slice header 的结构体定义：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// runtime/slice.go</span></span><br><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span> &#123;</span><br><span class="line">    array unsafe.Pointer <span class="comment">// 元素指针</span></span><br><span class="line">    <span class="built_in">len</span>   <span class="keyword">int</span> <span class="comment">// 长度 </span></span><br><span class="line">    <span class="built_in">cap</span>   <span class="keyword">int</span> <span class="comment">// 容量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用 make 函数新建一个 slice，底层调用的是 makeslice 函数，返回的是 slice 结构体：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeslice</span><span class="params">(et *_type, <span class="built_in">len</span>, <span class="built_in">cap</span> <span class="keyword">int</span>)</span> <span class="title">slice</span></span></span><br></pre></td></tr></table></figure><p>因此我们可以通过 unsafe.Pointer 和 uintptr 进行转换，得到 slice 的字段值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">9</span>, <span class="number">20</span>)</span><br><span class="line">    <span class="keyword">var</span> Len = *(*<span class="keyword">int</span>)(unsafe.Pointer(<span class="keyword">uintptr</span>(unsafe.Pointer(&amp;s)) + <span class="keyword">uintptr</span>(<span class="number">8</span>)))</span><br><span class="line">    fmt.Println(Len, <span class="built_in">len</span>(s)) <span class="comment">// 9 9</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> Cap = *(*<span class="keyword">int</span>)(unsafe.Pointer(<span class="keyword">uintptr</span>(unsafe.Pointer(&amp;s)) + <span class="keyword">uintptr</span>(<span class="number">16</span>)))</span><br><span class="line">    fmt.Println(Cap, <span class="built_in">cap</span>(s)) <span class="comment">// 20 20</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Len，cap 的转换流程如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Len: &amp;s =&gt; pointer =&gt; uintptr =&gt; pointer =&gt; *int =&gt; int</span><br><span class="line">Cap: &amp;s =&gt; pointer =&gt; uintptr =&gt; pointer =&gt; *int =&gt; int</span><br></pre></td></tr></table></figure><h2 id="获取-map-长度"><a href="#获取-map-长度" class="headerlink" title="获取 map 长度"></a>获取 map 长度</h2><p>再来看一下上篇文章我们讲到的 map：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> hmap <span class="keyword">struct</span> &#123;</span><br><span class="line">    count     <span class="keyword">int</span></span><br><span class="line">    flags     <span class="keyword">uint8</span></span><br><span class="line">    B         <span class="keyword">uint8</span></span><br><span class="line">    noverflow <span class="keyword">uint16</span></span><br><span class="line">    hash0     <span class="keyword">uint32</span></span><br><span class="line"></span><br><span class="line">    buckets    unsafe.Pointer</span><br><span class="line">    oldbuckets unsafe.Pointer</span><br><span class="line">    nevacuate  <span class="keyword">uintptr</span></span><br><span class="line"></span><br><span class="line">    extra *mapextra</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和 slice 不同的是，makemap 函数返回的是 hmap 的指针，注意是指针：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makemap</span><span class="params">(t *maptype, hint <span class="keyword">int64</span>, h *hmap, bucket unsafe.Pointer)</span> *<span class="title">hmap</span></span></span><br></pre></td></tr></table></figure><p>我们依然能通过 unsafe.Pointer 和 uintptr 进行转换，得到 hamp 字段的值，只不过，现在 count 变成二级指针了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    mp := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br><span class="line">    mp[<span class="string">"qcrao"</span>] = <span class="number">100</span></span><br><span class="line">    mp[<span class="string">"stefno"</span>] = <span class="number">18</span></span><br><span class="line"></span><br><span class="line">    count := **(**<span class="keyword">int</span>)(unsafe.Pointer(&amp;mp))</span><br><span class="line">    fmt.Println(count, <span class="built_in">len</span>(mp)) <span class="comment">// 2 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>count 的转换过程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&amp;mp =&gt; pointer =&gt; **int =&gt; int</span><br></pre></td></tr></table></figure><h2 id="map-源码中的应用"><a href="#map-源码中的应用" class="headerlink" title="map 源码中的应用"></a>map 源码中的应用</h2><p>在 map 源码中，mapaccess1、mapassign、mapdelete 函数中，需要定位 key 的位置，会先对 key 做哈希运算。</p><p>例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b := (*bmap)(unsafe.Pointer(<span class="keyword">uintptr</span>(h.buckets) + (hash&amp;m)*<span class="keyword">uintptr</span>(t.bucketsize)))</span><br></pre></td></tr></table></figure><p><code>h.buckets</code> 是一个 <code>unsafe.Pointer</code>，将它转换成 <code>uintptr</code>，然后加上 <code>(hash&amp;m)*uintptr(t.bucketsize)</code>，二者相加的结果再次转换成 <code>unsafe.Pointer</code>，最后，转换成 <code>bmap 指针</code>，得到 key 所落入的 bucket 位置。如果不熟悉这个公式，可以看看上一篇文章，浅显易懂。</p><p>上面举的例子相对简单，来看一个关于赋值的更难一点的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// store new key/value at insert position</span></span><br><span class="line"><span class="keyword">if</span> t.indirectkey &#123;</span><br><span class="line">    kmem := newobject(t.key)</span><br><span class="line">    *(*unsafe.Pointer)(insertk) = kmem</span><br><span class="line">    insertk = kmem</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> t.indirectvalue &#123;</span><br><span class="line">    vmem := newobject(t.elem)</span><br><span class="line">    *(*unsafe.Pointer)(val) = vmem</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">typedmemmove(t.key, insertk, key)</span><br></pre></td></tr></table></figure><p>这段代码是在找到了 key 要插入的位置后，进行“赋值”操作。insertk 和 val 分别表示 key 和 value 所要“放置”的地址。如果 t.indirectkey 为真，说明 bucket 中存储的是 key 的指针，因此需要将 insertk 看成<code>指针的指针</code>，这样才能将 bucket 中的相应位置的值设置成指向真实 key 的地址值，也就是说 key 存放的是指针。</p><p>下面这张图展示了设置 key 的全部操作：</p><p><img src="https://user-images.githubusercontent.com/7698088/58756044-c1e67900-8522-11e9-9dda-72ba2a731acf.png" alt="map assign"></p><p>obj 是真实的 key 存放的地方。第 4 号图，obj 表示执行完 <code>typedmemmove</code> 函数后，被成功赋值。</p><h2 id="Offsetof-获取成员偏移量"><a href="#Offsetof-获取成员偏移量" class="headerlink" title="Offsetof 获取成员偏移量"></a>Offsetof 获取成员偏移量</h2><p>对于一个结构体，通过 offset 函数可以获取结构体成员的偏移量，进而获取成员的地址，读写该地址的内存，就可以达到改变成员值的目的。</p><p>这里有一个内存分配相关的事实：结构体会被分配一块连续的内存，结构体的地址也代表了第一个成员的地址。</p><p>我们来看一个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"unsafe"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Programmer <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">    language <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    p := Programmer&#123;<span class="string">"stefno"</span>, <span class="string">"go"</span>&#125;</span><br><span class="line">    fmt.Println(p)</span><br><span class="line">    </span><br><span class="line">    name := (*<span class="keyword">string</span>)(unsafe.Pointer(&amp;p))</span><br><span class="line">    *name = <span class="string">"qcrao"</span></span><br><span class="line"></span><br><span class="line">    lang := (*<span class="keyword">string</span>)(unsafe.Pointer(<span class="keyword">uintptr</span>(unsafe.Pointer(&amp;p)) + unsafe.Offsetof(p.language)))</span><br><span class="line">    *lang = <span class="string">"Golang"</span></span><br><span class="line"></span><br><span class="line">    fmt.Println(p)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行代码，输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;stefno go&#125;</span><br><span class="line">&#123;qcrao Golang&#125;</span><br></pre></td></tr></table></figure><p>name 是结构体的第一个成员，因此可以直接将 &amp;p 解析成 *string。这一点，在前面获取 map 的 count 成员时，用的是同样的原理。</p><p>对于结构体的私有成员，现在有办法可以通过 unsafe.Pointer 改变它的值了。</p><p>我把 Programmer 结构体升级，多加一个字段：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Programmer <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">    age <span class="keyword">int</span></span><br><span class="line">    language <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并且放在其他包，这样在 main 函数中，它的三个字段都是私有成员变量，不能直接修改。但我通过 unsafe.Sizeof() 函数可以获取成员大小，进而计算出成员的地址，直接修改内存。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    p := Programmer&#123;<span class="string">"stefno"</span>, <span class="number">18</span>, <span class="string">"go"</span>&#125;</span><br><span class="line">    fmt.Println(p)</span><br><span class="line"></span><br><span class="line">    lang := (*<span class="keyword">string</span>)(unsafe.Pointer(<span class="keyword">uintptr</span>(unsafe.Pointer(&amp;p)) + unsafe.Sizeof(<span class="keyword">int</span>(<span class="number">0</span>)) + unsafe.Sizeof(<span class="keyword">string</span>(<span class="string">""</span>))))</span><br><span class="line">    *lang = <span class="string">"Golang"</span></span><br><span class="line"></span><br><span class="line">    fmt.Println(p)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;stefno 18 go&#125;</span><br><span class="line">&#123;stefno 18 Golang&#125;</span><br></pre></td></tr></table></figure><h2 id="string-和-slice-的相互转换"><a href="#string-和-slice-的相互转换" class="headerlink" title="string 和 slice 的相互转换"></a>string 和 slice 的相互转换</h2><p>这是一个非常精典的例子。实现字符串和 bytes 切片之间的转换，要求是 <code>zero-copy</code>。想一下，一般的做法，都需要遍历字符串或 bytes 切片，再挨个赋值。</p><p>完成这个任务，我们需要了解 slice 和 string 的底层数据结构：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> StringHeader <span class="keyword">struct</span> &#123;</span><br><span class="line">    Data <span class="keyword">uintptr</span></span><br><span class="line">    Len  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> SliceHeader <span class="keyword">struct</span> &#123;</span><br><span class="line">    Data <span class="keyword">uintptr</span></span><br><span class="line">    Len  <span class="keyword">int</span></span><br><span class="line">    Cap  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是反射包下的结构体，路径：src/reflect/value.go。只需要共享底层 []byte 数组就可以实现 <code>zero-copy</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">string2bytes</span><span class="params">(s <span class="keyword">string</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">    stringHeader := (*reflect.StringHeader)(unsafe.Pointer(&amp;s))</span><br><span class="line"></span><br><span class="line">    bh := reflect.SliceHeader&#123;</span><br><span class="line">        Data: stringHeader.Data,</span><br><span class="line">        Len:  stringHeader.Len,</span><br><span class="line">        Cap:  stringHeader.Len,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> *(*[]<span class="keyword">byte</span>)(unsafe.Pointer(&amp;bh))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bytes2string</span><span class="params">(b []<span class="keyword">byte</span>)</span> <span class="title">string</span></span>&#123;</span><br><span class="line">    sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&amp;b))</span><br><span class="line"></span><br><span class="line">    sh := reflect.StringHeader&#123;</span><br><span class="line">        Data: sliceHeader.Data,</span><br><span class="line">        Len:  sliceHeader.Len,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> *(*<span class="keyword">string</span>)(unsafe.Pointer(&amp;sh))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码比较简单，不作详细解释。通过构造 slice header 和 string header，来完成 string 和 byte slice 之间的转换。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>unsafe 包绕过了 Go 的类型系统，达到直接操作内存的目的，使用它有一定的风险性。但是在某些场景下，使用 unsafe 包提供的函数会提升代码的效率，Go 源码中也是大量使用 unsafe 包。</p><p>unsafe 包定义了 Pointer 和三个函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ArbitraryType <span class="keyword">int</span></span><br><span class="line"><span class="keyword">type</span> Pointer *ArbitraryType</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sizeof</span><span class="params">(x ArbitraryType)</span> <span class="title">uintptr</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">Offsetof</span><span class="params">(x ArbitraryType)</span> <span class="title">uintptr</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">Alignof</span><span class="params">(x ArbitraryType)</span> <span class="title">uintptr</span></span></span><br></pre></td></tr></table></figure><p>通过三个函数可以获取变量的大小、偏移、对齐等信息。</p><p>uintptr 可以和 unsafe.Pointer 进行相互转换，uintptr 可以进行数学运算。这样，通过 uintptr 和 unsafe.Pointer 的结合就解决了 Go 指针不能进行数学运算的限制。</p><p>通过 unsafe 相关函数，可以获取结构体私有成员的地址，进而对其做进一步的读写操作，突破 Go 的类型安全限制。关于 unsafe 包，我们更多关注它的用法。</p><p>顺便说一句，unsafe 包用多了之后，也不觉得它的名字有多么地不“美观”了。相反，因为使用了官方并不提倡的东西，反而觉得有点酷炫。这就是叛逆的感觉吧。</p><p>最后，点击<a href="https://github.com/qcrao/Go-Questions" target="_blank" rel="noopener">阅读原文</a>，你将参与见证一个千星项目的成长，你值得拥有！</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.flysnow.org/2017/07/06/go-in-action-unsafe-pointer.html" target="_blank" rel="noopener">飞雪无情的博客</a></p><p><a href="https://gocn.vip/question/371" target="_blank" rel="noopener">译文 unsafe包详解</a></p><p><a href="https://golang.org/pkg/unsafe/" target="_blank" rel="noopener">官方文档</a></p><p><a href="http://www.opscoder.info/golang_unsafe.html" target="_blank" rel="noopener">例子</a></p><p><a href="https://segmentfault.com/a/1190000017389782" target="_blank" rel="noopener">煎鱼大佬的博客</a></p><p><a href="https://www.kancloud.cn/wizardforcel/gopl-zh/106477" target="_blank" rel="noopener">go语言圣经</a></p><p><a href="https://blog.gopheracademy.com/advent-2017/unsafe-pointer-and-system-calls/" target="_blank" rel="noopener">pointer and system calls</a></p><p><a href="https://my.oschina.net/xinxingegeya/blog/729673" target="_blank" rel="noopener">pointer and uintptr</a></p><p><a href="https://go101.org/article/unsafe.html" target="_blank" rel="noopener">unsafe.pointer</a></p><p><a href="https://go101.org/article/pointer.html" target="_blank" rel="noopener">go 指针类型</a></p><p><a href="https://juejin.im/post/5c189dce5188256b2e71e79b" target="_blank" rel="noopener">码洞 快学Go语言 unsafe</a></p><p><a href="https://golang.org/pkg/unsafe/" target="_blank" rel="noopener">官方文档</a></p><p><a href="http://www.opscoder.info/golang_unsafe.html" target="_blank" rel="noopener">jasper 的小窝</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt; Go语言unsafe：&lt;/strong&gt; &lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;/excerpt&gt;&lt;/p&gt;
&lt;p&gt;go语言养成记之深度解密Go语言unsafe&lt;/p&gt;
    
    </summary>
    
      <category term="golang" scheme="https://alexbrucelu.github.io/categories/golang/"/>
    
    
      <category term="golang" scheme="https://alexbrucelu.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>Go语言内存分配</title>
    <link href="https://alexbrucelu.github.io/2019/06/04/%E5%9B%BE%E8%A7%A3Go%E8%AF%AD%E8%A8%80%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/"/>
    <id>https://alexbrucelu.github.io/2019/06/04/图解Go语言内存分配/</id>
    <published>2019-06-03T18:06:49.604Z</published>
    <updated>2019-06-03T18:19:00.030Z</updated>
    
    <content type="html"><![CDATA[<p><strong> Go语言内存分配：</strong> <excerpt in="" index="" |="" 首页摘要=""></excerpt></p><p>go语言养成记之Go语言内存分配</p><a id="more"></a><p>[TOC]</p><p>Go语言内置运行时（就是runtime），抛弃了传统的内存分配方式，改为自主管理。这样可以自主地实现更好的内存使用模式，比如内存池、预分配等等。这样，不会每次内存分配都需要进行系统调用。</p><p>Golang运行时的内存分配算法主要源自 Google 为 C 语言开发的<code>TCMalloc算法</code>，全称<code>Thread-Caching Malloc</code>。核心思想就是把内存分为多级管理，从而降低锁的粒度。它将可用的堆内存采用二级分配的方式进行管理：每个线程都会自行维护一个独立的内存池，进行内存分配时优先从该内存池中分配，当内存池不足时才会向全局内存池申请，以避免不同线程对全局内存池的频繁竞争。</p><h1 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h1><p>Go在程序启动的时候，会先向操作系统申请一块内存（注意这时还只是一段虚拟的地址空间，并不会真正地分配内存），切成小块后自己进行管理。</p><p>申请到的内存块被分配了三个区域，在X64上分别是512MB，16GB，512GB大小。</p><p><img src="https://user-images.githubusercontent.com/7698088/54165891-9e6cde80-449d-11e9-8947-14e6f75f4089.png" alt="堆区总览"></p><p><code>arena区域</code>就是我们所谓的堆区，Go动态分配的内存都是在这个区域，它把内存分割成<code>8KB</code>大小的页，一些页组合起来称为<code>mspan</code>。</p><p><code>bitmap区域</code>标识<code>arena</code>区域哪些地址保存了对象，并且用<code>4bit</code>标志位表示对象是否包含指针、<code>GC</code>标记信息。<code>bitmap</code>中一个<code>byte</code>大小的内存对应<code>arena</code>区域中4个指针大小（指针大小为 8B ）的内存，所以<code>bitmap</code>区域的大小是<code>512GB/(4*8B)=16GB</code>。</p><p><img src="https://user-images.githubusercontent.com/7698088/54197565-3a7b0200-44ff-11e9-92e2-34185ee3e0bc.png" alt="bitmap arena"></p><p><img src="https://user-images.githubusercontent.com/7698088/54197295-85484a00-44fe-11e9-9c77-9836120b8454.png" alt="bitmap arena"></p><p>从上图其实还可以看到bitmap的高地址部分指向arena区域的低地址部分，也就是说bitmap的地址是由高地址向低地址增长的。</p><p><code>spans区域</code>存放<code>mspan</code>（也就是一些<code>arena</code>分割的页组合起来的内存管理基本单元，后文会再讲）的指针，每个指针对应一页，所以<code>spans</code>区域的大小就是<code>512GB/8KB*8B=512MB</code>。除以8KB是计算<code>arena</code>区域的页数，而最后乘以8是计算<code>spans</code>区域所有指针的大小。创建<code>mspan</code>的时候，按页填充对应的<code>spans</code>区域，在回收<code>object</code>时，根据地址很容易就能找到它所属的<code>mspan</code>。</p><h1 id="内存管理单元"><a href="#内存管理单元" class="headerlink" title="内存管理单元"></a>内存管理单元</h1><p><code>mspan</code>：Go中内存管理的基本单元，是由一片连续的<code>8KB</code>的页组成的大块内存。注意，这里的页和操作系统本身的页并不是一回事，它一般是操作系统页大小的几倍。一句话概括：<code>mspan</code>是一个包含起始地址、<code>mspan</code>规格、页的数量等内容的双端链表。</p><p>每个<code>mspan</code>按照它自身的属性<code>Size Class</code>的大小分割成若干个<code>object</code>，每个<code>object</code>可存储一个对象。并且会使用一个位图来标记其尚未使用的<code>object</code>。属性<code>Size Class</code>决定<code>object</code>大小，而<code>mspan</code>只会分配给和<code>object</code>尺寸大小接近的对象，当然，对象的大小要小于<code>object</code>大小。还有一个概念：<code>Span Class</code>，它和<code>Size Class</code>的含义差不多，</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Size_Class = Span_Class / <span class="number">2</span></span><br></pre></td></tr></table></figure><p>这是因为其实每个 <code>Size Class</code>有两个<code>mspan</code>，也就是有两个<code>Span Class</code>。其中一个分配给含有指针的对象，另一个分配给不含有指针的对象。这会给垃圾回收机制带来利好，之后的文章再谈。</p><p>如下图，<code>mspan</code>由一组连续的页组成，按照一定大小划分成<code>object</code>。</p><p><img src="https://user-images.githubusercontent.com/7698088/54070690-0b198a80-429e-11e9-8838-eef9cd160f5c.png" alt="page mspan"></p><p>Go1.9.2里<code>mspan</code>的<code>Size Class</code>共有67种，每种<code>mspan</code>分割的object大小是8*2n的倍数，这个是写死在代码里的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// path: /usr/local/go/src/runtime/sizeclasses.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> _NumSizeClasses = <span class="number">67</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> class_to_size = [_NumSizeClasses]<span class="keyword">uint16</span>&#123;<span class="number">0</span>, <span class="number">8</span>, <span class="number">16</span>, <span class="number">32</span>, <span class="number">48</span>, <span class="number">64</span>, <span class="number">80</span>, <span class="number">96</span>, <span class="number">112</span>, <span class="number">128</span>, <span class="number">144</span>, <span class="number">160</span>, <span class="number">176</span>, <span class="number">192</span>, <span class="number">208</span>, <span class="number">224</span>, <span class="number">240</span>, <span class="number">256</span>, <span class="number">288</span>, <span class="number">320</span>, <span class="number">352</span>, <span class="number">384</span>, <span class="number">416</span>, <span class="number">448</span>, <span class="number">480</span>, <span class="number">512</span>, <span class="number">576</span>, <span class="number">640</span>, <span class="number">704</span>, <span class="number">768</span>, <span class="number">896</span>, <span class="number">1024</span>, <span class="number">1152</span>, <span class="number">1280</span>, <span class="number">1408</span>, <span class="number">1536</span>,<span class="number">1792</span>, <span class="number">2048</span>, <span class="number">2304</span>, <span class="number">2688</span>, <span class="number">3072</span>, <span class="number">3200</span>, <span class="number">3456</span>, <span class="number">4096</span>, <span class="number">4864</span>, <span class="number">5376</span>, <span class="number">6144</span>, <span class="number">6528</span>, <span class="number">6784</span>, <span class="number">6912</span>, <span class="number">8192</span>, <span class="number">9472</span>, <span class="number">9728</span>, <span class="number">10240</span>, <span class="number">10880</span>, <span class="number">12288</span>, <span class="number">13568</span>, <span class="number">14336</span>, <span class="number">16384</span>, <span class="number">18432</span>, <span class="number">19072</span>, <span class="number">20480</span>, <span class="number">21760</span>, <span class="number">24576</span>, <span class="number">27264</span>, <span class="number">28672</span>, <span class="number">32768</span>&#125;</span><br></pre></td></tr></table></figure><p>根据<code>mspan</code>的<code>Size Class</code>可以得到它划分的<code>object</code>大小。 比如<code>Size Class</code>等于3，<code>object</code>大小就是32B。 32B大小的object可以存储对象大小范围在17B~32B的对象。而对于微小对象（小于16B），分配器会将其进行合并，将几个对象分配到同一个<code>object</code>中。</p><p>数组里最大的数是32768，也就是32KB，超过此大小就是大对象了，它会被特别对待，这个稍后会再介绍。顺便提一句，类型<code>Size Class</code>为0表示大对象，它实际上直接由堆内存分配，而小对象都要通过<code>mspan</code>来分配。</p><p>对于mspan来说，它的<code>Size Class</code>会决定它所能分到的页数，这也是写死在代码里的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// path: /usr/local/go/src/runtime/sizeclasses.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> _NumSizeClasses = <span class="number">67</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> class_to_allocnpages = [_NumSizeClasses]<span class="keyword">uint8</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">10</span>, <span class="number">7</span>, <span class="number">4</span>&#125;</span><br></pre></td></tr></table></figure><p>比如当我们要申请一个<code>object</code>大小为<code>32B</code>的<code>mspan</code>的时候，在class_to_size里对应的索引是3，而索引3在<code>class_to_allocnpages</code>数组里对应的页数就是1。</p><p><code>mspan</code>结构体定义：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// path: /usr/local/go/src/runtime/mheap.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> mspan <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">//链表前向指针，用于将span链接起来</span></span><br><span class="line">    next *mspan </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//链表前向指针，用于将span链接起来</span></span><br><span class="line">    prev *mspan </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 起始地址，也即所管理页的地址</span></span><br><span class="line">    startAddr <span class="keyword">uintptr</span> </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 管理的页数</span></span><br><span class="line">    npages <span class="keyword">uintptr</span> </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 块个数，表示有多少个块可供分配</span></span><br><span class="line">    nelems <span class="keyword">uintptr</span> </span><br><span class="line"></span><br><span class="line">    <span class="comment">//分配位图，每一位代表一个块是否已分配</span></span><br><span class="line">    allocBits *gcBits </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 已分配块的个数</span></span><br><span class="line">    allocCount <span class="keyword">uint16</span> </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// class表中的class ID，和Size Classs相关</span></span><br><span class="line">    spanclass spanClass  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// class表中的对象大小，也即块大小</span></span><br><span class="line">    elemsize <span class="keyword">uintptr</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们将<code>mspan</code>放到更大的视角来看：</p><p><img src="https://user-images.githubusercontent.com/7698088/54192326-a440df00-44f2-11e9-950a-bbdfb7c36e62.png" alt="mspan更大视角"></p><p>上图可以看到有两个<code>S</code>指向了同一个<code>mspan</code>，因为这两个<code>S</code>指向的<code>P</code>是同属一个<code>mspan</code>的。所以，通过<code>arena</code>上的地址可以快速找到指向它的<code>S</code>，通过<code>S</code>就能找到<code>mspan</code>，回忆一下前面我们说的<code>mspan</code>区域的每个指针对应一页。</p><p>假设最左边第一个<code>mspan</code>的<code>Size Class</code>等于10，根据前面的<code>class_to_size</code>数组，得出这个<code>msapn</code>分割的<code>object</code>大小是144B，算出可分配的对象个数是<code>8KB/144B=56.89</code>个，取整56个，所以会有一些内存浪费掉了，Go的源码里有所有<code>Size Class</code>的<code>mspan</code>浪费的内存的大小；再根据<code>class_to_allocnpages</code>数组，得到这个<code>mspan</code>只由1个<code>page</code>组成；假设这个<code>mspan</code>是分配给无指针对象的，那么<code>spanClass</code>等于20。</p><p><code>startAddr</code>直接指向<code>arena</code>区域的某个位置，表示这个<code>mspan</code>的起始地址，<code>allocBits</code>指向一个位图，每位代表一个块是否被分配了对象；<code>allocCount</code>则表示总共已分配的对象个数。</p><p>这样，左起第一个<code>mspan</code>的各个字段参数就如下图所示：</p><p><img src="https://user-images.githubusercontent.com/7698088/54210478-87200680-451a-11e9-98dc-2e5adbb43d4a.png" alt="左起第一个mspan具体值"></p><h1 id="内存管理组件"><a href="#内存管理组件" class="headerlink" title="内存管理组件"></a>内存管理组件</h1><p>内存分配由内存分配器完成。分配器由3种组件构成：<code>mcache</code>, <code>mcentral</code>, <code>mheap</code>。</p><h2 id="mcache"><a href="#mcache" class="headerlink" title="mcache"></a>mcache</h2><p><code>mcache</code>：每个工作线程都会绑定一个mcache，本地缓存可用的<code>mspan</code>资源，这样就可以直接给Goroutine分配，因为不存在多个Goroutine竞争的情况，所以不会消耗锁资源。</p><p><code>mcache</code>的结构体定义：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//path: /usr/local/go/src/runtime/mcache.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> mcache <span class="keyword">struct</span> &#123;</span><br><span class="line">    alloc [numSpanClasses]*mspan</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">numSpanClasses = _NumSizeClasses &lt;&lt; <span class="number">1</span></span><br></pre></td></tr></table></figure><p><code>mcache</code>用<code>Span Classes</code>作为索引管理多个用于分配的<code>mspan</code>，它包含所有规格的<code>mspan</code>。它是<code>_NumSizeClasses</code>的2倍，也就是<code>67*2=134</code>，为什么有一个两倍的关系，前面我们提到过：为了加速之后内存回收的速度，数组里一半的<code>mspan</code>中分配的对象不包含指针，另一半则包含指针。</p><p>对于无指针对象的<code>mspan</code>在进行垃圾回收的时候无需进一步扫描它是否引用了其他活跃的对象。 后面的垃圾回收文章会再讲到，这次先到这里。</p><p><img src="https://user-images.githubusercontent.com/7698088/54191324-a86bfd00-44f0-11e9-9039-3b64d39036d9.png" alt="mcache"></p><p><code>mcache</code>在初始化的时候是没有任何<code>mspan</code>资源的，在使用过程中会动态地从<code>mcentral</code>申请，之后会缓存下来。当对象小于等于32KB大小时，使用<code>mcache</code>的相应规格的<code>mspan</code>进行分配。</p><h2 id="mcentral"><a href="#mcentral" class="headerlink" title="mcentral"></a>mcentral</h2><p><code>mcentral</code>：为所有<code>mcache</code>提供切分好的<code>mspan</code>资源。每个<code>central</code>保存一种特定大小的全局<code>mspan</code>列表，包括已分配出去的和未分配出去的。 每个<code>mcentral</code>对应一种<code>mspan</code>，而<code>mspan</code>的种类导致它分割的<code>object</code>大小不同。当工作线程的<code>mcache</code>中没有合适（也就是特定大小的）的<code>mspan</code>时就会从<code>mcentral</code>获取。</p><p><code>mcentral</code>被所有的工作线程共同享有，存在多个Goroutine竞争的情况，因此会消耗锁资源。结构体定义：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//path: /usr/local/go/src/runtime/mcentral.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> mcentral <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 互斥锁</span></span><br><span class="line">    lock mutex </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 规格</span></span><br><span class="line">    sizeclass <span class="keyword">int32</span> </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 尚有空闲object的mspan链表</span></span><br><span class="line">    nonempty mSpanList </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 没有空闲object的mspan链表，或者是已被mcache取走的msapn链表</span></span><br><span class="line">    empty mSpanList </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 已累计分配的对象个数</span></span><br><span class="line">    nmalloc <span class="keyword">uint64</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://user-images.githubusercontent.com/7698088/54211962-2219e000-451d-11e9-85e1-0e8200925fa5.png" alt="mcentral"></p><p><code>empty</code>表示这条链表里的<code>mspan</code>都被分配了<code>object</code>，或者是已经被<code>cache</code>取走了的<code>mspan</code>，这个<code>mspan</code>就被那个工作线程独占了。而<code>nonempty</code>则表示有空闲对象的<code>mspan</code>列表。每个<code>central</code>结构体都在<code>mheap</code>中维护。</p><p>简单说下<code>mcache</code>从<code>mcentral</code>获取和归还<code>mspan</code>的流程：</p><ul><li>获取<br>加锁；从<code>nonempty</code>链表找到一个可用的<code>mspan</code>；并将其从<code>nonempty</code>链表删除；将取出的<code>mspan</code>加入到<code>empty</code>链表；将<code>mspan</code>返回给工作线程；解锁。</li><li>归还<br>加锁；将<code>mspan</code>从<code>empty</code>链表删除；将<code>mspan</code>加入到<code>nonempty</code>链表；解锁。</li></ul><h2 id="mheap"><a href="#mheap" class="headerlink" title="mheap"></a>mheap</h2><p><code>mheap</code>：代表Go程序持有的所有堆空间，Go程序使用一个<code>mheap</code>的全局对象<code>_mheap</code>来管理堆内存。</p><p>当<code>mcentral</code>没有空闲的<code>mspan</code>时，会向<code>mheap</code>申请。而<code>mheap</code>没有资源时，会向操作系统申请新内存。<code>mheap</code>主要用于大对象的内存分配，以及管理未切割的<code>mspan</code>，用于给<code>mcentral</code>切割成小对象。</p><p>同时我们也看到，<code>mheap</code>中含有所有规格的<code>mcentral</code>，所以，当一个<code>mcache</code>从<code>mcentral</code>申请<code>mspan</code>时，只需要在独立的<code>mcentral</code>中使用锁，并不会影响申请其他规格的<code>mspan</code>。</p><p><code>mheap</code>结构体定义：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//path: /usr/local/go/src/runtime/mheap.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> mheap <span class="keyword">struct</span> &#123;</span><br><span class="line">    lock mutex</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// spans: 指向mspans区域，用于映射mspan和page的关系</span></span><br><span class="line">    spans []*mspan </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 指向bitmap首地址，bitmap是从高地址向低地址增长的</span></span><br><span class="line">    bitmap <span class="keyword">uintptr</span> </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指示arena区首地址</span></span><br><span class="line">    arena_start <span class="keyword">uintptr</span> </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 指示arena区已使用地址位置</span></span><br><span class="line">    arena_used  <span class="keyword">uintptr</span> </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 指示arena区末地址</span></span><br><span class="line">    arena_end   <span class="keyword">uintptr</span> </span><br><span class="line"></span><br><span class="line">    central [<span class="number">67</span>*<span class="number">2</span>]<span class="keyword">struct</span> &#123;</span><br><span class="line">        mcentral mcentral</span><br><span class="line">        pad [sys.CacheLineSize - unsafe.Sizeof(mcentral&#123;&#125;)%sys.CacheLineSize]<span class="keyword">byte</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://user-images.githubusercontent.com/7698088/54213273-1cbd9500-451f-11e9-93e4-28f39615b6a2.png" alt="mheap"></p><p>上图我们看到，bitmap和arena_start指向了同一个地址，这是因为bitmap的地址是从高到低增长的，所以他们指向的内存位置相同。</p><h1 id="内存分配流程"><a href="#内存分配流程" class="headerlink" title="内存分配流程"></a>内存分配流程</h1><p>上一篇文章<a href="https://www.cnblogs.com/qcrao-2018/p/10453260.html" target="_blank" rel="noopener">《Golang之变量去哪儿》</a>中我们提到了，变量是在栈上分配还是在堆上分配，是由逃逸分析的结果决定的。通常情况下，编译器是倾向于将变量分配到栈上的，因为它的开销小，最极端的就是”zero garbage”，所有的变量都会在栈上分配，这样就不会存在内存碎片，垃圾回收之类的东西。</p><p>Go的内存分配器在分配对象时，根据对象的大小，分成三类：小对象（小于等于16B）、一般对象（大于16B，小于等于32KB）、大对象（大于32KB）。</p><p>大体上的分配流程：</p><ul><li><blockquote><p>32KB 的对象，直接从mheap上分配；</p></blockquote></li><li><p>&lt;=16B 的对象使用mcache的tiny分配器分配；</p></li><li><p>(16B,32KB] 的对象，首先计算对象的规格大小，然后使用mcache中相应规格大小的mspan分配；</p><ul><li>如果mcache没有相应规格大小的mspan，则向mcentral申请</li><li>如果mcentral没有相应规格大小的mspan，则向mheap申请</li><li>如果mheap中也没有合适大小的mspan，则向操作系统申请</li></ul></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Go语言的内存分配非常复杂，它的一个原则就是能复用的一定要复用。源码很难追，后面可能会再来一篇关于内存分配的源码阅读相关的文章。简单总结一下本文吧。</p><p>文章从一个比较粗的角度来看Go的内存分配，并没有深入细节。一般而言，了解它的原理，到这个程度也可以了。</p><ul><li>Go在程序启动时，会向操作系统申请一大块内存，之后自行管理。</li><li>Go内存管理的基本单元是mspan，它由若干个页组成，每种mspan可以分配特定大小的object。</li><li>mcache, mcentral, mheap是Go内存管理的三大组件，层层递进。mcache管理线程在本地缓存的mspan；mcentral管理全局的mspan供所有线程使用；mheap管理Go的所有动态分配内存。</li><li>极小对象会分配在一个object中，以节省资源，使用tiny分配器分配内存；一般小对象通过mspan分配内存；大对象则直接由mheap分配内存。</li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://yq.aliyun.com/articles/652551" target="_blank" rel="noopener">简单易懂，非常清晰</a></p><p><a href="https://www.jianshu.com/p/47691d870756" target="_blank" rel="noopener">内存分配器的初始化过程，分配流程图很详细</a></p><p><a href="https://swanspouse.github.io/2018/08/22/golang-memory-model/" target="_blank" rel="noopener">全局的图</a></p><p><a href="https://github.com/qyuhen/book" target="_blank" rel="noopener">雨痕 Go1.5源码阅读</a></p><p><a href="https://www.jianshu.com/p/47691d870756" target="_blank" rel="noopener">图不错</a></p><p><a href="https://juejin.im/post/59f2e19f5188253d6816d504" target="_blank" rel="noopener">整体感</a></p><p><a href="http://legendtkl.com/2017/04/02/golang-alloc/" target="_blank" rel="noopener">源码解读</a></p><p><a href="https://www.linuxzen.com/go-memory-allocator-visual-guide.html" target="_blank" rel="noopener">重点推荐 深入到晶体管了 图很好</a></p><p><a href="http://gocode.cc/project/4/article/103" target="_blank" rel="noopener">总体描述对象分配流程</a></p><p><a href="https://mikespook.com/2014/12/%E7%90%86%E8%A7%A3-go-%E8%AF%AD%E8%A8%80%E7%9A%84%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8/" target="_blank" rel="noopener">实际Linux命令</a></p><p><a href="http://blog.newbmiao.com/2018/08/20/go-source-analysis-of-memory-alloc.html" target="_blank" rel="noopener">整体流程图 对象分配函数调用链路</a></p><p><a href="https://www.cnblogs.com/zkweb/p/7880099.html" target="_blank" rel="noopener">源码讲解 非常细致</a></p><p><a href="https://zhuanlan.zhihu.com/p/34930748" target="_blank" rel="noopener">源码阅读</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt; Go语言内存分配：&lt;/strong&gt; &lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;/excerpt&gt;&lt;/p&gt;
&lt;p&gt;go语言养成记之Go语言内存分配&lt;/p&gt;
    
    </summary>
    
      <category term="golang" scheme="https://alexbrucelu.github.io/categories/golang/"/>
    
    
      <category term="golang" scheme="https://alexbrucelu.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>Golang之轻松化解defer的温柔陷阱</title>
    <link href="https://alexbrucelu.github.io/2019/06/04/Golang%E4%B9%8B%E8%BD%BB%E6%9D%BE%E5%8C%96%E8%A7%A3defer%E7%9A%84%E6%B8%A9%E6%9F%94%E9%99%B7%E9%98%B1/"/>
    <id>https://alexbrucelu.github.io/2019/06/04/Golang之轻松化解defer的温柔陷阱/</id>
    <published>2019-06-03T17:59:31.135Z</published>
    <updated>2019-06-03T18:04:09.729Z</updated>
    
    <content type="html"><![CDATA[<p><strong> Golang之轻松化解defer的温柔陷阱：</strong> <excerpt in="" index="" |="" 首页摘要=""></excerpt></p><p>Golang之轻松化解defer的温柔陷阱</p><a id="more"></a><p>[TOC]</p><h1 id="什么是defer？"><a href="#什么是defer？" class="headerlink" title="什么是defer？"></a>什么是defer？</h1><p><code>defer</code>是Go语言提供的一种用于注册延迟调用的机制：让函数或语句可以在当前函数执行完毕后（包括通过return正常结束或者panic导致的异常结束）执行。</p><p><code>defer</code>语句通常用于一些成对操作的场景：打开连接/关闭连接；加锁/释放锁；打开文件/关闭文件等。</p><p><code>defer</code>在一些需要回收资源的场景非常有用，可以很方便地在函数结束前做一些清理操作。在打开资源语句的下一行，直接一句defer就可以在函数返回前关闭资源，可谓相当优雅。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f, _ := os.Open(<span class="string">"defer.txt"</span>)</span><br><span class="line"><span class="keyword">defer</span> f.Close()</span><br></pre></td></tr></table></figure><p>注意：以上代码，忽略了err, 实际上应该先判断是否出错，如果出错了，直接return. 接着再判断<code>f</code>是否为空，如果<code>f</code>为空，就不能调用<code>f.Close()</code>函数了，会直接panic的。</p><h1 id="为什么需要defer？"><a href="#为什么需要defer？" class="headerlink" title="为什么需要defer？"></a>为什么需要defer？</h1><p>程序员在编程的时候，经常需要打开一些资源，比如数据库连接、文件、锁等，这些资源需要在用完之后释放掉，否则会造成内存泄漏。</p><p>但是程序员都是人，是人就会犯错。因此经常有程序员忘记关闭这些资源。Golang直接在语言层面提供<code>defer</code>关键字，在打开资源语句的下一行，就可以直接用<code>defer</code>语句来注册函数结束后执行关闭资源的操作。因为这样一颗“小小”的语法糖，程序员忘写关闭资源语句的情况就大大地减少了。</p><h1 id="怎样合理使用defer"><a href="#怎样合理使用defer" class="headerlink" title="怎样合理使用defer?"></a>怎样合理使用defer?</h1><p>defer的使用其实非常简单：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">f,err := os.Open(filename)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> f != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> f.Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在打开文件的语句附近，用defer语句关闭文件。这样，在函数结束之前，会自动执行defer后面的语句来关闭文件。</p><p>当然，defer会有小小地延迟，对时间要求特别特别特别高的程序，可以避免使用它，其他一般忽略它带来的延迟。</p><h1 id="defer进阶"><a href="#defer进阶" class="headerlink" title="defer进阶"></a>defer进阶</h1><h2 id="defer的底层原理是什么？"><a href="#defer的底层原理是什么？" class="headerlink" title="defer的底层原理是什么？"></a>defer的底层原理是什么？</h2><p>我们先看一下官方对<code>defer</code>的解释：</p><blockquote><p>Each time a “defer” statement executes, the function value and parameters to the call are evaluated as usual and saved anew but the actual function is not invoked. Instead, deferred functions are invoked immediately before the surrounding function returns, in the reverse order they were deferred. If a deferred function value evaluates to nil, execution panics when the function is invoked, not when the “defer” statement is executed.</p></blockquote><p>翻译一下：每次defer语句执行的时候，会把函数“压栈”，函数参数会被拷贝下来；当外层函数（非代码块，如一个for循环）退出时，defer函数按照定义的逆序执行；如果defer执行的函数为nil, 那么会在最终调用函数的产生panic.</p><p>defer语句并不会马上执行，而是会进入一个栈，函数return前，会按先进后出的顺序执行。也说是说最先被定义的defer语句最后执行。先进后出的原因是后面定义的函数可能会依赖前面的资源，自然要先执行；否则，如果前面先执行，那后面函数的依赖就没有了。</p><p>在defer函数定义时，对外部变量的引用是有两种方式的，分别是作为函数参数和作为闭包引用。作为函数参数，则在defer定义时就把值传递给defer，并被cache起来；作为闭包引用的话，则会在defer函数真正调用时根据整个上下文确定当前的值。</p><p>defer后面的语句在执行的时候，函数调用的参数会被保存起来，也就是复制了一份。真正执行的时候，实际上用到的是这个复制的变量，因此如果此变量是一个“值”，那么就和定义的时候是一致的。如果此变量是一个“引用”，那么就可能和定义的时候不一致。</p><p>举个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> whatever [<span class="number">3</span>]<span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> whatever &#123;</span><br><span class="line">        <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; </span><br><span class="line">            fmt.Println(i) </span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">2</span><br><span class="line">2</span><br></pre></td></tr></table></figure><p>defer后面跟的是一个闭包（后面会讲到），i是“引用”类型的变量，最后i的值为2, 因此最后打印了三个2.</p><p>有了上面的基础，我们来检验一下成果：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> number <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n number)</span> <span class="title">print</span><span class="params">()</span></span>   &#123; fmt.Println(n) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *number)</span> <span class="title">pprint</span><span class="params">()</span></span> &#123; fmt.Println(*n) &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> n number</span><br><span class="line"></span><br><span class="line">    <span class="keyword">defer</span> n.<span class="built_in">print</span>()</span><br><span class="line">    <span class="keyword">defer</span> n.pprint()</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; n.<span class="built_in">print</span>() &#125;()</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; n.pprint() &#125;()</span><br><span class="line"></span><br><span class="line">    n = <span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">3</span><br><span class="line">3</span><br><span class="line">0</span><br></pre></td></tr></table></figure><p>第四个defer语句是闭包，引用外部函数的n, 最终结果是3;<br>第三个defer语句同第四个；<br>第二个defer语句，n是引用，最终求值是3.<br>第一个defer语句，对n直接求值，开始的时候n=0, 所以最后是0;</p><h2 id="利用defer原理"><a href="#利用defer原理" class="headerlink" title="利用defer原理"></a>利用defer原理</h2><p>有些情况下，我们会故意用到defer的先求值，再延迟调用的性质。想象这样的场景：在一个函数里，需要打开两个文件进行合并操作，合并完后，在函数执行完后关闭打开的文件句柄。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mergeFile</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    f, _ := os.Open(<span class="string">"file1.txt"</span>)</span><br><span class="line">    <span class="keyword">if</span> f != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">(f io.Closer)</span></span> &#123;</span><br><span class="line">            <span class="keyword">if</span> err := f.Close(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                fmt.Printf(<span class="string">"defer close file1.txt err %v\n"</span>, err)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;(f)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ……</span></span><br><span class="line"></span><br><span class="line">    f, _ = os.Open(<span class="string">"file2.txt"</span>)</span><br><span class="line">    <span class="keyword">if</span> f != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">(f io.Closer)</span></span> &#123;</span><br><span class="line">            <span class="keyword">if</span> err := f.Close(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                fmt.Printf(<span class="string">"defer close file2.txt err %v\n"</span>, err)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;(f)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中就用到了defer的原理，defer函数定义的时候，参数就已经复制进去了，之后，真正执行close()函数的时候就刚好关闭的是正确的“文件”了，妙哉！可以想像一下如果不这样将f当成函数参数传递进去的话，最后两个语句关闭的就是同一个文件了，都是最后一个打开的文件。</p><p>不过在调用close()函数的时候，要注意一点：先判断调用主体是否为空，否则会panic. 比如上面的代码片段里，先判断<code>f</code>不为空，才会调用<code>Close()</code>函数，这样最安全。</p><h2 id="defer命令的拆解"><a href="#defer命令的拆解" class="headerlink" title="defer命令的拆解"></a>defer命令的拆解</h2><p>如果defer像上面介绍地那样简单（其实也不简单啦），这个世界就完美了。事情总是没这么简单，defer用得不好，是会跳进很多坑的。</p><p>理解这些坑的关键是这条语句：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> xxx</span><br></pre></td></tr></table></figure><p>上面这条语句经过编译之后，变成了三条指令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 返回值 = xxx</span><br><span class="line">2. 调用defer函数</span><br><span class="line">3. 空的return</span><br></pre></td></tr></table></figure><p>1,3步才是Return 语句真正的命令，第2步是defer定义的语句，这里可能会操作返回值。</p><p>下面我们来看两个例子，试着将return语句和defer语句拆解到正确的顺序。</p><p>第一个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span> <span class="params">(r <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">     t := <span class="number">5</span></span><br><span class="line">     <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">       t = t + <span class="number">5</span></span><br><span class="line">     &#125;()</span><br><span class="line">     <span class="keyword">return</span> t</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拆解后：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span> <span class="params">(r <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">     t := <span class="number">5</span></span><br><span class="line">     </span><br><span class="line">     <span class="comment">// 1. 赋值指令</span></span><br><span class="line">     r = t</span><br><span class="line">     </span><br><span class="line">     <span class="comment">// 2. defer被插入到赋值与返回之间执行，这个例子中返回值r没被修改过</span></span><br><span class="line">     <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;        </span><br><span class="line">         t = t + <span class="number">5</span></span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     <span class="comment">// 3. 空的return指令</span></span><br><span class="line">     <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里第二步没有操作返回值r, 因此，main函数中调用f()得到5.</p><p>第二个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span> <span class="params">(r <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">(r <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">          r = r + <span class="number">5</span></span><br><span class="line">    &#125;(r)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拆解后：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span> <span class="params">(r <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">     <span class="comment">// 1. 赋值</span></span><br><span class="line">     r = <span class="number">1</span></span><br><span class="line">     </span><br><span class="line">     <span class="comment">// 2. 这里改的r是之前传值传进去的r，不会改变要返回的那个r值</span></span><br><span class="line">     <span class="function"><span class="keyword">func</span><span class="params">(r <span class="keyword">int</span>)</span></span> &#123; </span><br><span class="line">          r = r + <span class="number">5</span></span><br><span class="line">     &#125;(r)</span><br><span class="line">     </span><br><span class="line">     <span class="comment">// 3. 空的return</span></span><br><span class="line">     <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，main函数中调用f()得到1.</p><h2 id="defer语句的参数"><a href="#defer语句的参数" class="headerlink" title="defer语句的参数"></a>defer语句的参数</h2><p>defer语句表达式的值在定义时就已经确定了。下面展示三个函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f1</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> err error</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(err)</span><br><span class="line"></span><br><span class="line">    err = errors.New(<span class="string">"defer error"</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f2</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> err error</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    err = errors.New(<span class="string">"defer error"</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f3</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> err error</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">(err error)</span></span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    &#125;(err)</span><br><span class="line"></span><br><span class="line">    err = errors.New(<span class="string">"defer error"</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    f1()</span><br><span class="line">    f2()</span><br><span class="line">    f3()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;nil&gt;</span><br><span class="line">defer error</span><br><span class="line">&lt;nil&gt;</span><br></pre></td></tr></table></figure><p>第1，3个函数是因为作为函数参数，定义的时候就会求值，定义的时候err变量的值都是nil, 所以最后打印的时候都是nil. 第2个函数的参数其实也是会在定义的时候求值，只不过，第2个例子中是一个闭包，它引用的变量err在执行的时候最终变成<code>defer error</code>了。关于闭包在本文后面有介绍。</p><p>第3个函数的错误还比较容易犯，在生产环境中，很容易写出这样的错误代码。最后defer语句没有起到作用。</p><h2 id="闭包是什么？"><a href="#闭包是什么？" class="headerlink" title="闭包是什么？"></a>闭包是什么？</h2><p>闭包是由函数及其相关引用环境组合而成的实体,即：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">闭包=函数+引用环境</span><br></pre></td></tr></table></figure><p>一般的函数都有函数名，但是匿名函数就没有。匿名函数不能独立存在，但可以直接调用或者赋值于某个变量。匿名函数也被称为闭包，一个闭包继承了函数声明时的作用域。在Golang中，所有的匿名函数都是闭包。</p><p>有个不太恰当的例子，可以把闭包看成是一个类，一个闭包函数调用就是实例化一个类。闭包在运行时可以有多个实例，它会将同一个作用域里的变量和常量捕获下来，无论闭包在什么地方被调用（实例化）时，都可以使用这些变量和常量。而且，闭包捕获的变量和常量是引用传递，不是值传递。</p><p>举个简单的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a = Accumulator()</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">"%d\n"</span>, a(<span class="number">1</span>))</span><br><span class="line">    fmt.Printf(<span class="string">"%d\n"</span>, a(<span class="number">10</span>))</span><br><span class="line">    fmt.Printf(<span class="string">"%d\n"</span>, a(<span class="number">100</span>))</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">"------------------------"</span>)</span><br><span class="line">    <span class="keyword">var</span> b = Accumulator()</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">"%d\n"</span>, b(<span class="number">1</span>))</span><br><span class="line">    fmt.Printf(<span class="string">"%d\n"</span>, b(<span class="number">10</span>))</span><br><span class="line">    fmt.Printf(<span class="string">"%d\n"</span>, b(<span class="number">100</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Accumulator</span><span class="params">()</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(delta <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"(%+v, %+v) - "</span>, &amp;x, x)</span><br><span class="line">        x += delta</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(0xc420014070, 0) - 1</span><br><span class="line">(0xc420014070, 1) - 11</span><br><span class="line">(0xc420014070, 11) - 111</span><br><span class="line">------------------------</span><br><span class="line">(0xc4200140b8, 0) - 1</span><br><span class="line">(0xc4200140b8, 1) - 11</span><br><span class="line">(0xc4200140b8, 11) - 111</span><br></pre></td></tr></table></figure><p>闭包引用了x变量，a,b可看作2个不同的实例，实例之间互不影响。实例内部，x变量是同一个地址，因此具有“累加效应”。</p><h2 id="defer配合recover"><a href="#defer配合recover" class="headerlink" title="defer配合recover"></a>defer配合recover</h2><p>Golang被诟病比较多的就是它的error, 经常是各种error满天飞。编程的时候总是会返回一个error, 留给调用者处理。如果是那种致命的错误，比如程序执行初始化的时候出问题，直接panic掉，省得上线运行后出更大的问题。</p><p>但是有些时候，我们需要从异常中恢复。比如服务器程序遇到严重问题，产生了panic, 这时我们至少可以在程序崩溃前做一些“扫尾工作”，如关闭客户端的连接，防止客户端一直等待等等。</p><p>panic会停掉当前正在执行的程序，不只是当前协程。在这之前，它会有序地执行完当前协程defer列表里的语句，其它协程里挂的defer语句不作保证。因此，我们经常在defer里挂一个recover语句，防止程序直接挂掉，这起到了<code>try...catch</code>的效果。</p><p>注意，recover()函数只在defer的上下文中才有效（且只有通过在defer中用匿名函数调用才有效），直接调用的话，只会返回<code>nil</code>.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(<span class="string">"defer main"</span>)</span><br><span class="line">    <span class="keyword">var</span> user = os.Getenv(<span class="string">"USER_"</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">"defer caller"</span>)</span><br><span class="line">            <span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                fmt.Println(<span class="string">"recover success. err: "</span>, err)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;()</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">                fmt.Println(<span class="string">"defer here"</span>)</span><br><span class="line">            &#125;()</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> user == <span class="string">""</span> &#123;</span><br><span class="line">                <span class="built_in">panic</span>(<span class="string">"should set user env."</span>)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 此处不会执行</span></span><br><span class="line">            fmt.Println(<span class="string">"after panic"</span>)</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    time.Sleep(<span class="number">100</span>)</span><br><span class="line">    fmt.Println(<span class="string">"end of main function"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的panic最终会被recover捕获到。这样的处理方式在一个http server的主流程常常会被用到。一次偶然的请求可能会触发某个bug, 这时用recover捕获panic, 稳住主流程，不影响其他请求。</p><p>程序员通过监控获知此次panic的发生，按时间点定位到日志相应位置，找到发生panic的原因，三下五除二，修复上线。一看四周，大家都埋头干自己的事，简直完美：偷偷修复了一个bug, 没有发现！嘿嘿！</p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>defer非常好用，一般情况下不会有什么问题。但是只有深入理解了defer的原理才会避开它的温柔陷阱。掌握了它的原理后，就会写出易懂易维护的代码。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt; Golang之轻松化解defer的温柔陷阱：&lt;/strong&gt; &lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;/excerpt&gt;&lt;/p&gt;
&lt;p&gt;Golang之轻松化解defer的温柔陷阱&lt;/p&gt;
    
    </summary>
    
      <category term="golang" scheme="https://alexbrucelu.github.io/categories/golang/"/>
    
    
      <category term="golang" scheme="https://alexbrucelu.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>深度理解“三次握手，四次挥手”</title>
    <link href="https://alexbrucelu.github.io/2019/06/04/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/"/>
    <id>https://alexbrucelu.github.io/2019/06/04/三次握手四次挥手/</id>
    <published>2019-06-03T16:19:44.245Z</published>
    <updated>2019-06-03T17:55:26.740Z</updated>
    
    <content type="html"><![CDATA[<p><strong> 深度理解“三次握手，四次挥手”：</strong> <excerpt in="" index="" |="" 首页摘要=""></excerpt></p><p>深度理解“三次握手，四次挥手”</p><a id="more"></a><p>[TOC]</p><p>作为程序员，要有刨根问底的精神。知其然，切知其所以然。</p><h2 id="什么是“三次握手，四次挥手”？"><a href="#什么是“三次握手，四次挥手”？" class="headerlink" title="什么是“三次握手，四次挥手”？"></a>什么是“三次握手，四次挥手”？</h2><p>TCP是一种面向连接的单播协议，在发送数据前，通信双方必须在彼此之间建立一条连接。所谓的“连接”，其实是客户端与服务器的内存里保存的一份关于对方的信息，譬如IP地址、端口号等。</p><p>TCP可以看成是一种字节流，它会处理IP层或以下层的丢包、重复以及错误问题。在连接的建立过程中，双方需要交换一些连接的参数。这些参数可以放在TCP的头部。</p><p>TCP提供了一种可靠、面向连接、字节流、传输层的服务，采用三次握手建立一个连接。采用四次挥手来关闭一个连接。</p><h3 id="TCP服务模型"><a href="#TCP服务模型" class="headerlink" title="TCP服务模型"></a>TCP服务模型</h3><p>在了解建立连接、关闭连接的“三次握手、四次挥手”后，我们需要了解下TCP相关的东西。</p><p>一个TCP连接是由一个4元组构成的，分别是两个IP地址和两个端口号。一个TCP连接通常会分为三个阶段：启动、数据传输、退出（关闭）。</p><p>当TCP接收到另一端的数据时，它会发送一个确认，但这个确认不会立即发送，一般会延迟一会儿。ACK是累积的，一个确认字节号N的ACK表示所有直到N的字节（不包括N）已经成功被接收了。这样的好处是如果一个ACK丢失，很可能后续的ACK就足以确认前面的报文段了。</p><p>一个完整的TCP连接是双向和对称的，数据可以在两个方向上平等地流动。给上层应用程序提供一种<code>双工服务</code>。一旦建立了一个连接，这个连接的一个方向上的每个TCP报文段都包含了相反方向上的报文段的一个ACK。</p><p>序列号的作用是使得一个TCP接收端可丢弃重复的报文段，记录以杂乱次序到达的报文段。因为TCP使用IP来传输报文段，而IP不提供重复消除或者保证次序正确的功能。另一方面，TCP是一个字节流协议，绝不会以杂乱的次序给上层程序发送数据。因此TCP接收端会被迫先保持大序列号的数据不交给应用程序，直到缺失的小序列号的报文段被填满。</p><h3 id="TCP头部"><a href="#TCP头部" class="headerlink" title="TCP头部"></a>TCP头部</h3><p><img src="http://upload-images.jianshu.io/upload_images/12234098-40089b5b24b9d38b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>源端口和目的端口在TCP层确定双方进程，序列号表示的是报文段数据中的第一个字节号，ACK表示确认号，该确认号的发送方期待接收的下一个序列号，即最后被成功接收的数据字节序列号加1，这个字段只有在ACK位被启用的时候才有效。</p><p>当新建一个连接时，从客户端发送到服务端的第一个报文段的SYN位被启用，这称为SYN报文段，这时序列号字段包含了在本次连接的这个方向上要使用的第一个序列号，即初始序列号<code>ISN</code>，之后发送的数据是ISN加1，因此SYN位字段会<code>消耗</code>一个序列号，这意味着使用重传进行可靠传输。而不消耗序列号的ACK则不是。</p><p>头部长度（图中的数据偏移）以32位字为单位，也就是以4bytes为单位，它只有4位，最大为15，因此头部最大长度为60字节，而其最小为5，也就是头部最小为20字节（可变选项为空）。</p><p>ACK —— 确认，使得确认号有效。</p><p>RST —— 重置连接（经常看到的reset by peer）就是此字段搞的鬼。 </p><p>SYN —— 用于初如化一个连接的序列号。 </p><p>FIN —— 该报文段的发送方已经结束向对方发送数据。</p><p>当一个连接被建立或被终止时，交换的报文段只包含TCP头部，而没有数据。</p><h3 id="状态转换"><a href="#状态转换" class="headerlink" title="状态转换"></a>状态转换</h3><p>三次握手和四次挥手的状态转换如下图。</p><p><img src="http://upload-images.jianshu.io/upload_images/12234098-40f65020a755ca18?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h2 id="为什么要“三次握手，四次挥手”？"><a href="#为什么要“三次握手，四次挥手”？" class="headerlink" title="为什么要“三次握手，四次挥手”？"></a>为什么要“三次握手，四次挥手”？</h2><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p>换个易于理解的视角来看为什么要3次握手。</p><p>客户端和服务端通信前要进行连接，“3次握手”的作用就是<code>双方都能明确自己和对方的收、发能力是正常的</code>。</p><p><code>第一次握手</code>：客户端发送网络包，服务端收到了。这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。</p><p><code>第二次握手</code>：服务端发包，客户端收到了。这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。<br>从客户端的视角来看，我接到了服务端发送过来的响应数据包，说明服务端接收到了我在第一次握手时发送的网络包，并且成功发送了响应数据包，这就说明，服务端的接收、发送能力正常。而另一方面，我收到了服务端的响应数据包，说明我第一次发送的网络包成功到达服务端，这样，我自己的发送和接收能力也是正常的。</p><p><code>第三次握手</code>：客户端发包，服务端收到了。这样服务端就能得出结论：客户端的接收、发送能力，服务端的发送、接收能力是正常的。<br>第一、二次握手后，服务端并不知道客户端的接收能力以及自己的发送能力是否正常。而在第三次握手时，服务端收到了客户端对第二次握手作的回应。从服务端的角度，我在第二次握手时的响应数据发送出去了，客户端接收到了。所以，我的发送能力是正常的。而客户端的接收能力也是正常的。</p><p>经历了上面的三次握手过程，客户端和服务端都确认了自己的接收、发送能力是正常的。之后就可以正常通信了。</p><p>每次都是接收到数据包的一方可以得到一些结论，发送的一方其实没有任何头绪。我虽然有发包的动作，但是我怎么知道我有没有发出去，而对方有没有接收到呢？</p><p>而从上面的过程可以看到，最少是需要三次握手过程的。两次达不到让双方都得出自己、对方的接收、发送能力都正常的结论。其实每次收到网络包的一方至少是可以得到：对方的发送、我方的接收是正常的。而每一步都是有关联的，下一次的“响应”是由于第一次的“请求”触发，因此每次握手其实是可以得到额外的结论的。比如第三次握手时，服务端收到数据包，表明看服务端只能得到客户端的发送能力、服务端的接收能力是正常的，但是结合第二次，说明服务端在第二次发送的响应包，客户端接收到了，并且作出了响应，从而得到额外的结论：客户端的接收、服务端的发送是正常的。</p><p>用表格总结一下：</p><table><thead><tr><th>视角</th><th>客收</th><th>客发</th><th>服收</th><th>服发</th></tr></thead><tbody><tr><td>客视角</td><td>二</td><td>一 + 二</td><td>一 + 二</td><td>二</td></tr><tr><td>服视角</td><td>二 + 三</td><td>一</td><td>一</td><td>二 + 三</td></tr></tbody></table><h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p>TCP连接是双向传输的对等的模式，就是说双方都可以同时向对方发送或接收数据。当有一方要关闭连接时，会发送指令告知对方，我要关闭连接了。这时对方会回一个ACK，此时一个方向的连接关闭。但是另一个方向仍然可以继续传输数据，等到发送完了所有的数据后，会发送一个FIN段来关闭此方向上的连接。接收方发送ACK确认关闭连接。注意，接收到FIN报文的一方只能回复一个ACK, 它是无法马上返回对方一个FIN报文段的，因为结束数据传输的“指令”是上层应用层给出的，我只是一个“搬运工”，我无法了解<code>“上层的意志”</code>。</p><h2 id="“三次握手，四次挥手”怎么完成？"><a href="#“三次握手，四次挥手”怎么完成？" class="headerlink" title="“三次握手，四次挥手”怎么完成？"></a>“三次握手，四次挥手”怎么完成？</h2><p>其实3次握手的目的并不只是让通信双方都了解到一个连接正在建立，还在于利用数据包的选项来传输特殊的信息，交换初始序列号ISN。</p><p>3次握手是指发送了3个报文段，4次挥手是指发送了4个报文段。注意，SYN和FIN段都是会利用重传进行可靠传输的。</p><p><img src="http://upload-images.jianshu.io/upload_images/12234098-8604b533d42457b5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="三次握手"></p><h3 id="三次握手-1"><a href="#三次握手-1" class="headerlink" title="三次握手"></a>三次握手</h3><ol><li>客户端发送一个SYN段，并指明客户端的初始序列号，即ISN(c).</li><li>服务端发送自己的SYN段作为应答，同样指明自己的ISN(s)。为了确认客户端的SYN，将ISN(c)+1作为ACK数值。这样，每发送一个SYN，序列号就会加1. 如果有丢失的情况，则会重传。</li><li>为了确认服务器端的SYN，客户端将ISN(s)+1作为返回的ACK数值。</li></ol><h3 id="四次挥手-1"><a href="#四次挥手-1" class="headerlink" title="四次挥手"></a>四次挥手</h3><p><img src="http://upload-images.jianshu.io/upload_images/12234098-3754de754cbcf2af.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="四次挥手"></p><ol><li>客户端发送一个FIN段，并包含一个希望接收者看到的自己当前的序列号K. 同时还包含一个ACK表示确认对方最近一次发过来的数据。</li><li>服务端将K值加1作为ACK序号值，表明收到了上一个包。这时上层的应用程序会被告知另一端发起了关闭操作，通常这将引起应用程序发起自己的关闭操作。</li><li>服务端发起自己的FIN段，ACK=K+1, Seq=L</li><li>客户端确认。ACK=L+1</li></ol><h3 id="为什么建立连接是“三次握手”，而关闭连接是“四次挥手”呢？"><a href="#为什么建立连接是“三次握手”，而关闭连接是“四次挥手”呢？" class="headerlink" title="为什么建立连接是“三次握手”，而关闭连接是“四次挥手”呢？"></a>为什么建立连接是“三次握手”，而关闭连接是“四次挥手”呢？</h3><p>这是因为服务端在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。而关闭连接时，当收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，己方是否现在关闭发送数据通道，需要上层应用来决定，因此，己方ACK和FIN一般都会分开发送。</p><h2 id="“三次握手，四次挥手”进阶"><a href="#“三次握手，四次挥手”进阶" class="headerlink" title="“三次握手，四次挥手”进阶"></a>“三次握手，四次挥手”进阶</h2><h3 id="ISN"><a href="#ISN" class="headerlink" title="ISN"></a>ISN</h3><p>三次握手的一个重要功能是客户端和服务端交换ISN(Initial Sequence Number), 以便让对方知道接下来接收数据的时候如何按序列号组装数据。</p><p>如果ISN是固定的，攻击者很容易猜出后续的确认号。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ISN = M + F(localhost, localport, remotehost, remoteport)</span><br></pre></td></tr></table></figure><p>M是一个计时器，每隔4微秒加1。<br>F是一个Hash算法，根据源IP、目的IP、源端口、目的端口生成一个随机数值。要保证hash算法不能被外部轻易推算得出。</p><h3 id="序列号回绕"><a href="#序列号回绕" class="headerlink" title="序列号回绕"></a>序列号回绕</h3><p>因为ISN是随机的，所以序列号容易就会超过2^31-1. 而tcp对于丢包和乱序等问题的判断都是依赖于序列号大小比较的。此时就出现了所谓的tcp序列号回绕（sequence wraparound）问题。怎么解决？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* The next routines deal with comparing 32 bit unsigned ints</span></span><br><span class="line"><span class="comment">* and worry about wraparound (automatic with unsigned arithmetic).</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">before</span><span class="params">(__u32 seq1, __u32 seq2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (__s32)(seq1-seq2) &lt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> after(seq2, seq1) before(seq1, seq2)</span></span><br></pre></td></tr></table></figure><p>上述代码是内核中的解决回绕问题代码。<strong>s32是有符号整型的意思，而</strong>u32则是无符号整型。序列号发生回绕后，序列号变小，相减之后，把结果变成有符号数了，因此结果成了负数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">假设seq1=255， seq2=1（发生了回绕）。</span><br><span class="line">seq1 = 1111 1111 seq2 = 0000 0001</span><br><span class="line">我们希望比较结果是</span><br><span class="line"> seq1 - seq2=</span><br><span class="line"> 1111 1111</span><br><span class="line">-0000 0001</span><br><span class="line">-----------</span><br><span class="line"> 1111 1110</span><br><span class="line"></span><br><span class="line">由于我们将结果转化成了有符号数，由于最高位是1，因此结果是一个负数，负数的绝对值为</span><br><span class="line"> 0000 0001 + 1 = 0000 0010 = 2</span><br><span class="line"></span><br><span class="line">因此seq1 - seq2 &lt; 0</span><br></pre></td></tr></table></figure><h3 id="syn-flood攻击"><a href="#syn-flood攻击" class="headerlink" title="syn flood攻击"></a>syn flood攻击</h3><p>最基本的DoS攻击就是利用合理的服务请求来占用过多的服务资源，从而使合法用户无法得到服务的响应。syn flood属于Dos攻击的一种。</p><p>如果恶意的向某个服务器端口发送大量的SYN包，则可以使服务器打开大量的半开连接，分配TCB（Transmission Control Block）, 从而消耗大量的服务器资源，同时也使得正常的连接请求无法被相应。当开放了一个TCP端口后，该端口就处于Listening状态，不停地监视发到该端口的Syn报文，一 旦接收到Client发来的Syn报文，就需要为该请求分配一个TCB，通常一个TCB至少需要280个字节，在某些操作系统中TCB甚至需要1300个字节，并返回一个SYN ACK命令，立即转为SYN-RECEIVED即半开连接状态。系统会为此耗尽资源。</p><p>常见的防攻击方法有：</p><h4 id="无效了解的监视释放"><a href="#无效了解的监视释放" class="headerlink" title="无效了解的监视释放"></a>无效了解的监视释放</h4><p>监视系统的半开连接和不活动连接，当达到一定阈值时拆除这些连接，从而释放系统资源。这种方法对于所有的连接一视同仁，而且由于SYN Flood造成的半开连接数量很大，正常连接请求也被淹没在其中被这种方式误释放掉，因此这种方法属于入门级的SYN Flood方法。</p><h4 id="延缓TCB分配方法"><a href="#延缓TCB分配方法" class="headerlink" title="延缓TCB分配方法"></a>延缓TCB分配方法</h4><p>消耗服务器资源主要是因为当SYN数据报文一到达，系统立即分配TCB，从而占用了资源。而SYN Flood由于很难建立起正常连接，因此，当正常连接建立起来后再分配TCB则可以有效地减轻服务器资源的消耗。常见的方法是使用Syn Cache和Syn Cookie技术。</p><h5 id="Syn-Cache技术"><a href="#Syn-Cache技术" class="headerlink" title="Syn Cache技术"></a>Syn Cache技术</h5><p>系统在收到一个SYN报文时，在一个专用HASH表中保存这种半连接信息，直到收到正确的回应ACK报文再分配TCB。这个开销远小于TCB的开销。当然还需要保存序列号。</p><h5 id="Syn-Cookie技术"><a href="#Syn-Cookie技术" class="headerlink" title="Syn Cookie技术"></a>Syn Cookie技术</h5><p>Syn Cookie技术则完全不使用任何存储资源，这种方法比较巧妙，它使用一种特殊的算法生成Sequence Number，这种算法考虑到了对方的IP、端口、己方IP、端口的固定信息，以及对方无法知道而己方比较固定的一些信息，如MSS(Maximum Segment Size，最大报文段大小，指的是TCP报文的最大数据报长度，其中不包括TCP首部长度。)、时间等，在收到对方 的ACK报文后，重新计算一遍，看其是否与对方回应报文中的（Sequence Number-1）相同，从而决定是否分配TCB资源。</p><h4 id="使用SYN-Proxy防火墙"><a href="#使用SYN-Proxy防火墙" class="headerlink" title="使用SYN Proxy防火墙"></a>使用SYN Proxy防火墙</h4><p>一种方式是防止墙dqywb连接的有效性后，防火墙才会向内部服务器发起SYN请求。防火墙代服务器发出的SYN ACK包使用的序列号为c, 而真正的服务器回应的序列号为c’, 这样，在每个数据报文经过防火墙的时候进行序列号的修改。另一种方式是防火墙确定了连接的安全后，会发出一个safe reset命令，client会进行重新连接，这时出现的syn报文会直接放行。这样不需要修改序列号了。但是，client需要发起两次握手过程，因此建立连接的时间将会延长。</p><h3 id="连接队列"><a href="#连接队列" class="headerlink" title="连接队列"></a>连接队列</h3><p>在外部请求到达时，被服务程序最终感知到前，连接可能处于SYN_RCVD状态或是ESTABLISHED状态，但还未被应用程序接受。</p><p><img src="http://upload-images.jianshu.io/upload_images/12234098-36b3c46688c685c7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="tcp queue"></p><p>对应地，服务器端也会维护两种队列，处于SYN_RCVD状态的半连接队列，而处于ESTABLISHED状态但仍未被应用程序accept的为全连接队列。如果这两个队列满了之后，就会出现各种丢包的情形。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看是否有连接溢出</span></span><br><span class="line">netstat -s | grep LISTEN</span><br></pre></td></tr></table></figure><h4 id="半连接队列满了"><a href="#半连接队列满了" class="headerlink" title="半连接队列满了"></a>半连接队列满了</h4><p>在三次握手协议中，服务器维护一个半连接队列，该队列为每个客户端的SYN包开设一个条目(服务端在接收到SYN包的时候，就已经创建了request_sock结构，存储在半连接队列中)，该条目表明服务器已收到SYN包，并向客户发出确认，正在等待客户的确认包。这些条目所标识的连接在服务器处于Syn_RECV状态，当服务器收到客户的确认包时，删除该条目，服务器进入ESTABLISHED状态。</p><blockquote><p>目前，Linux下默认会进行5次重发SYN-ACK包，重试的间隔时间从1s开始，下次的重试间隔时间是前一次的双倍，5次的重试时间间隔为1s, 2s, 4s, 8s, 16s, 总共31s, 称为<code>指数退避</code>，第5次发出后还要等32s才知道第5次也超时了，所以，总共需要 1s + 2s + 4s+ 8s+ 16s + 32s = 63s, TCP才会把断开这个连接。由于，SYN超时需要63秒，那么就给攻击者一个攻击服务器的机会，攻击者在短时间内发送大量的SYN包给Server(俗称SYN flood攻击)，用于耗尽Server的SYN队列。对于应对SYN 过多的问题，linux提供了几个TCP参数：tcp_syncookies、tcp_synack_retries、tcp_max_syn_backlog、tcp_abort_on_overflow 来调整应对。</p></blockquote><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>tcp_syncookies</td><td>SYNcookie将连接信息编码在ISN(initialsequencenumber)中返回给客户端，这时server不需要将半连接保存在队列中，而是利用客户端随后发来的ACK带回的ISN还原连接信息，以完成连接的建立，避免了半连接队列被攻击SYN包填满。</td></tr><tr><td>tcp_syncookies</td><td>内核放弃建立连接之前发送SYN包的数量。</td></tr><tr><td>tcp_synack_retries</td><td>内核放弃连接之前发送SYN+ACK包的数量</td></tr><tr><td>tcp_max_syn_backlog</td><td>默认为1000. 这表示半连接队列的长度，如果超过则放弃当前连接。</td></tr><tr><td>tcp_abort_on_overflow</td><td>如果设置了此项，则直接reset. 否则，不做任何操作，这样当服务器半连接队列有空了之后，会重新接受连接。<code>Linux坚持在能力许可范围内不忽略进入的连接</code>。客户端在这期间会重复发送sys包，当重试次数到达上限之后，会得到<code>connection time out</code>响应。</td></tr></tbody></table><h4 id="全连接队列满了"><a href="#全连接队列满了" class="headerlink" title="全连接队列满了"></a>全连接队列满了</h4><p>当第三次握手时，当server接收到ACK包之后，会进入一个新的叫 accept 的队列。</p><p>当accept队列满了之后，即使client继续向server发送ACK的包，也会不被响应，此时ListenOverflows+1，同时server通过tcp_abort_on_overflow来决定如何返回，0表示直接丢弃该ACK，1表示发送RST通知client；相应的，client则会分别返回<code>read timeout</code> 或者 <code>connection reset by peer</code>。另外，tcp_abort_on_overflow是0的话，server过一段时间再次发送syn+ack给client（也就是重新走握手的第二步），如果client超时等待比较短，就很容易异常了。而客户端收到多个 SYN ACK 包，则会认为之前的 ACK 丢包了。于是促使客户端再次发送 ACK ，在 accept队列有空闲的时候最终完成连接。若 accept队列始终满员，则最终客户端收到 RST 包（此时服务端发送syn+ack的次数超出了tcp_synack_retries）。</p><p>服务端仅仅只是创建一个定时器，以固定间隔重传syn和ack到服务端</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>tcp_abort_on_overflow</td><td>如果设置了此项，则直接reset. 否则，不做任何操作，这样当服务器半连接队列有空了之后，会重新接受连接。<code>Linux坚持在能力许可范围内不忽略进入的连接</code>。客户端在这期间会重复发送sys包，当重试次数到达上限之后，会得到<code>connection time out</code>响应。</td></tr><tr><td>min(backlog, somaxconn)</td><td>全连接队列的长度。</td></tr></tbody></table><h4 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h4><p>netstat -s命令</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@server ~]<span class="comment">#  netstat -s | egrep "listen|LISTEN" </span></span><br><span class="line">667399 <span class="built_in">times</span> the listen queue of a socket overflowed</span><br><span class="line">667399 SYNs to LISTEN sockets ignored</span><br></pre></td></tr></table></figure><p>上面看到的 667399 times ，表示全连接队列溢出的次数，隔几秒钟执行下，如果这个数字一直在增加的话肯定全连接队列偶尔满了。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@server ~]<span class="comment">#  netstat -s | grep TCPBacklogDrop</span></span><br></pre></td></tr></table></figure><p>查看 Accept queue 是否有溢出</p><p>ss命令</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@server ~]<span class="comment">#  ss -lnt</span></span><br><span class="line">State Recv-Q Send-Q Local Address:Port Peer Address:Port</span><br><span class="line">LISTEN     0      128 *:6379 *:*</span><br><span class="line">LISTEN     0      128 *:22 *:*</span><br></pre></td></tr></table></figure><p>如果State是listen状态，Send-Q 表示第三列的listen端口上的全连接队列最大为50，第一列Recv-Q为全连接队列当前使用了多少。<br>非 LISTEN 状态中 Recv-Q 表示 receive queue 中的 bytes 数量；Send-Q 表示 send queue 中的 bytes 数值。</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>当外部连接请求到来时，TCP模块会首先查看max_syn_backlog，如果处于SYN_RCVD状态的连接数目超过这一阈值，进入的连接会被拒绝。根据tcp_abort_on_overflow字段来决定是直接丢弃，还是直接reset.</p><p>从服务端来说，三次握手中，第一步server接受到client的syn后，把相关信息放到半连接队列中，同时回复syn+ack给client. 第三步当收到客户端的ack, 将连接加入到全连接队列。</p><p>一般，全连接队列比较小，会先满，此时半连接队列还没满。如果这时收到syn报文，则会进入半连接队列，没有问题。但是如果收到了三次握手中的第3步(ACK)，则会根据tcp_abort_on_overflow字段来决定是直接丢弃，还是直接reset.此时，客户端发送了ACK, 那么客户端认为三次握手完成，它认为服务端已经准备好了接收数据的准备。但此时服务端可能因为全连接队列满了而无法将连接放入，会重新发送第2步的syn+ack, 如果这时有数据到来，服务器TCP模块会将数据存入队列中。一段时间后，client端没收到回复，超时，连接异常，client会主动关闭连接。</p><h2 id="“三次握手，四次挥手”Redis实例分析"><a href="#“三次握手，四次挥手”Redis实例分析" class="headerlink" title="“三次握手，四次挥手”Redis实例分析"></a>“三次握手，四次挥手”Redis实例分析</h2><ol><li>我在dev机器上部署redis服务，端口号为6379,</li><li>通过tcpdump工具获取数据包，使用如下命令</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -w /tmp/a.cap port 6379 -s0</span><br><span class="line"><span class="comment"># -w把数据写入文件，-s0设置每个数据包的大小默认为68字节，如果用-S 0则会抓到完整数据包</span></span><br></pre></td></tr></table></figure><ol><li>在dev2机器上用redis-cli访问dev:6379, 发送一个ping, 得到回复pong</li><li>停止抓包，用tcpdump读取捕获到的数据包</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -r /tmp/a.cap -n -nn -A -x| vim -</span><br><span class="line"><span class="comment">#（-x 以16进制形式展示，便于后面分析）</span></span><br></pre></td></tr></table></figure><p>共收到了7个包。</p><p>抓到的是IP数据包，IP数据包分为IP头部和IP数据部分，IP数据部分是TCP头部加TCP数据部分。</p><p>IP的数据格式为：<br><img src="http://upload-images.jianshu.io/upload_images/12234098-e6b04f3e9bebdac4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ip head"><br>它由固定长度20B+可变长度构成。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">10:55:45.662077 IP dev2.39070 &gt; dev.6379: Flags [S], seq 4133153791, win 29200, options [mss 1460,sackOK,TS val 2959270704 ecr 0,nop,wscale 7], length 0</span><br><span class="line">        0x0000:  4500 003c 08cf 4000 3606 14a5 0ab3 b561</span><br><span class="line">        0x0010:  0a60 5cd4 989e 18eb f65a ebff 0000 0000</span><br><span class="line">        0x0020:  a002 7210 872f 0000 0204 05b4 0402 080a</span><br><span class="line">        0x0030:  b062 e330 0000 0000 0103 0307</span><br></pre></td></tr></table></figure><p>对着IP头部格式，来拆解数据包的具体含义。</p><table><thead><tr><th>字节值</th><th>字节含义</th></tr></thead><tbody><tr><td>0x4</td><td>IP版本为ipv4</td></tr><tr><td>0x5</td><td>首部长度为5 * 4字节=20B</td></tr><tr><td>0x00</td><td>服务类型，现在基本都置为0</td></tr><tr><td>0x003c</td><td>总长度为3*16+12=60字节，上面所有的长度就是60字节</td></tr><tr><td>0x08cf</td><td>标识。同一个数据报的唯一标识。当IP数据报被拆分时，会复制到每一个数据中。</td></tr><tr><td>0x4000</td><td><code>3bit 标志 + 13bit 片偏移</code>。3bit 标志对应 R、DF、MF。目前只有后两位有效，DF位：为1表示不分片，为0表示分片。MF：为1表示“更多的片”，为0表示这是最后一片。13bit 片位移：本分片在原先数据报文中相对首位的偏移位。（需要再乘以8 )</td></tr><tr><td>0x36</td><td>生存时间TTL。IP报文所允许通过的路由器的最大数量。每经过一个路由器，TTL减1，当为 0 时，路由器将该数据报丢弃。TTL 字段是由发送端初始设置一个 8 bit字段.推荐的初始值由分配数字 RFC 指定。发送 ICMP 回显应答时经常把 TTL 设为最大值 255。TTL可以防止数据报陷入路由循环。 此处为54.</td></tr><tr><td>0x06</td><td>协议类型。指出IP报文携带的数据使用的是哪种协议，以便目的主机的IP层能知道要将数据报上交到哪个进程。TCP 的协议号为6，UDP 的协议号为17。ICMP 的协议号为1，IGMP 的协议号为2。该 IP 报文携带的数据使用 TCP 协议，得到了验证。</td></tr><tr><td>0x14a5</td><td>16bitIP首部校验和。</td></tr><tr><td>0x0ab3 b561</td><td>32bit源ip地址。</td></tr><tr><td>0x0a60 5cd4</td><td>32bit目的ip地址。</td></tr></tbody></table><p>剩余的数据部分即为TCP协议相关的。TCP也是20B固定长度+可变长度部分。</p><table><thead><tr><th>字节值</th><th>字节含义</th></tr></thead><tbody><tr><td>0x989e</td><td>16bit源端口。1<em>16</em>16<em>16+8</em>16<em>16+14</em>16+11=39070</td></tr><tr><td>0x18eb</td><td>16bit目的端口6379</td></tr><tr><td>0xf65a ebff</td><td>32bit序列号。4133153791</td></tr><tr><td>0x0000 0000</td><td>32bit确认号。</td></tr><tr><td>0xa</td><td>4bit首部长度，以4byte为单位。共10*4=40字节。因此TCP报文的可选长度为40-20=20</td></tr><tr><td>0b000000</td><td>6bit保留位。目前置为0.</td></tr><tr><td>0b000010</td><td>6bitTCP标志位。从左到右依次是紧急 URG、确认 ACK、推送 PSH、复位 RST、同步 SYN 、终止 FIN。</td></tr><tr><td>0x7210</td><td>滑动窗口大小，滑动窗口即tcp接收缓冲区的大小，用于tcp拥塞控制。29200</td></tr><tr><td>0x872f</td><td>16bit校验和。</td></tr><tr><td>0x0000</td><td>紧急指针。仅在 URG = 1时才有意义，它指出本报文段中的紧急数据的字节数。当 URG = 1 时，发送方 TCP 就把紧急数据插入到本报文段数据的最前面，而在紧急数据后面的数据仍是普通数据。</td></tr></tbody></table><p>可变长度部分，协议如下：</p><table><thead><tr><th>字节值</th><th>字节含义</th></tr></thead><tbody><tr><td>0x0204 05b4</td><td>最大报文长度为，05b4=1460. 即可接收的最大包长度，通常为MTU减40字节，IP头和TCP头各20字节</td></tr><tr><td>0x0402</td><td>表示支持SACK</td></tr><tr><td>0x080a b062 e330 0000 0000</td><td>时间戳。Ts val=b062 e330=2959270704, ecr=0</td></tr><tr><td>0x01</td><td>无操作</td></tr><tr><td>0x03 0307</td><td>窗口扩大因子为7. 移位7, 乘以128</td></tr></tbody></table><p>这样第一个包分析完了。dev2向dev发送SYN请求。<code>也就是三次握手中的第一次了。</code><br><code>SYN seq(c)=4133153791</code></p><p>第二个包，dev响应连接，ack=4133153792. 表明dev下次准备接收这个序号的包，用于tcp字节注的顺序控制。dev（也就是server端）的初始序号为seq=4264776963, syn=1.<br><code>SYN ack=seq(c)+1 seq(s)=4264776963</code></p><p>第三个包，client包确认，这里使用了相对值应答。seq=4133153792, 等于第二个包的ack. ack=4264776964.<br><code>ack=seq(s)+1, seq=seq(c)+1</code><br>至此，三次握手完成。接下来就是发送ping和pong的数据了。</p><p>接着第四个包。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">10:55:48.090073 IP dev2.39070 &gt; dev.6379: Flags [P.], seq 1:15, ack 1, win 229, options [nop,nop,TS val 2959273132 ecr 3132256230], length 14</span><br><span class="line">        0x0000:  4500 0042 08d1 4000 3606 149d 0ab3 b561</span><br><span class="line">        0x0010:  0a60 5cd4 989e 18eb f65a ec00 fe33 5504</span><br><span class="line">        0x0020:  8018 00e5 4b5f 0000 0101 080a b062 ecac</span><br><span class="line">        0x0030:  bab2 6fe6 2a31 0d0a 2434 0d0a 7069 6e67</span><br><span class="line">        0x0040:  0d0a</span><br></pre></td></tr></table></figure><p>tcp首部长度为32B, 可选长度为12B. IP报文的总长度为66B, 首部长度为20B, 因此TCP数据部分长度为14B. seq=0xf65a ec00=4133153792<br>ACK, PSH. 数据部分为2a31 0d0a 2434 0d0a 7069 6e67 0d0a</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0x2a31         -&gt; *1</span><br><span class="line">0x0d0a         -&gt; \r\n</span><br><span class="line">0x2434         -&gt; $4</span><br><span class="line">0x0d0a         -&gt; \r\n</span><br><span class="line">0x7069 0x6e67  -&gt; ping</span><br><span class="line">0x0d0a         -&gt; \r\n</span><br></pre></td></tr></table></figure><p>dev2向dev发送了ping数据，第四个包完毕。</p><p>第五个包，dev2向dev发送ack响应。<br>序列号为0xfe33 5504=4264776964, ack确认号为0xf65a ec0e=4133153806=(4133153792+14).</p><p>第六个包，dev向dev2响应pong消息。序列号fe33 5504，确认号f65a ec0e, TCP头部可选长度为12B, IP数据报总长度为59B, 首部长度为20B, 因此TCP数据长度为7B.<br>数据部分2b50 4f4e 470d 0a, 翻译过来就是<code>+PONG\r\n</code>.</p><p>至此，Redis客户端和Server端的三次握手过程分析完毕。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>“三次握手，四次挥手”看似简单，但是深究进去，还是可以延伸出很多知识点的。比如半连接队列、全连接队列等等。以前关于TCP建立连接、关闭连接的过程很容易就会忘记，可能是因为只是死记硬背了几个过程，没有深入研究背后的原理。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://segmentfault.com/a/1190000015044878" target="_blank" rel="noopener">Redis</a></li><li><a href="https://blog.csdn.net/wdscq1234/article/details/52423272" target="_blank" rel="noopener">tcp option</a></li><li><a href="https://www.zhihu.com/question/32255109" target="_blank" rel="noopener">滑动窗口</a></li><li><a href="http://jm.taobao.org/2017/05/25/525-1/" target="_blank" rel="noopener">全连接队列</a></li><li><a href="https://github.com/torvalds/linux/commit/5ea8ea2cb7f1d0db15762c9b0bb9e7330425a071" target="_blank" rel="noopener">client fooling</a></li><li><a href="http://blog.51cto.com/59090939/1947443" target="_blank" rel="noopener">backlog RECV_Q</a></li><li><a href="https://www.cnblogs.com/menghuanbiao/p/5212131.html" target="_blank" rel="noopener">定时器</a></li><li><a href="https://www.itcodemonkey.com/article/5834.html" target="_blank" rel="noopener">队列图示</a></li><li><a href="https://www.cnblogs.com/hubavyn/p/4477883.html" target="_blank" rel="noopener">tcp flood攻击</a></li><li><a href="https://blog.csdn.net/LoseInVain/article/details/53694265" target="_blank" rel="noopener">MSS MTU</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt; 深度理解“三次握手，四次挥手”：&lt;/strong&gt; &lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;/excerpt&gt;&lt;/p&gt;
&lt;p&gt;深度理解“三次握手，四次挥手”&lt;/p&gt;
    
    </summary>
    
      <category term="TCP通信" scheme="https://alexbrucelu.github.io/categories/TCP%E9%80%9A%E4%BF%A1/"/>
    
    
      <category term="TCP" scheme="https://alexbrucelu.github.io/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>Go Test</title>
    <link href="https://alexbrucelu.github.io/2019/05/27/gotest/"/>
    <id>https://alexbrucelu.github.io/2019/05/27/gotest/</id>
    <published>2019-05-27T08:34:49.958Z</published>
    <updated>2019-05-27T09:09:42.611Z</updated>
    
    <content type="html"><![CDATA[<p><strong> Go Test：</strong> <excerpt in="" index="" |="" 首页摘要=""></excerpt></p><p>Go Test相关介绍</p><a id="more"></a><h2 id="Go-Test"><a href="#Go-Test" class="headerlink" title="Go Test"></a>Go Test</h2><h3 id="go-test-和-go-test-v"><a href="#go-test-和-go-test-v" class="headerlink" title="go test 和 go test -v"></a>go test 和 go test -v</h3><h3 id="t-SkipNow-的作用"><a href="#t-SkipNow-的作用" class="headerlink" title="t.SkipNow()的作用"></a>t.SkipNow()的作用</h3><h3 id="go-test的顺序执行"><a href="#go-test的顺序执行" class="headerlink" title="go test的顺序执行"></a>go test的顺序执行</h3><blockquote><p>go test 明确指出并不会按照顺序来执行，需要顺序执行某些<code>test</code>时使用<code>t.Run()</code></p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testPrint1</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"print 1..."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testPrint2</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"print 2..."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestAll</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">t.Run(<span class="string">"testPrint1"</span>,testPrint1)</span><br><span class="line">t.Run(<span class="string">"testPrint2"</span>,testPrint2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="TestMain-用来初始化"><a href="#TestMain-用来初始化" class="headerlink" title="TestMain 用来初始化"></a>TestMain 用来初始化</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestMain</span><span class="params">(m *testing.M)</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"This is a testmain"</span>)</span><br><span class="line">m.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用TestMain来初始化test，并使用m.Run()来调用其他tests，可以完成需要初始化的一些testing，如：数据库连接，打开文件，REST服务登录等。</p><p>如果整个TestMain里面没有执行m.Run()，整个test文件中的其他tests将不会被执行，只有TestMain会被执行。</p><h3 id="benchmark的书写"><a href="#benchmark的书写" class="headerlink" title="benchmark的书写"></a>benchmark的书写</h3><blockquote><p>go test -bench=.    // 一般使用<code>.</code>就可以了</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkAll</span><span class="params">(b *testing.B)</span></span> &#123; <span class="comment">// 测试函数性能,函数首字母大写</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">PrintHello()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试性能，每次平均时间，执行次数， b.N 表示函数稳定执行的最大次数，若函数执行时间并不稳定，测试函数就会一直执行下去，永远跑不完，没有输出结果。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">aaa</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> i &gt; <span class="number">0</span> &#123;</span><br><span class="line">i--</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkAll</span><span class="params">(b *testing.B)</span></span> &#123; <span class="comment">// 测试函数性能</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">aaa(i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt; Go Test：&lt;/strong&gt; &lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;/excerpt&gt;&lt;/p&gt;
&lt;p&gt;Go Test相关介绍&lt;/p&gt;
    
    </summary>
    
      <category term="golang" scheme="https://alexbrucelu.github.io/categories/golang/"/>
    
    
      <category term="golang" scheme="https://alexbrucelu.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>kafka</title>
    <link href="https://alexbrucelu.github.io/2019/03/24/kafka%E5%AE%89%E8%A3%85%E4%B8%8E%E8%AE%BE%E7%BD%AE/"/>
    <id>https://alexbrucelu.github.io/2019/03/24/kafka安装与设置/</id>
    <published>2019-03-24T09:20:32.598Z</published>
    <updated>2019-03-24T09:29:33.230Z</updated>
    
    <content type="html"><![CDATA[<p><strong> kafka：</strong> <excerpt in="" index="" |="" 首页摘要=""></excerpt></p><p>windows 安装及配置kafka  </p><a id="more"></a><p>[TOC]</p><h2 id="kafka安装与设置"><a href="#kafka安装与设置" class="headerlink" title="kafka安装与设置"></a>kafka安装与设置</h2><h3 id="1-Kafka是一种高吞吐量的分布式发布订阅消息系统。详细介绍可查阅官网：kafka官网"><a href="#1-Kafka是一种高吞吐量的分布式发布订阅消息系统。详细介绍可查阅官网：kafka官网" class="headerlink" title="1. Kafka是一种高吞吐量的分布式发布订阅消息系统。详细介绍可查阅官网：kafka官网"></a>1. Kafka是一种高吞吐量的分布式发布订阅消息系统。详细介绍可查阅官网：kafka官网</h3><h3 id="2-环境搭建"><a href="#2-环境搭建" class="headerlink" title="2.环境搭建"></a>2.环境搭建</h3><h4 id="2-1-安装JDK"><a href="#2-1-安装JDK" class="headerlink" title="2.1 安装JDK"></a>2.1 安装JDK</h4><p>​    下载地址：<a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html" target="_blank" rel="noopener">jre下载</a></p><p>   默认安装文件夹，C:\Program Files\Java\jre1.8.0_202</p><h4 id="2-1-1-设置环境变量"><a href="#2-1-1-设置环境变量" class="headerlink" title="2.1.1 设置环境变量"></a>2.1.1 设置环境变量</h4><p>新建系统变量<code>JAVA_HOME</code>：C:\Program Files\Java\jre1.8.0_202;</p><p>在<code>path</code>里面添加：<code>%JAVA_HOME%\bin</code>；</p><h3 id="2-2-安装Zookeeper"><a href="#2-2-安装Zookeeper" class="headerlink" title="2.2 安装Zookeeper"></a>2.2 安装Zookeeper</h3><p>​     下载地址：<a href="https://zookeeper.apache.org/releases.html" target="_blank" rel="noopener">https://zookeeper.apache.org/releases.html</a></p><pre><code>下载后，解压放在目录D:\kafka（本文所用的目录）下，关于zookeeper以及kafka的目录，路径中最好不要出现空格，比如D:\Program Files，尽量别用，运行脚本时会有问题。1. 进入zookeeper的相关设置所在的文件目录，例如本文的：     D:\bigdata\zookeeper-3.4.10\conf2. 将&quot;zoo_sample.cfg&quot;重命名为&quot;zoo.cfg&quot;3. 打开zoo.cfg(至于使用什么编辑器，根据自己喜好选即可)，找到并编辑：dataDir=/tmp/zookeeper  to  D:/kafka/zookeeper-3.4.10/data或 D:\\kafka\\zookeeper-3.4.10\\data(路径仅为示例，具体可根据需要配置)这里注意，路径要么是&quot;/&quot;分割，要么是转义字符&quot;\\&quot;，这样会生成正确的路径(层级，子目录)。4. 与配置jre类似，在系统环境变量中添加：    a.系统变量中添加ZOOKEEPER_HOME=D:\kafka\zookeeper-3.4.10    b.编辑系统变量中的path变量，增加%ZOOKEEPER_HOME%\bin5. 在zoo.cfg文件中修改默认的Zookeeper端口(默认端口2181)6. 打开cmd窗口，输入zkserver，运行Zookeeper，运行结果如下：</code></pre><p><img src="https://img-blog.csdn.net/20170812132732633?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDI4Mzg5NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p><p>恭喜，Zookeeper已经安装完成，已在2181端口运行。</p><h3 id="2-3-安装kafka"><a href="#2-3-安装kafka" class="headerlink" title="2.3 安装kafka"></a>2.3 安装kafka</h3><p>下载地址：<a href="http://kafka.apache.org/downloads" target="_blank" rel="noopener">http://kafka.apache.org/downloads</a></p><pre><code>要下载Binary downloads这个类型，不要下载源文件，这种方便使用。下载后，解压放在D:\bigdata目录下。</code></pre><p>①进入kafka配置文件所在目录，D:\bigdata\kafka_2.11-0.9.0.1\config</p><p>②编辑文件”server.properties”，找到并编辑：</p><p> log.dirs=/tmp/kafka-logs  to  log.dirs=D:/bigdata/kafka_2.11-0.9.0.1/kafka-logs 或者 D:\bigdata\kafka_2.11-0.9.0.1\kafka-logs</p><p>同样注意：路径要么是”/“分割，要么是转义字符”\“，这样会生成正确的路径(层级，子目录)。错误路径情况可自行尝试，文件夹名为这种形式：bigdatakafka_2.11-0.9.0.1kafka-logs</p><p>③在server.properties文件中，zookeeper.connect=localhost:2181代表kafka所连接的zookeeper所在的服务器IP以及端口，可根据需要更改。本文在同一台机器上使用，故不用修改。</p><p>④kafka会按照默认配置，在9092端口上运行，并连接zookeeper的默认端口2181。</p><h3 id="2-4-运行kafka"><a href="#2-4-运行kafka" class="headerlink" title="2.4 运行kafka"></a>2.4 运行kafka</h3><p>提示：请确保启动kafka服务器前，Zookeeper实例已经在运行，因为kafka的运行是需要zookeeper这种分布式应用程序协调服务。</p><p>①进入kafka安装目录D:\bigdata\kafka_2.11-0.9.0.1</p><p>②按下shift+鼠标右键，选择”在此处打开命令窗口”，打开命令行。</p><p>③在命令行中输入：.\bin\windows\kafka-server-start.bat .\config\server.properties   回车。</p><p>④正确运行的情况为：</p><p><img src="https://img-blog.csdn.net/20170812132906662?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDI4Mzg5NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p><p>到目前为止，zookeeper以及kafka都已正确运行。保持运行状态，不要关闭。</p><font color="red">重要（操作日志的处理）：</font><p>kafka启动后，如果你去查看kafka所在的根目录，或者是kafka本身的目录，会发现已经默认生成一堆操作日志(这样看起来真心很乱)：</p><p>而且会不断生成不同时间戳的操作日志。刚开始不知所措，一番研究后，看了启动的脚本内容，发现启动的时候是会默认使用到这个log4j.properties文件中的配置，而在zoo.cfg是不会看到本身的启动会调用到这个，还以为只有那一个日志路径：</p><p><img src="https://img-blog.csdn.net/20170812133057808?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDI4Mzg5NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p><p>在这里配置一下就可以了，找到config下的log4j.properties：</p><p><img src="https://img-blog.csdn.net/20170812133131159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDI4Mzg5NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p><p>将路径更改下即可，这样就可以归档在一个文件夹下边了，路径根据自己喜好定义：</p><p><img src="https://img-blog.csdn.net/20170812133222818?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDI4Mzg5NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p><p>另外如何消除不断生成日志的问题，就是同一天的不同时间会不停生成。</p><p>修改这里，还是在log4j.properties中：</p><p><img src="https://img-blog.csdn.net/20170812133300278?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDI4Mzg5NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p><p>本身都为trace，字面理解为会生成一堆跟踪日志，将其改为INFO即可。</p><h2 id="3-创建主题"><a href="#3-创建主题" class="headerlink" title="3. 创建主题"></a>3. 创建主题</h2><p>①创建主题，命名为”test0811”，replicationfactor=1(因为只有一个kafka服务器在运行)。可根据集群中kafka服务器个数来修改replicationfactor的数量，以便提高系统容错性等。</p><p>②在D:\kafka\kafka_2.11-0.9.0.1\bin\windows目录下打开新的命令行</p><p>③输入命令：</p><p>kafka-topics.bat –create –zookeeper localhost:2181 –replication-factor 1 –partitions 1 –topic test0811回车。 </p><p><img src="https://img-blog.csdn.net/20170812133330959?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDI4Mzg5NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p><font color="red">该窗口可以关闭。</font><h3 id="3-1-创建生产者、消费者"><a href="#3-1-创建生产者、消费者" class="headerlink" title="3.1 创建生产者、消费者"></a>3.1 创建生产者、消费者</h3><p>①在D:\bigdata\kafka_2.11-0.9.0.1\bin\windows目录下打开新的命令行。</p><p>②输入命令，启动producer：</p><p>kafka-console-producer.bat –broker-list localhost:9092 –topic test0811 </p><p><strong>该窗口不要关闭。</strong></p><p>③同样在该目录下打开新的命令行。</p><p>④输入命令，启动consumer：</p><p>kafka-console-consumer.bat –bootstrap-server localhost:9092 –topic test0811 –from-beginning</p><p><strong><font color="red">参数 –from-beginning 是表示消费者从生产者消息源头开始接收，去掉之后就只是接收新消息</font></strong></p><p><img src="https://img-blog.csdn.net/20170812133419255?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDI4Mzg5NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p><p>现在生产者、消费者均已创建完成。</p><p>⑤在producer命令行窗口中任意输入内容，回车  在consumer命令行窗口中即可看到相应的内容。</p><p><img src="https://img-blog.csdn.net/20170812133447425?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDI4Mzg5NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt; kafka：&lt;/strong&gt; &lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;/excerpt&gt;&lt;/p&gt;
&lt;p&gt;windows 安装及配置kafka  &lt;/p&gt;
    
    </summary>
    
      <category term="others" scheme="https://alexbrucelu.github.io/categories/others/"/>
    
    
      <category term="Windows" scheme="https://alexbrucelu.github.io/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>http幂等性</title>
    <link href="https://alexbrucelu.github.io/2019/02/27/HTTP%E5%B9%82%E7%AD%89%E6%80%A7/"/>
    <id>https://alexbrucelu.github.io/2019/02/27/HTTP幂等性/</id>
    <published>2019-02-27T06:06:14.910Z</published>
    <updated>2019-02-27T06:50:38.907Z</updated>
    
    <content type="html"><![CDATA[<p><strong> http幂等性：</strong> <excerpt in="" index="" |="" 首页摘要=""></excerpt></p><p>编程中的幂等性-http幂等性</p><a id="more"></a><h1 id="编程中的幂等性-—-HTTP幂等性"><a href="#编程中的幂等性-—-HTTP幂等性" class="headerlink" title="编程中的幂等性 — HTTP幂等性"></a><a href="https://www.cnblogs.com/duhuo/p/4245202.html" target="_blank" rel="noopener">编程中的幂等性 — HTTP幂等性</a></h1><p>幂等（idempotent、idempotence）是一个数学与计算机学概念，常见于抽象代数中。</p><p>在编程中.<strong>一个幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同</strong>。幂等函数，或幂等方法，是指可以使用相同参数重复执行，并能获得相同结果的函数。这些函数不会影响系统状态，也不用担心重复执行会对系统造成改变。例如，“getUsername()和setTrue()”函数就是一个幂等函数.更复杂的操作幂等保证是利用唯一交易号(流水号)实现.</p><p>——百度百科</p><h2 id="什么是幂等性-Idempotence-？"><a href="#什么是幂等性-Idempotence-？" class="headerlink" title="什么是幂等性(Idempotence)？"></a>什么是幂等性(Idempotence)？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Methods can also have the property of “idempotence” in that (aside from error or expiration issues) the side-effects of N &gt; 0 identical requests is the same as for a single request.</span><br><span class="line">——HTTP/1.1规范中幂等性的定义</span><br></pre></td></tr></table></figure><p>从定义上看，HTTP方法的幂等性是指一次和多次请求某一个资源应该具有同样的副作用。说白了就是，<strong>同一个请求，发送一次和发送N次效果是一样的！</strong>幂等性是分布式系统设计中十分重要的概念，而HTTP的分布式本质也决定了它在HTTP中具有重要地位。下面将以HTTP中的幂等性做例子加以介绍。</p><h2 id="简单示例"><a href="#简单示例" class="headerlink" title="简单示例"></a>简单示例</h2><p>假设有一个从账户取钱的远程API（可以是HTTP的，也可以不是），我们暂时用类函数的方式记为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bool withdraw(account_id, amount)</span><br></pre></td></tr></table></figure><p>withdraw的语义是从account_id对应的账户中扣除amount数额的钱；如果扣除成功则返回true，账户余额减少amount；如果扣除失败则返回false，账户余额不变。</p><p>值得注意的是：和本地环境相比，<strong>我们不能轻易假设分布式环境的可靠性</strong>。</p><p>所以问题来了，一种典型的情况是withdraw请求已经被服务器端正确处理，但服务器端的返回结果由于网络等原因被掉丢了，导致客户端无法得知处理结果。如果是在网页上，一些不恰当的设计可能会使用户认为上一次操作失败了，然后刷新页面，这就导致了withdraw被调用两次，账户也被多扣了一次钱。如图所示：</p><p><img src="http://cdn.i3geek.com/wp-content/uploads/auto_save_image/2015/07/033717ZKv.png" alt="non-idempotent"></p><p>解决方案一：采用分布式事务，通过引入支持分布式事务的中间件来保证withdraw功能的事务性。分布式事务的优点是对于调用者很简单，复杂性都交给了中间件来管理。缺点则是一方面架构太重量级，容易被绑在特定的中间件上，不利于异构系统的集成；另一方面分布式事务虽然能保证事务的ACID性质，而但却无法提供性能和可用性的保证。</p><p>解决方案二：幂等设计。我们可以通过一些技巧把withdraw变成幂等的，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int create_ticket() </span><br><span class="line">bool idempotent_withdraw(ticket_id, account_id, amount)</span><br></pre></td></tr></table></figure><p>create_ticket的语义是<strong>获取一个服务器端生成的唯一的处理号ticket_id，它将用于标识后续的操作</strong>。idempotent_withdraw和withdraw的区别在于关联了一个ticket_id，一个ticket_id表示的操作至多只会被处理一次，每次调用都将返回第一次调用时的处理结果。这样，idempotent_withdraw就符合幂等性了，客户端就可以放心地多次调用。</p><p>基于幂等性的解决方案中一个完整的取钱流程被分解成了两个步骤：1.调用create_ticket()获取ticket_id；2.调用idempotent_withdraw(ticket_id, account_id, amount)。虽然create_ticket不是幂等的，但在这种设计下，它对系统状态的影响可以忽略，加上idempotent_withdraw是幂等的，所以任何一步由于网络等原因失败或超时，客户端都可以重试，直到获得结果。如图所示：</p><p><img src="http://cdn.i3geek.com/wp-content/uploads/auto_save_image/2015/07/033718EYW.png" alt="idempotent"></p><p>和分布式事务相比，幂等设计的优势在于它的轻量级，容易适应异构环境，以及性能和可用性方面。在某些性能要求比较高的应用，幂等设计往往是唯一的选择。</p><h2 id="HTTP的幂等性"><a href="#HTTP的幂等性" class="headerlink" title="HTTP的幂等性"></a>HTTP的幂等性</h2><p>本文主要以HTTP GET、DELETE、PUT、POST四种方法为主进行语义和幂等性的介绍。</p><p><strong>HTTP GET方法用于获取资源，不应有副作用，所以是幂等的。</strong>比如：GET <a href="http://www.bank.com/account/123456，不会改变资源的状态，不论调用一次还是N次都没有副作用。请注意，这里强调的是一次和N次具有相同的副作用，而不是每次GET的结果相同。GET" target="_blank" rel="noopener">http://www.bank.com/account/123456，不会改变资源的状态，不论调用一次还是N次都没有副作用。请注意，这里强调的是一次和N次具有相同的副作用，而不是每次GET的结果相同。GET</a> <a href="http://www.news.com/latest-news这个HTTP请求可能会每次得到不同的结果，但它本身并没有产生任何副作用，因而是满足幂等性的。" target="_blank" rel="noopener">http://www.news.com/latest-news这个HTTP请求可能会每次得到不同的结果，但它本身并没有产生任何副作用，因而是满足幂等性的。</a></p><p><strong>HTTP DELETE方法用于删除资源，有副作用，但它应该满足幂等性。</strong>比如：DELETE <a href="http://www.forum.com/article/4231，调用一次和N次对系统产生的副作用是相同的，即删掉id为4231的帖子；因此，调用者可以多次调用或刷新页面而不必担心引起错误。" target="_blank" rel="noopener">http://www.forum.com/article/4231，调用一次和N次对系统产生的副作用是相同的，即删掉id为4231的帖子；因此，调用者可以多次调用或刷新页面而不必担心引起错误。</a></p><p><strong>HTTP POST方法用于创建资源，所对应的URI并非创建的资源本身，而是去执行创建动作的操作者，有副作用，不满足幂等性。</strong>比如：POST <a href="http://www.forum.com/articles的语义是在http://www.forum.com/articles下创建一篇帖子，HTTP响应中应包含帖子的创建状态以及帖子的URI。两次相同的POST请求会在服务器端创建两份资源，它们具有不同的URI；所以，POST方法不具备幂等性。" target="_blank" rel="noopener">http://www.forum.com/articles的语义是在http://www.forum.com/articles下创建一篇帖子，HTTP响应中应包含帖子的创建状态以及帖子的URI。两次相同的POST请求会在服务器端创建两份资源，它们具有不同的URI；所以，POST方法不具备幂等性。</a></p><p><strong>HTTP PUT方法用于创建或更新操作，所对应的URI是要创建或更新的资源本身，有副作用，它应该满足幂等性。</strong>比如：PUT <a href="http://www.forum/articles/4231的语义是创建或更新ID为4231的帖子。对同一URI进行多次PUT的副作用和一次PUT是相同的；因此，PUT方法具有幂等性。" target="_blank" rel="noopener">http://www.forum/articles/4231的语义是创建或更新ID为4231的帖子。对同一URI进行多次PUT的副作用和一次PUT是相同的；因此，PUT方法具有幂等性。</a></p><h3 id="对前文示例进行改进"><a href="#对前文示例进行改进" class="headerlink" title="对前文示例进行改进"></a>对前文示例进行改进</h3><p>利用Web API的形式实现前面所提到的取款功能。</p><p>1、用POST /tickets来实现create_ticket；</p><p>2、用PUT /accounts/account_id/ticket_id&amp;amount=xxx来实现idempotent_withdraw。</p><p>值得注意的是严格来讲amount参数不应该作为URI的一部分，真正的URI应该是/accounts/account_id/ticket_id，而amount应该放在请求的body中。这种模式可以应用于很多场合，比如：论坛网站中防止意外的重复发帖。</p><h2 id="电商中遇到的问题"><a href="#电商中遇到的问题" class="headerlink" title="电商中遇到的问题"></a>电商中遇到的问题</h2><h3 id="如何防范-POST-重复提交"><a href="#如何防范-POST-重复提交" class="headerlink" title="如何防范 POST 重复提交"></a>如何防范 POST 重复提交</h3><p>HTTP POST 操作既不是安全的，也不是幂等的（至少在HTTP规范里没有保证）。当我们因为反复刷新浏览器导致多次提交表单，多次发出同样的POST请求，导致远端服务器重复创建出了资源。</p><p>所以，对于电商应用来说，第一对应的后端 WebService 一定要做到<strong>幂等性</strong>，第二服务器端收到 POST 请求，在操作成功后<strong>必须302跳转到另外一个页面</strong>，这样即使用户刷新页面，也不会重复提交表单。</p><h3 id="把分布式事务分解为具有幂等性的异步消息处理"><a href="#把分布式事务分解为具有幂等性的异步消息处理" class="headerlink" title="把分布式事务分解为具有幂等性的异步消息处理"></a>把分布式事务分解为具有幂等性的异步消息处理</h3><p>电商的很多业务，考虑更多的是 BASE（即Basically Available、Soft state、和Eventually consistent），而不是 ACID（Atomicity、Consistency、Isolation和 Durability）。即为了满足高负载的用户访问，我们可以容忍短暂的数据不一致。那怎么做呢？</p><p>第一，不做分布式事务，代价太大。<br>第二，不一定需要实时一致性，只需要保证最终的一致性即可。<br>第三，“通过状态机和严格的有序操作，来最大限度地降低不一致性”。<br>第四，最终一致性（Eventually Consistent）通过异步事件做到。</p><p>如果消息具有操作幂等性，也就是一个消息被应用多次与应用一次产生的效果是一样的话，那么把不需要同步执行的事务交给异步消息推送和订阅者集群来处理即可。假如消息处理失败，那么就消息重播，由于幂等性，应用多次也能产生正确的结果。</p><p>实际情况下，消息很难具有幂等性，解决方法是使用另一个表记录已经被成功应用的消息，即消息队列和消息应用状态表一起来解决问题。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上面简单介绍了幂等性的概念，用幂等设计取代分布式事务的方法，以及HTTP主要方法的语义和幂等性特征。其实，如果要追根溯源，幂等性是数学中的一个概念，表达的是N次变换与1次变换的结果相同，有兴趣的读者可以从Wikipedia上进一步了解。</p><p>转自：<a href="http://www.i3geek.com/archives/841" target="_blank" rel="noopener">http://www.i3geek.com/archives/841</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt; http幂等性：&lt;/strong&gt; &lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;/excerpt&gt;&lt;/p&gt;
&lt;p&gt;编程中的幂等性-http幂等性&lt;/p&gt;
    
    </summary>
    
      <category term="others" scheme="https://alexbrucelu.github.io/categories/others/"/>
    
    
      <category term="http" scheme="https://alexbrucelu.github.io/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>测试与性能调优</title>
    <link href="https://alexbrucelu.github.io/2019/01/22/C%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%89%A7%E8%A1%8C/"/>
    <id>https://alexbrucelu.github.io/2019/01/22/C程序的执行/</id>
    <published>2019-01-22T12:38:28.613Z</published>
    <updated>2019-01-22T14:23:31.160Z</updated>
    
    <content type="html"><![CDATA[<p><strong> 测试与性能调优：</strong> <excerpt in="" index="" |="" 首页摘要=""></excerpt></p><p>C语言的基础入门</p><a id="more"></a><p>[TOC]</p><h2 id="一段程序在计算机内部是怎么运行的"><a href="#一段程序在计算机内部是怎么运行的" class="headerlink" title="一段程序在计算机内部是怎么运行的"></a>一段程序在计算机内部是怎么运行的</h2><h2 id="各种基本类型所占字节大小"><a href="#各种基本类型所占字节大小" class="headerlink" title="各种基本类型所占字节大小"></a>各种基本类型所占字节大小</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"data type        number of bytes\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"----------       ---------------\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"char             %d\n"</span>, <span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"int              %d\n"</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"short int        %d\n"</span>, <span class="keyword">sizeof</span>(<span class="keyword">short</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"long int         %d\n"</span>, <span class="keyword">sizeof</span>(<span class="keyword">long</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"float            %d\n"</span>, <span class="keyword">sizeof</span>(<span class="keyword">float</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"double           %d\n"</span>, <span class="keyword">sizeof</span>(<span class="keyword">double</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 执行结果如下：</span></span><br><span class="line"><span class="comment">// data type        number of bytes</span></span><br><span class="line"><span class="comment">// ----------       ---------------</span></span><br><span class="line"><span class="comment">// char             1</span></span><br><span class="line"><span class="comment">// int              4</span></span><br><span class="line"><span class="comment">// short int        2</span></span><br><span class="line"><span class="comment">// long int         4</span></span><br><span class="line"><span class="comment">// float            4</span></span><br><span class="line"><span class="comment">// double           8</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt; 测试与性能调优：&lt;/strong&gt; &lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;/excerpt&gt;&lt;/p&gt;
&lt;p&gt;C语言的基础入门&lt;/p&gt;
    
    </summary>
    
      <category term="C程序的执行" scheme="https://alexbrucelu.github.io/categories/C%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%89%A7%E8%A1%8C/"/>
    
    
      <category term="C" scheme="https://alexbrucelu.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>golang性能优化</title>
    <link href="https://alexbrucelu.github.io/2018/12/21/golang%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <id>https://alexbrucelu.github.io/2018/12/21/golang性能优化/</id>
    <published>2018-12-21T02:24:21.049Z</published>
    <updated>2018-12-21T06:15:24.241Z</updated>
    
    <content type="html"><![CDATA[<p><strong> golang性能优化：</strong> <excerpt in="" index="" |="" 首页摘要=""></excerpt></p><p>go语言养成记之golang性能优化</p><a id="more"></a><p>[TOC]</p><h2 id="string-amp-profiling"><a href="#string-amp-profiling" class="headerlink" title="string &amp; profiling"></a>string &amp; profiling</h2><h3 id="string-连接"><a href="#string-连接" class="headerlink" title="string 连接"></a>string 连接</h3><h4 id="fmt-VS-“-”"><a href="#fmt-VS-“-”" class="headerlink" title="fmt VS “+”"></a>fmt VS “+”</h4><ol><li><p>如图所示：</p><p><img src="https://github.com/AlexBruceLu/DAPP/wiki/you1.png" alt=""></p><font color="red"><strong>比对结果：</strong></font><font color="red"><strong>BenchmarkFmt 1000000 1617 ns/op </strong></font><font color="red"><strong>BenchmarkPlus 5000000 393 ns/op  </strong></font></li><li><p>如图所示：</p><p><img src="https://github.com/AlexBruceLu/DAPP/wiki/you2.png" alt=""></p><font color="red"><strong>比对结果：</strong></font><font color="red"><strong>BenchmarkFmt 1000000 1324 ns/op </strong></font><font color="red"><strong>BenchmarkPlus 5000000 751 ns/op</strong></font></li></ol><h4 id="strings-join-VS-“-”"><a href="#strings-join-VS-“-”" class="headerlink" title="strings.join VS “+”"></a>strings.join VS “+”</h4><ol><li><p>如图所示：</p><p><img src="https://github.com/AlexBruceLu/DAPP/wiki/you3.png" alt=""></p></li><li><p>如图所示：</p><p><img src="https://github.com/AlexBruceLu/DAPP/wiki/you4.png" alt=""></p><font color="red"><strong>比对结果：</strong></font><font color="red"><strong>BenchmarkPlus 500000 4659 ns/op  </strong></font><font color="red"><strong>BenchmarkJoin 1000000 1491 ns/op </strong></font></li></ol><h4 id="strings-Join-VS-bytes-Buffer"><a href="#strings-Join-VS-bytes-Buffer" class="headerlink" title="strings.Join VS bytes.Buffer"></a>strings.Join VS bytes.Buffer</h4><ol><li><p>如图所示：</p><p><img src="https://github.com/AlexBruceLu/DAPP/wiki/you5.png" alt=""></p></li><li><p>如图所示：</p><p><img src="https://github.com/AlexBruceLu/DAPP/wiki/you6.png" alt=""></p><font color="red"><strong>比对结果：</strong></font><font color="red"><strong>BenchmarkJoin 1000000 1505 ns/op   </strong></font><font color="red"><strong>BenchmarkBuffer 500000 2886 ns/op  </strong></font></li><li><p>如图所示：</p><p><img src="https://github.com/AlexBruceLu/DAPP/wiki/you7.png" alt=""></p></li><li><p>如图所示：</p><p><img src="https://github.com/AlexBruceLu/DAPP/wiki/you8.png" alt=""></p><font color="red"><strong>比对结果：</strong></font><font color="red"><strong>BenchmarkJoin 1000000 1824 ns/op   </strong></font><font color="red"><strong>BenchmarkBuffer 500000 2588 ns/op </strong></font></li><li><p>如图所示：</p><p><img src="https://github.com/AlexBruceLu/DAPP/wiki/you9.png" alt=""></p></li><li><p>如图所示：</p><p><img src="https://github.com/AlexBruceLu/DAPP/wiki/you10.png" alt=""></p><font color="red"><strong>比对结果：</strong></font><font color="red"><strong>BenchmarkJoin 1000000 1500 ns/op   </strong></font><font color="red"><strong>BenchmarkBuffer 1000000 1482 ns/op  </strong></font></li><li><p>如图所示：</p><p><img src="https://github.com/AlexBruceLu/DAPP/wiki/you11.png" alt=""></p></li><li><p>如图所示：</p><p><img src="https://github.com/AlexBruceLu/DAPP/wiki/you12.png" alt=""></p><font color="red"><strong>比对结果：</strong></font><font color="red"><strong>BenchmarkJoin 1000000 1792 ns/op   </strong></font><font color="red"><strong>BenchmarkBuffer 1000000 1162 ns/op  </strong></font></li></ol><h2 id="string-amp-byte"><a href="#string-amp-byte" class="headerlink" title="string &amp; []byte"></a>string &amp; []byte</h2><ol><li>如果可以的话，尽量多用<code>[]byte</code> ，少用<code>string</code></li><li>尽可能的少在两者之间做转换</li><li>append([]byte,string…)</li><li>copy([]byte,string)</li></ol><h3 id="strconv"><a href="#strconv" class="headerlink" title="strconv"></a>strconv</h3><p>  1. func AppendBool(dst []byte, b bool) []byte<br>  2. func AppendFloat(dst []byte, f float64, fmt byte, prec int,bitSize int) []byte<br>  3. func AppendInt(dst []byte, i int64, base int) []byte<br>  4. func AppendUint(dst []byte, i uint64, base int) []byte<br>  5. func FormatBool(b bool) string<br>  6. func FormatFloat(f float64, fmt byte, prec, bitSize int) string<br>  7. func FormatInt(i int64, base int) string<br>  8. func FormatUint(i uint64, base int) string </p><h2 id="slice-amp-array"><a href="#slice-amp-array" class="headerlink" title="slice &amp; array"></a>slice &amp; array</h2><p>array：值传递</p><p>slice：引用传递</p><p><img src="https://github.com/AlexBruceLu/DAPP/wiki/you13.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt; golang性能优化：&lt;/strong&gt; &lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;/excerpt&gt;&lt;/p&gt;
&lt;p&gt;go语言养成记之golang性能优化&lt;/p&gt;
    
    </summary>
    
      <category term="golang" scheme="https://alexbrucelu.github.io/categories/golang/"/>
    
    
      <category term="golang" scheme="https://alexbrucelu.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>类型断言</title>
    <link href="https://alexbrucelu.github.io/2018/12/19/%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80/"/>
    <id>https://alexbrucelu.github.io/2018/12/19/类型断言/</id>
    <published>2018-12-19T06:18:03.497Z</published>
    <updated>2018-12-19T07:09:44.408Z</updated>
    
    <content type="html"><![CDATA[<p><strong> 类型断言：</strong> <excerpt in="" index="" |="" 首页摘要=""></excerpt></p><p>go语言养成记之类型断言</p><a id="more"></a><p>[TOC]</p><h2 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h2><h3 id="引出类型断言的需求案例"><a href="#引出类型断言的需求案例" class="headerlink" title="引出类型断言的需求案例"></a>引出类型断言的需求案例</h3><p>如何将一个接口变量，赋值给自定义类型的变量？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Point <span class="keyword">struct</span> &#123;</span><br><span class="line">    x <span class="keyword">int</span></span><br><span class="line">    y <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">var</span> point Point = Point&#123;<span class="number">1</span>,<span class="number">2</span>&#125;</span><br><span class="line">    a = point <span class="comment">// ok</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如何将a赋给一个Point变量</span></span><br><span class="line">    <span class="keyword">var</span> b Point</span><br><span class="line">    b = a <span class="comment">// 可以吗 =&gt; error</span></span><br><span class="line">    <span class="comment">// cannot use a (type interface &#123;&#125;) as type Point in assignment: need type assertion</span></span><br><span class="line">    fmt.Println(b)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以转换为以下代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">var</span> point Point = Point&#123;<span class="number">1</span>,<span class="number">2</span>&#125;</span><br><span class="line">    a = point</span><br><span class="line">    <span class="keyword">var</span> b Point</span><br><span class="line">    b = a.(Point) <span class="comment">// 类型断言</span></span><br><span class="line">    fmt.Println(b)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 执行结果</span></span><br><span class="line"><span class="comment">// &#123;1 2&#125;</span></span><br></pre></td></tr></table></figure><p>代码说明：<code>b = a.(Point)</code>就是类型断言，表示判断<code>a</code>是否指向<code>Point</code>类型的变量，如果是就转化为<code>Point</code>类型并赋值给<code>b</code>变量，否则报错。</p><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>类型断言，有接口是一般类型，不知道具体类型，如果要转成具体类型，就需要使用类型断言，具体如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> b2 <span class="keyword">float32</span> = <span class="number">1.1</span></span><br><span class="line">x = b2</span><br><span class="line">y := x.(<span class="keyword">float32</span>)</span><br><span class="line">fmt.Printf(<span class="string">"y 的类型是 %T 值是 = %v"</span>,y,y)</span><br><span class="line"><span class="comment">// 执行结果</span></span><br><span class="line"><span class="comment">// y 的类型是 float32 值是 = 1.1</span></span><br></pre></td></tr></table></figure><font color="red"><strong>对上面代码的说明：</strong></font><p>在进行类型断言时，如果类型不匹配，就会报<code>panic</code>，因此，进行类型断言时，要确保原来的空接口指向的就是断言的类型。</p><font color="red"><strong>如何在进行断言时，带上检测机制，如果成功就ok，否则也不要报<code>panic</code></strong></font><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> b2 <span class="keyword">float32</span> = <span class="number">1.1</span></span><br><span class="line">x = b2</span><br><span class="line"><span class="keyword">if</span>y,ok := x.(<span class="keyword">float32</span>); ok &#123;</span><br><span class="line">    fmt.Println(<span class="string">"convert success"</span>)</span><br><span class="line">    fmt.Printf(<span class="string">"y 的类型是 %T 值是 = %v"</span>,y,y)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"convert fail"</span>)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"继续执行。。。"</span>)</span><br><span class="line"><span class="comment">// 执行结果</span></span><br><span class="line"><span class="comment">// convert success</span></span><br><span class="line"><span class="comment">// y 的类型是 float32 值是 = 1.1</span></span><br><span class="line"><span class="comment">// 继续执行。。。</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt; 类型断言：&lt;/strong&gt; &lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;/excerpt&gt;&lt;/p&gt;
&lt;p&gt;go语言养成记之类型断言&lt;/p&gt;
    
    </summary>
    
      <category term="golang" scheme="https://alexbrucelu.github.io/categories/golang/"/>
    
    
      <category term="golang" scheme="https://alexbrucelu.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>函数和方法的区别</title>
    <link href="https://alexbrucelu.github.io/2018/12/19/go%E4%B8%AD%E5%87%BD%E6%95%B0%E5%92%8C%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://alexbrucelu.github.io/2018/12/19/go中函数和方法的区别/</id>
    <published>2018-12-19T01:32:15.033Z</published>
    <updated>2018-12-19T02:15:35.120Z</updated>
    
    <content type="html"><![CDATA[<p><strong> 函数和方法的区别：</strong> <excerpt in="" index="" |="" 首页摘要=""></excerpt></p><p>go语言养成记之函数和方法的区别</p><a id="more"></a><p>[TOC]</p><p>在接触到<code>go</code>之前，我认为函数和方法只是同一个东西的两个名字而已（在我熟悉的<code>c/c++</code>，<code>python</code>，<code>java</code>中没有明显的区别），但是在<code>golang</code>中者完全是两个不同的东西。官方的解释是，方法是包含了接收者的函数。到底什么意思呢。</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>首先函数的格式是固定的，func＋函数名＋ 参数 ＋ 返回值（可选） ＋ 函数体。例:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"hello golang"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在golang中有两个特殊的函数，<code>main</code>函数和<code>init</code>函数，<code>main</code>函数不用介绍在所有语言中都一样，它作为一个程序的入口，只能有一个。<code>init</code>函数在每个package是可选的，可有可无，甚至可以有多个(但是强烈建议一个package中一个init函数)，init函数在你导入该package时程序会自动调用init函数，所以init函数不用我们手动调用,l另外它只会被调用一次，因为当一个package被多次引用时，它只会被导入一次。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> my</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> I <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    I = <span class="number">0</span></span><br><span class="line">    fmt.Println(<span class="string">"Call my init1"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    I = <span class="number">1</span></span><br><span class="line">    fmt.Println(<span class="string">"Call my init2"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"my"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"hello go .... I ="</span>,my.I)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>执行结果：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Call my init1</span><br><span class="line">Call my init2</span><br><span class="line">hello go .... I = 1</span><br></pre></td></tr></table></figure><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> myint <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *myint)</span> <span class="title">double</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">*m = *m * <span class="number">2</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m myint)</span> <span class="title">square</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">m = m * m</span><br><span class="line">fmt.Printf(<span class="string">"square is %d\n"</span>, m)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> i myint = <span class="number">2</span></span><br><span class="line">i.double()</span><br><span class="line">fmt.Println(<span class="string">"i = "</span>,i)</span><br><span class="line">i.square()</span><br><span class="line">fmt.Println(<span class="string">"i = "</span>,i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>执行结果：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">i = 4</span><br><span class="line">square is 16</span><br><span class="line">i = 4</span><br></pre></td></tr></table></figure><p>我们可以看到方法和函数的区别，方法在<code>func</code>关键字后是接收者而不是函数名，接收者可以是自己定义的一个类型，这个类型可以是<code>struct</code>，<code>interface</code>，甚至我们可以重定义基本数据类型。我们可以给他一些我们想要的方法来满足我们的实际工程中的需求，就像上面一样我重定义了int并给了它一个乘2和平法的方法，这里我们要注意一个细节，接收者是指针和非指针的区别，我们可以看到当接收者为指针式，我们可以通过方法改变该接收者的属性，但是非指针类型缺做不到。</p><p>这里的接收者和c++中的this指针有一些相似，我们可以把接受者当作一个class，而这些方法就是类的成员函数，当接收者为指针类型是就是c++中的非const成员函数，为非指针时就是const成员函数，不能通过此方法改变累的成员变量。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt; 函数和方法的区别：&lt;/strong&gt; &lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;/excerpt&gt;&lt;/p&gt;
&lt;p&gt;go语言养成记之函数和方法的区别&lt;/p&gt;
    
    </summary>
    
      <category term="golang" scheme="https://alexbrucelu.github.io/categories/golang/"/>
    
    
      <category term="golang" scheme="https://alexbrucelu.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>go操作Redis</title>
    <link href="https://alexbrucelu.github.io/2018/12/18/go%E6%93%8D%E4%BD%9Credis/"/>
    <id>https://alexbrucelu.github.io/2018/12/18/go操作redis/</id>
    <published>2018-12-18T11:26:01.944Z</published>
    <updated>2018-12-19T03:54:19.087Z</updated>
    
    <content type="html"><![CDATA[<p><strong> go操作Redis：</strong> <excerpt in="" index="" |="" 首页摘要=""></excerpt></p><p>Redis的简介及golang简易操作redis</p><a id="more"></a><p>[TOC]</p><h2 id="redis简介"><a href="#redis简介" class="headerlink" title="redis简介"></a>redis简介</h2><p>redis（REmote DIctionary Server）是一个由Salvatore Sanfilippo 写的<code>Key-value</code>存储系统，由<code>C</code>语言编写、遵守<code>BSD协议</code>、支持网络、可基于内存亦可持久化的日志型、<code>Key-Value</code>类型的数据库，并提供多种语言的API。和Memcached类似，它支持存储的value类型相对更多，包括<code>string(字符串)</code>、<code>list(链表)</code>、<code>set(集合)</code>、<code>zset(sorted set --有序集合)</code>和<code>hash（哈希类型）</code>。这些数据类型都支持push/pop、add/remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。在此基础上，redis支持各种不同方式的排序。与memcached一样，为了保证效率，数据都是缓存在内存中。区别的是redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步，redis在3.0版本推出集群模式。</p><p>官方网站：<a href="https://redis.io/" target="_blank" rel="noopener">https://redis.io/</a></p><h2 id="源码部署"><a href="#源码部署" class="headerlink" title="源码部署"></a>源码部署</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ yum install gcc -y  <span class="comment">#安装C依赖</span></span><br><span class="line">$ wget http://download.redis.io/redis-stable.tar.gz  <span class="comment">#下载稳定版本</span></span><br><span class="line">$ tar zxvf redis-stable.tar.gz  <span class="comment">#解压</span></span><br><span class="line">$ <span class="built_in">cd</span> redis-stable</span><br><span class="line">$ make PREFIX=/opt/app/redis install   <span class="comment">#指定目录编译</span></span><br><span class="line">$ make install</span><br><span class="line">$ mkdir /etc/redis   <span class="comment">#建立配置目录</span></span><br><span class="line">$ cp redis.conf /etc/redis/6379.conf <span class="comment"># 拷贝配置文件</span></span><br><span class="line">$ cp utils/redis_init_script /etc/init.d/redis  <span class="comment">#拷贝init启动脚本针对6.X系统</span></span><br><span class="line">$ chmod a+x  /etc/init.d/redis  <span class="comment">#添加执行权限</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改配置文件：</span></span><br><span class="line">$ vi /etc/redis/6379.conf</span><br><span class="line"><span class="built_in">bind</span> 0.0.0.0      <span class="comment">#监听地址</span></span><br><span class="line">maxmemory 4294967296   <span class="comment">#限制最大内存（4G）：</span></span><br><span class="line">daemonize yes   <span class="comment">#后台运行</span></span><br></pre></td></tr></table></figure><h3 id="启动与停止"><a href="#启动与停止" class="headerlink" title="启动与停止"></a>启动与停止</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">####启动与停止</span></span><br><span class="line">$ /etc/init.d/redis start</span><br><span class="line">$ /etc/init.d/redis stop</span><br></pre></td></tr></table></figure><h3 id="查看版本信息"><a href="#查看版本信息" class="headerlink" title="查看版本信息"></a>查看版本信息</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#执行客户端工具</span></span><br><span class="line">$ redis-cli </span><br><span class="line"><span class="comment">#输入命令info</span></span><br><span class="line">127.0.0.1:6379&gt; info</span><br><span class="line"><span class="comment"># Server</span></span><br><span class="line">redis_version:4.0.10</span><br><span class="line">redis_git_sha1:00000000</span><br><span class="line">redis_git_dirty:0</span><br><span class="line">redis_build_id:cf83e9c690dbed33</span><br><span class="line">redis_mode:standalone</span><br><span class="line">os:Linux 2.6.32-642.el6.x86_64 x86_64</span><br><span class="line">arch_bits:64</span><br><span class="line">multiplexing_api:epoll</span><br></pre></td></tr></table></figure><h2 id="golang操作redis"><a href="#golang操作redis" class="headerlink" title="golang操作redis"></a>golang操作redis</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>golang操作redis的客户端包有多个比如<code>redigo</code>、<code>go-redis</code>，github上Star最多的莫属<code>redigo</code>。</p><p>github地址：<a href="https://github.com/garyburd/redigo" target="_blank" rel="noopener">https://github.com/garyburd/redigo</a>  </p><p>目前已经迁移到：<a href="https://github.com/gomodule/redigo" target="_blank" rel="noopener">https://github.com/gomodule/redigo</a> </p><p>文档：<a href="https://godoc.org/github.com/garyburd/redigo/redis" target="_blank" rel="noopener">https://godoc.org/github.com/garyburd/redigo/redis</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ go get github.com/garyburd/redigo/redis</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"github.com/garyburd/redigo/redis"</span></span><br></pre></td></tr></table></figure><h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><p><code>Conn</code>接口是与<code>Redis</code>协作的主要接口，可以使用<code>Dial</code>,<code>DialWithTimeout</code>或者<code>NewConn</code>函数来创建连接，当任务完成时，应用程序必须调用<code>Close</code>函数来完成操作。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"github.com/garyburd/redigo/redis"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">    conn,err := redis.Dial(<span class="string">"tcp"</span>,<span class="string">"10.1.210.69:6379"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"connect redis error :"</span>,err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> conn.Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="命令操作"><a href="#命令操作" class="headerlink" title="命令操作"></a>命令操作</h3><p>通过使用Conn接口中的do方法执行redis命令，redis命令大全参考：<a href="http://doc.redisfans.com/" target="_blank" rel="noopener">http://doc.redisfans.com/</a></p><p>go中发送与响应对应类型：</p><p><code>Do</code>函数会必要时将参数转化为二进制字符串</p><table><thead><tr><th style="text-align:left"><strong>Go Type</strong></th><th style="text-align:center"><strong>Conversion</strong></th></tr></thead><tbody><tr><td style="text-align:left">[]byte</td><td style="text-align:center">Sent as is</td></tr><tr><td style="text-align:left">string</td><td style="text-align:center">Sent as is</td></tr><tr><td style="text-align:left">int, int64</td><td style="text-align:center">strconv.FormatInt(v)</td></tr><tr><td style="text-align:left">float64</td><td style="text-align:center">strconv.FormatFloat(v, ‘g’, -1, 64)</td></tr><tr><td style="text-align:left">bool</td><td style="text-align:center">true -&gt; “1”, false -&gt; “0”</td></tr><tr><td style="text-align:left">nil</td><td style="text-align:center">“”</td></tr><tr><td style="text-align:left">all other types</td><td style="text-align:center">fmt.Print(v)</td></tr></tbody></table><p>Redis 命令响应会用以下Go类型表示：</p><table><thead><tr><th>Redis Type</th><th>Go Type</th></tr></thead><tbody><tr><td>error</td><td>redis.Error</td></tr><tr><td>interger</td><td>int64</td></tr><tr><td>simple string</td><td>string</td></tr><tr><td>bulk string</td><td>[]byte or nil if value not present</td></tr><tr><td>arrary</td><td>[]interface{} or nil if value not present</td></tr></tbody></table><p>可以使用GO的类型断言或者<code>reply</code>辅助函数将返回的<code>interface{}</code>转换为对应类型。</p><h4 id="操作示例：get、set"><a href="#操作示例：get、set" class="headerlink" title="操作示例：get、set"></a>操作示例：<strong><code>get</code>、<code>set</code></strong></h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"github.com/garyburd/redigo/redis"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">    conn,err := redis.Dial(<span class="string">"tcp"</span>,<span class="string">"10.1.210.69:6379"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"connect redis error :"</span>,err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> conn.Close()</span><br><span class="line">    _, err = conn.Do(<span class="string">"SET"</span>, <span class="string">"name"</span>, <span class="string">"wd"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"redis set error:"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    name, err := redis.String(conn.Do(<span class="string">"GET"</span>, <span class="string">"name"</span>))</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"redis get error:"</span>, err)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"Got name: %s \n"</span>, name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="设置key过期时间"><a href="#设置key过期时间" class="headerlink" title="设置key过期时间"></a>设置key过期时间</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_, err = conn.Do(<span class="string">"expire"</span>, <span class="string">"name"</span>, <span class="number">10</span>) <span class="comment">//10秒过期</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"set expire error: "</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="批量获取mget、批量设置mset"><a href="#批量获取mget、批量设置mset" class="headerlink" title="批量获取mget、批量设置mset"></a>批量获取mget、批量设置mset</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">_, err = conn.Do(<span class="string">"MSET"</span>, <span class="string">"name"</span>, <span class="string">"wd"</span>,<span class="string">"age"</span>,<span class="number">22</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"redis mset error:"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    res, err := redis.Strings(conn.Do(<span class="string">"MGET"</span>, <span class="string">"name"</span>,<span class="string">"age"</span>))</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"redis get error:"</span>, err)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        res_type := reflect.TypeOf(res)</span><br><span class="line">        fmt.Printf(<span class="string">"res type : %s \n"</span>, res_type)</span><br><span class="line">        fmt.Printf(<span class="string">"MGET name: %s \n"</span>, res)</span><br><span class="line">        fmt.Println(<span class="built_in">len</span>(res))</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//结果：</span></span><br><span class="line"><span class="comment">//res type : []string </span></span><br><span class="line"><span class="comment">//MGET name: [wd 22] </span></span><br><span class="line"><span class="comment">//2</span></span><br></pre></td></tr></table></figure><h4 id="列表操作"><a href="#列表操作" class="headerlink" title="列表操作"></a>列表操作</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"github.com/garyburd/redigo/redis"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">    conn,err := redis.Dial(<span class="string">"tcp"</span>,<span class="string">"10.1.210.69:6379"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"connect redis error :"</span>,err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> conn.Close()</span><br><span class="line">    _, err = conn.Do(<span class="string">"LPUSH"</span>, <span class="string">"list1"</span>, <span class="string">"ele1"</span>,<span class="string">"ele2"</span>,<span class="string">"ele3"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"redis mset error:"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    res, err := redis.String(conn.Do(<span class="string">"LPOP"</span>, <span class="string">"list1"</span>))</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"redis POP error:"</span>, err)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        res_type := reflect.TypeOf(res)</span><br><span class="line">        fmt.Printf(<span class="string">"res type : %s \n"</span>, res_type)</span><br><span class="line">        fmt.Printf(<span class="string">"res  : %s \n"</span>, res)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//res type : string </span></span><br><span class="line"><span class="comment">//res  : ele3</span></span><br></pre></td></tr></table></figure><h4 id="hash操作"><a href="#hash操作" class="headerlink" title="hash操作"></a>hash操作</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"github.com/garyburd/redigo/redis"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">    conn,err := redis.Dial(<span class="string">"tcp"</span>,<span class="string">"10.1.210.69:6379"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"connect redis error :"</span>,err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> conn.Close()</span><br><span class="line">    _, err = conn.Do(<span class="string">"HSET"</span>, <span class="string">"student"</span>,<span class="string">"name"</span>, <span class="string">"wd"</span>,<span class="string">"age"</span>,<span class="number">22</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"redis mset error:"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    res, err := redis.Int64(conn.Do(<span class="string">"HGET"</span>, <span class="string">"student"</span>,<span class="string">"age"</span>))</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"redis HGET error:"</span>, err)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        res_type := reflect.TypeOf(res)</span><br><span class="line">        fmt.Printf(<span class="string">"res type : %s \n"</span>, res_type)</span><br><span class="line">        fmt.Printf(<span class="string">"res  : %d \n"</span>, res)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//res type : int64 </span></span><br><span class="line"><span class="comment">//res  : 22</span></span><br></pre></td></tr></table></figure><h4 id="Pipelining-管道"><a href="#Pipelining-管道" class="headerlink" title="Pipelining(管道)"></a>Pipelining(管道)</h4><p>管道操作可以理解为并发操作，并通过<code>Send()</code>，<code>Flush()</code>，<code>Receive()</code>三个方法实现。客户端可以使用<code>send()</code>方法一次性向服务器发送一个或多个命令，命令发送完毕时，使用<code>flush()</code>方法将缓冲区的命令输入一次性发送到服务器，客户端再使用<code>Receive()</code>方法依次按照先进先出的顺序读取所有命令操作结果。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Send(commandName <span class="keyword">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;) error</span><br><span class="line">Flush() error</span><br><span class="line">Receive() (reply <span class="keyword">interface</span>&#123;&#125;, err error)</span><br></pre></td></tr></table></figure><ul><li><code>Send</code>：发送命令至缓冲区</li><li><code>Flush</code>:  清空缓冲区，将命令一次性发送至服务器</li><li><code>Recevie</code>:  依次读取服务器响应结果，当读取的命令未响应时，该操作会阻塞</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"github.com/garyburd/redigo/redis"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">    conn,err := redis.Dial(<span class="string">"tcp"</span>,<span class="string">"10.1.210.69:6379"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"connect redis error :"</span>,err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> conn.Close()</span><br><span class="line">    conn.Send(<span class="string">"HSET"</span>, <span class="string">"student"</span>,<span class="string">"name"</span>, <span class="string">"wd"</span>,<span class="string">"age"</span>,<span class="string">"22"</span>)</span><br><span class="line">    conn.Send(<span class="string">"HSET"</span>, <span class="string">"student"</span>,<span class="string">"Score"</span>,<span class="string">"100"</span>)</span><br><span class="line">    conn.Send(<span class="string">"HGET"</span>, <span class="string">"student"</span>,<span class="string">"age"</span>)</span><br><span class="line">    conn.Flush()</span><br><span class="line"></span><br><span class="line">    res1, err := conn.Receive()</span><br><span class="line">    fmt.Printf(<span class="string">"Receive res1:%v \n"</span>, res1)</span><br><span class="line">    res2, err := conn.Receive()</span><br><span class="line">    fmt.Printf(<span class="string">"Receive res2:%v\n"</span>,res2)</span><br><span class="line">    res3, err := conn.Receive()</span><br><span class="line">    fmt.Printf(<span class="string">"Receive res3:%s\n"</span>,res3)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Receive res1:0 </span></span><br><span class="line"><span class="comment">//Receive res2:0</span></span><br><span class="line"><span class="comment">//Receive res3:22</span></span><br></pre></td></tr></table></figure><h4 id="发布-订阅"><a href="#发布-订阅" class="headerlink" title="发布/订阅"></a>发布/订阅</h4><p>redis本身具有发布订阅的功能，其发布订阅功能通过命令SUBSCRIBE(订阅)／PUBLISH(发布)实现，并且发布订阅模式可以是多对多模式还可支持正则表达式，发布者可以向一个或多个频道发送消息，订阅者可订阅一个或者多个频道接受消息。</p><blockquote><ul><li><p>示意图：</p><ul><li><p>发布者：</p><p><img src="https://github.com/AlexBruceLu/DAPP/wiki/rd1.png" alt=""></p></li><li><p>订阅者：</p><p><img src="https://github.com/AlexBruceLu/DAPP/wiki/rd2.png" alt=""></p></li></ul></li></ul></blockquote><p>操作示例，示例中将使用两个<code>goroutine</code>分别担任发布者和订阅者角色进行演示：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"github.com/garyburd/redigo/redis"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Subs</span><span class="params">()</span></span> &#123;  <span class="comment">//订阅者</span></span><br><span class="line">    conn, err := redis.Dial(<span class="string">"tcp"</span>, <span class="string">"10.1.210.69:6379"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"connect redis error :"</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> conn.Close()</span><br><span class="line">    psc := redis.PubSubConn&#123;conn&#125;</span><br><span class="line">    psc.Subscribe(<span class="string">"channel1"</span>) <span class="comment">//订阅channel1频道</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> v := psc.Receive().(<span class="keyword">type</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> redis.Message:</span><br><span class="line">            fmt.Printf(<span class="string">"%s: message: %s\n"</span>, v.Channel, v.Data)</span><br><span class="line">        <span class="keyword">case</span> redis.Subscription:</span><br><span class="line">            fmt.Printf(<span class="string">"%s: %s %d\n"</span>, v.Channel, v.Kind, v.Count)</span><br><span class="line">        <span class="keyword">case</span> error:</span><br><span class="line">            fmt.Println(v)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Push</span><span class="params">(message <span class="keyword">string</span>)</span></span>  &#123; <span class="comment">//发布者</span></span><br><span class="line">    conn, _ := redis.Dial(<span class="string">"tcp"</span>, <span class="string">"10.1.210.69:6379"</span>)</span><br><span class="line">    _,err1 := conn.Do(<span class="string">"PUBLISH"</span>, <span class="string">"channel1"</span>, message)</span><br><span class="line">    <span class="keyword">if</span> err1 != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"pub err: "</span>, err1)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">    <span class="keyword">go</span> Subs()</span><br><span class="line">    <span class="keyword">go</span> Push(<span class="string">"this is wd"</span>)</span><br><span class="line">    time.Sleep(time.Second*<span class="number">3</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//channel1: subscribe 1</span></span><br><span class="line"><span class="comment">//channel1: message: this is wd</span></span><br></pre></td></tr></table></figure><h4 id="事务操作"><a href="#事务操作" class="headerlink" title="事务操作"></a>事务操作</h4><p><code>MULTI</code>, <code>EXEC</code>,<code>DISCARD</code>和<code>WATCH</code>是构成Redis事务的基础，当然我们使用go语言对redis进行事务操作的时候本质也是使用这些命令。</p><p><code>MULTI</code>：开启事务</p><p><code>EXEC</code>：执行事务</p><p><code>DISCARD</code>：取消事务</p><p><code>WATCH</code>：监视事务中的键变化，一旦有改变则取消事务</p><font color="red"><strong>示例：</strong></font><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"github.com/garyburd/redigo/redis"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">    conn,err := redis.Dial(<span class="string">"tcp"</span>,<span class="string">"10.1.210.69:6379"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"connect redis error :"</span>,err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> conn.Close()</span><br><span class="line">    conn.Send(<span class="string">"MULTI"</span>)</span><br><span class="line">    conn.Send(<span class="string">"INCR"</span>, <span class="string">"foo"</span>)</span><br><span class="line">    conn.Send(<span class="string">"INCR"</span>, <span class="string">"bar"</span>)</span><br><span class="line">    r, err := conn.Do(<span class="string">"EXEC"</span>)</span><br><span class="line">    fmt.Println(r)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//[1, 1]</span></span><br></pre></td></tr></table></figure><h4 id="连接池使用"><a href="#连接池使用" class="headerlink" title="连接池使用"></a>连接池使用</h4><p><code>redis</code>连接池是通过<code>pool</code>结构体实现，以下是源码定义，相关参数说明已经备注：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Pool <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// Dial is an application supplied function for creating and configuring a</span></span><br><span class="line">    <span class="comment">// connection.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// The connection returned from Dial must not be in a special state</span></span><br><span class="line">    <span class="comment">// (subscribed to pubsub channel, transaction started, ...).</span></span><br><span class="line">    Dial <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="params">(Conn, error)</span> //连接方法</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    // <span class="title">TestOnBorrow</span> <span class="title">is</span> <span class="title">an</span> <span class="title">optional</span> <span class="title">application</span> <span class="title">supplied</span> <span class="title">function</span> <span class="title">for</span> <span class="title">checking</span></span></span><br><span class="line"><span class="function">    // <span class="title">the</span> <span class="title">health</span> <span class="title">of</span> <span class="title">an</span> <span class="title">idle</span> <span class="title">connection</span> <span class="title">before</span> <span class="title">the</span> <span class="title">connection</span> <span class="title">is</span> <span class="title">used</span> <span class="title">again</span> <span class="title">by</span></span></span><br><span class="line"><span class="function">// <span class="title">the</span> <span class="title">application</span>. <span class="title">Argument</span> <span class="title">t</span> <span class="title">is</span> <span class="title">the</span> <span class="title">time</span> <span class="title">that</span> <span class="title">the</span> <span class="title">connection</span> <span class="title">was</span> <span class="title">returned</span></span></span><br><span class="line"><span class="function">    // <span class="title">to</span> <span class="title">the</span> <span class="title">pool</span>. <span class="title">If</span> <span class="title">the</span> <span class="title">function</span> <span class="title">returns</span> <span class="title">an</span> <span class="title">error</span>, <span class="title">then</span> <span class="title">the</span> <span class="title">connection</span> <span class="title">is</span></span></span><br><span class="line"><span class="function">    // <span class="title">closed</span>.</span></span><br><span class="line"><span class="function">    <span class="title">TestOnBorrow</span> <span class="title">func</span><span class="params">(c Conn, t time.Time)</span> <span class="title">error</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    // <span class="title">Maximum</span> <span class="title">number</span> <span class="title">of</span> <span class="title">idle</span> <span class="title">connections</span> <span class="title">in</span> <span class="title">the</span> <span class="title">pool</span>.</span></span><br><span class="line"><span class="function">    <span class="title">MaxIdle</span> <span class="title">int</span>  //最大的空闲连接数，即使没有<span class="title">redis</span>连接时依然可以保持<span class="title">N</span>个空闲的连接，而不被清除，随时处于待命状态</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    // <span class="title">Maximum</span> <span class="title">number</span> <span class="title">of</span> <span class="title">connections</span> <span class="title">allocated</span> <span class="title">by</span> <span class="title">the</span> <span class="title">pool</span> <span class="title">at</span> <span class="title">a</span> <span class="title">given</span> <span class="title">time</span>.</span></span><br><span class="line"><span class="function">    // <span class="title">When</span> <span class="title">zero</span>, <span class="title">there</span> <span class="title">is</span> <span class="title">no</span> <span class="title">limit</span> <span class="title">on</span> <span class="title">the</span> <span class="title">number</span> <span class="title">of</span> <span class="title">connections</span> <span class="title">in</span> <span class="title">the</span> <span class="title">pool</span>.</span></span><br><span class="line"><span class="function">    <span class="title">MaxActive</span> <span class="title">int</span> //最大的激活连接数，同时最多有<span class="title">N</span>个连接</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    // <span class="title">Close</span> <span class="title">connections</span> <span class="title">after</span> <span class="title">remaining</span> <span class="title">idle</span> <span class="title">for</span> <span class="title">this</span> <span class="title">duration</span>. <span class="title">If</span> <span class="title">the</span> <span class="title">value</span></span></span><br><span class="line"><span class="function">    // <span class="title">is</span> <span class="title">zero</span>, <span class="title">then</span> <span class="title">idle</span> <span class="title">connections</span> <span class="title">are</span> <span class="title">not</span> <span class="title">closed</span>. <span class="title">Applications</span> <span class="title">should</span> <span class="title">set</span></span></span><br><span class="line"><span class="function">    // <span class="title">the</span> <span class="title">timeout</span> <span class="title">to</span> <span class="title">a</span> <span class="title">value</span> <span class="title">less</span> <span class="title">than</span> <span class="title">the</span> <span class="title">server</span>'<span class="title">s</span> <span class="title">timeout</span>.</span></span><br><span class="line"><span class="function">    <span class="title">IdleTimeout</span> <span class="title">time</span>.<span class="title">Duration</span>  //空闲连接等待时间，超过此时间后，空闲连接将被关闭</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    // <span class="title">If</span> <span class="title">Wait</span> <span class="title">is</span> <span class="title">true</span> <span class="title">and</span> <span class="title">the</span> <span class="title">pool</span> <span class="title">is</span> <span class="title">at</span> <span class="title">the</span> <span class="title">MaxActive</span> <span class="title">limit</span>, <span class="title">then</span> <span class="title">Get</span><span class="params">()</span> <span class="title">waits</span></span></span><br><span class="line"><span class="function">    // <span class="title">for</span> <span class="title">a</span> <span class="title">connection</span> <span class="title">to</span> <span class="title">be</span> <span class="title">returned</span> <span class="title">to</span> <span class="title">the</span> <span class="title">pool</span> <span class="title">before</span> <span class="title">returning</span>.</span></span><br><span class="line"><span class="function">    <span class="title">Wait</span> <span class="title">bool</span>  //当配置项为<span class="title">true</span>并且<span class="title">MaxActive</span>参数有限制时候，使用<span class="title">Get</span>方法等待一个连接返回给连接池</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    // <span class="title">Close</span> <span class="title">connections</span> <span class="title">older</span> <span class="title">than</span> <span class="title">this</span> <span class="title">duration</span>. <span class="title">If</span> <span class="title">the</span> <span class="title">value</span> <span class="title">is</span> <span class="title">zero</span>, <span class="title">then</span></span></span><br><span class="line"><span class="function">    // <span class="title">the</span> <span class="title">pool</span> <span class="title">does</span> <span class="title">not</span> <span class="title">close</span> <span class="title">connections</span> <span class="title">based</span> <span class="title">on</span> <span class="title">age</span>.</span></span><br><span class="line"><span class="function">    <span class="title">MaxConnLifetime</span> <span class="title">time</span>.<span class="title">Duration</span></span></span><br><span class="line"><span class="function">    // <span class="title">contains</span> <span class="title">filtered</span> <span class="title">or</span> <span class="title">unexported</span> <span class="title">fields</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><font color="red"><strong>示例：</strong></font><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"github.com/garyburd/redigo/redis"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Pool redis.Pool</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span>  &#123;      <span class="comment">//init 用于初始化一些参数，先于main执行</span></span><br><span class="line">    Pool = redis.Pool&#123;</span><br><span class="line">        MaxIdle:     <span class="number">16</span>,</span><br><span class="line">        MaxActive:   <span class="number">32</span>,</span><br><span class="line">        IdleTimeout: <span class="number">120</span>,</span><br><span class="line">        Dial: <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="params">(redis.Conn, error)</span></span> &#123;</span><br><span class="line">            <span class="keyword">return</span> redis.Dial(<span class="string">"tcp"</span>, <span class="string">"10.1.210.69:6379"</span>)</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line"></span><br><span class="line">    conn :=Pool.Get()</span><br><span class="line">    res,err := conn.Do(<span class="string">"HSET"</span>,<span class="string">"student"</span>,<span class="string">"name"</span>,<span class="string">"jack"</span>)</span><br><span class="line">    fmt.Println(res,err)</span><br><span class="line">    res1,err := redis.String(conn.Do(<span class="string">"HGET"</span>,<span class="string">"student"</span>,<span class="string">"name"</span>))</span><br><span class="line">    fmt.Printf(<span class="string">"res:%s,error:%v"</span>,res1,err)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//0 &lt;nil&gt;</span></span><br><span class="line"><span class="comment">//res:jack,error:&lt;nil&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Golang-redis-学习指南"><a href="#Golang-redis-学习指南" class="headerlink" title="Golang redis 学习指南"></a>Golang redis 学习指南</h2><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><h4 id="创建客户端"><a href="#创建客户端" class="headerlink" title="创建客户端"></a>创建客户端</h4><p>通过 redis.NewClient 函数即可创建一个 redis 客户端, 这个方法接收一个 <code>redis.Options</code>对象参数, 通过这个参数, 我们可以配置 redis 相关的属性, 例如 redis 服务器地址, 数据库名, 数据库密码等.<br>下面是一个连接的例子:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建 redis 客户端</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createClient</span><span class="params">()</span> *<span class="title">redis</span>.<span class="title">Client</span></span> &#123;</span><br><span class="line"></span><br><span class="line">client := redis.NewClient(&amp;redis.Options&#123;</span><br><span class="line">Addr:     <span class="string">"localhost:6379"</span>,</span><br><span class="line">Password: <span class="string">""</span>,</span><br><span class="line">DB:       <span class="number">0</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 cient.Ping() 来检查是否成功连接到了 redis 服务器</span></span><br><span class="line">pong, err := client.Ping().Result()</span><br><span class="line">fmt.Println(pong, err)</span><br><span class="line"><span class="keyword">return</span> client</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="String-操作"><a href="#String-操作" class="headerlink" title="String 操作"></a>String 操作</h4><p><code>redis</code>的<code>String</code>操作有:</p><blockquote><p>set(key, value)：给数据库中名称为key的string赋予值value</p><p>get(key)：返回数据库中名称为key的string的value</p><p>getset(key, value)：给名称为key的string赋予上一次的value</p><p>mget(key1, key2,…, key N)：返回库中多个string的value</p><p>setnx(key, value)：添加string，名称为key，值为value</p><p>setex(key, time, value)：向库中添加string，设定过期时间time</p><p>mset(key N, value N)：批量设置多个string的值</p><p>msetnx(key N, value N)：如果所有名称为key i的string都不存在</p><p>incr(key)：名称为key的string增1操作</p><p>incrby(key, integer)：名称为key的string增加integer</p><p>decr(key)：名称为key的string减1操作</p><p>decrby(key, integer)：名称为key的string减少integer</p><p>append(key, value)：名称为key的string的值附加value</p><p>substr(key, start, end)：返回名称为key的string的value的子串</p></blockquote><p>在 <code>go-redis</code> 中, 我们可以直接找到对应的操作方法, 直接上代码:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// String 操作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">stringOperation</span><span class="params">(client *redis.Client)</span></span> &#123;</span><br><span class="line"><span class="comment">// 第三个参数是过期时间, 如果是0, 则表示没有过期时间.</span></span><br><span class="line">err := client.Set(<span class="string">"name"</span>, <span class="string">"xys"</span>, <span class="number">0</span>).Err()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">val, err := client.Get(<span class="string">"name"</span>).Result()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"> <span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">"name"</span>, val)</span><br><span class="line"><span class="comment">// 这里设置过期时间.</span></span><br><span class="line">err = client.Set(<span class="string">"age"</span>, <span class="string">"20"</span>, <span class="number">1</span> * time.Second).Err()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">client.Incr(<span class="string">"age"</span>) <span class="comment">// 自增</span></span><br><span class="line">client.Incr(<span class="string">"age"</span>) <span class="comment">// 自增</span></span><br><span class="line">client.Decr(<span class="string">"age"</span>) <span class="comment">// 自减</span></span><br><span class="line"></span><br><span class="line">val, err = client.Get(<span class="string">"age"</span>).Result()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">"age"</span>, val) <span class="comment">// age 的值为21</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为 key "age" 的过期时间是一秒钟, 因此当一秒后, 此 key 会自动被删除了.</span></span><br><span class="line">time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">val, err = client.Get(<span class="string">"age"</span>).Result()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// 因为 key "age" 已经过期了, 因此会有一个 redis: nil 的错误.</span></span><br><span class="line">fmt.Printf(<span class="string">"error: %v\n"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"age"</span>, val)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="list-操作"><a href="#list-操作" class="headerlink" title="list 操作"></a>list 操作</h4><p>redis 的 list 操作有:</p><blockquote><p>rpush(key, value)：在名称为key的list尾添加一个值为value的元素</p><p>lpush(key, value)：在名称为key的list头添加一个值为value的 元素</p><p>llen(key)：返回名称为key的list的长度</p><p>lrange(key, start, end)：返回名称为key的list中start至end之间的元素</p><p>ltrim(key, start, end)：截取名称为key的list</p><p>lindex(key, index)：返回名称为key的list中index位置的元素</p><p>lset(key, index, value)：给名称为key的list中index位置的元素赋值</p><p>lrem(key, count, value)：删除count个key的list中值为value的元素</p><p>lpop(key)：返回并删除名称为key的list中的首元素</p><p>rpop(key)：返回并删除名称为key的list中的尾元素</p><p>blpop(key1, key2,… key N, timeout)：lpop命令的block版本。</p><p>brpop(key1, key2,… key N, timeout)：rpop的block版本。</p><p>rpoplpush(srckey, dstkey)：返回并删除名称为srckey的list的尾元素，并将该元素添加到名称为dstkey的list的头部</p></blockquote><p>同样地, 在 go-redis 中也可以找到对应的方法, 下面是一个简单的示例:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// list 操作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">listOperation</span><span class="params">(client *redis.Client)</span></span> &#123;</span><br><span class="line">client.RPush(<span class="string">"fruit"</span>, <span class="string">"apple"</span>) <span class="comment">//在名称为 fruit 的list尾添加一个值为value的元素</span></span><br><span class="line">client.LPush(<span class="string">"fruit"</span>, <span class="string">"banana"</span>) <span class="comment">//在名称为 fruit 的list头添加一个值为value的 元素</span></span><br><span class="line">length, err := client.LLen(<span class="string">"fruit"</span>).Result() <span class="comment">//返回名称为 fruit 的list的长度</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"length: "</span>, length) <span class="comment">// 长度为2</span></span><br><span class="line">value, err := client.LPop(<span class="string">"fruit"</span>).Result() <span class="comment">//返回并删除名称为 fruit 的list中的首元素</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"fruit: "</span>, value)</span><br><span class="line">value, err = client.RPop(<span class="string">"fruit"</span>).Result() <span class="comment">// 返回并删除名称为 fruit 的list中的尾元素</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"fruit: "</span>, value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="set-操作"><a href="#set-操作" class="headerlink" title="set 操作"></a>set 操作</h4><blockquote><p>redis 的 set 操作:</p><p>sadd(key, member)：向名称为key的set中添加元素member</p><p>srem(key, member) ：删除名称为key的set中的元素member</p><p>spop(key) ：随机返回并删除名称为key的set中一个元素</p><p>smove(srckey, dstkey, member) ：移到集合元素</p><p>scard(key) ：返回名称为key的set的基数</p><p>sismember(key, member) ：member是否是名称为key的set的元素</p><p>sinter(key1, key2,…key N) ：求交集</p><p>sinterstore(dstkey, (keys)) ：求交集并将交集保存到dstkey的集合</p><p>sunion(key1, (keys)) ：求并集</p><p>sunionstore(dstkey, (keys)) ：求并集并将并集保存到dstkey的集合</p><p>sdiff(key1, (keys)) ：求差集</p><p>sdiffstore(dstkey, (keys)) ：求差集并将差集保存到dstkey的集合</p><p>smembers(key) ：返回名称为key的set的所有元素</p><p>srandmember(key) ：随机返回名称为key的set的一个元素</p></blockquote><p>接下来是 go-redis 的 set 操作:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// set 操作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setOperation</span><span class="params">(client *redis.Client)</span></span> &#123;</span><br><span class="line">client.SAdd(<span class="string">"blacklist"</span>, <span class="string">"Obama"</span>) <span class="comment">// 向 blacklist 中添加元素</span></span><br><span class="line">client.SAdd(<span class="string">"blacklist"</span>, <span class="string">"Hillary"</span>) <span class="comment">// 再次添加</span></span><br><span class="line">client.SAdd(<span class="string">"blacklist"</span>, <span class="string">"the Elder"</span>) <span class="comment">// 添加新元素</span></span><br><span class="line">client.SAdd(<span class="string">"whitelist"</span>, <span class="string">"the Elder"</span>) <span class="comment">// 向 whitelist 添加元素</span></span><br><span class="line"><span class="comment">// 判断元素是否在集合中</span></span><br><span class="line">isMember, err := client.SIsMember(<span class="string">"blacklist"</span>, <span class="string">"Bush"</span>).Result()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"Is Bush in blacklist: "</span>, isMember)</span><br><span class="line"><span class="comment">// 求交集, 即既在黑名单中, 又在白名单中的元素</span></span><br><span class="line">names, err := client.SInter(<span class="string">"blacklist"</span>, <span class="string">"whitelist"</span>).Result()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取到的元素是 "the Elder"</span></span><br><span class="line">fmt.Println(<span class="string">"Inter result: "</span>, names)</span><br><span class="line"><span class="comment">// 获取指定集合的所有元素</span></span><br><span class="line">all, err := client.SMembers(<span class="string">"blacklist"</span>).Result()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"All member: "</span>, all)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="hash-操作"><a href="#hash-操作" class="headerlink" title="hash 操作"></a>hash 操作</h4><p>redis 的 hash 操作:</p><blockquote><p>hset(key, field, value)：向名称为key的hash中添加元素field</p><p>hget(key, field)：返回名称为key的hash中field对应的value</p><p>hmget(key, (fields))：返回名称为key的hash中field i对应的value</p><p>hmset(key, (fields))：向名称为key的hash中添加元素field </p><p>hincrby(key, field, integer)：将名称为key的hash中field的value增加integer</p><p>hexists(key, field)：名称为key的hash中是否存在键为field的域</p><p>hdel(key, field)：删除名称为key的hash中键为field的域</p><p>hlen(key)：返回名称为key的hash中元素个数</p><p>hkeys(key)：返回名称为key的hash中所有键</p><p>hvals(key)：返回名称为key的hash中所有键对应的value</p><p>hgetall(key)：返回名称为key的hash中所有的键（field）及其对应的value</p></blockquote><p><code>go-redis</code> 中的 hash 操作:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hash 操作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hashOperation</span><span class="params">(client *redis.Client)</span></span> &#123;</span><br><span class="line">client.HSet(<span class="string">"user_xys"</span>, <span class="string">"name"</span>, <span class="string">"xys"</span>); <span class="comment">// 向名称为 user_xys 的 hash 中添加元素 name</span></span><br><span class="line">client.HSet(<span class="string">"user_xys"</span>, <span class="string">"age"</span>, <span class="string">"18"</span>); <span class="comment">// 向名称为 user_xys 的 hash 中添加元素 age</span></span><br><span class="line"><span class="comment">// 批量地向名称为 user_test 的 hash 中添加元素 name 和 age</span></span><br><span class="line">client.HMSet(<span class="string">"user_test"</span>, <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;<span class="string">"name"</span>: <span class="string">"test"</span>, <span class="string">"age"</span>:<span class="string">"20"</span>&#125;)</span><br><span class="line"><span class="comment">// 批量获取名为 user_test 的 hash 中的指定字段的值.</span></span><br><span class="line">fields, err := client.HMGet(<span class="string">"user_test"</span>, <span class="string">"name"</span>, <span class="string">"age"</span>).Result()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"fields in user_test: "</span>, fields)</span><br><span class="line"><span class="comment">// 获取名为 user_xys 的 hash 中的字段个数</span></span><br><span class="line">length, err := client.HLen(<span class="string">"user_xys"</span>).Result()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"field count in user_xys: "</span>, length) <span class="comment">// 字段个数为2</span></span><br><span class="line"><span class="comment">// 删除名为 user_test 的 age 字段</span></span><br><span class="line">client.HDel(<span class="string">"user_test"</span>, <span class="string">"age"</span>)</span><br><span class="line">age, err := client.HGet(<span class="string">"user_test"</span>, <span class="string">"age"</span>).Result()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"Get user_test age error: %v\n"</span>, err)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"user_test age is: "</span>, age) <span class="comment">// 字段个数为2</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="关于连接池"><a href="#关于连接池" class="headerlink" title="关于连接池"></a>关于连接池</h4><p>redis.v4 包实现了 redis 的连接池管理, 因此我们就不需要自己手动管理 redis 的连接了. 默认情况下, redis.v4 的 redis 连接池大小是10, 不过我们可以在初始化 redis 客户端时自行设置连接池的大小, 例如:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">client := redis.NewClient(&amp;redis.Options&#123;</span><br><span class="line">Addr:     <span class="string">"localhost:6379"</span>,</span><br><span class="line">Password: <span class="string">""</span>,</span><br><span class="line">DB:       <span class="number">0</span>,</span><br><span class="line">PoolSize: <span class="number">5</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>通过 redis.Options 的 PoolSize 属性, 我们设置了 redis 连接池的大小为5.那么接下来我们来看一下这个设置有什么效果吧:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// redis.v4 的连接池管理</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">connectPool</span><span class="params">(client *redis.Client)</span></span> &#123;</span><br><span class="line">wg := sync.WaitGroup&#123;&#125;</span><br><span class="line">wg.Add(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">100</span>; j++ &#123;</span><br><span class="line">client.Set(fmt.Sprintf(<span class="string">"name%d"</span>, j), fmt.Sprintf(<span class="string">"xys%d"</span>, j), <span class="number">0</span>).Err()</span><br><span class="line">client.Get(fmt.Sprintf(<span class="string">"name%d"</span>, j)).Result()</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"PoolStats, TotalConns: %d, FreeConns: %d\n"</span>, client.PoolStats().TotalConns, client.PoolStats().FreeConns);</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的例子启动了10个 routine 来不断向 redis 读写数据, 然后我们通过 client.PoolStats() 获取连接池的信息. 运行这个例子, 输出如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">PoolStats, TotalConns: 5, FreeConns: 1</span><br><span class="line"></span><br><span class="line">PoolStats, TotalConns: 5, FreeConns: 1</span><br><span class="line"></span><br><span class="line">PoolStats, TotalConns: 5, FreeConns: 1</span><br><span class="line"></span><br><span class="line">PoolStats, TotalConns: 5, FreeConns: 1</span><br><span class="line"></span><br><span class="line">PoolStats, TotalConns: 5, FreeConns: 1</span><br><span class="line"></span><br><span class="line">PoolStats, TotalConns: 5, FreeConns: 2</span><br><span class="line"></span><br><span class="line">PoolStats, TotalConns: 5, FreeConns: 2</span><br><span class="line"></span><br><span class="line">PoolStats, TotalConns: 5, FreeConns: 3</span><br><span class="line"></span><br><span class="line">PoolStats, TotalConns: 5, FreeConns: 4</span><br><span class="line"></span><br><span class="line">PoolStats, TotalConns: 5, FreeConns: 5</span><br></pre></td></tr></table></figure><p>通过输出可以看到, 此时最大的连接池数量确实是 5 了, 并且一开始时, 因为 coroutine 的数量大于5, 会造成 redis 连接不足的情况(反映在 FreeConns 上就是前几次的输出 FreeConns 一直是1), 当某个 coroutine 结束后, 会释放此 redis 连接, 因此 FreeConns 会增加.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//完整示例</span></span><br><span class="line"><span class="comment">// author xiongyongshun</span></span><br><span class="line"><span class="comment">// project go_redis</span></span><br><span class="line"><span class="comment">// version 1.0</span></span><br><span class="line"><span class="comment">// created 16/10/6 03:49</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"gopkg.in/redis.v4"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">client := createClient()</span><br><span class="line"><span class="keyword">defer</span> client.Close()</span><br><span class="line">stringOperation(client)</span><br><span class="line">listOperation(client)</span><br><span class="line">setOperation(client)</span><br><span class="line">hashOperation(client)</span><br><span class="line">connectPool(client)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 redis 客户端</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createClient</span><span class="params">()</span> *<span class="title">redis</span>.<span class="title">Client</span></span> &#123;</span><br><span class="line">client := redis.NewClient(&amp;redis.Options&#123;</span><br><span class="line">Addr:     <span class="string">"localhost:6379"</span>,</span><br><span class="line">Password: <span class="string">""</span>,</span><br><span class="line">DB:       <span class="number">0</span>,</span><br><span class="line">PoolSize: <span class="number">5</span>,</span><br><span class="line">&#125;)</span><br><span class="line">pong, err := client.Ping().Result()</span><br><span class="line">fmt.Println(pong, err)</span><br><span class="line"><span class="keyword">return</span> client</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// String 操作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">stringOperation</span><span class="params">(client *redis.Client)</span></span> &#123;</span><br><span class="line"><span class="comment">// 第三个参数是过期时间, 如果是0, 则表示没有过期时间.</span></span><br><span class="line">err := client.Set(<span class="string">"name"</span>, <span class="string">"xys"</span>, <span class="number">0</span>).Err()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">val, err := client.Get(<span class="string">"name"</span>).Result()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"name"</span>, val)</span><br><span class="line"><span class="comment">// 这里设置过期时间.</span></span><br><span class="line">err = client.Set(<span class="string">"age"</span>, <span class="string">"20"</span>, <span class="number">1</span> * time.Second).Err()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">client.Incr(<span class="string">"age"</span>) <span class="comment">// 自增</span></span><br><span class="line">client.Incr(<span class="string">"age"</span>) <span class="comment">// 自增</span></span><br><span class="line">client.Decr(<span class="string">"age"</span>) <span class="comment">// 自减</span></span><br><span class="line">val, err = client.Get(<span class="string">"age"</span>).Result()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"age"</span>, val) <span class="comment">// age 的值为21</span></span><br><span class="line"><span class="comment">// 因为 key "age" 的过期时间是一秒钟, 因此当一秒后, 此 key 会自动被删除了.</span></span><br><span class="line">time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">val, err = client.Get(<span class="string">"age"</span>).Result()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// 因为 key "age" 已经过期了, 因此会有一个 redis: nil 的错误.</span></span><br><span class="line">fmt.Printf(<span class="string">"error: %v\n"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"age"</span>, val)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// list 操作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">listOperation</span><span class="params">(client *redis.Client)</span></span> &#123;</span><br><span class="line">client.RPush(<span class="string">"fruit"</span>, <span class="string">"apple"</span>) <span class="comment">//在名称为 fruit 的list尾添加一个值为value的元素</span></span><br><span class="line">client.LPush(<span class="string">"fruit"</span>, <span class="string">"banana"</span>) <span class="comment">//在名称为 fruit 的list头添加一个值为value的 元素</span></span><br><span class="line">length, err := client.LLen(<span class="string">"fruit"</span>).Result() <span class="comment">//返回名称为 fruit 的list的长度</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"length: "</span>, length) <span class="comment">// 长度为2</span></span><br><span class="line">value, err := client.LPop(<span class="string">"fruit"</span>).Result() <span class="comment">//返回并删除名称为 fruit 的list中的首元素</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"fruit: "</span>, value)</span><br><span class="line">value, err = client.RPop(<span class="string">"fruit"</span>).Result() <span class="comment">// 返回并删除名称为 fruit 的list中的尾元素</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"fruit: "</span>, value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// set 操作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setOperation</span><span class="params">(client *redis.Client)</span></span> &#123;</span><br><span class="line">client.SAdd(<span class="string">"blacklist"</span>, <span class="string">"Obama"</span>) <span class="comment">// 向 blacklist 中添加元素</span></span><br><span class="line">client.SAdd(<span class="string">"blacklist"</span>, <span class="string">"Hillary"</span>) <span class="comment">// 再次添加</span></span><br><span class="line">client.SAdd(<span class="string">"blacklist"</span>, <span class="string">"the Elder"</span>) <span class="comment">// 添加新元素</span></span><br><span class="line">client.SAdd(<span class="string">"whitelist"</span>, <span class="string">"the Elder"</span>) <span class="comment">// 向 whitelist 添加元素</span></span><br><span class="line"><span class="comment">// 判断元素是否在集合中</span></span><br><span class="line">isMember, err := client.SIsMember(<span class="string">"blacklist"</span>, <span class="string">"Bush"</span>).Result()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"Is Bush in blacklist: "</span>, isMember)</span><br><span class="line"><span class="comment">// 求交集, 即既在黑名单中, 又在白名单中的元素</span></span><br><span class="line">names, err := client.SInter(<span class="string">"blacklist"</span>, <span class="string">"whitelist"</span>).Result()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取到的元素是 "the Elder"</span></span><br><span class="line">fmt.Println(<span class="string">"Inter result: "</span>, names)</span><br><span class="line"><span class="comment">// 获取指定集合的所有元素</span></span><br><span class="line">all, err := client.SMembers(<span class="string">"blacklist"</span>).Result()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"All member: "</span>, all)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// hash 操作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hashOperation</span><span class="params">(client *redis.Client)</span></span> &#123;</span><br><span class="line">client.HSet(<span class="string">"user_xys"</span>, <span class="string">"name"</span>, <span class="string">"xys"</span>); <span class="comment">// 向名称为 user_xys 的 hash 中添加元素 name</span></span><br><span class="line">client.HSet(<span class="string">"user_xys"</span>, <span class="string">"age"</span>, <span class="string">"18"</span>); <span class="comment">// 向名称为 user_xys 的 hash 中添加元素 age</span></span><br><span class="line"><span class="comment">// 批量地向名称为 user_test 的 hash 中添加元素 name 和 age</span></span><br><span class="line">client.HMSet(<span class="string">"user_test"</span>, <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;<span class="string">"name"</span>: <span class="string">"test"</span>, <span class="string">"age"</span>:<span class="string">"20"</span>&#125;)</span><br><span class="line"><span class="comment">// 批量获取名为 user_test 的 hash 中的指定字段的值.</span></span><br><span class="line">fields, err := client.HMGet(<span class="string">"user_test"</span>, <span class="string">"name"</span>, <span class="string">"age"</span>).Result()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"fields in user_test: "</span>, fields)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取名为 user_xys 的 hash 中的字段个数</span></span><br><span class="line">length, err := client.HLen(<span class="string">"user_xys"</span>).Result()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"field count in user_xys: "</span>, length) <span class="comment">// 字段个数为2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除名为 user_test 的 age 字段</span></span><br><span class="line">client.HDel(<span class="string">"user_test"</span>, <span class="string">"age"</span>)</span><br><span class="line">age, err := client.HGet(<span class="string">"user_test"</span>, <span class="string">"age"</span>).Result()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"Get user_test age error: %v\n"</span>, err)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"user_test age is: "</span>, age) <span class="comment">// 字段个数为2</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// redis.v4 的连接池管理</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">connectPool</span><span class="params">(client *redis.Client)</span></span> &#123;</span><br><span class="line">wg := sync.WaitGroup&#123;&#125;</span><br><span class="line">wg.Add(<span class="number">10</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">100</span>; j++ &#123;</span><br><span class="line">client.Set(fmt.Sprintf(<span class="string">"name%d"</span>, j), fmt.Sprintf(<span class="string">"xys%d"</span>, j), <span class="number">0</span>).Err()</span><br><span class="line">client.Get(fmt.Sprintf(<span class="string">"name%d"</span>, j)).Result()</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"PoolStats, TotalConns: %d, FreeConns: %d\n"</span>,client.PoolStats().TotalConns,client.PoolStats().FreeConns)</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt; go操作Redis：&lt;/strong&gt; &lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;/excerpt&gt;&lt;/p&gt;
&lt;p&gt;Redis的简介及golang简易操作redis&lt;/p&gt;
    
    </summary>
    
      <category term="database" scheme="https://alexbrucelu.github.io/categories/database/"/>
    
    
      <category term="Redis" scheme="https://alexbrucelu.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>MySQL的常用命令与简介</title>
    <link href="https://alexbrucelu.github.io/2018/12/16/MySQL%E7%9A%84%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>https://alexbrucelu.github.io/2018/12/16/MySQL的常用命令/</id>
    <published>2018-12-16T09:05:10.305Z</published>
    <updated>2018-12-16T17:07:39.794Z</updated>
    
    <content type="html"><![CDATA[<p><strong> MySQL的常用命令与简介：</strong> <excerpt in="" index="" |="" 首页摘要=""></excerpt></p><p>MySQL养成记之常用命令</p><a id="more"></a><p>[TOC]</p><h2 id="数据库简介"><a href="#数据库简介" class="headerlink" title="数据库简介"></a>数据库简介</h2><p>当前使用的数据库，主要分为两类：</p><ul><li>文档型：sqlite，就是一个文件，通过对文件的复制完成数据库的复制</li><li>服务型：mysql、postgre，数据存储在一个物理文件中，但是需要使用终端以tcp/ip协议连接，进行数据库的读写操作</li></ul><h2 id="E-R模式"><a href="#E-R模式" class="headerlink" title="E-R模式"></a>E-R模式</h2><ul><li>当前物理的数据库都是按照E-R模型设计的<ul><li>E表示entry，实体</li><li>R表示relationship，关系</li></ul></li><li>一个实体转换为数据库中的一个表</li><li>关系描述两个实体之间的对应规则，包括<ul><li>一对一</li><li>一对多</li><li>多对多</li></ul></li><li>关系转换为数据库表中的一个列 <code>*</code>在关系型数据库中一行就是一个对象</li></ul><h2 id="三范式"><a href="#三范式" class="headerlink" title="三范式"></a>三范式</h2><p>经过研究和对使用中问题的总结，对于数据库提出了一些规范</p><blockquote><ul><li>第一范式（1NF）：列不可拆分</li><li>第二范式（2NF）：唯一标识</li><li>第三范式（3NF）：引用主键</li></ul><p><strong><font color="red">说明：后一个范式，都是基于前一个范式的基础建立的</font></strong></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt; MySQL的常用命令与简介：&lt;/strong&gt; &lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;/excerpt&gt;&lt;/p&gt;
&lt;p&gt;MySQL养成记之常用命令&lt;/p&gt;
    
    </summary>
    
      <category term="database" scheme="https://alexbrucelu.github.io/categories/database/"/>
    
    
      <category term="MySQL" scheme="https://alexbrucelu.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>gRPC官方文档</title>
    <link href="https://alexbrucelu.github.io/2018/12/12/gRPC%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/"/>
    <id>https://alexbrucelu.github.io/2018/12/12/gRPC官方文档/</id>
    <published>2018-12-12T08:28:36.238Z</published>
    <updated>2018-12-21T06:06:04.158Z</updated>
    
    <content type="html"><![CDATA[<p><strong> gRPC官方文档：</strong> <excerpt in="" index="" |="" 首页摘要=""></excerpt></p><p>微服务之gRPC官方文档</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt; gRPC官方文档：&lt;/strong&gt; &lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;/excerpt&gt;&lt;/p&gt;
&lt;p&gt;微服务之gRPC官方文档&lt;/p&gt;
    
    </summary>
    
      <category term="microServices" scheme="https://alexbrucelu.github.io/categories/microServices/"/>
    
    
      <category term="微服务" scheme="https://alexbrucelu.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>常见的共识算法</title>
    <link href="https://alexbrucelu.github.io/2018/12/10/%E5%B8%B8%E8%A7%81%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/"/>
    <id>https://alexbrucelu.github.io/2018/12/10/常见共识算法/</id>
    <published>2018-12-10T06:04:06.415Z</published>
    <updated>2018-12-10T06:38:43.474Z</updated>
    
    <content type="html"><![CDATA[<p><strong> 常见的共识算法：</strong> <excerpt in="" index="" |="" 首页摘要=""></excerpt></p><p>PoS、PoW、DPoS</p><a id="more"></a><p>本文是对区块链技术中涉及的共识算法的学习总结整理。 其中PBFT和Raft是联盟链和私有链常用的共识算法，而PoW（比特币采用）和PoS是公有链常用的共识算法。</p><blockquote><p>建议对区块链的学习，要分成是公有链还是联盟链，这两种链中一般采用的共识算法是有较大不同的，P2P网络等也有较大的不同。传统的共识算法一般不适用于公有链，而一定程度上适用于联盟链。</p></blockquote><h2 id="实用拜占庭容错系统PBFT（联盟链中常用）"><a href="#实用拜占庭容错系统PBFT（联盟链中常用）" class="headerlink" title="实用拜占庭容错系统PBFT（联盟链中常用）"></a>实用拜占庭容错系统PBFT（联盟链中常用）</h2><p>拜占庭容错技术（Byzantine Fault Tolerance,BFT）是一类分布式计算领域的容错技术，是一种解决分布式系统容错问题的通用方案。实用拜占庭容错系统（Practical Byzantine Fault Tolerance，PBFT）使拜占庭协议的运行复杂度从指数级别降低到多项式级别，使拜占庭协议在分布式系统中应用成为可能。</p><h3 id="拜占庭将军问题"><a href="#拜占庭将军问题" class="headerlink" title="拜占庭将军问题"></a>拜占庭将军问题</h3><p>拜占庭将军（Byzantine Generals Problem）问题，是 Leslie Lamport 1982 年提出用来解释一致性问题的一个虚构模型。拜占庭是古代东罗马帝国的首都，由于地域宽广，守卫边境的多个将军（系统中的多个节点）需要通过信使来传递消息，达成某些一致的决定。但由于将军中可能存在叛徒（系统中节点出错），这些叛徒将努力向不同的将军发送不同的消息，试图会干扰一致性的达成。拜占庭问题即为在此情况下，如何让忠诚的将军们能达成行动的一致。</p><h3 id="拜占庭容错系统"><a href="#拜占庭容错系统" class="headerlink" title="拜占庭容错系统"></a>拜占庭容错系统</h3><p>拜占庭容错系统是指：在一个拥有nn台节点的系统，整个系统，对每个请求满足如下条件：</p><p>所有非拜占庭节点使用相同的输入信息，产生同样的结果；<br>如果输入的信息正确，那么所有非拜占庭节点必须接收这个信息，并计算相应的结果。<br>与此同时,在拜占庭系统的实际运行过程中一般假设系统中拜占庭节点不超过mm台，并且对每个请求满足2个指标：</p><p>安全性——任何已经完成的请求都不会被更改，它可以在以后请求看到；<br>活性——可以接受并且执行非拜占庭客户端的请求，不会被任何因素影响而导致非拜占庭客户端的请求不能执行。<br>拜占庭系统目前普遍采用的假设条件包括:<br>1) 拜占庭节点的行为可以是任意的，拜占庭节点之间可以共谋；<br>2) 节点之间的错误是不相关的；<br>3) 节点之间通过异步网络连接，网络中的消息可能丢失、乱序、延时到达；<br>4) 服务器之间传递的信息,第三方可以知晓 ,但是不能窜改、伪造信息的内容和验证信息的完整性；</p><p>（发生故障的节点称为拜占庭节点；正常的节点为非拜占庭节点。）</p><h3 id="状态机拜占庭系统"><a href="#状态机拜占庭系统" class="headerlink" title="状态机拜占庭系统"></a>状态机拜占庭系统</h3><h4 id="状态机拜占庭系统的特点"><a href="#状态机拜占庭系统的特点" class="headerlink" title="状态机拜占庭系统的特点"></a>状态机拜占庭系统的特点</h4><p>状态机拜占庭系统的特点是整个系统共同维护一个状态,所有节点采取一致的行动,一般包括 3 种协议：一致性协议、 检查点协议和视图更换协议。系统正常运行在一致性协议和检查点协议下，视图更换协议则是只有在主节点出错或者运行缓慢的情况下才会启动，负责维系系统继续执行客户端请求的能力。</p><h4 id="状态机拜占庭系统的核心协议"><a href="#状态机拜占庭系统的核心协议" class="headerlink" title="状态机拜占庭系统的核心协议"></a>状态机拜占庭系统的核心协议</h4><h5 id="一、一致性协议"><a href="#一、一致性协议" class="headerlink" title="一、一致性协议"></a>一、一致性协议</h5><p>一致性协议的目标是使来自客户端的请求在每个服务器上都按照一个确定的顺序执行。在协议中，一般有一个服务器被称作主节点，负责将客户端的请求排序；其余的服务器称作从节点，按照主节点提供的顺序执行请求。所有的服务器都在相同的配置信息下工作，这个配置信息称作view，每更换一次主节点，view就会随之变化。</p><p>一致性协议至少包含3个阶段：发送请求、序号分配和返回结果。根据协议设计的不同，可能包含相互交互、序号确认等阶段。</p><p>一致性协议解决一致性的方法主要有：<br>1）服务器之间两两交互，服务器通过将自己获得的信息传递给其他的服务器；<br>2）由客户端收集服务器的信息，将收集的信息制作成证明文件再发送给服务器。对于一个包含3m+13m+1台服务器的拜占庭系统，需要收集到2m+12m+1台服务器发送的一致信息，才能保证达成一致的非拜占庭服务器数量大于拜占庭服务器数量。</p><p>引申思考： </p><ol><li>部署一个采用PBFT共识算法的区块链，至少需要几个节点呢？ </li><li>PBFT共识算法的区块链，最佳节点数量问题，采用PBFT共识算法的区块链系统节点数量的下限和上限？</li></ol><h5 id="二、检查点协议"><a href="#二、检查点协议" class="headerlink" title="二、检查点协议"></a>二、检查点协议</h5><p>拜占庭系统每执行一个请求，服务器需要记录日志。如果日志得不到及时的清理，就会导致系统资源被大量的日志所占用，影响系统性能及可用性。另一方面，由于拜占庭服务器的存在，一致性协议并不能保证每一台服务器都执行了相同的请求，所以，不同服务器状态可能不一致。例如，某些服务器可能由于网络延时导致从某个序号开始，之后的请求都没有执行。因此，拜占庭系统中设置周期性的检查点协议，将系统中的服务器同步到某一个相同的状态。因此，周期性的检查点协议可以定期地处理日志，节约资源，同时及时纠正服务器状态。</p><p>处理日志主要解决的问题就是区分那些日志可以清理，那些日志仍然需要保留。如果一个请求已经被m+1m+1台非拜占庭服务器执行，并且某一服务器ii能够向其他的服务器证明这一点，那么ii就可以将关于这个请求的日志删除。目前，协议普遍采用的方式是服务器每执行一定数量的请求，就将自己的状态发送给所有服务器并且执行一个该协议，如果某台服务器接收到2m+12m+1台服务器的状态，那么其中一致的部分就是至少有m+1m+1非拜占庭服务器经历过的状态，因此，这部分的日志就可以删除，同时将自己状态更新只较新状态。</p><h5 id="三、视图更换"><a href="#三、视图更换" class="headerlink" title="三、视图更换"></a>三、视图更换</h5><p>在一致性协议里，已经知道主节点在整个系统中拥有序号分配，请求转发等核心能力，支配着这个系统的运行行为。然而一旦主节点自身发生错误，就可能导致从节点接收到具有相同序号的不同请求，或者同一个请求被分配多个序号等问题，这将直接导致请求不能被正确执行。视图更换协议的作用就是在主节点不能继续履行职责时，将其用一个从节点替换掉，并且保证已经被非拜占庭服务器执行的请求不会被篡改。</p><p>视图更换协议一般有两种触发方式：<br>1）只由服务器触发，这一类触发方式中，判断服务器一致性是否达成的工作是由服务器自身负责，客户端不能从请求的整个执行过程中获得服务器运行状况的信息；<br>2）客户端触发，这一类触发方式中，客户端一般负责判断服务器是否达成一致，如果不达成一致，那么就能判断服务器运行出现问题，如果是主节点的问题就会要求服务器更换主节点。</p><p>视图更换协议需要解决的问题是如何保证已经被非拜占庭服务器执行的请求不被更改。由于系统达成一致性之后至少有m+1m+1台非拜占庭服务器执行了请求，所以目前采用的方法是：由新的主节点收集至少2m+12m+1台服务器的状态信息，这些状态信息中一定包含所有执行过的请求；然后，新主节点将这些状态信息发送给所有的服务器，服务器按照相同的原则将在上一个主节点完成的请求同步一遍.同步之后,所有的节点都处于相同的状态,这时就可以开始执行新的请求。</p><h4 id="实用拜占庭容错系统PBFT详解"><a href="#实用拜占庭容错系统PBFT详解" class="headerlink" title="实用拜占庭容错系统PBFT详解"></a>实用拜占庭容错系统PBFT详解</h4><p>实用拜占庭容错系统（Practical Byzantine Fault Tolerance，PBFT），是一类状态机拜占庭系统。</p><p>PBFT的一致性协议如下：PBFT系统通常假设故障节点数为mm个，而整个服务节点数为3m+13m+1个。每一个客户端的请求需要经过5个阶段，通过采用两次两两交互的方式在服务器达成一致之后再执行客户端的请求。由于客户端不能从服务器端获取任何服务器运行的状态信息，PBFT中主节点是否发生错误只能由服务器监测。如果服务器在一段时间内都不能完成客户端的请求，则会触发视图更换协议。 </p><p><img src="https://github.com/AlexBruceLu/DAPP/wiki/ddd.png" alt=""></p><p>上图显示了一个简化的PBFT的协议通信模式，其中CC为客户端，N0N0~N3N3表示服务节点，特别的，N0N0为主节点，N3N3为故障节点。整个协议的基本过程如下：<br>1）客户端发送请求，激活主节点的服务操作；<br>2）当主节点接收请求后，启动三阶段的协议以向各从节点广播请求；</p><p>序号分配阶段，主节点给请求赋值一个序号nn，广播序号分配消息和客户端的请求消息mm，并将构造pre-prepare消息给各从节点；<br>交互阶段，从节点接收pre-prepare消息，向其他服务节点广播prepare消息；<br>序号确认阶段，各节点对视图内的请求和次序进行验证后，广播commit消息，执行收到的客户端的请求并给客户端响应。<br>3）客户端等待来自不同节点的响应，若有m+1m+1个响应相同，则该响应即为运算的结果；</p><h3 id="Raft协议"><a href="#Raft协议" class="headerlink" title="Raft协议"></a>Raft协议</h3><p>Raft是在非拜占庭故障下达成共识的强一致协议。在区块链系统中，使用Raft实现记账共识的过程可以描述如下：首先选举一个leader，接着赋予leader完全的权利管理记账。leader从客户端接收记账请求，完成记账操作，生成区块，并复制到其他记账节点。有了leader简化了记账操作的管理。如果leader失效或与其他节点失去联系，这时，系统就会选出新的leader。</p><h4 id="Raft基础"><a href="#Raft基础" class="headerlink" title="Raft基础"></a>Raft基础</h4><p>一个Raft集群通常包含5个服务器，允许系统有2个故障服务器。每个服务器处于3个状态之一：leader、follower或candidate。正常操作状态下，仅有一个leader，其他的服务器均为follower。follower是被动的，不会对自身发出的请求而是对来自leader和candidate的请求做出响应。leader处理所有的客户端请求（若客户端联系follower，则该follower将转发给leader)。candidate状态用来选举leader。</p><p>Raft阶段主要分为两个，首先是leader选举过程，然后在选举出来的leader基础上进行正常操作，比如日志复制、记账等。</p><h4 id="leader选举"><a href="#leader选举" class="headerlink" title="leader选举"></a>leader选举</h4><p>当follower在选举超时时间内未收到leader的心跳消息，则转换为candidate状态。为了避免选举冲突，这个超时时间是一个150~300ms之间的随机数。</p><p>一般而言，在Raft系统中：<br>1）任何一个服务器都可以成为一个候选者candidate，它向其他服务器follower发出要求选举自己的请求。<br>2）其他服务器同意了，发出OK。如果在这个过程中，有一个follower宕机，没有收到请求选举的要求，此时候选者可以自己选自己，只要达到N/2+1N/2+1的大多数票，候选人还是可以成为leader。<br>3）这样这个候选者就成为了leader领导人，它可以向follower发出指令，比如进行记账。<br>4）以后可以通过心跳进行记账的通知。<br>5）一旦这个leader崩溃了，那么follower中有一个成为候选者，并发出邀票选举。<br>6）follower同意后，其成为leader，继续承担记账等指导工作。</p><h4 id="记账过程"><a href="#记账过程" class="headerlink" title="记账过程"></a>记账过程</h4><p>Raft的记账过程按以下步骤完成：<br>1）假设leader领导人已经选出，这时客户端发出增加一个日志的要求；<br>2）leader要求follower遵从他的指令，都将这个新的日志内容追加到他们各自日志中；<br>3）大多数follower服务器将交易记录写入账本后，确认追加成功，发出确认成功消息；<br>4）在下一个心跳中，leader会通知所有follower更新确认的项目。<br>对于每个新的交易记录，重复上述过程。</p><p>如果在这一过程中，发生了网络通信故障，使得leader不能访问大多数follower，那么leader只能正常更新它能访问的那些follower服务器。而大多数的服务器follower因为没有了leader，它们将重新选举一个候选者作为leader，然后这个leader作为代表与外界打交道，如果外界要求其添加新的交易记录，这个新的leader就按上述步骤通知大多数follower，如果这时网络故障修复了，那么原先的leader就变成follower，在失联阶段，这个老leader的任何更新都不能算确认，都回滚，接收新的leader的新更新。</p><p>如果想更直观的理解Raft协议，可以看动画演示。<br>论文原文：In Search of an Understandable Consensus Algorithm<br>学习参考：The Raft Consensus Algorithm</p><h2 id="PoW"><a href="#PoW" class="headerlink" title="PoW"></a>PoW</h2><p>PoW的原理可参看这篇博文中哈希函数难题友好性这一节：<a href="http://blog.csdn.net/s_lisheng/article/details/77937202，理解了难题友好性，就基本理解了PoW机制的原理。结合比特币去理解PoW。比特币PoW的过程，就是将不同的nonce值作为输入，尝试进行SHA256哈希运算，找出满足给定数量前导0的哈希值的过程。要求的前导0的个数越多，代表难度越大。比特币节点求解工作量证明问题的步骤归纳如下：" target="_blank" rel="noopener">http://blog.csdn.net/s_lisheng/article/details/77937202，理解了难题友好性，就基本理解了PoW机制的原理。结合比特币去理解PoW。比特币PoW的过程，就是将不同的nonce值作为输入，尝试进行SHA256哈希运算，找出满足给定数量前导0的哈希值的过程。要求的前导0的个数越多，代表难度越大。比特币节点求解工作量证明问题的步骤归纳如下：</a></p><p>1）生成铸币交易，并与其他所有准备打包进区块的交易组成交易列表，通过Merkle树算法生成Merkle跟哈希；<br>2）把Merkle根哈希及其他相关字段组装成区块头，将区块头的80字节数据作为工作量证明的输入；<br>3）不停地变更区块头中的随机数nonce，并对每次变更后的区块头做双重SHA256运算，将结果值与当前网络的目标难度做比对，如果满足难度条件，则解题成功，工作量证明完成。</p><h2 id="PoS"><a href="#PoS" class="headerlink" title="PoS"></a>PoS</h2><p>PoW存在以下弊端：</p><p>矿池的出现，一定程度上违背了去中心化的初衷，同时也使得51%攻击成为可能，影响其安全性。<br>PoW存在巨大的算力浪费，看看矿池用掉多少电就知道了。<br>PoS（权益证明，Proof of Stake）的出现很大程度上是因为PoW的缺陷而提出的。采用PoS的币中不同币的PoS不完全相同，权益证明要求用户证明拥有某些数量的货币（即对货币的权益），下面以点点币为例，理解PoS的思想。</p><p>点点币在SHA-256的哈希运算的难度方便引入了币龄的概念，使得难度与交易输入的币龄成反比。在点点币中，币龄被定义为币的数量与币所拥有的天数的乘积。点点币的权益证明机制结合了随机化与币龄的概念，未使用至少30天的币可以参与竞争下一区块，越久和越大的币集有更大的可能去签名下一区块。而一旦币的权益被用于签名一个区块，则币龄将清为零，这样必须等待至少30日才能签署另一个区块。同时，为防止非常老或非常大的权益控制区块链，寻找下一区块的最大概率在90天后达到最大值，这一过程保护了网络，并随着时间逐渐成为新的币而无需消耗大量的计算能力。</p><h2 id="DPoS"><a href="#DPoS" class="headerlink" title="DPoS"></a>DPoS</h2><p>PoS机制虽然考虑了PoW的不足，但也有缺点：依据权益结余来选择，会导致首富账户的权力更大，有可能支配记账权。股份授权证明机制（Delegated Proof of Stake，DPoS），是对PoW、PoS不足的提出的。下面以比特股为例，理解DPoS的思想。</p><p>比特股引入了见证人这个概念，见证人可以生成区块，每一个持有比特股的人都可以投票选举见证人。得到总同意票数中的前NN个（NN通常定义为101）候选者可以当选为见证人，当选见证人的个数需满足：至少一半的参与投票者相信NN已经充分地去中心化。见证人的候选名单每个维护周期（1天）更新一次。见证人然后随机排列，每个见证人按序有2秒的权限时间生成区块，若见证人在给定的时间片不能生成区块，区块生成权限交给下一时间片对应的见证人。如果见证人提供的算力不稳定或计算机宕机等，持股人可以随时通过投票更换这些见证人。</p><p>可以看到，其核心思想是通过缩小参与核心共识过程的节点数量，以提高共识效率。（这里可以认为选举见证人的过程为非核心共识过程，而见证人按序生成区块可以认为是核心共识过程）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt; 常见的共识算法：&lt;/strong&gt; &lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;/excerpt&gt;&lt;/p&gt;
&lt;p&gt;PoS、PoW、DPoS&lt;/p&gt;
    
    </summary>
    
      <category term="others" scheme="https://alexbrucelu.github.io/categories/others/"/>
    
    
      <category term="共识算法" scheme="https://alexbrucelu.github.io/tags/%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数据结构入门</title>
    <link href="https://alexbrucelu.github.io/2018/12/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>https://alexbrucelu.github.io/2018/12/09/数据结构/</id>
    <published>2018-12-09T06:55:49.216Z</published>
    <updated>2018-12-09T11:11:30.466Z</updated>
    
    <content type="html"><![CDATA[<p><strong> 数据结构入门：</strong> <excerpt in="" index="" |="" 首页摘要=""></excerpt></p><p>常见的数据结构基础</p><a id="more"></a><h2 id="数据结构基础理论"><a href="#数据结构基础理论" class="headerlink" title="数据结构基础理论"></a>数据结构基础理论</h2><h3 id="什么是数据？"><a href="#什么是数据？" class="headerlink" title="什么是数据？"></a>什么是数据？</h3><p>数据：是描述客观事物的符号，是计算机中可以操作的对象，是能被计算机识别，并输入给计算机处理的符号集合。数据不仅仅包括整型、实型等数值类型，还包括字符及声音、图像、视频等非数值类型。 </p><h3 id="数据结构的概念"><a href="#数据结构的概念" class="headerlink" title="数据结构的概念"></a>数据结构的概念</h3><p>数据结构是计算机存储、组织数据的方式。数据结构是指相互之间存在一种或多种特定关系的数据元素的集合。通常情况下，精心选择的数据结构可以带来更高的运行或者存储效率。数据结构往往同高效的检索算法和索引技术有关。 </p><blockquote><font color="red">数据结构是计算机存储、组织数据的方式。是相互之间存在一种或多种特定关系的数据元素集合 </font></blockquote><h3 id="算法的概念"><a href="#算法的概念" class="headerlink" title="算法的概念"></a>算法的概念</h3><p>算法：<font color="red">特定问题求解不走的描述，</font>在计算机中表现为<strong>指令的有限序列</strong>，算法是独立存在的一种解决问题的方法和思想。<strong>对于算法来说，语言不重要，重要的是思想。</strong></p><h4 id="算法和数据结构的区别"><a href="#算法和数据结构的区别" class="headerlink" title="算法和数据结构的区别"></a>算法和数据结构的区别</h4><p>数据结构只是静态的描述了数据元素之间的关系，高效的程序需要在数据结构的基础上设计和选择算法。</p><ul><li><font color="red">算法是为了解决实际问题而设计的</font></li><li><font color="red">数据结构是算法需要处理的问题的载体</font></li><li>数据结构与算法相符相成</li></ul><h4 id="算法的比较"><a href="#算法的比较" class="headerlink" title="算法的比较"></a>算法的比较</h4><p>假设求解1 + 2 + … + 100 的结果，写程序会怎么写</p><ul><li><p><strong>方法一：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sum := <span class="number">0</span></span><br><span class="line">n := <span class="number">100</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">    sum += i</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"%d"</span>,sum)</span><br></pre></td></tr></table></figure></li><li><p><strong>方法二：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sum := <span class="number">0</span></span><br><span class="line">n := <span class="number">100</span></span><br><span class="line">sum = (<span class="number">1</span> + n) * n / <span class="number">2</span></span><br><span class="line">fmt.Println(<span class="string">"%d"</span>,sum)</span><br></pre></td></tr></table></figure></li></ul><p><strong>上述两段代码，第二种算法会比较高效，这就是一个好的算法对程序高效性的体现。</strong></p><h4 id="算法的特性"><a href="#算法的特性" class="headerlink" title="算法的特性"></a>算法的特性</h4><p>算法的五大基本特性：<strong>输入、输出、有穷性、确定性和可行性。</strong></p><p><strong>输入、输出：</strong>算法具有零个或多个输入，至少有一个或多个输出。</p><p><strong>有穷性：</strong>指算法在执行有限的步骤之后，自动结束而不会出现无限循环，并且每一个步骤在可接受的时间内完成。</p><p><strong>确定性：</strong>算法的每一步骤都有确定的含义，不会出现二义性。</p><p><strong>可行性：</strong>算法的每一步都必须是可行的，换言之，每一步都能通过执行有限次数完成。</p><h3 id="数据结构分类"><a href="#数据结构分类" class="headerlink" title="数据结构分类"></a>数据结构分类</h3><p>按照视点的不同，可以把数据结构分为<strong>逻辑结构、物理结构。</strong></p><h4 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h4><h5 id="集合结构"><a href="#集合结构" class="headerlink" title="集合结构"></a>集合结构</h5><p>集合结构中的数据元素除了同属于一个集合外，它们本身之间并没有关系。各个数据元素是平等的。它们共同属于同一个集合，数据结构中的集合关系类似于数学中的集合，如下图：</p><p><img src="https://github.com/AlexBruceLu/DAPP/wiki/data1.png" alt=""></p><h5 id="线性结构"><a href="#线性结构" class="headerlink" title="线性结构"></a>线性结构</h5><p>线性结构中的数据元素之间是一一对应关系。如下图：</p><p><img src="https://github.com/AlexBruceLu/DAPP/wiki/data2.png" alt=""></p><h5 id="树形结构"><a href="#树形结构" class="headerlink" title="树形结构"></a>树形结构</h5><p>树形结构中是数据元素之间存在一种一对多的层次关系，如下图：</p><p><img src="https://github.com/AlexBruceLu/DAPP/wiki/data3.png" alt=""></p><h5 id="图形结构"><a href="#图形结构" class="headerlink" title="图形结构"></a>图形结构</h5><p>图形结构中的数据元素之间是存在多对多的关系，如图：</p><p><img src="https://github.com/AlexBruceLu/DAPP/wiki/data4.png" alt=""></p><h4 id="物理结构"><a href="#物理结构" class="headerlink" title="物理结构"></a>物理结构</h4><p><strong>物理结构：</strong>是指数据的逻辑结构在计算机中的存储形式，共分为两种：顺序存储和链式存储。</p><h5 id="顺序存储"><a href="#顺序存储" class="headerlink" title="顺序存储"></a>顺序存储</h5><p>是把数据元素存放在地址连续的存储单元里，其数据的逻辑关系和物理关系是一致的，如图：</p><p><img src="https://github.com/AlexBruceLu/DAPP/wiki/data5.png" alt=""></p><blockquote><p>如果所有的数据结构都很简单且有规律，就比较易于操作。可往往实际情况，数据结构中的元素总会遇到增、删、改、查的操作。面对市场变化的数据结构，运用以上顺序存储是不科学的。</p></blockquote><h5 id="链式存储"><a href="#链式存储" class="headerlink" title="链式存储"></a>链式存储</h5><p>是把数据元素存放在任意的存储单元里，这组存储单元可以是连续的，也可以是不连续的。数据存储的关系并不能反映其逻辑关系，因此需要用一个指针存放数据元素的地址，这样通过地址就可以找到相关数据的位置，如下图：</p><p><img src="https://github.com/AlexBruceLu/DAPP/wiki/data6.png" alt=""></p><h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><h3 id="线性表基础概念"><a href="#线性表基础概念" class="headerlink" title="线性表基础概念"></a>线性表基础概念</h3><p>线性表是一种最简单的且常用的数据结构。数据结构的基本特点是节点之间满足线性关系。动态数组、栈、队列都属于线性结构。它们的共同之处，是节点中有且只有一个开始节点和终端节点。这种关系，可以把它们的所有节点排成一个线性序列。但是，它们分别属于几种不同的抽象数据类型实现，它们之间的区别，主要就是操作的不同。</p><p>线性表是零个或多个数据元素的有限序列，数据元素之间是有顺序的，数据元素个数是有限的，数据元素的类型必须相同。</p><p><img src="https://github.com/AlexBruceLu/DAPP/wiki/data7.png" alt=""></p><p>线性表的性质：</p><ul><li><p>a0 为线性表的第一个元素，只有一个后继；</p></li><li><p>an 为线性表的最后一个元素，只有一个前驱；</p></li><li><p>除了 a0 和 an 外的其他元素 ai ，既有一个前驱又有一个后继；</p></li><li><p>线性表能够逐项访问和顺序存取；</p><blockquote><p><strong>线性表的抽象数据类型定义：</strong> </p><p>ADT 线性表（ List） </p><p>Data<br>线性表的数据对象集合为{ a0, a1, ……, an }，每个元素的类型均为 DataType。其中，除第一个元素 a0外，每个元素有且只有一个直接前驱元素，除了最后一个元素 an 外，每个元素有且只有一个直接后继元素。数据元素之间的关系是一一对应的。 </p><p>peration（操作）<br>// 初始化，建立一个空的线性表 L。<br>InitList(*L);<br>// 若线性表为空，返回 true，否则返回 false<br>ListEmpty(L);<br>// 将线性表清空 </p><p>ClearList(<em>L);<br>// 将线性表 L 中的第 i 个位置的元素返回给 e<br>GetElem(L, i, </em>e);<br>// 在线性表 L 中的第 i 个位置插入新元素 e<br>ListInsert(<em>L, i, e);<br>// 删除线性表 L 中的第 i 个位置元素，并用 e 返回其值<br>ListDelete(</em>L, i, <em>e);<br>// 返回线性表 L 的元素个数<br>ListLength(L);<br>// 销毁线性表<br>DestroyList(</em>L); </p></blockquote></li></ul><h3 id="线性表的顺序存储"><a href="#线性表的顺序存储" class="headerlink" title="线性表的顺序存储"></a>线性表的顺序存储</h3><p>通常线性表可以采用顺序存储和链式存储。</p><p>采用顺序存储是表示线性表最简单的方法，具体做法是：将线性表中的元素一个接一个的存储在一块连续的存储区域中，这种顺序表示的线性表也称为顺序表。</p><h4 id="线性表顺内需存储（动态数组）的设计与实现"><a href="#线性表顺内需存储（动态数组）的设计与实现" class="headerlink" title="线性表顺内需存储（动态数组）的设计与实现"></a>线性表顺内需存储（动态数组）的设计与实现</h4><font color="red"><strong>操作要点：</strong></font><ul><li><p>插入元素操作</p><ul><li>判断线性表是否合法</li><li>判断插入位置是否合法</li><li>判断空间是否满足</li><li>把最后一个与元素到插入位置的元素后移一位</li><li>将新元素插入</li><li>线性表长度加1</li></ul></li><li><p>获取元素操作</p><ul><li>判断线性表是否合法</li><li>判断位置是否合法</li><li>直接通过元素的下表方式获取元素</li></ul></li><li><p>删除元素的操作</p><ul><li>判断线性表是否合法</li><li>判断删除位置是否合法</li><li>将元素取出</li><li>将删除位置后的元素分别向前移动一个位置</li><li>线性表长度减1</li></ul></li><li><p>元素的插入</p><p><img src="![](https://github.com/AlexBruceLu/DAPP/wiki/data8.png" alt=""></p></li><li><p>元素的删除</p><p><img src="![](https://github.com/AlexBruceLu/DAPP/wiki/data9.png" alt=""></p><p><font color="red"><strong>注意：</strong></font>链表的容量和链表的长度是两个不同的概念</p></li></ul><h4 id="优点和缺点"><a href="#优点和缺点" class="headerlink" title="优点和缺点"></a>优点和缺点</h4><font color="red"><strong>优点</strong></font><ul><li>无需为线性表中的逻辑关系增加额外的空间</li><li>可以快速的获取表中合法位置的元素</li></ul><font color="red"><strong>缺点</strong></font><ul><li>插入和删除操作需要移动大量的元素</li></ul><h3 id="线性表的链式存储"><a href="#线性表的链式存储" class="headerlink" title="线性表的链式存储"></a>线性表的链式存储</h3><p>链表为了表示每个元素与其直接后继元素之间的逻辑关系，每个元素除了存储本身的信息外，还需要存储指示其直接后继的信息。</p><p><img src="![](https://github.com/AlexBruceLu/DAPP/wiki/data10.png" alt=""></p><ul><li><p>单链表</p><ul><li><p>线性表的链式存储结构中，每个节点中只包含一个指针域，这样的链表叫做单链表</p></li><li><p>通过每个节点的指针域将线性表的数据元素按其逻辑次序链接在一起</p><p><img src="![](https://github.com/AlexBruceLu/DAPP/wiki/data11.png" alt=""></p></li></ul></li><li><p>概念解释</p><ul><li><p>表头节点</p><ul><li>链表中的第一个节点，包含指向第一个数据元素的指针以及链表自身的一些信息</li></ul></li><li><p>数据节点</p><ul><li>链表中代表数据元素的节点，包含指向下一个数据元素的指针和数据元素的信息</li></ul></li><li><p>尾节点</p><ul><li>链表中的最后一个数据节点，下一个元素指针为空，表示无后继元素</li></ul><p><img src="https://github.com/AlexBruceLu/DAPP/wiki/data12.png" alt=""></p></li></ul></li></ul><h4 id="线性表的链式存储（单项链表）的设计与实现"><a href="#线性表的链式存储（单项链表）的设计与实现" class="headerlink" title="线性表的链式存储（单项链表）的设计与实现"></a>线性表的链式存储（单项链表）的设计与实现</h4><ul><li><p><strong>插入操作</strong></p><p><img src="https://github.com/AlexBruceLu/DAPP/wiki/data13.png" alt=""></p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node -&gt; next = current -&gt; next;</span><br><span class="line">current -&gt; next = node;</span><br></pre></td></tr></table></figure><ul><li><p>删除操作</p><p><img src="https://github.com/AlexBruceLu/DAPP/wiki/data14.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">current-&gt;next = ret-&gt;next;</span><br></pre></td></tr></table></figure></li></ul><h4 id="优点和缺点-1"><a href="#优点和缺点-1" class="headerlink" title="优点和缺点"></a>优点和缺点</h4><ul><li><font color="red"><strong>优点</strong></font><ul><li>无需一次性定制链表的容量 </li><li>插入和删除操作无需移动数据元素 </li></ul></li><li><font color="red"><strong>缺点</strong></font><ul><li>数据元素必须保存后继元素的位置信息 </li><li>获取指定数据的元素操作需要顺序访问之前的元素 </li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt; 数据结构入门：&lt;/strong&gt; &lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;/excerpt&gt;&lt;/p&gt;
&lt;p&gt;常见的数据结构基础&lt;/p&gt;
    
    </summary>
    
      <category term="others" scheme="https://alexbrucelu.github.io/categories/others/"/>
    
    
      <category term="数据结构" scheme="https://alexbrucelu.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>详解TCP/IP协议</title>
    <link href="https://alexbrucelu.github.io/2018/12/05/%E8%AF%A6%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE/"/>
    <id>https://alexbrucelu.github.io/2018/12/05/详解TCPIP协议/</id>
    <published>2018-12-05T08:22:37.467Z</published>
    <updated>2018-12-06T06:28:08.072Z</updated>
    
    <content type="html"><![CDATA[<p><strong> 详解TCP/IP协议：</strong> <excerpt in="" index="" |="" 首页摘要=""></excerpt></p><p>TCP/IP网络协议的详解概述</p><a id="more"></a><p>[TOC]</p><p><img src="https://upload-images.jianshu.io/upload_images/1856419-168b63033e3a808d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp" alt="img"></p><h3 id="计算机网络体系结构分层"><a href="#计算机网络体系结构分层" class="headerlink" title="计算机网络体系结构分层"></a>计算机网络体系结构分层</h3><p><img src="https:////upload-images.jianshu.io/upload_images/1856419-efd361484c60d785.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/581/format/webp" alt="img"></p><p>计算机网络体系结构分层</p><p><img src="https:////upload-images.jianshu.io/upload_images/1856419-c69d60eeeebadd37.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp" alt="img"></p><p>计算机网络体系结构分层</p><p>不难看出，TCP/IP 与 OSI 在分层模块上稍有区别。OSI 参考模型注重“通信协议必要的功能是什么”，而 TCP/IP 则更强调“在计算机上实现协议应该开发哪种程序”。</p><h3 id="TCP-IP-基础"><a href="#TCP-IP-基础" class="headerlink" title="TCP/IP 基础"></a>TCP/IP 基础</h3><h4 id="TCP-IP-的具体含义"><a href="#TCP-IP-的具体含义" class="headerlink" title="TCP/IP 的具体含义"></a>TCP/IP 的具体含义</h4><p>从字面意义上讲，有人可能会认为 TCP/IP 是指 TCP 和 IP 两种协议。实际生活当中有时也确实就是指这两种协议。然而在很多情况下，它只是利用 IP 进行通信时所必须用到的协议群的统称。具体来说，IP 或 ICMP、TCP 或 UDP、TELNET 或 FTP、以及 HTTP 等都属于 TCP/IP 协议。他们与 TCP 或 IP 的关系紧密，是互联网必不可少的组成部分。TCP/IP 一词泛指这些协议，因此，有时也称 TCP/IP 为网际协议群。<br> 互联网进行通信时，需要相应的网络协议，TCP/IP 原本就是为使用互联网而开发制定的协议族。因此，互联网的协议就是 TCP/IP，TCP/IP 就是互联网的协议。</p><p><img src="https:////upload-images.jianshu.io/upload_images/1856419-ca4aba22c1f7a217.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/768/format/webp" alt="img"></p><p>网际协议群</p><h4 id="数据包"><a href="#数据包" class="headerlink" title="数据包"></a>数据包</h4><p><strong>包、帧、数据包、段、消息</strong><br> 以上五个术语都用来表述数据的单位，大致区分如下：</p><ul><li>包可以说是全能性术语；</li><li>帧用于表示数据链路层中包的单位；</li><li>数据包是 IP 和 UDP 等网络层以上的分层中包的单位；</li><li>段则表示 TCP 数据流中的信息；</li><li>消息是指应用协议中数据的单位。</li></ul><p>每个分层中，都会对所发送的数据附加一个首部，在这个首部中包含了该层必要的信息，如发送的目标地址以及协议相关信息。通常，为协议提供的信息为包首部，所要发送的内容为数据。在下一层的角度看，从上一层收到的包全部都被认为是本层的数据。</p><p><img src="https:////upload-images.jianshu.io/upload_images/1856419-dfd044f1ccc5c752.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/560/format/webp" alt="img"></p><p>数据包首部</p><p>网络中传输的数据包由两部分组成：一部分是协议所要用到的首部，另一部分是上一层传过来的数据。首部的结构由协议的具体规范详细定义。在数据包的首部，明确标明了协议应该如何读取数据。反过来说，看到首部，也就能够了解该协议必要的信息以及所要处理的数据。<strong>包首部就像协议的脸。</strong></p><h4 id="数据处理流程"><a href="#数据处理流程" class="headerlink" title="数据处理流程"></a>数据处理流程</h4><p>下图以用户 a 向用户 b 发送邮件为例子：</p><p><img src="https:////upload-images.jianshu.io/upload_images/1856419-2051967a4e85d719.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/772/format/webp" alt="img"></p><p>数据处理流程</p><ul><li>① 应用程序处理<br> 首先应用程序会进行编码处理，这些编码相当于 OSI 的表示层功能；<br> 编码转化后，邮件不一定马上被发送出去，这种何时建立通信连接何时发送数据的管理功能，相当于 OSI 的会话层功能。</li><li>② TCP 模块的处理<br> TCP 根据应用的指示，负责建立连接、发送数据以及断开连接。TCP 提供将应用层发来的数据顺利发送至对端的可靠传输。为了实现这一功能，需要在应用层数据的前端附加一个 TCP 首部。</li><li>③ IP 模块的处理<br> IP 将 TCP 传过来的 TCP 首部和 TCP 数据合起来当做自己的数据，并在 TCP 首部的前端加上自己的 IP 首部。IP 包生成后，参考路由控制表决定接受此 IP 包的路由或主机。</li><li>④ 网络接口（以太网驱动）的处理<br> 从 IP 传过来的 IP 包对于以太网来说就是数据。给这些数据附加上以太网首部并进行发送处理，生成的以太网数据包将通过物理层传输给接收端。</li><li>⑤ 网络接口（以太网驱动）的处理<br> 主机收到以太网包后，首先从以太网包首部找到 MAC 地址判断是否为发送给自己的包，若不是则丢弃数据。<br> 如果是发送给自己的包，则从以太网包首部中的类型确定数据类型，再传给相应的模块，如 IP、ARP 等。这里的例子则是 IP 。</li><li>⑥ IP 模块的处理<br> IP 模块接收到 数据后也做类似的处理。从包首部中判断此 IP 地址是否与自己的 IP 地址匹配，如果匹配则根据首部的协议类型将数据发送给对应的模块，如 TCP、UDP。这里的例子则是 TCP。<br> 另外吗，对于有路由器的情况，接收端地址往往不是自己的地址，此时，需要借助路由控制表，在调查应该送往的主机或路由器之后再进行转发数据。</li><li>⑦ TCP 模块的处理<br> 在 TCP 模块中，首先会计算一下校验和，判断数据是否被破坏。然后检查是否在按照序号接收数据。最后检查端口号，确定具体的应用程序。数据被完整地接收以后，会传给由端口号识别的应用程序。</li><li>⑧ 应用程序的处理<br> 接收端应用程序会直接接收发送端发送的数据。通过解析数据，展示相应的内容。</li></ul><h3 id="传输层中的-TCP-和-UDP"><a href="#传输层中的-TCP-和-UDP" class="headerlink" title="传输层中的 TCP 和 UDP"></a>传输层中的 TCP 和 UDP</h3><p>TCP/IP 中有两个具有代表性的传输层协议，分别是 TCP 和 UDP。</p><ul><li>TCP 是面向连接的、可靠的流协议。流就是指不间断的数据结构，当应用程序采用 TCP 发送消息时，虽然可以保证发送的顺序，但还是犹如没有任何间隔的数据流发送给接收端。TCP 为提供可靠性传输，实行“顺序控制”或“重发控制”机制。此外还具备“流控制（流量控制）”、“拥塞控制”、提高网络利用率等众多功能。</li><li>UDP 是不具有可靠性的数据报协议。细微的处理它会交给上层的应用去完成。在 UDP 的情况下，虽然可以确保发送消息的大小，却不能保证消息一定会到达。因此，应用有时会根据自己的需要进行重发处理。</li><li>TCP 和 UDP 的优缺点无法简单地、绝对地去做比较：TCP 用于在传输层有必要实现可靠传输的情况；而在一方面，UDP 主要用于那些对高速传输和实时性有较高要求的通信或广播通信。TCP 和 UDP 应该根据应用的目的按需使用。</li></ul><h4 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h4><p>数据链路和 IP 中的地址，分别指的是 MAC 地址和 IP 地址。前者用来识别同一链路中不同的计算机，后者用来识别 TCP/IP  网络中互连的主机和路由器。在传输层也有这种类似于地址的概念，那就是端口号。端口号用来识别同一台计算机中进行通信的不同应用程序。因此，它也被称为程序地址。</p><h5 id="根据端口号识别应用"><a href="#根据端口号识别应用" class="headerlink" title="根据端口号识别应用"></a>根据端口号识别应用</h5><p>一台计算机上同时可以运行多个程序。传输层协议正是利用这些端口号识别本机中正在进行通信的应用程序，并准确地将数据传输。</p><p><img src="https:////upload-images.jianshu.io/upload_images/1856419-aee529e8e598ec48.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500/format/webp" alt="img"></p><p>通过端口号识别应用</p><h5 id="通过-IP-地址、端口号、协议号进行通信识别"><a href="#通过-IP-地址、端口号、协议号进行通信识别" class="headerlink" title="通过 IP 地址、端口号、协议号进行通信识别"></a>通过 IP 地址、端口号、协议号进行通信识别</h5><ul><li>仅凭目标端口号识别某一个通信是远远不够的。</li></ul><p><img src="https:////upload-images.jianshu.io/upload_images/1856419-96457c6ddbe3157f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/763/format/webp" alt="img"></p><p><img src="https:////upload-images.jianshu.io/upload_images/1856419-47a50ea9428c29fc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/748/format/webp" alt="img"></p><p>通过端口号、IP地址、协议号进行通信识别</p><ul><li>① 和② 的通信是在两台计算机上进行的。它们的目标端口号相同，都是80。这里可以根据源端口号加以区分。</li><li>③ 和 ① 的目标端口号和源端口号完全相同，但它们各自的源 IP 地址不同。</li><li>此外，当 IP 地址和端口号全都一样时，我们还可以通过协议号来区分（TCP 和 UDP）。</li></ul><h5 id="端口号的确定"><a href="#端口号的确定" class="headerlink" title="端口号的确定"></a>端口号的确定</h5><ul><li>标准既定的端口号：这种方法也叫静态方法。它是指每个应用程序都有其指定的端口号。但并不是说可以随意使用任何一个端口号。例如 HTTP、FTP、TELNET 等广为使用的应用协议中所使用的端口号就是固定的。这些端口号被称为知名端口号，分布在 0~1023 之间；除知名端口号之外，还有一些端口号被正式注册，它们分布在 1024~49151 之间，不过这些端口号可用于任何通信用途。</li><li>时序分配法：服务器有必要确定监听端口号，但是接受服务的客户端没必要确定端口号。在这种方法下，客户端应用程序完全可以不用自己设置端口号，而全权交给操作系统进行分配。动态分配的端口号范围在 49152~65535 之间。</li></ul><h5 id="端口号与协议"><a href="#端口号与协议" class="headerlink" title="端口号与协议"></a>端口号与协议</h5><ul><li>端口号由其使用的传输层协议决定。因此，不同的传输层协议可以使用相同的端口号。</li><li>此外，那些知名端口号与传输层协议并无关系。只要端口一致都将分配同一种应用程序进行处理。</li></ul><h4 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h4><ul><li>UDP 不提供复杂的控制机制，利用 IP 提供面向无连接的通信服务。</li><li>并且它是将应用程序发来的数据在收到的那一刻，立即按照原样发送到网络上的一种机制。即使是出现网络拥堵的情况，UDP 也无法进行流量控制等避免网络拥塞行为。</li><li>此外，传输途中出现丢包，UDP 也不负责重发。</li><li>甚至当包的到达顺序出现乱序时也没有纠正的功能。</li><li>如果需要以上的细节控制，不得不交由采用 UDP 的应用程序去处理。</li><li>UDP 常用于一下几个方面：1.包总量较少的通信（DNS、SNMP等）；2.视频、音频等多媒体通信（即时通信）；3.限定于 LAN 等特定网络中的应用通信；4.广播通信（广播、多播）。</li></ul><h4 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h4><ul><li>TCP 与 UDP 的区别相当大。它充分地实现了数据传输时各种控制功能，可以进行丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。而这些在 UDP 中都没有。</li><li>此外，TCP 作为一种面向有连接的协议，只有在确认通信对端存在时才会发送数据，从而可以控制通信流量的浪费。</li><li>根据 TCP 的这些机制，在 IP 这种无连接的网络上也能够实现高可靠性的通信（ 主要通过检验和、序列号、确认应答、重发控制、连接管理以及窗口控制等机制实现）。</li></ul><h5 id="三次握手（重点）"><a href="#三次握手（重点）" class="headerlink" title="三次握手（重点）"></a>三次握手（重点）</h5><ul><li>TCP 提供面向有连接的通信传输。面向有连接是指在数据通信开始之前先做好两端之间的准备工作。</li><li>所谓三次握手是指建立一个 TCP 连接时需要客户端和服务器端总共发送三个包以确认连接的建立。在socket编程中，这一过程由客户端执行connect来触发。</li></ul><p>下面来看看三次握手的流程图：</p><p><img src="https:////upload-images.jianshu.io/upload_images/1856419-52baa0818e1bd1c1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/602/format/webp" alt="img"></p><p>三次握手</p><ul><li>第一次握手：客户端将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给服务器端，客户端进入SYN_SENT状态，等待服务器端确认。</li><li>第二次握手：服务器端收到数据包后由标志位SYN=1知道客户端请求建立连接，服务器端将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给客户端以确认连接请求，服务器端进入SYN_RCVD状态。</li><li>第三次握手：客户端收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给服务器端，服务器端检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，客户端和服务器端进入ESTABLISHED状态，完成三次握手，随后客户端与服务器端之间可以开始传输数据了。</li></ul><h5 id="四次挥手（重点）"><a href="#四次挥手（重点）" class="headerlink" title="四次挥手（重点）"></a>四次挥手（重点）</h5><ul><li>四次挥手即终止TCP连接，就是指断开一个TCP连接时，需要客户端和服务端总共发送4个包以确认连接的断开。在socket编程中，这一过程由客户端或服务端任一方执行close来触发。</li><li>由于TCP连接是全双工的，因此，每个方向都必须要单独进行关闭，这一原则是当一方完成数据发送任务后，发送一个FIN来终止这一方向的连接，收到一个FIN只是意味着这一方向上没有数据流动了，即不会再收到数据了，但是在这个TCP连接上仍然能够发送数据，直到这一方向也发送了FIN。首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭。</li></ul><p>下面来看看四次挥手的流程图：</p><p><img src="https:////upload-images.jianshu.io/upload_images/1856419-8787d7fb9fc4e802.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/596/format/webp" alt="img"></p><p>四次挥手</p><ul><li>中断连接端可以是客户端，也可以是服务器端。</li><li>第一次挥手：客户端发送一个FIN=M，用来关闭客户端到服务器端的数据传送，客户端进入FIN_WAIT_1状态。意思是说”我客户端没有数据要发给你了”，但是如果你服务器端还有数据没有发送完成，则不必急着关闭连接，可以继续发送数据。</li><li>第二次挥手：服务器端收到FIN后，先发送ack=M+1，告诉客户端，你的请求我收到了，但是我还没准备好，请继续你等我的消息。这个时候客户端就进入FIN_WAIT_2 状态，继续等待服务器端的FIN报文。</li><li>第三次挥手：当服务器端确定数据已发送完成，则向客户端发送FIN=N报文，告诉客户端，好了，我这边数据发完了，准备好关闭连接了。服务器端进入LAST_ACK状态。</li><li>第四次挥手：客户端收到FIN=N报文后，就知道可以关闭连接了，但是他还是不相信网络，怕服务器端不知道要关闭，所以发送ack=N+1后进入TIME_WAIT状态，如果Server端没有收到ACK则可以重传。服务器端收到ACK后，就知道可以断开连接了。客户端等待了2MSL后依然没有收到回复，则证明服务器端已正常关闭，那好，我客户端也可以关闭连接了。最终完成了四次握手。</li></ul><p><strong>上面是一方主动关闭，另一方被动关闭的情况，实际中还会出现同时发起主动关闭的情况，</strong><br> 具体流程如下图：</p><p><img src="https:////upload-images.jianshu.io/upload_images/1856419-baf89c213c19d3bd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/619/format/webp" alt="img"></p><p>同时挥手</p><h5 id="通过序列号与确认应答提高可靠性"><a href="#通过序列号与确认应答提高可靠性" class="headerlink" title="通过序列号与确认应答提高可靠性"></a>通过序列号与确认应答提高可靠性</h5><ul><li>在 TCP 中，当发送端的数据到达接收主机时，接收端主机会返回一个已收到消息的通知。这个消息叫做确认应答（ACK）。当发送端将数据发出之后会等待对端的确认应答。如果有确认应答，说明数据已经成功到达对端。<strong>反之，则数据丢失的可能性很大</strong>。</li><li>在一定时间内没有等待到确认应答，发送端就可以认为数据已经丢失，并进行重发。由此，即使产生了丢包，仍然能够保证数据能够到达对端，实现可靠传输。</li><li>未收到确认应答并不意味着数据一定丢失。也有可能是数据对方已经收到，只是返回的确认应答在途中丢失。这种情况也会导致发送端误以为数据没有到达目的地而重发数据。</li><li>此外，也有可能因为一些其他原因导致确认应答延迟到达，在源主机重发数据以后才到达的情况也屡见不鲜。此时，源主机只要按照机制重发数据即可。</li><li>对于目标主机来说，反复收到相同的数据是不可取的。为了对上层应用提供可靠的传输，目标主机必须放弃重复的数据包。为此我们引入了序列号。</li><li><strong>序列号是按照顺序给发送数据的每一个字节（8位字节）都标上号码的编号。接收端查询接收数据 TCP 首部中的序列号和数据的长度，将自己下一步应该接收的序列号作为确认应答返送回去。通过序列号和确认应答号，TCP 能够识别是否已经接收数据，又能够判断是否需要接收，从而实现可靠传输。</strong></li></ul><p><img src="https:////upload-images.jianshu.io/upload_images/1856419-9221af60624ef403.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp" alt="img"></p><p>序列号和确认应答</p><h5 id="重发超时的确定"><a href="#重发超时的确定" class="headerlink" title="重发超时的确定"></a>重发超时的确定</h5><ul><li><strong>重发超时是指在重发数据之前，等待确认应答到来的那个特定时间间隔。</strong>如果超过这个时间仍未收到确认应答，发送端将进行数据重发。最理想的是，找到一个最小时间，它能保证“确认应答一定能在这个时间内返回”。</li><li>TCP 要求不论处在何种网络环境下都要提供高性能通信，并且无论网络拥堵情况发生何种变化，都必须保持这一特性。为此，它在每次发包时都会计算往返时间及其偏差。将这个往返时间和偏差时间相加，重发超时的时间就是比这个总和要稍大一点的值。</li><li>在 BSD 的 Unix 以及 Windows 系统中，超时都以0.5秒为单位进行控制，因此重发超时都是0.5秒的整数倍。不过，最初其重发超时的默认值一般设置为6秒左右。</li><li>数据被重发之后若还是收不到确认应答，则进行再次发送。此时，等待确认应答的时间将会以2倍、4倍的指数函数延长。</li><li>此外，<strong>数据也不会被无限、反复地重发。达到一定重发次数之后，如果仍没有任何确认应答返回，就会判断为网络或对端主机发生了异常，强制关闭连接。并且通知应用通信异常强行终止。</strong> </li></ul><h5 id="以段为单位发送数据"><a href="#以段为单位发送数据" class="headerlink" title="以段为单位发送数据"></a>以段为单位发送数据</h5><ul><li>在建立 TCP 连接的同时，也可以确定发送数据包的单位，我们也可以称其为“最大消息长度”（MSS）。最理想的情况是，最大消息长度正好是 IP 中不会被分片处理的最大数据长度。</li><li>TCP 在传送大量数据时，是以 MSS 的大小将数据进行分割发送。进行重发时也是以 MSS  为单位。</li><li>MSS 在三次握手的时候，在两端主机之间被计算得出。两端的主机在发出建立连接的请求时，会在 TCP 首部中写入 MSS  选项，告诉对方自己的接口能够适应的 MSS 的大小。然后会在两者之间选择一个较小的值投入使用。</li></ul><h5 id="利用窗口控制提高速度"><a href="#利用窗口控制提高速度" class="headerlink" title="利用窗口控制提高速度"></a>利用窗口控制提高速度</h5><ul><li><p>TCP 以1个段为单位，每发送一个段进行一次确认应答的处理。这样的传输方式有一个缺点，就是包的往返时间越长通信性能就越低。</p></li><li><p>为解决这个问题，TCP 引入了窗口这个概念。确认应答不再是以每个分段，而是以更大的单位进行确认，转发时间将会被大幅地缩短。也就是说，发送端主机，在发送了一个段以后不必要一直等待确认应答，而是继续发送。如下图所示：</p></li></ul><p>  <img src="https:////upload-images.jianshu.io/upload_images/1856419-3883cce343404099.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/605/format/webp" alt="img"></p><p>  窗口控制</p><ul><li>窗口大小就是指无需等待确认应答而可以继续发送数据的最大值。上图中窗口大小为4个段。这个机制实现了使用大量的缓冲区，通过对多个段同时进行确认应答的功能。</li></ul><h5 id="滑动窗口控制"><a href="#滑动窗口控制" class="headerlink" title="滑动窗口控制"></a>滑动窗口控制</h5><p><img src="https:////upload-images.jianshu.io/upload_images/1856419-7919bd12b5b2917b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/859/format/webp" alt="img"></p><p>滑动窗口</p><ul><li>上图中的窗口内的数据即便没有收到确认应答也可以被发送出去。不过，在整个窗口的确认应答没有到达之前，如果其中部分数据出现丢包，那么发送端仍然要负责重传。为此，发送端主机需要设置缓存保留这些待被重传的数据，直到收到他们的确认应答。</li><li>在滑动窗口以外的部分包括未发送的数据以及已经确认对端已收到的数据。当数据发出后若如期收到确认应答就可以不用再进行重发，此时数据就可以从缓存区清除。</li><li>收到确认应答的情况下，将窗口滑动到确认应答中的序列号的位置。这样可以顺序地将多个段同时发送提高通信性能。这种机制也别称为滑动窗口控制。</li></ul><h5 id="窗口控制中的重发控制"><a href="#窗口控制中的重发控制" class="headerlink" title="窗口控制中的重发控制"></a>窗口控制中的重发控制</h5><p>在使用窗口控制中， 出现丢包一般分为两种情况：</p><ul><li>① 确认应答未能返回的情况。在这种情况下，数据已经到达对端，是不需要再进行重发的，如下图：</li></ul><p><img src="https:////upload-images.jianshu.io/upload_images/1856419-f17380d7afc3bb73.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/595/format/webp" alt="img"></p><p>部分确认应答丢失</p><ul><li>② 某个报文段丢失的情况。接收主机如果收到一个自己应该接收的序列号以外的数据时，会针对当前为止收到数据返回确认应答。如下图所示，当某一报文段丢失后，发送端会一直收到序号为1001的确认应答，因此，在窗口比较大，又出现报文段丢失的情况下，同一个序列号的确认应答将会被重复不断地返回。而发送端主机如果连续3次收到同一个确认应答，就会将其对应的数据进行重发。这种机制比之前提到的超时管理更加高效，因此也被称为高速重发控制。</li></ul><p><img src="https:////upload-images.jianshu.io/upload_images/1856419-0732e3d90fea80c8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/884/format/webp" alt="img"></p><p>高速重发控制</p><h3 id="网络层中的-IP-协议"><a href="#网络层中的-IP-协议" class="headerlink" title="网络层中的 IP 协议"></a>网络层中的 IP 协议</h3><ul><li>IP（IPv4、IPv6）相当于 OSI 参考模型中的第3层——网络层。网络层的主要作用是“实现终端节点之间的通信”。这种终端节点之间的通信也叫“点对点通信”。</li><li>网络的下一层——数据链路层的主要作用是在互连同一种数据链路的节点之间进行包传递。而一旦跨越多种数据链路，就需要借助网络层。网络层可以跨越不同的数据链路，即使是在不同的数据链路上也能实现两端节点之间的数据包传输。</li><li><strong>IP 大致分为三大作用模块，它们是 IP 寻址、路由（最终节点为止的转发）以及 IP 分包与组包。</strong></li></ul><h4 id="IP-地址"><a href="#IP-地址" class="headerlink" title="IP 地址"></a>IP 地址</h4><h5 id="IP-地址概述"><a href="#IP-地址概述" class="headerlink" title="IP 地址概述"></a>IP 地址概述</h5><ul><li>在计算机通信中，为了识别通信对端，必须要有一个类似于地址的识别码进行标识。在数据链路中的 MAC 地址正是用来标识同一个链路中不同计算机的一种识别码。</li><li>作为网络层的 IP ,也有这种地址信息，一般叫做 IP 地址。IP 地址用于在“连接到网络中的所有主机中识别出进行通信的目标地址”。因此，在 TCP/IP 通信中所有主机或路由器必须设定自己的 IP 地址。</li><li>不论一台主机与哪种数据链路连接，其 IP 地址的形式都保持不变。</li><li>IP 地址（IPv4 地址）由32位正整数来表示。IP 地址在计算机内部以二进制方式被处理。然而，由于我们并不习惯于采用二进制方式，我们将32位的 IP 地址以每8位为一组，分成4组，每组以 “.” 隔开，再将每组数转换成十进制数。如下：</li></ul><table><thead><tr><th>28</th><th>28</th><th>28</th><th>28</th><th></th></tr></thead><tbody><tr><td>10101100</td><td>00010100</td><td>00000001</td><td>00000001</td><td>（2进制）</td></tr><tr><td>10101100.</td><td>00010100.</td><td>00000001.</td><td>00000001</td><td>（2进制）</td></tr><tr><td>172.</td><td>20.</td><td>1.</td><td>1</td><td>（10进制）</td></tr></tbody></table><h5 id="IP-地址由网络和主机两部分标识组成"><a href="#IP-地址由网络和主机两部分标识组成" class="headerlink" title="IP 地址由网络和主机两部分标识组成"></a>IP 地址由网络和主机两部分标识组成</h5><ul><li>如下图，网络标识在数据链路的每个段配置不同的值。网络标识必须保证相互连接的每个段的地址不相重复。而相同段内相连的主机必须有相同的网络地址。IP 地址的“主机标识”则不允许在同一个网段内重复出现。由此，可以通过设置网络地址和主机地址，在相互连接的整个网络中保证每台主机的 IP 地址都不会相互重叠。即 IP 地址具有了唯一性。</li></ul><p><img src="https:////upload-images.jianshu.io/upload_images/1856419-d653f38b146f5f9f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/728/format/webp" alt="img"></p><p>IP地址的主机标识</p><ul><li>如下图，IP 包被转发到途中某个路由器时，正是利用目标 IP 地址的网络标识进行路由。因为即使不看主机标识，只要一见到网络标识就能判断出是否为该网段内的主机。</li></ul><p><img src="https:////upload-images.jianshu.io/upload_images/1856419-98e99ce9135f6eeb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/724/format/webp" alt="img"></p><p>IP地址的网络标识</p><h5 id="IP-地址的分类"><a href="#IP-地址的分类" class="headerlink" title="IP 地址的分类"></a>IP 地址的分类</h5><ul><li><strong>IP 地址分为四个级别，分别为A类、B类、C类、D类。它根据 IP 地址中从第 1 位到第 4 位的比特列对其网络标识和主机标识进行区分。</strong></li><li><strong>A 类 IP 地址是首位以 “0” 开头的地址。</strong>从第 1 位到第 8 位是它的网络标识。用十进制表示的话，0.0.0.0~127.0.0.0 是 A 类的网络地址。A 类地址的后 24 位相当于主机标识。因此，一个网段内可容纳的主机地址上限为16,777,214个。</li><li><strong>B 类 IP 地址是前两位 “10” 的地址。</strong>从第 1 位到第 16 位是它的网络标识。用十进制表示的话，128.0.0.0~191.255.0.0 是 B 类的网络地址。B 类地址的后 16 位相当于主机标识。因此，一个网段内可容纳的主机地址上限为65,534个。</li><li><strong>C 类 IP 地址是前三位为 “110” 的地址。</strong>从第 1 位到第 24 位是它的网络标识。用十进制表示的话，192.0.0.0~223.255.255.0 是 C 类的网络地址。C 类地址的后 8 位相当于主机标识。因此，一个网段内可容纳的主机地址上限为254个。</li><li><strong>D 类 IP 地址是前四位为 “1110” 的地址。</strong>从第 1 位到第 32 位是它的网络标识。用十进制表示的话，224.0.0.0~239.255.255.255 是 D 类的网络地址。D 类地址没有主机标识，常用于多播。</li><li>在分配 IP 地址时关于主机标识有一点需要注意。即要用比特位表示主机地址时，不可以全部为 0 或全部为 1。因为全部为 0 只有在表示对应的网络地址或 IP 地址不可以获知的情况下才使用。而全部为 1 的主机通常作为广播地址。因此，在分配过程中，应该去掉这两种情况。这也是为什么 C 类地址每个网段最多只能有 254（ 28 - 2 = 254）个主机地址的原因。</li></ul><h5 id="广播地址"><a href="#广播地址" class="headerlink" title="广播地址"></a>广播地址</h5><ul><li>广播地址用于在同一个链路中相互连接的主机之间发送数据包。将 IP 地址中的主机地址部分全部设置为 1，就成了广播地址。</li><li>广播分为本地广播和直接广播两种。在本网络内的广播叫做本地广播；在不同网络之间的广播叫做直接广播。</li></ul><h5 id="IP-多播"><a href="#IP-多播" class="headerlink" title="IP 多播"></a>IP 多播</h5><ul><li><p>多播用于将包发送给特定组内的所有主机。由于其直接使用 IP 地址，因此也不存在可靠传输。</p></li><li><p>相比于广播，多播既可以穿透路由器，又可以实现只给那些必要的组发送数据包。请看下图：</p></li></ul><p>  <img src="https:////upload-images.jianshu.io/upload_images/1856419-18d212851da62909.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/547/format/webp" alt="img"></p><p>  IP 多播</p><ul><li><p>多播使用 D 类地址。因此，如果从首位开始到第 4 位是 “1110”，就可以认为是多播地址。而剩下的 28 位可以成为多播的组编号。</p></li><li><p>此外， 对于多播，所有的主机（路由器以外的主机和终端主机）必须属于 224.0.0.1 的组，所有的路由器必须属于 224.0.0.2 的组。</p></li></ul><h5 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h5><ul><li>现在一个 IP 地址的网络标识和主机标识已不再受限于该地址的类别，而是由一个叫做“子网掩码”的识别码通过子网网络地址细分出比 A 类、B 类、C 类更小粒度的网络。这种方式实际上就是将原来 A 类、B 类、C 类等分类中的主机地址部分用作子网地址，可以将原网络分为多个物理网络的一种机制。</li><li>子网掩码用二进制方式表示的话，也是一个 32 位的数字。它对应 IP 地址网络标识部分的位全部为 “1”，对应 IP 地址主机标识的部分则全部为 “0”。由此，一个 IP 地址可以不再受限于自己的类别，而是可以用这样的子网掩码自由地定位自己的网络标识长度。当然，子网掩码必须是 IP 地址的首位开始连续的 “1”。</li><li>对于子网掩码，目前有两种表示方式。第一种是，将 IP 地址与子网掩码的地址分别用两行来表示。以 172.20.100.52 的前 26 位是网络地址的情况为例，如下：</li></ul><table><thead><tr><th>IP 地址</th><th>172.</th><th>20.</th><th>100.</th><th>52</th></tr></thead><tbody><tr><td>子网掩码</td><td>255.</td><td>255.</td><td>255.</td><td>192</td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td>网络地址</td><td>172.</td><td>20.</td><td>100.</td><td>0</td></tr><tr><td>子网掩码</td><td>255.</td><td>255.</td><td>255.</td><td>192</td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td>广播地址</td><td>172.</td><td>20.</td><td>100.</td><td>63</td></tr><tr><td>子网掩码</td><td>255.</td><td>255.</td><td>255.</td><td>192</td></tr></tbody></table><ul><li>第二种表示方式是，在每个 IP 地址后面追加网络地址的位数用 “/ ” 隔开，如下：</li></ul><table><thead><tr><th>IP 地址</th><th>172.</th><th>20.</th><th>100.</th><th>52</th><th>/ 26</th></tr></thead><tbody><tr><td>网络地址</td><td>172.</td><td>20.</td><td>100.</td><td>0</td><td>/ 26</td></tr><tr><td>广播地址</td><td>172.</td><td>20.</td><td>100.</td><td>63</td><td>/ 26</td></tr></tbody></table><ul><li>另外，在第二种方式下记述网络地址时可以省略后面的 “0” 。例如：172.20.0.0/26 跟 172.20/26 其实是一个意思。</li></ul><h4 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h4><ul><li>发送数据包时所使用的地址是网络层的地址，即 IP 地址。然而仅仅有 IP 地址还不足以实现将数据包发送到对端目标地址，在数据发送过程中还需要类似于“指明路由器或主机”的信息，以便真正发往目标地址。保存这种信息的就是路由控制表。</li><li>该路由控制表的形成方式有两种：一种是管理员手动设置，另一种是路由器与其他路由器相互交换信息时自动刷新。前者也叫做静态路由控制，而后者叫做动态路由控制。</li><li>IP 协议始终认为路由表是正确的。然后，IP 本身并没有定义制作路由控制表的协议。即 IP 没有制作路由控制表的机制。该表示由一个叫做“路由协议”的协议制作而成。</li></ul><h5 id="IP-地址与路由控制"><a href="#IP-地址与路由控制" class="headerlink" title="IP 地址与路由控制"></a>IP 地址与路由控制</h5><ul><li>IP 地址的网络地址部分用于进行路由控制。</li><li>路由控制表中记录着网络地址与下一步应该发送至路由器的地址。</li><li>在发送 IP 包时，首先要确定 IP 包首部中的目标地址，再从路由控制表中找到与该地址具有相同网络地址的记录，根据该记录将 IP 包转发给相应的下一个路由器。如果路由控制表中存在多条相同网络地址的记录，就选择一个最为吻合的网络地址。</li></ul><p><img src="https:////upload-images.jianshu.io/upload_images/1856419-cd4c3759c61abb38.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/730/format/webp" alt="img"></p><p>路由控制表与 IP 包发送</p><h4 id="IP-分包与组包"><a href="#IP-分包与组包" class="headerlink" title="IP 分包与组包"></a>IP 分包与组包</h4><ul><li>每种数据链路的最大传输单元（MTU）都不尽相同，因为每个不同类型的数据链路的使用目的不同。使用目的不同，可承载的 MTU 也就不同。</li><li>任何一台主机都有必要对 IP 分片进行相应的处理。分片往往在网络上遇到比较大的报文无法一下子发送出去时才会进行处理。</li><li>经过分片之后的 IP 数据报在被重组的时候，只能由目标主机进行。路由器虽然做分片但不会进行重组。</li></ul><h5 id="路径-MTU-发现"><a href="#路径-MTU-发现" class="headerlink" title="路径 MTU 发现"></a>路径 MTU 发现</h5><ul><li>分片机制也有它的不足。如路由器的处理负荷加重之类。因此，只要允许，是不希望由路由器进行 IP 数据包的分片处理的。</li><li>为了应对分片机制的不足，“路径 MTU 发现” 技术应运而生。路径 MTU 指的是，从发送端主机到接收端主机之间不需要分片是最大 MTU 的大小。即路径中存在的所有数据链路中最小的 MTU 。</li><li>进行路径 MTU 发现，就可以避免在中途的路由器上进行分片处理，也可以在 TCP 中发送更大的包。</li></ul><h4 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h4><ul><li>IPv6（IP version 6）是为了根本解决 IPv4 地址耗尽的问题而被标准化的网际协议。IPv4 的地址长度为 4 个 8 位字节，即 32 比特。而 IPv6 的地址长度则是原来的 4 倍，即 128 比特，一般写成 8 个 16 位字节。</li></ul><h5 id="IPv6-的特点"><a href="#IPv6-的特点" class="headerlink" title="IPv6 的特点"></a>IPv6 的特点</h5><ul><li>IP 得知的扩大与路由控制表的聚合。</li><li>性能提升。包首部长度采用固定的值（40字节），不再采用首部检验码。简化首部结构，减轻路由器负担。路由器不再做分片处理。</li><li>支持即插即用功能。即使没有DHCP服务器也可以实现自动分配 IP 地址。</li><li>采用认证与加密功能。应对伪造 IP 地址的网络安全功能以及防止线路窃听的功能。</li><li>多播、Mobile IP 成为扩展功能。</li></ul><h5 id="IPv6-中-IP-地址的标记方法"><a href="#IPv6-中-IP-地址的标记方法" class="headerlink" title="IPv6 中 IP 地址的标记方法"></a>IPv6 中 IP 地址的标记方法</h5><ul><li>一般人们将 128 比特 IP 地址以每 16 比特为一组，每组用冒号（“：”）隔开进行标记。</li><li>而且如果出现连续的 0 时还可以将这些 0 省略，并用两个冒号（“：：”）隔开。但是，一个 IP 地址中只允许出现一次两个连续的冒号。</li></ul><h5 id="IPv6-地址的结构"><a href="#IPv6-地址的结构" class="headerlink" title="IPv6 地址的结构"></a>IPv6 地址的结构</h5><ul><li>IPv6 类似 IPv4，也是通过 IP 地址的前几位标识 IP 地址的种类。</li><li>在互联网通信中，使用一种全局的单播地址。它是互联网中唯一的一个地址，不需要正式分配 IP 地址。</li></ul><table><thead><tr><th>未定义</th><th>0000 … 0000（128比特）</th><th>：：/ 128</th></tr></thead><tbody><tr><td>环回地址</td><td>0000 … 0001（128比特）</td><td>：：1 / 128</td></tr><tr><td>唯一本地地址</td><td>1111 110</td><td>FC00：/ 7</td></tr><tr><td>链路本地单播地址</td><td>1111 1110 10</td><td>FE80：：/ 10</td></tr><tr><td>多播地址</td><td>1111 1111</td><td>FF00：：/ 8</td></tr><tr><td>全局单播地址</td><td>（其他）</td></tr></tbody></table><h5 id="全局单播地址"><a href="#全局单播地址" class="headerlink" title="全局单播地址"></a>全局单播地址</h5><ul><li>全局单播地址是指世界上唯一的一个地址。它是互联网通信以及各个域内部通信中最为常用的一个 IPv6 地址。</li><li>格式如下图所示，现在 IPv6 的网络中所使用的格式为，n = 48，m = 16 以及 128 - n - m = 64。即前 64 比特为网络标识，后 64 比特为主机标识。</li></ul><p><img src="https:////upload-images.jianshu.io/upload_images/1856419-3cd8f2d1fae94dcf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/785/format/webp" alt="img"></p><p>全局单播地址</p><h5 id="链路本地单播地址"><a href="#链路本地单播地址" class="headerlink" title="链路本地单播地址"></a>链路本地单播地址</h5><ul><li>链路本地单播地址是指在同一个数据链路内唯一的地址。它用于不经过路由器，在同一个链路中的通信。通常接口 ID 保存 64 比特版的 MAC 地址。</li></ul><p><img src="https:////upload-images.jianshu.io/upload_images/1856419-dca23d5bfda77579.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/772/format/webp" alt="img"></p><p>链路本地单播地址</p><h5 id="唯一本地地址"><a href="#唯一本地地址" class="headerlink" title="唯一本地地址"></a>唯一本地地址</h5><ul><li>唯一本地地址是不进行互联网通信时所用的地址。</li><li>唯一本地地址虽然不会与互联网连接，但是也会尽可能地随机生成一个唯一的全局 ID。</li><li>L 通常被置为 1</li><li>全局 ID 的值随机决定</li><li>子网 ID 是指该域子网地址</li><li>接口 ID 即为接口的 ID</li></ul><p><img src="https:////upload-images.jianshu.io/upload_images/1856419-baee1dd0cd9d16a2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/820/format/webp" alt="img"></p><p>唯一本地地址</p><h5 id="IPv6-分段处理"><a href="#IPv6-分段处理" class="headerlink" title="IPv6 分段处理"></a>IPv6 分段处理</h5><ul><li>IPv6 的分片处理只在作为起点的发送端主机上进行，路由器不参与分片。</li><li>IPv6 中最小 MTU 为 1280 字节，因此，在嵌入式系统中对于那些有一定系统资源限制的设备来说，不需要进行“路径 MTU 发现”，而是在发送 IP 包时直接以 1280 字节为单位分片送出。</li></ul><h5 id="IP-首部（暂略）"><a href="#IP-首部（暂略）" class="headerlink" title="IP 首部（暂略）"></a>IP 首部（暂略）</h5><h4 id="IP-协议相关技术"><a href="#IP-协议相关技术" class="headerlink" title="IP 协议相关技术"></a>IP 协议相关技术</h4><ul><li>IP 旨在让最终目标主机收到数据包，但是在这一过程中仅仅有 IP 是无法实现通信的。必须还有能够解析主机名称和 MAC 地址的功能，以及数据包在发送过程中异常情况处理的功能。</li></ul><h5 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h5><ul><li>我们平常在访问某个网站时不适用 IP 地址，而是用一串由罗马字和点号组成的字符串。而一般用户在使用 TCP/IP 进行通信时也不使用 IP 地址。能够这样做是因为有了 DNS （Domain Name System）功能的支持。DNS 可以将那串字符串自动转换为具体的 IP 地址。</li><li>这种 DNS 不仅适用于 IPv4，还适用于 IPv6。</li></ul><h5 id="ARP"><a href="#ARP" class="headerlink" title="ARP"></a>ARP</h5><ul><li>只要确定了 IP 地址，就可以向这个目标地址发送 IP 数据报。然而，在底层数据链路层，进行实际通信时却有必要了解每个 IP 地址所对应的 MAC 地址。</li><li>ARP 是一种解决地址问题的协议。以目标 IP 地址为线索，用来定位下一个应该接收数据分包的网络设备对应的 MAC 地址。不过 ARP 只适用于 IPv4，不能用于 IPv6。IPv6 中可以用 ICMPv6 替代 ARP 发送邻居探索消息。</li><li>RARP 是将 ARP 反过来，从 MAC 地址定位 IP 地址的一种协议。</li></ul><h5 id="5-3-ICMP"><a href="#5-3-ICMP" class="headerlink" title="5.3 ICMP"></a>5.3 ICMP</h5><ul><li>ICMP 的主要功能包括，确认 IP 包是否成功送达目标地址，通知在发送过程当中 IP 包被废弃的具体原因，改善网络设置等。</li><li>IPv4 中 ICMP 仅作为一个辅助作用支持 IPv4。也就是说，在 IPv4 时期，即使没有 ICMP，仍然可以实现 IP 通信。然而，在 IPv6 中，ICMP 的作用被扩大，如果没有 ICMPv6，IPv6 就无法进行正常通信。</li></ul><h5 id="DHCP"><a href="#DHCP" class="headerlink" title="DHCP"></a>DHCP</h5><ul><li>如果逐一为每一台主机设置 IP 地址会是非常繁琐的事情。特别是在移动使用笔记本电脑、只能终端以及平板电脑等设备时，每移动到一个新的地方，都要重新设置 IP 地址。</li><li>于是，为了实现自动设置 IP 地址、统一管理 IP 地址分配，就产生了 DHCP（Dynamic Host Configuration Protocol）协议。有了 DHCP，计算机只要连接到网络，就可以进行 TCP/IP 通信。也就是说，DHCP 让即插即用变得可能。</li><li>DHCP 不仅在 IPv4 中，在 IPv6 中也可以使用。</li></ul><h5 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h5><ul><li>NAT（Network Address Translator）是用于在本地网络中使用私有地址，在连接互联网时转而使用全局 IP 地址的技术。</li><li>除转换 IP 地址外，还出现了可以转换 TCP、UDP 端口号的 NAPT（Network Address Ports Translator）技术，由此可以实现用一个全局 IP 地址与多个主机的通信。</li><li>NAT（NAPT）实际上是为正在面临地址枯竭的 IPv4 而开发的技术。不过，在 IPv6 中为了提高网络安全也在使用 NAT，在 IPv4 和 IPv6 之间的相互通信当中常常使用 NAT-PT。</li></ul><h5 id="IP-隧道"><a href="#IP-隧道" class="headerlink" title="IP 隧道"></a>IP 隧道</h5><p><img src="https:////upload-images.jianshu.io/upload_images/1856419-d45032d360259d59.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/641/format/webp" alt="img"></p><p>夹着 IPv4 网络的两个 IPv6 网络</p><ul><li>如上图的网络环境中，网络 A 与网络 B 之间无法直接进行通信，为了让它们之间正常通信，这时必须得采用 IP 隧道的功能。</li><li>IP 隧道可以将那些从网络 A 发过来的 IPv6 的包统合为一个数据，再为之追加一个 IPv4 的首部以后转发给网络 C。</li><li>一般情况下，紧接着 IP 首部的是 TCP 或 UDP 的首部。然而，现在的应用当中“ IP 首部的后面还是 IP 首部”或者“ IP 首部的后面是 IPv6 的首部”等情况与日俱增。这种在网络层的首部后面追加网络层首部的通信方法就叫做“ IP 隧道”。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt; 详解TCP/IP协议：&lt;/strong&gt; &lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;/excerpt&gt;&lt;/p&gt;
&lt;p&gt;TCP/IP网络协议的详解概述&lt;/p&gt;
    
    </summary>
    
      <category term="others" scheme="https://alexbrucelu.github.io/categories/others/"/>
    
    
      <category term="TCP/IP" scheme="https://alexbrucelu.github.io/tags/TCP-IP/"/>
    
  </entry>
  
  <entry>
    <title>详解http协议</title>
    <link href="https://alexbrucelu.github.io/2018/12/05/%E8%AF%A6%E8%A7%A3http%E5%8D%8F%E8%AE%AE/"/>
    <id>https://alexbrucelu.github.io/2018/12/05/详解http协议/</id>
    <published>2018-12-05T08:20:13.313Z</published>
    <updated>2018-12-05T09:41:11.358Z</updated>
    
    <content type="html"><![CDATA[<p><strong> 详解http协议：</strong> <excerpt in="" index="" |="" 首页摘要=""></excerpt></p><p>http网络协议的详解概述</p><a id="more"></a><p>[TOC]</p><p><img src="https://github.com/AlexBruceLu/DAPP/wiki/http3.webp" alt="一张图带你看完本篇文章"></p><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><h4 id="计算机网络体系结构分层"><a href="#计算机网络体系结构分层" class="headerlink" title="计算机网络体系结构分层"></a>计算机网络体系结构分层</h4><p><img src="https://github.com/AlexBruceLu/DAPP/wiki/http2.webp" alt="计算机网络体系结构分层"></p><h4 id="TCP-IP-通信传输流"><a href="#TCP-IP-通信传输流" class="headerlink" title="TCP/IP 通信传输流"></a>TCP/IP 通信传输流</h4><p>利用 TCP/IP 协议族进行网络通信时，会通过分层顺序与对方进行通信。发送端从应用层往下走，接收端则从链路层往上走。如下：</p><p><img src="https://github.com/AlexBruceLu/DAPP/wiki/http4.webp" alt="TCP/IP 通信传输流"></p><ul><li>首先作为发送端的客户端在应用层（HTTP 协议）发出一个想看某个 Web 页面的 HTTP 请求。</li><li>接着，为了传输方便，在传输层（TCP 协议）把从应用层处收到的数据（HTTP 请求报文）进行分割，并在各个报文上打上标记序号及端口号后转发给网络层。</li><li>在网络层（IP 协议），增加作为通信目的地的 MAC 地址后转发给链路层。这样一来，发往网络的通信请求就准备齐全了。</li><li>接收端的服务器在链路层接收到数据，按序往上层发送，一直到应用层。当传输到应用层，才能算真正接收到由客户端发送过来的 HTTP请求。</li></ul><p>如下图所示：</p><p><img src="https://github.com/AlexBruceLu/DAPP/wiki/http5.webp" alt="HTTP 请求"></p><p>在网络体系结构中，包含了众多的网络协议，这篇文章主要围绕 HTTP 协议（HTTP/1.1版本）展开。</p><blockquote><p>HTTP协议（HyperText Transfer Protocol，超文本传输协议）是用于从WWW服务器传输超文本到本地浏览器的传输协议。它可以使浏览器更加高效，使网络传输减少。它不仅保证计算机正确快速地传输超文本文档，还确定传输文档中的哪一部分，以及哪部分内容首先显示(如文本先于图形)等。<br> HTTP是客户端浏览器或其他程序与Web服务器之间的应用层通信协议。在Internet上的Web服务器上存放的都是超文本信息，客户机需要通过HTTP协议传输所要访问的超文本信息。HTTP包含命令和传输信息，不仅可用于Web访问，也可以用于其他因特网/内联网应用系统之间的通信，从而实现各类应用资源超媒体访问的集成。<br> 我们在浏览器的地址栏里输入的网站地址叫做URL (Uniform Resource Locator，统一资源定位符)。就像每家每户都有一个门牌地址一样，每个网页也都有一个Internet地址。当你在浏览器的地址框中输入一个URL或是单击一个超级链接时，URL就确定了要浏览的地址。浏览器通过超文本传输协议(HTTP)，将Web服务器上站点的网页代码提取出来，并翻译成漂亮的网页。</p></blockquote><h3 id="HTTP-工作过程"><a href="#HTTP-工作过程" class="headerlink" title="HTTP 工作过程"></a>HTTP 工作过程</h3><p><img src="https://github.com/AlexBruceLu/DAPP/wiki/http6.webp" alt="HTTP请求响应模型"></p><p>HTTP通信机制是在一次完整的 HTTP 通信过程中，客户端与服务器之间将完成下列7个步骤：</p><h4 id="建立-TCP-连接"><a href="#建立-TCP-连接" class="headerlink" title="建立 TCP 连接"></a><strong>建立 TCP 连接</strong></h4><p>在HTTP工作开始之前，客户端首先要通过网络与服务器建立连接，该连接是通过 TCP 来完成的，该协议与 IP 协议共同构建 Internet，即著名的 TCP/IP 协议族，因此 Internet 又被称作是 TCP/IP 网络。HTTP 是比 TCP 更高层次的应用层协议，根据规则，只有低层协议建立之后，才能进行高层协议的连接，因此，首先要建立 TCP 连接，一般 TCP 连接的端口号是80；</p><h4 id="客户端向服务器发送请求命令"><a href="#客户端向服务器发送请求命令" class="headerlink" title="客户端向服务器发送请求命令"></a><strong>客户端向服务器发送请求命令</strong></h4><p> 一旦建立了TCP连接，客户端就会向服务器发送请求命令；<br> 例如：<code>GET/sample/hello.jsp HTTP/1.1</code> </p><h4 id="客户端发送请求头信息"><a href="#客户端发送请求头信息" class="headerlink" title="客户端发送请求头信息"></a><strong>客户端发送请求头信息</strong></h4><p> 客户端发送其请求命令之后，还要以头信息的形式向服务器发送一些别的信息，之后客户端发送了一空白行来通知服务器，它已经结束了该头信息的发送；</p><h4 id="服务器应答"><a href="#服务器应答" class="headerlink" title="服务器应答"></a><strong>服务器应答</strong></h4><p> 客户端向服务器发出请求后，服务器会客户端返回响应；<br> 例如： <code>HTTP/1.1 200 OK</code><br> 响应的第一部分是协议的版本号和响应状态码</p><h4 id="服务器返回响应头信息"><a href="#服务器返回响应头信息" class="headerlink" title="服务器返回响应头信息"></a><strong>服务器返回响应头信息</strong></h4><p> 正如客户端会随同请求发送关于自身的信息一样，服务器也会随同响应向用户发送关于它自己的数据及被请求的文档；</p><h4 id="服务器向客户端发送数据"><a href="#服务器向客户端发送数据" class="headerlink" title="服务器向客户端发送数据"></a><strong>服务器向客户端发送数据</strong></h4><p> 服务器向客户端发送头信息后，它会发送一个空白行来表示头信息的发送到此为结束，接着，它就以 Content-Type 响应头信息所描述的格式发送用户所请求的实际数据；</p><h4 id="服务器关闭-TCP-连接"><a href="#服务器关闭-TCP-连接" class="headerlink" title="服务器关闭 TCP 连接"></a><strong>服务器关闭 TCP 连接</strong></h4><p> 一般情况下，一旦服务器向客户端返回了请求数据，它就要关闭 TCP 连接，然后如果客户端或者服务器在其头信息加入了这行代码 <code>Connection:keep-alive</code> ，TCP 连接在发送后将仍然保持打开状态，于是，客户端可以继续通过相同的连接发送请求。保持连接节省了为每个请求建立新连接所需的时间，还节约了网络带宽。</p><h3 id="HTTP-协议基础"><a href="#HTTP-协议基础" class="headerlink" title="HTTP 协议基础"></a>HTTP 协议基础</h3><h4 id="通过请求和响应的交换达成通信"><a href="#通过请求和响应的交换达成通信" class="headerlink" title="通过请求和响应的交换达成通信"></a>通过请求和响应的交换达成通信</h4><p>应用 HTTP 协议时，必定是一端担任客户端角色，另一端担任服务器端角色。仅从一条通信线路来说，服务器端和客服端的角色是确定的。HTTP 协议规定，请求从客户端发出，最后服务器端响应该请求并返回。<strong>换句话说，肯定是先从客户端开始建立通信的，服务器端在没有接收到请求之前不会发送响应。</strong></p><h4 id="HTTP-是不保存状态的协议"><a href="#HTTP-是不保存状态的协议" class="headerlink" title="HTTP 是不保存状态的协议"></a>HTTP 是不保存状态的协议</h4><p>HTTP 是一种无状态协议。协议自身不对请求和响应之间的通信状态进行保存。也就是说在 HTTP 这个级别，协议对于发送过的请求或响应都不做持久化处理。这是为了更快地处理大量事务，确保协议的可伸缩性，而特意把 HTTP 协议设计成如此简单的。<br>可是随着 Web 的不断发展，我们的很多业务都需要对通信状态进行保存。于是我们引入了 Cookie 技术。有了 Cookie 再用 HTTP 协议通信，就可以管理状态了。</p><h4 id="使用-Cookie-的状态管理"><a href="#使用-Cookie-的状态管理" class="headerlink" title="使用 Cookie 的状态管理"></a>使用 Cookie 的状态管理</h4><p>Cookie 技术通过在请求和响应报文中写入 Cookie 信息来控制客户端的状态。Cookie 会根据从服务器端发送的响应报文内的一个叫做 Set-Cookie 的首部字段信息，通知客户端保存Cookie。当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入 Cookie 值后发送出去。服务器端发现客户端发送过来的 Cookie 后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到之前的状态信息。</p><p><img src="https://github.com/AlexBruceLu/DAPP/wiki/http7.webp" alt="Cookie 的流程"></p><h4 id="请求-URI-定位资源"><a href="#请求-URI-定位资源" class="headerlink" title="请求 URI 定位资源"></a>请求 URI 定位资源</h4><p>HTTP 协议使用 URI 定位互联网上的资源。正是因为 URI 的特定功能，在互联网上任意位置的资源都能访问到。</p><h4 id="告知服务器意图的-HTTP-方法（HTTP-1-1）"><a href="#告知服务器意图的-HTTP-方法（HTTP-1-1）" class="headerlink" title="告知服务器意图的 HTTP 方法（HTTP/1.1）"></a>告知服务器意图的 HTTP 方法（HTTP/1.1）</h4><p><img src="https://github.com/AlexBruceLu/DAPP/wiki/http8.webp" alt="HTTP 方法"></p><h4 id="持久连接"><a href="#持久连接" class="headerlink" title="持久连接"></a>持久连接</h4><p>HTTP 协议的初始版本中，每进行一个 HTTP 通信都要断开一次 TCP 连接。比如使用浏览器浏览一个包含多张图片的 HTML 页面时，在发送请求访问 HTML 页面资源的同时，也会请求该 HTML 页面里包含的其他资源。因此，每次的请求都会造成无畏的 TCP 连接建立和断开，增加通信量的开销。<br> 为了解决上述 TCP 连接的问题，HTTP/1.1 和部分 HTTP/1.0 想出了持久连接的方法。<strong>其特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。旨在建立一次 TCP 连接后进行多次请求和响应的交互。</strong>在 HTTP/1.1 中，所有的连接默认都是持久连接。</p><h4 id="管线化"><a href="#管线化" class="headerlink" title="管线化"></a>管线化</h4><p>持久连接使得多数请求以管线化方式发送成为可能。以前发送请求后需等待并接收到响应，才能发送下一个请求。管线化技术出现后，不用等待亦可发送下一个请求。这样就能做到同时并行发送多个请求，而不需要一个接一个地等待响应了。<br> 比如，当请求一个包含多张图片的 HTML 页面时，与挨个连接相比，用持久连接可以让请求更快结束。而管线化技术要比持久连接速度更快。请求数越多，时间差就越明显。</p><h3 id="HTTP-协议报文结构"><a href="#HTTP-协议报文结构" class="headerlink" title="HTTP 协议报文结构"></a>HTTP 协议报文结构</h3><h4 id="HTTP-报文"><a href="#HTTP-报文" class="headerlink" title="HTTP 报文"></a>HTTP 报文</h4><p>用于 HTTP 协议交互的信息被称为 HTTP 报文。请求端（客户端）的 HTTP 报文叫做请求报文；响应端（服务器端）的叫做响应报文。HTTP 报文本身是由多行（用 CR+LF 作换行符）数据构成的字符串文本。</p><h4 id="HTTP-报文结构"><a href="#HTTP-报文结构" class="headerlink" title="HTTP 报文结构"></a>HTTP 报文结构</h4><p>HTTP 报文大致可分为报文首部和报文主体两部分。两者由最初出现的空行（CR+LF）来划分。通常，并不一定有报文主体。如下：</p><p><img src="https://github.com/AlexBruceLu/DAPP/wiki/http.webp" alt="HTTP 报文结构"></p><p><img src="https://github.com/AlexBruceLu/DAPP/wiki/http901.webp" alt="HTTP 报文结构"></p><h5 id="请求报文结构"><a href="#请求报文结构" class="headerlink" title="请求报文结构"></a>请求报文结构</h5><p><img src="https://github.com/AlexBruceLu/DAPP/wiki/http10.webp" alt="请求报文结构"></p><p>请求报文的首部内容由以下数据组成：</p><ul><li><strong>请求行</strong> —— 包含用于请求的方法、请求 URI 和 HTTP 版本。</li><li><strong>首部字段</strong> —— 包含表示请求的各种条件和属性的各类首部。（通用首部、请求首部、实体首部以及RFC里未定义的首部如 Cookie 等）</li></ul><p>请求报文的示例，如下：</p><p><img src="https://github.com/AlexBruceLu/DAPP/wiki/http11.webp" alt="请求报文示例"></p><h5 id="响应报文结构"><a href="#响应报文结构" class="headerlink" title="响应报文结构"></a>响应报文结构</h5><p><img src="https://github.com/AlexBruceLu/DAPP/wiki/http12.webp" alt="响应报文结构"></p><p>响应报文的首部内容由以下数据组成：</p><ul><li><strong>状态行</strong> —— 包含表明响应结果的状态码、原因短语和 HTTP 版本。</li><li><strong>首部字段</strong> —— 包含表示请求的各种条件和属性的各类首部。（通用首部、响应首部、实体首部以及RFC里未定义的首部如 Cookie 等）</li></ul><p>响应报文的示例，如下：</p><p><img src="https://github.com/AlexBruceLu/DAPP/wiki/http13.webp" alt="响应报文结构"></p><h3 id="HTTP-报文首部之请求行、状态行"><a href="#HTTP-报文首部之请求行、状态行" class="headerlink" title="HTTP 报文首部之请求行、状态行"></a>HTTP 报文首部之请求行、状态行</h3><h4 id="请求行"><a href="#请求行" class="headerlink" title="请求行"></a>请求行</h4><p>举个栗子，下面是一个 HTTP 请求的报文：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET  /index.htm  HTTP/1.1</span><br><span class="line">Host: sample.com</span><br></pre></td></tr></table></figure><p>其中，下面的这行就是请求行，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET  /index.htm  HTTP/1.1</span><br></pre></td></tr></table></figure><ul><li>开头的 GET 表示请求访问服务器的类型，称为方法；</li><li>随后的字符串  <code>/index.htm</code> 指明了请求访问的资源对象，也叫做请求 URI；</li><li>最后的 <code>HTTP/1.1</code>，即 HTTP 的版本号，用来提示客户端使用的 HTTP 协议功能。</li></ul><p>综合来看，大意是请求访问某台 HTTP 服务器上的 <code>/index.htm</code> 页面资源。</p><h4 id="状态行"><a href="#状态行" class="headerlink" title="状态行"></a>状态行</h4><p>同样举个栗子，下面是一个 HTTP 响应的报文：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1  200  OK</span><br><span class="line">Date: Mon, 10 Jul 2017 15:50:06 GMT</span><br><span class="line">Content-Length: 256</span><br><span class="line">Content-Type: text/html</span><br><span class="line">    </span><br><span class="line">&lt;html&gt;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>其中，下面的这行就是状态行，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1  200  OK</span><br></pre></td></tr></table></figure><ul><li>开头的 <code>HTTP/1.1</code> 表示服务器对应的 HTTP 版本；</li><li>紧挨着的 <code>200 OK</code> 表示请求的处理结果的状态码和原因短语。</li></ul><h3 id="HTTP-报文首部之首部字段（重点分析）"><a href="#HTTP-报文首部之首部字段（重点分析）" class="headerlink" title="HTTP 报文首部之首部字段（重点分析）"></a>HTTP 报文首部之首部字段（重点分析）</h3><h4 id="首部字段概述"><a href="#首部字段概述" class="headerlink" title="首部字段概述"></a>首部字段概述</h4><p>先来回顾一下首部字段在报文的位置，HTTP 报文包含报文首部和报文主体，报文首部包含请求行（或状态行）和首部字段。<br> 在报文众多的字段当中，HTTP 首部字段包含的信息最为丰富。首部字段同时存在于请求和响应报文内，并涵盖 HTTP 报文相关的内容信息。使用首部字段是为了给客服端和服务器端提供报文主体大小、所使用的语言、认证信息等内容。</p><h4 id="首部字段结构"><a href="#首部字段结构" class="headerlink" title="首部字段结构"></a>首部字段结构</h4><ul><li>HTTP 首部字段是由首部字段名和字段值构成的，中间用冒号“：”分隔。</li><li>另外，字段值对应单个 HTTP 首部字段可以有多个值。</li><li>当 HTTP 报文首部中出现了两个或以上具有相同首部字段名的首部字段时，这种情况在规范内尚未明确，根据浏览器内部处理逻辑的不同，优先处理的顺序可能不同，结果可能并不一致。</li></ul><table><thead><tr><th>首部字段名</th><th>冒号</th><th>字段值</th></tr></thead><tbody><tr><td>Content-Type</td><td>：</td><td>text/html</td></tr><tr><td>Keep-Alive</td><td>：</td><td>timeout=30, max=120</td></tr></tbody></table><h4 id="首部字段类型"><a href="#首部字段类型" class="headerlink" title="首部字段类型"></a>首部字段类型</h4><p>首部字段根据实际用途被分为以下4种类型：</p><table><thead><tr><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>通用首部字段</td><td>请求报文和响应报文两方都会使用的首部</td></tr><tr><td>请求首部字段</td><td>从客户端向服务器端发送请求报文时使用的首部。补充了请求的附加内容、客户端信息、响应内容相关优先级等信息</td></tr><tr><td>响应首部字段</td><td>从服务器端向客户端返回响应报文时使用的首部。补充了响应的附加内容，也会要求客户端附加额外的内容信息。</td></tr><tr><td>实体首部字段</td><td>针对请求报文和响应报文的实体部分使用的首部。补充了资源内容更新时间等与实体有关的的信息。</td></tr></tbody></table><h4 id="通用首部字段（HTTP-1-1）"><a href="#通用首部字段（HTTP-1-1）" class="headerlink" title="通用首部字段（HTTP/1.1）"></a>通用首部字段（HTTP/1.1）</h4><table><thead><tr><th>首部字段名</th><th>说明</th></tr></thead><tbody><tr><td>Cache-Control</td><td>控制缓存的行为</td></tr><tr><td>Connection</td><td>逐挑首部、连接的管理</td></tr><tr><td>Date</td><td>创建报文的日期时间</td></tr><tr><td>Pragma</td><td>报文指令</td></tr><tr><td>Trailer</td><td>报文末端的首部一览</td></tr><tr><td>Transfer-Encoding</td><td>指定报文主体的传输编码方式</td></tr><tr><td>Upgrade</td><td>升级为其他协议</td></tr><tr><td>Via</td><td>代理服务器的相关信息</td></tr><tr><td>Warning</td><td>错误通知</td></tr></tbody></table><h5 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h5><p>通过指定首部字段 Cache-Control 的指令，就能操作缓存的工作机制。</p><h5 id="可用的指令一览"><a href="#可用的指令一览" class="headerlink" title="可用的指令一览"></a>可用的指令一览</h5><p>可用的指令按请求和响应分类如下：</p><h5 id="缓存请求指令"><a href="#缓存请求指令" class="headerlink" title="缓存请求指令"></a><strong>缓存请求指令</strong></h5><table><thead><tr><th>指令</th><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>no-cache</td><td>无</td><td>强制向服务器再次验证</td></tr><tr><td>no-store</td><td>无</td><td>不缓存请求或响应的任何内容</td></tr><tr><td>max-age = [秒]</td><td>必需</td><td>响应的最大Age值</td></tr><tr><td>max-stale( =[秒])</td><td>可省略</td><td>接收已过期的响应</td></tr><tr><td>min-fresh = [秒]</td><td>必需</td><td>期望在指定时间内的响应仍有效</td></tr><tr><td>no-transform</td><td>无</td><td>代理不可更改媒体类型</td></tr><tr><td>only-if-cached</td><td>无</td><td>从缓存获取资源</td></tr><tr><td>cache-extension</td><td>-</td><td>新指令标记（token）</td></tr></tbody></table><h5 id="缓存响应指令"><a href="#缓存响应指令" class="headerlink" title="缓存响应指令"></a><strong>缓存响应指令</strong></h5><table><thead><tr><th>指令</th><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>public</td><td>无</td><td>可向任意方提供响应的缓存</td></tr><tr><td>private</td><td>可省略</td><td>仅向特定用户返回响应</td></tr><tr><td>no-cache</td><td>可省略</td><td>缓存前必须先确认其有效性</td></tr><tr><td>no-store</td><td>无</td><td>不缓存请求或响应的任何内容</td></tr><tr><td>no-transform</td><td>无</td><td>代理不可更改媒体类型</td></tr><tr><td>must-revalidate</td><td>无</td><td>可缓存但必须再向源服务器进行确认</td></tr><tr><td>proxy-revalidate</td><td>无</td><td>要求中间缓存服务器对缓存的响应有效性再进行确认</td></tr><tr><td>max-age = [秒]</td><td>必需</td><td>响应的最大Age值</td></tr><tr><td>s-maxage = [秒]</td><td>必需</td><td>公共缓存服务器响应的最大Age值</td></tr><tr><td>cache-extension</td><td>-</td><td>新指令标记（token）</td></tr></tbody></table><h5 id="表示能否缓存的指令"><a href="#表示能否缓存的指令" class="headerlink" title="表示能否缓存的指令"></a><strong>表示能否缓存的指令</strong></h5><p><strong>public 指令</strong><br> <code>Cache-Control: public</code><br> 当指定使用 public 指令时，则明确表明其他用户也可利用缓存。</p><p><strong>private 指令</strong><br> <code>Cache-Control: private</code><br> 当指定 private 指令后，响应只以特定的用户作为对象，这与 public 指令的行为相反。缓存服务器会对该特定用户提供资源缓存的服务，对于其他用户发送过来的请求，代理服务器则不会返回缓存。</p><p><strong>no-cache 指令</strong><br> <code>Cache-Control: no-cache</code></p><ul><li>使用 no-cache 指令是为了防止从缓存中返回过期的资源。</li><li>客户端发送的请求中如果包含 no-cache 指令，则表示客户端将不会接收缓存过的响应。于是，“中间”的缓存服务器必须把客户端请求转发给源服务器。</li><li>如果服务器中返回的响应包含 no-cache 指令，那么缓存服务器不能对资源进行缓存。源服务器以后也将不再对缓存服务器请求中提出的资源有效性进行确认，且禁止其对响应资源进行缓存操作。</li></ul><p><code>Cache-Control: no-cache=Location</code><br> 由服务器返回的响应中，若报文首部字段 Cache-Control 中对 no-cache 字段名具体指定参数值，那么客户端在接收到这个被指定参数值的首部字段对应的响应报文后，就不能使用缓存。换言之，无参数值的首部字段可以使用缓存。只能在响应指令中指定该参数。</p><p><strong>no-store 指令</strong><br> <code>Cache-Control: no-store</code><br> 当使用 no-store 指令时，暗示请求（和对应的响应）或响应中包含机密信息。因此，该指令规定缓存不能在本地存储请求或响应的任一部分。<br> 注意：no-cache 指令代表不缓存过期的指令，缓存会向源服务器进行有效期确认后处理资源；no-store 指令才是真正的不进行缓存。</p><h6 id="指定缓存期限和认证的指令"><a href="#指定缓存期限和认证的指令" class="headerlink" title="指定缓存期限和认证的指令"></a>指定缓存期限和认证的指令</h6><p><strong>s-maxage 指令</strong><br> <code>Cache-Control: s-maxage=604800（单位：秒）</code></p><ul><li>s-maxage 指令的功能和 max-age 指令的相同，它们的不同点是 s-maxage 指令只适用于供多位用户使用的公共缓存服务器（一般指代理）。也就是说，对于向同一用户重复返回响应的服务器来说，这个指令没有任何作用。</li><li>另外，当使用 s-maxage 指令后，则直接忽略对 Expires 首部字段及 max-age 指令的处理。</li></ul><p><strong>max-age 指令</strong><br> <code>Cache-Control: max-age=604800（单位：秒）</code></p><ul><li>当客户端发送的请求中包含 max-age 指令时，如果判定缓存资源的缓存时间数值比指定的时间更小，那么客户端就接收缓存的资源。另外，当指定 max-age 的值为0，那么缓存服务器通常需要将请求转发给源服务器。</li><li>当服务器返回的响应中包含 max-age 指令时，缓存服务器将不对资源的有效性再作确认，而 max-age 数值代表资源保存为缓存的最长时间。</li><li>应用 HTTP/1.1 版本的缓存服务器遇到同时存在 Expires 首部字段的情况时，会优先处理 max-age 指令，并忽略掉 Expires 首部字段；而 HTTP/1.0 版本的缓存服务器则相反。</li></ul><p><strong>min-fresh 指令</strong><br> <code>Cache-Control: min-fresh=60（单位：秒）</code><br> min-fresh 指令要求缓存服务器返回至少还未过指定时间的缓存资源。</p><p><strong>max-stale 指令</strong><br> <code>Cache-Control: max-stale=3600（单位：秒）</code></p><ul><li>使用 max-stale 可指示缓存资源，即使过期也照常接收。</li><li>如果指令未指定参数值，那么无论经过多久，客户端都会接收响应；如果指定了具体参数值，那么即使过期，只要仍处于 max-stale 指定的时间内，仍旧会被客户端接收。</li></ul><p><strong>only-if-cached 指令</strong><br> <code>Cache-Control: only-if-cached</code><br> 表示客户端仅在缓存服务器本地缓存目标资源的情况下才会要求其返回。换言之，该指令要求缓存服务器不重新加载响应，也不会再次确认资源的有效性。</p><p><strong>must-revalidate 指令</strong><br> <code>Cache-Control: must-revalidate</code><br> 使用 must-revalidate 指令，代理会向源服务器再次验证即将返回的响应缓存目前是否仍有效。另外，使用 must-revalidate 指令会忽略请求的 max-stale 指令。</p><p><strong>proxy-revalidate 指令</strong><br> <code>Cache-Control: proxy-revalidate</code><br> proxy-revalidate 指令要求所有的缓存服务器在接收到客户端带有该指令的请求返回响应之前，必须再次验证缓存的有效性。</p><p><strong>no-transform 指令</strong><br> <code>Cache-Control: no-transform</code><br> 使用 no-transform 指令规定无论是在请求还是响应中，缓存都不能改变实体主体的媒体类型。这样做可防止缓存或代理压缩图片等类似操作。</p><h6 id="Cache-Control-扩展"><a href="#Cache-Control-扩展" class="headerlink" title="Cache-Control 扩展"></a>Cache-Control 扩展</h6><p><code>Cache-Control: private, community=&quot;UCI&quot;</code><br> 通过 cache-extension 标记（token），可以扩展 Cache-Control 首部字段内的指令。上述 community 指令即扩展的指令，如果缓存服务器不能理解这个新指令，就会直接忽略掉。</p><h5 id="Connection"><a href="#Connection" class="headerlink" title="Connection"></a>Connection</h5><p>Connection 首部字段具备以下两个作用：</p><p><strong>控制不再转发的首部字段</strong><br> <code>Connection: Upgrade</code><br> 在客户端发送请求和服务器返回响应中，使用 Connection 首部字段，可控制不再转发给代理的首部字段，即删除后再转发（即Hop-by-hop首部）。</p><p><strong>管理持久连接</strong><br> <code>Connection: close</code><br> HTTP/1.1 版本的默认连接都是持久连接。当服务器端想明确断开连接时，则指定 Connection 首部字段的值为 close。<br> <code>Connection: Keep-Alive</code><br> HTTP/1.1 之前的 HTTP 版本的默认连接都是非持久连接。为此，如果想在旧版本的 HTTP 协议上维持持续连接，则需要指定 Connection 首部字段的值为 Keep-Alive。</p><h5 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h5><p>表明创建 HTTP 报文的日期和时间。<br> <code>Date: Mon, 10 Jul 2017 15:50:06 GMT</code><br> HTTP/1.1 协议使用在 RFC1123 中规定的日期时间的格式。</p><h5 id="Pragma"><a href="#Pragma" class="headerlink" title="Pragma"></a>Pragma</h5><p>Pragma 首部字段是 HTTP/1.1 版本之前的历史遗留字段，仅作为与 HTTP/1.0 的向后兼容而定义。<br> <code>Pragma: no-cache</code></p><ul><li>该首部字段属于通用首部字段，但只用在客户端发送的请求中，要求所有的中间服务器不返回缓存的资源。</li><li>所有的中间服务器如果都能以 HTTP/1.1 为基准，那直接采用 <code>Cache-Control: no-cache</code> 指定缓存的处理方式最为理想。但是要整体掌握所有中间服务器使用的 HTTP 协议版本却是不现实的，所以，发送的请求会同时包含下面两个首部字段：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: no-cache</span><br><span class="line">Pragma: no-cache</span><br></pre></td></tr></table></figure><h5 id="Trailer"><a href="#Trailer" class="headerlink" title="Trailer"></a>Trailer</h5><p><code>Trailer: Expires</code><br> 首部字段 Trailer 会事先说明在报文主体后记录了哪些首部字段。可应用在 HTTP/1.1 版本分块传输编码时。</p><h5 id="Transfer-Encoding"><a href="#Transfer-Encoding" class="headerlink" title="Transfer-Encoding"></a>Transfer-Encoding</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Transfer-Encoding: chunked</span><br></pre></td></tr></table></figure><ul><li>规定了传输报文主体时采用的编码方式。</li><li>HTTP/1.1 的传输编码方式仅对分块传输编码有效。</li></ul><h5 id="Upgrade"><a href="#Upgrade" class="headerlink" title="Upgrade"></a>Upgrade</h5><p><code>Upgrade: TSL/1.0</code><br> 用于检测 HTTP 协议及其他协议是否可使用更高的版本进行通信，其参数值可以用来指定一个完全不同的通信协议。</p><h5 id="Via"><a href="#Via" class="headerlink" title="Via"></a>Via</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Via: 1.1 a1.sample.com(Squid/2.7)</span><br></pre></td></tr></table></figure><ul><li>为了追踪客户端和服务器端之间的请求和响应报文的传输路径。</li><li>报文经过代理或网关时，会现在首部字段 Via 中附加该服务器的信息，然后再进行转发。</li><li>首部字段 Via 不仅用于追踪报文的转发，还可避免请求回环的发生。</li></ul><h5 id="Warning"><a href="#Warning" class="headerlink" title="Warning"></a>Warning</h5><p>该首部字段通常会告知用户一些与缓存相关的问题的警告。<br> Warning 首部字段的格式如下：<br> <code>Warning：[警告码][警告的主机:端口号] &quot;[警告内容]&quot;([日期时间])</code><br> 最后的日期时间可省略。<br> HTTP/1.1 中定义了7种警告，警告码对应的警告内容仅推荐参考，另外，警告码具备扩展性，今后有可能追加新的警告码。</p><table><thead><tr><th>警告码</th><th>警告内容</th><th>说明</th></tr></thead><tbody><tr><td>110</td><td>Response is stale(响应已过期)</td><td>代理返回已过期的资源</td></tr><tr><td>111</td><td>Revalidation failed(再验证失败)</td><td>代理再验证资源有效性时失败（服务器无法到达等原因）</td></tr><tr><td>112</td><td>Disconnection operation(断开连接操作)</td><td>代理与互联网连接被故意切断</td></tr><tr><td>113</td><td>Heuristic expiration(试探性过期)</td><td>响应的试用期超过24小时(有效缓存的设定时间大于24小时的情况下)</td></tr><tr><td>199</td><td>Miscellaneous warning(杂项警告)</td><td>任意的警告内容</td></tr><tr><td>214</td><td>Transformation applied(使用了转换)</td><td>代理对内容编码或媒体类型等执行了某些处理时</td></tr><tr><td>299</td><td>Miscellaneous persistent warning(持久杂项警告)</td><td>任意的警告内容</td></tr></tbody></table><h4 id="请求首部字段（HTTP-1-1）"><a href="#请求首部字段（HTTP-1-1）" class="headerlink" title="请求首部字段（HTTP/1.1）"></a>请求首部字段（HTTP/1.1）</h4><table><thead><tr><th>首部字段名</th><th>说明</th></tr></thead><tbody><tr><td>Accept</td><td>用户代理可处理的媒体类型</td></tr><tr><td>Accept-Charset</td><td>优先的字符集</td></tr><tr><td>Accept-Encoding</td><td>优先的内容编码</td></tr><tr><td>Accept-Language</td><td>优先的语言（自然语言）</td></tr><tr><td>Authorization</td><td>Web认证信息</td></tr><tr><td>Expect</td><td>期待服务器的特定行为</td></tr><tr><td>From</td><td>用户的电子邮箱地址</td></tr><tr><td>Host</td><td>请求资源所在服务器</td></tr><tr><td>If-Match</td><td>比较实体标记（ETag）</td></tr><tr><td>If-Modified-Since</td><td>比较资源的更新时间</td></tr><tr><td>If-None-Match</td><td>比较实体标记（与 If-Macth 相反）</td></tr><tr><td>If-Range</td><td>资源未更新时发送实体 Byte 的范围请求</td></tr><tr><td>If-Unmodified-Since</td><td>比较资源的更新时间(与 If-Modified-Since 相反)</td></tr><tr><td>Max-Forwards</td><td>最大传输逐跳数</td></tr><tr><td>Proxy-Authorization</td><td>代理服务器要求客户端的认证信息</td></tr><tr><td>Range</td><td>实体的字节范围请求</td></tr><tr><td>Referer</td><td>对请求中 URI 的原始获取方</td></tr><tr><td>TE</td><td>传输编码的优先级</td></tr><tr><td>User-Agent</td><td>HTTP 客户端程序的信息</td></tr></tbody></table><h5 id="Accept"><a href="#Accept" class="headerlink" title="Accept"></a>Accept</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Accept: text/html, application/xhtml+xml, application/xml; q=0.5</span><br></pre></td></tr></table></figure><ul><li>Accept 首部字段可通知服务器，用户代理能够处理的媒体类型及媒体类型的相对优先级。可使用 type/subtype 这种形式，一次指定多种媒体类型。</li><li>若想要给显示的媒体类型增加优先级，则使用 <code>q=[数值]</code> 来表示权重值，用分号（;）进行分隔。权重值的范围 0~1（可精确到小数点后三位），且 1 为最大值。不指定权重值时，默认为 1。</li></ul><h5 id="Accept-Charset"><a href="#Accept-Charset" class="headerlink" title="Accept-Charset"></a>Accept-Charset</h5><p><code>Accept-Charset: iso-8859-5, unicode-1-1; q=0.8</code><br> Accept-Charset 首部字段可用来通知服务器用户代理支持的字符集及字符集的相对优先顺序。另外，可一次性指定多种字符集。同样使用 <code>q=[数值]</code> 来表示相对优先级。</p><h5 id="Accept-Encoding"><a href="#Accept-Encoding" class="headerlink" title="Accept-Encoding"></a>Accept-Encoding</h5><p><code>Accept-Encoding: gzip, deflate</code><br> Accept-Encoding 首部字段用来告知服务器用户代理支持的内容编码及内容编码的优先顺序，并可一次性指定多种内容编码。同样使用 <code>q=[数值]</code> 来表示相对优先级。也可使用星号（*）作为通配符，指定任意的编码格式。</p><h5 id="Accept-Language"><a href="#Accept-Language" class="headerlink" title="Accept-Language"></a>Accept-Language</h5><p><code>Accept-Lanuage: zh-cn,zh;q=0.7,en=us,en;q=0.3</code><br> 告知服务器用户代理能够处理的自然语言集（指中文或英文等），以及自然语言集的相对优先级，可一次性指定多种自然语言集。同样使用 <code>q=[数值]</code> 来表示相对优先级。</p><h5 id="Authorization"><a href="#Authorization" class="headerlink" title="Authorization"></a>Authorization</h5><p><code>Authorization: Basic ldfKDHKfkDdasSAEdasd==</code><br> 告知服务器用户代理的认证信息（证书值）。通常，想要通过服务器认证的用户代理会在接收到返回的 401 状态码响应后，把首部字段 Authorization 加入请求中。共用缓存在接收到含有 Authorization 首部字段的请求时的操作处理会略有差异。</p><h5 id="Expect"><a href="#Expect" class="headerlink" title="Expect"></a>Expect</h5><p><code>Expect: 100-continue</code><br> 告知服务器客户端期望出现的某种特定行为。</p><h5 id="5-7-From"><a href="#5-7-From" class="headerlink" title="5.7 From"></a>5.7 From</h5><p><code>From: Deeson_Woo@163.com</code><br> 告知服务器使用用户代理的电子邮件地址。</p><h5 id="Host"><a href="#Host" class="headerlink" title="Host"></a>Host</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Host: www.jianshu.com</span><br></pre></td></tr></table></figure><ul><li>告知服务器，请求的资源所处的互联网主机和端口号。</li><li><strong>Host 首部字段是 HTTP/1.1 规范内唯一一个必须被包含在请求内的首部字段。</strong></li><li>若服务器未设定主机名，那直接发送一个空值即可  <code>Host:</code> 。</li></ul><h5 id="If-Match"><a href="#If-Match" class="headerlink" title="If-Match"></a>If-Match</h5><p>形如 If-xxx 这种样式的请求首部字段，都可称为条件请求。服务器接收到附带条件的请求后，只有判断指定条件为真时，才会执行请求。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">If-Match: &quot;123456&quot;</span><br></pre></td></tr></table></figure><ul><li>首部字段 If-Match，属附带条件之一，它会告知服务器匹配资源所用的实体标记（ETag）值。这时的服务器无法使用弱 ETag 值。</li><li>服务器会比对 If-Match 的字段值和资源的 ETag 值，仅当两者一致时，才会执行请求。反之，则返回状态码 <code>412 Precondition Failed</code> 的响应。</li><li>还可以使用星号（*）指定 If-Match 的字段值。针对这种情况，服务器将会忽略 ETag 的值，只要资源存在就处理请求。</li></ul><h5 id="If-Modified-Since"><a href="#If-Modified-Since" class="headerlink" title="If-Modified-Since"></a>If-Modified-Since</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">If-Modified-Since: Mon, 10 Jul 2017 15:50:06 GMT</span><br></pre></td></tr></table></figure><ul><li>首部字段 If-Modified-Since，属附带条件之一，用于确认代理或客户端拥有的本地资源的有效性。</li><li>它会告知服务器若 If-Modified-Since 字段值早于资源的更新时间，则希望能处理该请求。而在指定 If-Modified-Since 字段值的日期时间之后，如果请求的资源都没有过更新，则返回状态码 <code>304 Not Modified</code> 的响应。</li></ul><h5 id="If-None-Match"><a href="#If-None-Match" class="headerlink" title="If-None-Match"></a>If-None-Match</h5><p><code>If-None-Match: &quot;123456&quot;</code><br> 首部字段 If-None-Match 属于附带条件之一。它和首部字段 If-Match 作用相反。用于指定 If-None-Match 字段值的实体标记（ETag）值与请求资源的 ETag 不一致时，它就告知服务器处理该请求。</p><h5 id="If-Range"><a href="#If-Range" class="headerlink" title="If-Range"></a>If-Range</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">If-Range: &quot;123456&quot;</span><br></pre></td></tr></table></figure><ul><li>首部字段 If-Range 属于附带条件之一。它告知服务器若指定的 If-Range 字段值（ETag 值或者时间）和请求资源的 ETag 值或时间相一致时，则作为范围请求处理。反之，则返回全体资源。</li><li>下面我们思考一下不使用首部字段 If-Range 发送请求的情况。服务器端的资源如果更新，那客户端持有资源中的一部分也会随之无效，当然，范围请求作为前提是无效的。这时，服务器会暂且以状态码 <code>412 Precondition Failed</code> 作为响应返回，其目的是催促客户端再次发送请求。这样一来，与使用首部字段 If-Range 比起来，就需要花费两倍的功夫。</li></ul><h5 id="If-Unmodified-Since"><a href="#If-Unmodified-Since" class="headerlink" title="If-Unmodified-Since"></a>If-Unmodified-Since</h5><p><code>If-Unmodified-Since: Mon, 10 Jul 2017 15:50:06 GMT</code><br> 首部字段 If-Unmodified-Since 和首部字段 If-Modified-Since 的作用相反。它的作用的是告知服务器，指定的请求资源只有在字段值内指定的日期时间之后，未发生更新的情况下，才能处理请求。如果在指定日期时间后发生了更新，则以状态码 <code>412 Precondition Failed</code> 作为响应返回。</p><h5 id="Max-Forwards"><a href="#Max-Forwards" class="headerlink" title="Max-Forwards"></a>Max-Forwards</h5><p><code>Max-Forwards: 10</code><br> 通过 TRACE 方法或 OPTIONS 方法，发送包含首部字段 Max-Forwards 的请求时，该字段以十进制整数形式指定可经过的服务器最大数目。服务器在往下一个服务器转发请求之前，Max-Forwards 的值减 1 后重新赋值。当服务器接收到 Max-Forwards 值为 0 的请求时，则不再进行转发，而是直接返回响应。</p><h5 id="Proxy-Authorization"><a href="#Proxy-Authorization" class="headerlink" title="Proxy-Authorization"></a>Proxy-Authorization</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Proxy-Authorization: Basic dGlwOjkpNLAGfFY5</span><br></pre></td></tr></table></figure><ul><li>接收到从代理服务器发来的认证质询时，客户端会发送包含首部字段 Proxy-Authorization 的请求，以告知服务器认证所需要的信息。</li><li>这个行为是与客户端和服务器之间的 HTTP 访问认证相类似的，不同之处在于，认证行为发生在客户端与代理之间。</li></ul><h5 id="Range"><a href="#Range" class="headerlink" title="Range"></a>Range</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Range: bytes=5001-10000</span><br></pre></td></tr></table></figure><ul><li>对于只需获取部分资源的范围请求，包含首部字段 Range 即可告知服务器资源的指定范围。</li><li>接收到附带 Range 首部字段请求的服务器，会在处理请求之后返回状态码为 <code>206 Partial Content</code> 的响应。无法处理该范围请求时，则会返回状态码 <code>200 OK</code> 的响应及全部资源。</li></ul><h5 id="Referer"><a href="#Referer" class="headerlink" title="Referer"></a>Referer</h5><p><code>Referer: http://www.sample.com/index.html</code><br> 首部字段 Referer 会告知服务器请求的原始资源的 URI。</p><h5 id="TE"><a href="#TE" class="headerlink" title="TE"></a>TE</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TE: gzip, deflate; q=0.5</span><br></pre></td></tr></table></figure><ul><li>首部字段 TE 会告知服务器客户端能够处理响应的传输编码方式及相对优先级。它和首部字段 Accept-Encoding 的功能很相像，但是用于传输编码。</li><li>首部字段 TE 除指定传输编码之外，还可以指定伴随 trailer 字段的分块传输编码的方式。应用后者时，只需把 trailers 赋值给该字段值。<code>TE: trailers</code> </li></ul><h5 id="User-Agent"><a href="#User-Agent" class="headerlink" title="User-Agent"></a>User-Agent</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64; rv:13.0) Gecko/20100101</span><br></pre></td></tr></table></figure><ul><li>首部字段 User-Agent 会将创建请求的浏览器和用户代理名称等信息传达给服务器。</li><li>由网络爬虫发起请求时，有可能会在字段内添加爬虫作者的电子邮件地址。此外，如果请求经过代理，那么中间也很可能被添加上代理服务器的名称。</li></ul><h4 id="响应首部字段（HTTP-1-1）"><a href="#响应首部字段（HTTP-1-1）" class="headerlink" title="响应首部字段（HTTP/1.1）"></a>响应首部字段（HTTP/1.1）</h4><table><thead><tr><th>首部字段名</th><th>说明</th></tr></thead><tbody><tr><td>Accept-Ranges</td><td>是否接受字节范围请求</td></tr><tr><td>Age</td><td>推算资源创建经过时间</td></tr><tr><td>ETag</td><td>资源的匹配信息</td></tr><tr><td>Location</td><td>令客户端重定向至指定 URI</td></tr><tr><td>Proxy-Authenticate</td><td>代理服务器对客户端的认证信息</td></tr><tr><td>Retry-After</td><td>对再次发起请求的时机要求</td></tr><tr><td>Server</td><td>HTTP 服务器的安装信息</td></tr><tr><td>Vary</td><td>代理服务器缓存的管理信息</td></tr><tr><td>WWW-Authenticate</td><td>服务器对客户端的认证信息</td></tr></tbody></table><h5 id="Accept-Ranges"><a href="#Accept-Ranges" class="headerlink" title="Accept-Ranges"></a>Accept-Ranges</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Accept-Ranges: bytes</span><br></pre></td></tr></table></figure><ul><li>首部字段 Accept-Ranges 是用来告知客户端服务器是否能处理范围请求，以指定获取服务器端某个部分的资源。</li><li>可指定的字段值有两种，可处理范围请求时指定其为 bytes，反之则指定其为 none。</li></ul><h5 id="Age"><a href="#Age" class="headerlink" title="Age"></a>Age</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Age: 1200</span><br></pre></td></tr></table></figure><ul><li>首部字段 Age 能告知客户端，源服务器在多久前创建了响应。字段值的单位为秒。</li><li>若创建该响应的服务器是缓存服务器，Age 值是指缓存后的响应再次发起认证到认证完成的时间值。代理创建响应时必须加上首部字段 Age。</li></ul><h5 id="ETag"><a href="#ETag" class="headerlink" title="ETag"></a>ETag</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ETag: &quot;usagi-1234&quot;</span><br></pre></td></tr></table></figure><ul><li>首部字段 ETag 能告知客户端实体标识。它是一种可将资源以字符串形式做唯一性标识的方式。服务器会为每份资源分配对应的 ETag 值。</li><li>另外，当资源更新时，ETag 值也需要更新。生成 ETag 值时，并没有统一的算法规则，而仅仅是由服务器来分配。</li><li>ETag 中有强 ETag 值和弱 ETag 值之分。强 ETag 值，不论实体发生多么细微的变化都会改变其值；弱 ETag 值只用于提示资源是否相同。只有资源发生了根本改变，产生差异时才会改变 ETag 值。这时，会在字段值最开始处附加 W/： <code>ETag: W/&quot;usagi-1234&quot;</code>。</li></ul><h5 id="Location"><a href="#Location" class="headerlink" title="Location"></a>Location</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Location: http://www.sample.com/sample.html</span><br></pre></td></tr></table></figure><ul><li>使用首部字段 Location 可以将响应接收方引导至某个与请求 URI 位置不同的资源。</li><li>基本上，该字段会配合 3xx ：Redirection 的响应，提供重定向的 URI。</li><li>几乎所有的浏览器在接收到包含首部字段 Location 的响应后，都会强制性地尝试对已提示的重定向资源的访问。</li></ul><h5 id="Proxy-Authenticate"><a href="#Proxy-Authenticate" class="headerlink" title="Proxy-Authenticate"></a>Proxy-Authenticate</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Proxy-Authenticate: Basic realm=&quot;Usagidesign Auth&quot;</span><br></pre></td></tr></table></figure><ul><li>首部字段 Proxy-Authenticate 会把由代理服务器所要求的认证信息发送给客户端。</li><li>它与客户端和服务器之间的 HTTP 访问认证的行为相似，不同之处在于其认证行为是在客户端与代理之间进行的。</li></ul><h5 id="Retry-After"><a href="#Retry-After" class="headerlink" title="Retry-After"></a>Retry-After</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Retry-After: 180</span><br></pre></td></tr></table></figure><ul><li>首部字段 Retry-After 告知客户端应该在多久之后再次发送请求。主要配合状态码 <code>503 Service Unavailable</code> 响应，或 3xx Redirect 响应一起使用。</li><li>字段值可以指定为具体的日期时间（Mon, 10 Jul 2017 15:50:06 GMT 等格式），也可以是创建响应后的秒数。</li></ul><h5 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h5><p><code>Server: Apache/2.2.6 (Unix) PHP/5.2.5</code><br> 首部字段 Server 告知客户端当前服务器上安装的 HTTP 服务器应用程序的信息。不单单会标出服务器上的软件应用名称，还有可能包括版本号和安装时启用的可选项。</p><h5 id="Vary"><a href="#Vary" class="headerlink" title="Vary"></a>Vary</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vary: Accept-Language</span><br></pre></td></tr></table></figure><ul><li>首部字段 Vary 可对缓存进行控制。源服务器会向代理服务器传达关于本地缓存使用方法的命令。</li><li>从代理服务器接收到源服务器返回包含 Vary 指定项的响应之后，若再要进行缓存，仅对请求中含有相同 Vary 指定首部字段的请求返回缓存。即使对相同资源发起请求，但由于 Vary 指定的首部字段不相同，因此必须要从源服务器重新获取资源。</li></ul><h5 id="WWW-Authenticate"><a href="#WWW-Authenticate" class="headerlink" title="WWW-Authenticate"></a>WWW-Authenticate</h5><p><code>WWW-Authenticate: Basic realm=&quot;Usagidesign Auth&quot;</code><br> 首部字段 WWW-Authenticate 用于 HTTP 访问认证。它会告知客户端适用于访问请求 URI 所指定资源的认证方案（Basic 或是 Digest）和带参数提示的质询（challenge）。</p><h4 id="实体首部字段（HTTP-1-1）"><a href="#实体首部字段（HTTP-1-1）" class="headerlink" title="实体首部字段（HTTP/1.1）"></a>实体首部字段（HTTP/1.1）</h4><table><thead><tr><th>首部字段名</th><th>说明</th></tr></thead><tbody><tr><td>Allow</td><td>资源可支持的 HTTP 方法</td></tr><tr><td>Content-Encoding</td><td>实体主体适用的编码方式</td></tr><tr><td>Content-Language</td><td>实体主体的自然语言</td></tr><tr><td>Content-Length</td><td>实体主体的大小（单位：字节）</td></tr><tr><td>Content-Location</td><td>替代对应资源的 URI</td></tr><tr><td>Content-MD5</td><td>实体主体的报文摘要</td></tr><tr><td>Content-Range</td><td>实体主体的位置范围</td></tr><tr><td>Content-Type</td><td>实体主体的媒体类型</td></tr><tr><td>Expires</td><td>实体主体过期的日期时间</td></tr><tr><td>Last-Modified</td><td>资源的最后修改日期时间</td></tr></tbody></table><h5 id="Allow"><a href="#Allow" class="headerlink" title="Allow"></a>Allow</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Allow: GET, HEAD</span><br></pre></td></tr></table></figure><ul><li>首部字段 Allow 用于通知客户端能够支持 Request-URI 指定资源的所有 HTTP 方法。</li><li>当服务器接收到不支持的 HTTP 方法时，会以状态码 <code>405 Method Not Allowed</code> 作为响应返回。与此同时，还会把所有能支持的 HTTP 方法写入首部字段 Allow 后返回。</li></ul><h5 id="Content-Encoding"><a href="#Content-Encoding" class="headerlink" title="Content-Encoding"></a>Content-Encoding</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Encoding: gzip</span><br></pre></td></tr></table></figure><ul><li>首部字段 Content-Encoding 会告知客户端服务器对实体的主体部分选用的内容编码方式。内容编码是指在不丢失实体信息的前提下所进行的压缩。</li><li>主要采用这 4 种内容编码的方式（gzip、compress、deflate、identity）。</li></ul><h5 id="Content-Language"><a href="#Content-Language" class="headerlink" title="Content-Language"></a>Content-Language</h5><p><code>Content-Language: zh-CN</code><br> 首部字段 Content-Language 会告知客户端，实体主体使用的自然语言（指中文或英文等语言）。</p><h5 id="Content-Length"><a href="#Content-Length" class="headerlink" title="Content-Length"></a>Content-Length</h5><p><code>Content-Length: 15000</code><br> 首部字段 Content-Length 表明了实体主体部分的大小（单位是字节）。对实体主体进行内容编码传输时，不能再使用 Content-Length首部字段。</p><h5 id="Content-Location"><a href="#Content-Location" class="headerlink" title="Content-Location"></a>Content-Location</h5><p><code>Content-Location: http://www.sample.com/index.html</code><br> 首部字段 Content-Location 给出与报文主体部分相对应的 URI。和首部字段 Location 不同，Content-Location 表示的是报文主体返回资源对应的 URI。</p><h5 id="Content-MD5"><a href="#Content-MD5" class="headerlink" title="Content-MD5"></a>Content-MD5</h5><p><code>Content-MD5: OGFkZDUwNGVhNGY3N2MxMDIwZmQ4NTBmY2IyTY==</code><br> 首部字段 Content-MD5 是一串由 MD5 算法生成的值，其目的在于检查报文主体在传输过程中是否保持完整，以及确认传输到达。</p><h5 id="Content-Range"><a href="#Content-Range" class="headerlink" title="Content-Range"></a>Content-Range</h5><p><code>Content-Range: bytes 5001-10000/10000</code><br> 针对范围请求，返回响应时使用的首部字段 Content-Range，能告知客户端作为响应返回的实体的哪个部分符合范围请求。字段值以字节为单位，表示当前发送部分及整个实体大小。</p><h5 id="Content-Type"><a href="#Content-Type" class="headerlink" title="Content-Type"></a>Content-Type</h5><p><code>Content-Type: text/html; charset=UTF-8</code><br> 首部字段 Content-Type 说明了实体主体内对象的媒体类型。和首部字段 Accept 一样，字段值用 type/subtype 形式赋值。参数 charset 使用 iso-8859-1 或 euc-jp 等字符集进行赋值。</p><h5 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Expires: Mon, 10 Jul 2017 15:50:06 GMT</span><br></pre></td></tr></table></figure><ul><li>首部字段 Expires 会将资源失效的日期告知客户端。</li><li>缓存服务器在接收到含有首部字段 Expires 的响应后，会以缓存来应答请求，在 Expires 字段值指定的时间之前，响应的副本会一直被保存。当超过指定的时间后，缓存服务器在请求发送过来时，会转向源服务器请求资源。</li><li>源服务器不希望缓存服务器对资源缓存时，最好在 Expires 字段内写入与首部字段 Date 相同的时间值。</li></ul><h5 id="Last-Modified"><a href="#Last-Modified" class="headerlink" title="Last-Modified"></a>Last-Modified</h5><p><code>Last-Modified: Mon, 10 Jul 2017 15:50:06 GMT</code><br> 首部字段 Last-Modified 指明资源最终修改的时间。一般来说，这个值就是 Request-URI 指定资源被修改的时间。但类似使用 CGI 脚本进行动态数据处理时，该值有可能会变成数据最终修改时的时间。</p><h4 id="为-Cookie-服务的首部字段"><a href="#为-Cookie-服务的首部字段" class="headerlink" title="为 Cookie 服务的首部字段"></a>为 Cookie 服务的首部字段</h4><table><thead><tr><th>首部字段名</th><th>说明</th><th>首部类型</th></tr></thead><tbody><tr><td>Set-Cookie</td><td>开始状态管理所使用的 Cookie 信息</td><td>响应首部字段</td></tr><tr><td>Cookie</td><td>服务器接收到的 Cookie 信息</td><td>请求首部字段</td></tr></tbody></table><h5 id="Set-Cookie"><a href="#Set-Cookie" class="headerlink" title="Set-Cookie"></a>Set-Cookie</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-Cookie: status=enable; expires=Mon, 10 Jul 2017 15:50:06 GMT; path=/;</span><br></pre></td></tr></table></figure><p>下面的表格列举了 Set-Cookie 的字段值。</p><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>NAME=VALUE</td><td>赋予 Cookie 的名称和其值（必需项）</td></tr><tr><td>expires=DATE</td><td>Cookie 的有效期（若不明确指定则默认为浏览器关闭前为止）</td></tr><tr><td>path=PATH</td><td>将服务器上的文件目录作为Cookie的适用对象（若不指定则默认为文档所在的文件目录）</td></tr><tr><td>domain=域名</td><td>作为 Cookie 适用对象的域名 （若不指定则默认为创建 Cookie的服务器的域名）</td></tr><tr><td>Secure</td><td>仅在 HTTPS 安全通信时才会发送 Cookie</td></tr><tr><td>HttpOnly</td><td>加以限制，使 Cookie 不能被 JavaScript 脚本访问</td></tr></tbody></table><h6 id="expires-属性"><a href="#expires-属性" class="headerlink" title="expires 属性"></a>expires 属性</h6><ul><li>Cookie 的 expires 属性指定浏览器可发送 Cookie 的有效期。</li><li>当省略 expires 属性时，其有效期仅限于维持浏览器会话（Session）时间段内。这通常限于浏览器应用程序被关闭之前。</li><li>另外，一旦 Cookie 从服务器端发送至客户端，服务器端就不存在可以显式删除 Cookie 的方法。但可通过覆盖已过期的 Cookie，实现对客户端 Cookie 的实质性删除操作。</li></ul><h6 id="path-属性"><a href="#path-属性" class="headerlink" title="path 属性"></a>path 属性</h6><p>Cookie 的 path 属性可用于限制指定 Cookie 的发送范围的文件目录。</p><h6 id="domain-属性"><a href="#domain-属性" class="headerlink" title="domain 属性"></a>domain 属性</h6><ul><li>通过 Cookie 的 domain 属性指定的域名可做到与结尾匹配一致。比如，当指定 <a href="https://link.jianshu.com?t=http://example.com" target="_blank" rel="noopener">example.com</a> 后，除<a href="https://link.jianshu.com?t=http://example.com" target="_blank" rel="noopener">example.com</a> 以外，<a href="https://link.jianshu.com?t=http://www.example.com" target="_blank" rel="noopener">www.example.com</a> 或 <a href="https://link.jianshu.com?t=http://www2.example.com" target="_blank" rel="noopener">www2.example.com</a> 等都可以发送 Cookie。</li><li>因此，除了针对具体指定的多个域名发送 Cookie 之 外，不指定 domain 属性显得更安全。</li></ul><h6 id="secure-属性"><a href="#secure-属性" class="headerlink" title="secure 属性"></a>secure 属性</h6><p>Cookie 的 secure 属性用于限制 Web 页面仅在 HTTPS 安全连接时，才可以发送 Cookie。</p><h6 id="HttpOnly-属性"><a href="#HttpOnly-属性" class="headerlink" title="HttpOnly 属性"></a>HttpOnly 属性</h6><ul><li>Cookie 的 HttpOnly 属性是 Cookie 的扩展功能，它使 JavaScript 脚本无法获得 Cookie。其主要目的为防止跨站脚本攻击（Cross-site scripting，XSS）对 Cookie 的信息窃取。</li><li>通过上述设置，通常从 Web 页面内还可以对 Cookie 进行读取操作。但使用 JavaScript 的 document.cookie 就无法读取附加 HttpOnly 属性后的 Cookie 的内容了。因此，也就无法在 XSS 中利用 JavaScript 劫持 Cookie 了。</li></ul><h5 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h5><p><code>Cookie: status=enable</code><br> 首部字段 Cookie 会告知服务器，当客户端想获得 HTTP 状态管理支持时，就会在请求中包含从服务器接收到的 Cookie。接收到多个 Cookie 时，同样可以以多个 Cookie 形式发送。</p><h4 id="其他首部字段"><a href="#其他首部字段" class="headerlink" title="其他首部字段"></a>其他首部字段</h4><p>HTTP 首部字段是可以自行扩展的。所以在 Web 服务器和浏览器的应用上，会出现各种非标准的首部字段。<br> 以下是最为常用的首部字段。</p><h5 id="X-Frame-Options"><a href="#X-Frame-Options" class="headerlink" title="X-Frame-Options"></a>X-Frame-Options</h5><p><code>X-Frame-Options: DENY</code><br> 首部字段 X-Frame-Options 属于 HTTP 响应首部，用于控制网站内容在其他 Web 网站的 Frame 标签内的显示问题。其主要目的是为了防止点击劫持（clickjacking）攻击。首部字段 X-Frame-Options 有以下两个可指定的字段值：</p><ul><li>DENY：拒绝</li><li>SAMEORIGIN：仅同源域名下的页面（Top-level-browsing-context）匹配时许可。（比如，当指定 <a href="https://link.jianshu.com?t=http://sample.com/sample.html" target="_blank" rel="noopener">http://sample.com/sample.html</a> 页面为 SAMEORIGIN 时，那么 <a href="https://link.jianshu.com?t=http://sample.com" target="_blank" rel="noopener">sample.com</a> 上所有页面的 frame 都被允许可加载该页面，而 <a href="https://link.jianshu.com?t=http://example.com" target="_blank" rel="noopener">example.com</a> 等其他域名的页面就不行了）</li></ul><h5 id="X-XSS-Protection"><a href="#X-XSS-Protection" class="headerlink" title="X-XSS-Protection"></a>X-XSS-Protection</h5><p><code>X-XSS-Protection: 1</code><br> 首部字段 X-XSS-Protection 属于 HTTP 响应首部，它是针对跨站脚本攻击（XSS）的一种对策，用于控制浏览器 XSS 防护机制的开关。首部字段 X-XSS-Protection 可指定的字段值如下:</p><ul><li>0 ：将 XSS 过滤设置成无效状态</li><li>1 ：将 XSS 过滤设置成有效状态</li></ul><h5 id="DNT"><a href="#DNT" class="headerlink" title="DNT"></a>DNT</h5><p><code>DNT: 1</code><br> 首部字段 DNT 属于 HTTP 请求首部，其中 DNT 是 Do Not Track 的简称，意为拒绝个人信息被收集，是表示拒绝被精准广告追踪的一种方法。首部字段 DNT 可指定的字段值如下：</p><ul><li>0 ：同意被追踪</li><li>1 ：拒绝被追踪</li></ul><p>由于首部字段 DNT 的功能具备有效性，所以 Web 服务器需要对 DNT做对应的支持。</p><h5 id="P3P"><a href="#P3P" class="headerlink" title="P3P"></a>P3P</h5><p><code>P3P: CP=&quot;CAO DSP LAW CURa ADMa DEVa TAIa PSAa PSDa IVAa IVDa OUR BUS IND</code><br> 首部字段 P3P 属于 HTTP 响应首部，通过利用 P3P（The Platform for Privacy Preferences，在线隐私偏好平台）技术，可以让 Web 网站上的个人隐私变成一种仅供程序可理解的形式，以达到保护用户隐私的目的。<br> 要进行 P3P 的设定，需按以下操作步骤进行：</p><ul><li>步骤 1：创建 P3P 隐私</li><li>步骤 2：创建 P3P 隐私对照文件后，保存命名在 /w3c/p3p.xml</li><li>步骤 3：从 P3P 隐私中新建 Compact policies 后，输出到 HTTP 响应中</li></ul><h3 id="HTTP-响应状态码（重点分析）"><a href="#HTTP-响应状态码（重点分析）" class="headerlink" title="HTTP 响应状态码（重点分析）"></a>HTTP 响应状态码（重点分析）</h3><h4 id="状态码概述"><a href="#状态码概述" class="headerlink" title="状态码概述"></a>状态码概述</h4><ul><li>HTTP 状态码负责表示客户端 HTTP 请求的返回结果、标记服务器端的处理是否正常、通知出现的错误等工作。</li><li>HTTP 状态码如 <code>200 OK</code> ，以 3 位数字和原因短语组成。数字中的第一位指定了响应类别，后两位无分类。</li><li>不少返回的响应状态码都是错误的，但是用户可能察觉不到这点。比如 Web 应用程序内部发生错误，状态码依然返回 <code>200 OK</code>。</li></ul><h4 id="状态码类别"><a href="#状态码类别" class="headerlink" title="状态码类别"></a>状态码类别</h4><table><thead><tr><th></th><th>类别</th><th>原因短语</th></tr></thead><tbody><tr><td>1xx</td><td>Informational(信息性状态码)</td><td>接收的请求正在处理</td></tr><tr><td>2xx</td><td>Success(成功状态码)</td><td>请求正常处理完毕</td></tr><tr><td>3xx</td><td>Redirection(重定向状态码)</td><td>需要进行附加操作以完成请求</td></tr><tr><td>4xx</td><td>Client Error(客户端错误状态码)</td><td>服务器无法处理请求</td></tr><tr><td>5xx</td><td>Server Error(服务器错误状态码)</td><td>服务器处理请求出错</td></tr></tbody></table><p>我们可以自行改变 RFC2616 中定义的状态码或者服务器端自行创建状态码，只要遵守状态码的类别定义就可以了。</p><h4 id="常用状态码解析"><a href="#常用状态码解析" class="headerlink" title="常用状态码解析"></a>常用状态码解析</h4><p>HTTP 状态码种类繁多，数量达几十种。其中最常用的有以下 14 种，一起来看看。</p><h5 id="200-OK"><a href="#200-OK" class="headerlink" title="200 OK"></a>200 OK</h5><p>表示从客户端发来的请求在服务器端被正常处理了。</p><h5 id="204-No-Content"><a href="#204-No-Content" class="headerlink" title="204 No Content"></a>204 No Content</h5><ul><li>代表服务器接收的请求已成功处理，但在返回的响应报文中不含实体的主体部分。另外，也不允许返回任何实体的主体。</li><li>一般在只需要从客户端向服务器端发送消息，而服务器端不需要向客户端发送新消息内容的情况下使用。</li></ul><h5 id="206-Partial-Content"><a href="#206-Partial-Content" class="headerlink" title="206 Partial Content"></a>206 Partial Content</h5><p>表示客户端进行了范围请求，而服务器成功执行了这部分的 GET 请求。响应报文中包含由 Content-Range 首部字段指定范围的实体内容。</p><h5 id="301-Moved-Permanently"><a href="#301-Moved-Permanently" class="headerlink" title="301 Moved Permanently"></a>301 Moved Permanently</h5><p>永久性重定向。表示请求的资源已被分配了新的 URI。以后应使用资源现在所指的 URI。也就是说，如果已经把资源对应的 URI 保存为书签了，这时应该按 Location 首部字段提示的 URI 重新保存。</p><h5 id="302-Found"><a href="#302-Found" class="headerlink" title="302 Found"></a>302 Found</h5><ul><li>临时性重定向。表示请求的资源已被分配了新的 URI，希望用户（本次）能使用新的 URI 访问。</li><li>和 <code>301 Moved Permanently</code> 状态码相似，但 <code>302 Found</code> 状态码代表资源不是被永久移动，只是临时性质的。换句话说，已移动的资源对应的 URI 将来还有可能发生改变。</li></ul><h5 id="303-See-Other"><a href="#303-See-Other" class="headerlink" title="303 See Other"></a>303 See Other</h5><ul><li>表示由于请求的资源存在着另一个 URI，应使用 GET 方法定向获取请求的资源。</li><li><code>303 See Othe</code>r 和 <code>302 Found</code> 状态码有着相同的功能，但 <code>303 See Other</code> 状态码明确表示客户端应采用 GET 方法获取资源，这点与 <code>302 Found</code> 状态码有区别。</li></ul><h5 id="304-Not-Modified"><a href="#304-Not-Modified" class="headerlink" title="304 Not Modified"></a>304 Not Modified</h5><ul><li>表示客户端发送附带条件的请求时，服务器端允许请求访问的资源，但未满足条件的情况。</li><li><code>304 Not Modified</code> 状态码返回时，不包含任何响应的主体部分。</li><li><code>304 Not Modified</code> 虽然被划分到 3xx 类别中，但和重定向没有关系。</li></ul><h5 id="307-Temporary-Redirect"><a href="#307-Temporary-Redirect" class="headerlink" title="307 Temporary Redirect"></a>307 Temporary Redirect</h5><p>临时重定向。该状态码与 <code>302 Found</code> 有着相同的含义。</p><h5 id="400-Bad-Request"><a href="#400-Bad-Request" class="headerlink" title="400 Bad Request"></a>400 Bad Request</h5><ul><li>表示请求报文中存在语法错误。当错误发生时，需修改请求的内容后再次发送请求。</li><li>另外，浏览器会像 <code>200 OK</code> 一样对待该状态码。</li></ul><h5 id="401-Unauthorized"><a href="#401-Unauthorized" class="headerlink" title="401 Unauthorized"></a>401 Unauthorized</h5><ul><li>表示发送的请求需要有通过 HTTP 认证（BASIC 认证、DIGEST 认证）的认证信息。</li><li>另外，若之前已进行过 1 次请求，则表示用户认证失败。</li><li>返回含有 <code>401 Unauthorized</code> 的响应必须包含一个适用于被请求资源的 WWW-Authenticate 首部用以质询（challenge）用户信息。</li></ul><h5 id="403-Forbidden"><a href="#403-Forbidden" class="headerlink" title="403 Forbidden"></a>403 Forbidden</h5><p>表明对请求资源的访问被服务器拒绝了。服务器端没有必要给出详细的拒绝理由，当然也可以在响应报文的实体主体部分对原因进行描述。</p><h5 id="404-Not-Found"><a href="#404-Not-Found" class="headerlink" title="404 Not Found"></a>404 Not Found</h5><p>表明服务器上无法找到请求的资源。除此之外，也可以在服务器端拒绝请求且不想说明理由的时候使用。</p><h5 id="500-Internal-Server-Error"><a href="#500-Internal-Server-Error" class="headerlink" title="500 Internal Server Error"></a>500 Internal Server Error</h5><p>表明服务器端在执行请求时发生了错误。也可能是 Web 应用存在的 bug 或某些临时的故障。</p><h5 id="503-Service-Unavailable"><a href="#503-Service-Unavailable" class="headerlink" title="503 Service Unavailable"></a>503 Service Unavailable</h5><p>表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。如果事先得知解除以上状况需要的时间，最好写入 Retry-After 首部字段再返回给客户端。</p><h3 id="HTTP-报文实体"><a href="#HTTP-报文实体" class="headerlink" title="HTTP 报文实体"></a>HTTP 报文实体</h3><h4 id="HTTP-报文实体概述"><a href="#HTTP-报文实体概述" class="headerlink" title="HTTP 报文实体概述"></a>HTTP 报文实体概述</h4><p><img src="https://github.com/AlexBruceLu/DAPP/wiki/http13_1.webp" alt="HTTP 报文结构"></p><p>大家请仔细看看上面示例中，各个组成部分对应的内容。<br> 接着，我们来看看报文和实体的概念。如果把 HTTP 报文想象成因特网货运系统中的箱子，那么 HTTP 实体就是报文中实际的货物。</p><ul><li>报文：是网络中交换和传输的数据单元，即站点一次性要发送的数据块。报文包含了将要发送的完整的数据信息，其长短很不一致，长度不限且可变。</li><li>实体：作为请求或响应的有效载荷数据（补充项）被传输，其内容由实体首部和实体主体组成。（实体首部相关内容在上面第六点中已有阐述。）</li></ul><p>我们可以看到，上面示例右图中深红色框的内容就是报文的实体部分，而蓝色框的两部分内容分别就是实体首部和实体主体。而左图中粉红框内容就是报文主体。<br> <strong>通常，报文主体等于实体主体。只有当传输中进行编码操作时，实体主体的内容发生变化，才导致它和报文主体产生差异。</strong></p><h4 id="内容编码"><a href="#内容编码" class="headerlink" title="内容编码"></a>内容编码</h4><ul><li>HTTP 应用程序有时在发送之前需要对内容进行编码。例如，在把很大的 HTML 文档发送给通过慢速连接上来的客户端之前，服务器可能会对其进行压缩，这样有助于减少传输实体的时间。服务器还可以把内容搅乱或加密，以此来防止未授权的第三方看到文档的内容。</li><li>这种类型的编码是在发送方应用到内容之上的。当内容经过内容编码后，编好码的数据就放在实体主体中，像往常一样发送给接收方。</li></ul><p>内容编码类型：</p><table><thead><tr><th>编码方式</th><th>描述</th></tr></thead><tbody><tr><td>gzip</td><td>表明实体采用 GNU zip 编码</td></tr><tr><td>compress</td><td>表明实体采用 Unix 的文件压缩程序</td></tr><tr><td>deflate</td><td>表明实体采用 zlib 的格式压缩的</td></tr><tr><td>identity</td><td>表明没有对实体进行编码，当没有 Content-Encoding 首部字段时，默认采用此编码方式</td></tr></tbody></table><h4 id="传输编码"><a href="#传输编码" class="headerlink" title="传输编码"></a>传输编码</h4><p>内容编码是对报文的主体进行的可逆变换，是和内容的具体格式细节紧密相关的。<br> 传输编码也是作用在实体主体上的可逆变换，但使用它们是由于架构方面的原因，同内容的格式无关。使用传输编码是为了改变报文中的数据在网络上传输的方式。</p><p><img src="https://github.com/AlexBruceLu/DAPP/wiki/http13_3.webp" alt=""></p><h4 id="分块编码"><a href="#分块编码" class="headerlink" title="分块编码"></a>分块编码</h4><p>分块编码把报文分割成若干已知大小的块。块之间是紧挨着发送的，这样就不需要在发送之前知道整个报文的大小了。分块编码是一种传输编码，是报文的属性。</p><h5 id="分块编码与持久连接"><a href="#分块编码与持久连接" class="headerlink" title="分块编码与持久连接"></a><strong>分块编码与持久连接</strong></h5><p> 若客户端与服务器端之间不是持久连接，客户端就不需要知道它在读取的主体的长度，而只需要读取到服务器关闭主体连接为止。<br> 当使用持久连接时，在服务器写主体之前，必须知道它的大小并在 Content-Length 首部中发送。如果服务器动态创建内容，就可能在发送之前无法知道主体的长度。<br> 分块编码为这种困难提供了解决方案，只要允许服务器把主体分块发送，说明每块的大小就可以了。因为主体是动态创建的，服务器可以缓冲它的一部分，发送其大小和相应的块，然后在主体发送完之前重复这个过程。服务器可以用大小为 0 的块作为主体结束的信号，这样就可以继续保持连接，为下一个响应做准备。<br> 来看看一个分块编码的报文示例：</p><p><img src="https://github.com/AlexBruceLu/DAPP/wiki/http13_2.webp" alt=""></p><h4 id="多部分媒体类型"><a href="#多部分媒体类型" class="headerlink" title="多部分媒体类型"></a>多部分媒体类型</h4><p>MIME 中的 multipart（多部分）电子邮件报文中包含多个报文，它们合在一起作为单一的复杂报文发送。每一部分都是独立的，有各自的描述其内容的集，不同部分之间用分界字符串连接在一起。<br> 相应得，HTTP 协议中也采纳了多部分对象集合，发送的一份报文主体内可包含多种类型实体。<br> 多部分对象集合包含的对象如下：</p><ul><li>multipart/form-data：在 Web 表单文件上传时使用。</li><li>multipart/byteranges：状态码 <code>206 Partial Content</code> 响应报文包含了多个范围的内容时使用。</li></ul><h4 id="范围请求"><a href="#范围请求" class="headerlink" title="范围请求"></a>范围请求</h4><p>假设你正在下载一个很大的文件，已经下了四分之三，忽然网络中断了，那下载就必须重头再来一遍。为了解决这个问题，需要一种可恢复的机制，即能从之前下载中断处恢复下载。要实现该功能，这就要用到范围请求。<br> 有了范围请求， HTTP 客户端可以通过请求曾获取失败的实体的一个范围（或者说一部分），来恢复下载该实体。当然这有一个前提，那就是从客户端上一次请求该实体到这一次发出范围请求的时间段内，该对象没有改变过。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GET  /bigfile.html  HTTP/1.1</span><br><span class="line">Host: www.sample.com</span><br><span class="line">Range: bytes=20224-</span><br><span class="line">···</span><br></pre></td></tr></table></figure><p><img src="https://github.com/AlexBruceLu/DAPP/wiki/http13_4.webp" alt=""></p><p>上面示例中，客户端请求的是文档开头20224字节之后的部分。</p><h3 id="与-HTTP-协作的-Web-服务器"><a href="#与-HTTP-协作的-Web-服务器" class="headerlink" title="与 HTTP 协作的 Web 服务器"></a>与 HTTP 协作的 Web 服务器</h3><p>HTTP 通信时，除客户端和服务器外，还有一些用于协助通信的应用程序。如下列出比较重要的几个：<strong>代理、缓存、网关、隧道、Agent 代理</strong>。</p><h4 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h4><p><img src="https://github.com/AlexBruceLu/DAPP/wiki/http13_5.webp" alt=""></p><p>HTTP 代理服务器是 Web 安全、应用集成以及性能优化的重要组成模块。代理位于客户端和服务器端之间，接收客户端所有的 HTTP 请求，并将这些请求转发给服务器（可能会对请求进行修改之后再进行转发）。对用户来说，这些应用程序就是一个代理，代表用户访问服务器。<br> 出于安全考虑，通常会将代理作为转发所有 Web 流量的可信任中间节点使用。代理还可以对请求和响应进行过滤，安全上网或绿色上网。</p><h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h4><p><strong>浏览器第一次请求：</strong></p><p><img src="https://github.com/AlexBruceLu/DAPP/wiki/http13_6.webp" alt=""></p><p><strong>浏览器再次请求：</strong></p><p><img src="https://github.com/AlexBruceLu/DAPP/wiki/http13_7.webp" alt=""></p><p>Web 缓存或代理缓存是一种特殊的 HTTP 代理服务器，可以将经过代理传输的常用文档复制保存起来。下一个请求同一文档的客户端就可以享受缓存的私有副本所提供的服务了。客户端从附近的缓存下载文档会比从远程 Web 服务器下载快得多。</p><h4 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h4><p><img src="https://github.com/AlexBruceLu/DAPP/wiki/http13_8.webp" alt=""></p><p>网关是一种特殊的服务器，作为其他服务器的中间实体使用。通常用于将 HTTP 流量转换成其他的协议。网关接收请求时就好像自己是资源的源服务器一样。客户端可能并不知道自己正在跟一个网关进行通信。</p><h4 id="隧道"><a href="#隧道" class="headerlink" title="隧道"></a>隧道</h4><p><img src="https://github.com/AlexBruceLu/DAPP/wiki/http13_9.webp" alt=""></p><p>隧道是会在建立起来之后，就会在两条连接之间对原始数据进行盲转发的 HTTP 应用程序。HTTP 隧道通常用来在一条或多条 HTTP 连接上转发非 HTTP 数据，转发时不会窥探数据。<br> HTTP 隧道的一种常见用途就是通过 HTTP 连接承载加密的安全套接字层（SSL）流量，这样 SSL 流量就可以穿过只允许 Web 流量通过的防火墙了。</p><h4 id="Agent-代理"><a href="#Agent-代理" class="headerlink" title="Agent 代理"></a>Agent 代理</h4><p><img src="https://github.com/AlexBruceLu/DAPP/wiki/http13_10.webp" alt=""></p><p>Agent 代理是代表用户发起 HTTP 请求的客户端应用程序。所有发布 Web 请求的应用程序都是 HTTP Agent 代理。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt; 详解http协议：&lt;/strong&gt; &lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;/excerpt&gt;&lt;/p&gt;
&lt;p&gt;http网络协议的详解概述&lt;/p&gt;
    
    </summary>
    
      <category term="others" scheme="https://alexbrucelu.github.io/categories/others/"/>
    
    
      <category term="http/https" scheme="https://alexbrucelu.github.io/tags/http-https/"/>
    
  </entry>
  
  <entry>
    <title>http与https协议的区别</title>
    <link href="https://alexbrucelu.github.io/2018/12/03/http%E7%BD%91%E7%BB%9C/"/>
    <id>https://alexbrucelu.github.io/2018/12/03/http网络/</id>
    <published>2018-12-03T12:51:11.660Z</published>
    <updated>2018-12-05T07:45:45.513Z</updated>
    
    <content type="html"><![CDATA[<p><strong> http与https协议的区别：</strong> <excerpt in="" index="" |="" 首页摘要=""></excerpt></p><p>相关概念</p><a id="more"></a><p>[TOC]</p><p>超文本传输协议HTTP协议被用于在Web浏览器和网站服务器之间传递信息，HTTP协议以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此，HTTP协议不适合传输一些敏感信息，比如：信用卡号、密码等支付信息。</p><p>　　为了解决HTTP协议的这一缺陷，需要使用另一种协议：安全套接字层超文本传输协议HTTPS，为了数据传输的安全，HTTPS在HTTP的基础上加入了SSL协议，SSL依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。</p><h3 id="一、HTTP和HTTPS的基本概念"><a href="#一、HTTP和HTTPS的基本概念" class="headerlink" title="一、HTTP和HTTPS的基本概念"></a><strong>一、HTTP和HTTPS的基本概念</strong></h3><p>　　HTTP：是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。</p><p>　　HTTPS：是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。</p><p>　　HTTPS协议的主要作用可以分为两种：一种是建立一个信息安全通道，来保证数据传输的安全；另一种就是确认网站的真实性。</p><h3 id="二、HTTP与HTTPS有什么区别？"><a href="#二、HTTP与HTTPS有什么区别？" class="headerlink" title="二、HTTP与HTTPS有什么区别？"></a><strong>二、HTTP与HTTPS有什么区别？</strong></h3><p>　　HTTP协议传输的数据都是未加密的，也就是明文的，因此使用HTTP协议传输隐私信息非常不安全，为了保证这些隐私数据能加密传输，于是网景公司设计了SSL（Secure Sockets Layer）协议用于对HTTP协议传输的数据进行加密，从而就诞生了HTTPS。简单来说，HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全。</p><p>HTTPS和HTTP的区别主要如下：</p><p>　　1、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。</p><p>　　2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。</p><p>　　3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</p><p>　　4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</p><h3 id="三、HTTPS的工作原理"><a href="#三、HTTPS的工作原理" class="headerlink" title="三、HTTPS的工作原理"></a><strong>三、HTTPS的工作原理</strong></h3><p>　　我们都知道HTTPS能够加密信息，以免敏感信息被第三方获取，所以很多银行网站或电子邮箱等等安全级别较高的服务都会采用HTTPS协议。</p><p><img src="https://github.com/AlexBruceLu/DAPP/wiki/http1.jpg" alt=""></p><p>客户端在使用HTTPS方式与Web服务器通信时有以下几个步骤，如图所示。</p><p>　　（1）客户使用https的URL访问Web服务器，要求与Web服务器建立SSL连接。</p><p>　　（2）Web服务器收到客户端请求后，会将网站的证书信息（证书中包含公钥）传送一份给客户端。</p><p>　　（3）客户端的浏览器与Web服务器开始协商SSL连接的安全等级，也就是信息加密的等级。</p><p>　　（4）客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站。</p><p>　　（5）Web服务器利用自己的私钥解密出会话密钥。</p><p>　　（6）Web服务器利用会话密钥加密与客户端之间的通信。</p><p><img src="https://github.com/AlexBruceLU/DAPP/wiki/http2.gif" alt=""></p><h3 id="四、HTTPS的优点"><a href="#四、HTTPS的优点" class="headerlink" title="四、HTTPS的优点"></a><strong>四、HTTPS的优点</strong></h3><p>　　尽管HTTPS并非绝对安全，掌握根证书的机构、掌握加密算法的组织同样可以进行中间人形式的攻击，但HTTPS仍是现行架构下最安全的解决方案，主要有以下几个好处：</p><p>　　（1）使用HTTPS协议可认证用户和服务器，确保数据发送到正确的客户机和服务器；</p><p>　　（2）HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性。</p><p>　　（3）HTTPS是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。</p><p>　　（4）谷歌曾在2014年8月份调整搜索引擎算法，并称“比起同等HTTP网站，采用HTTPS加密的网站在搜索结果中的排名将会更高”。</p><h3 id="五、HTTPS的缺点"><a href="#五、HTTPS的缺点" class="headerlink" title="五、HTTPS的缺点"></a><strong>五、HTTPS的缺点</strong></h3><p>　　虽然说HTTPS有很大的优势，但其相对来说，还是存在不足之处的：</p><p>　　（1）HTTPS协议握手阶段比较费时，会使页面的加载时间延长近50%，增加10%到20%的耗电；</p><p>　　（2）HTTPS连接缓存不如HTTP高效，会增加数据开销和功耗，甚至已有的安全措施也会因此而受到影响；</p><p>　　（3）SSL证书需要钱，功能越强大的证书费用越高，个人网站、小网站没有必要一般不会用。</p><p>　   （4）SSL证书通常需要绑定IP，不能在同一IP上绑定多个域名，IPv4资源不可能支撑这个消耗。</p><p>　　（5）HTTPS协议的加密范围也比较有限，在黑客攻击、拒绝服务攻击、服务器劫持等方面几乎起不到什么作用。最关键的，SSL证书的信用链体系并不安全，特别是在某些国家可以控制CA根证书的情况下，中间人攻击一样可行。</p><h3 id="六、http切换到HTTPS"><a href="#六、http切换到HTTPS" class="headerlink" title="六、http切换到HTTPS"></a><strong>六、http切换到HTTPS</strong></h3><p>　　如果需要将网站从http切换到https到底该如何实现呢？</p><p>​     这里需要将页面中所有的链接，例如js，css，图片等等链接都由http改为https。例如：<a href="http://www.baidu.com改为https://www.baidu.com" target="_blank" rel="noopener">http://www.baidu.com改为https://www.baidu.com</a></p><p>　　BTW，这里虽然将http切换为了https，还是建议保留http。所以我们在切换的时候可以做http和https的兼容，具体实现方式是，去掉页面链接中的http头部，这样可以自动匹配http头和https头。例如：将<a href="http://www.baidu.com改为//www.baidu.com。然后当用户从http的入口进入访问页面时，页面就是http，如果用户是从https的入口进入访问页面，页面即使https的。" target="_blank" rel="noopener">http://www.baidu.com改为//www.baidu.com。然后当用户从http的入口进入访问页面时，页面就是http，如果用户是从https的入口进入访问页面，页面即使https的。</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt; http与https协议的区别：&lt;/strong&gt; &lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;/excerpt&gt;&lt;/p&gt;
&lt;p&gt;相关概念&lt;/p&gt;
    
    </summary>
    
      <category term="others" scheme="https://alexbrucelu.github.io/categories/others/"/>
    
    
      <category term="http/https" scheme="https://alexbrucelu.github.io/tags/http-https/"/>
    
  </entry>
  
</feed>
