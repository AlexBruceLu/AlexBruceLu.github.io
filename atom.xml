<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://alexbrucelu.github.io/"/>
  <updated>2018-12-05T08:23:58.733Z</updated>
  <id>https://alexbrucelu.github.io/</id>
  
  <author>
    <name>AlexBruceLu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>详解TCP/IP协议</title>
    <link href="https://alexbrucelu.github.io/2018/12/05/%E8%AF%A6%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE/"/>
    <id>https://alexbrucelu.github.io/2018/12/05/详解TCPIP协议/</id>
    <published>2018-12-05T08:22:37.467Z</published>
    <updated>2018-12-05T08:23:58.733Z</updated>
    
    <content type="html"><![CDATA[<p><strong> 详解TCP/IP协议：</strong> <excerpt in="" index="" |="" 首页摘要=""></excerpt></p><p>TCP/IP网络协议的详解概述</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt; 详解TCP/IP协议：&lt;/strong&gt; &lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;/excerpt&gt;&lt;/p&gt;
&lt;p&gt;TCP/IP网络协议的详解概述&lt;/p&gt;
    
    </summary>
    
      <category term="others" scheme="https://alexbrucelu.github.io/categories/others/"/>
    
    
      <category term="http/https" scheme="https://alexbrucelu.github.io/tags/http-https/"/>
    
  </entry>
  
  <entry>
    <title>详解http协议</title>
    <link href="https://alexbrucelu.github.io/2018/12/05/%E8%AF%A6%E8%A7%A3http%E5%8D%8F%E8%AE%AE/"/>
    <id>https://alexbrucelu.github.io/2018/12/05/详解http协议/</id>
    <published>2018-12-05T08:20:13.313Z</published>
    <updated>2018-12-05T09:41:11.358Z</updated>
    
    <content type="html"><![CDATA[<p><strong> 详解http协议：</strong> <excerpt in="" index="" |="" 首页摘要=""></excerpt></p><p>http网络协议的详解概述</p><a id="more"></a><p>[TOC]</p><p><img src="https://github.com/AlexBruceLu/DAPP/wiki/http3.webp" alt="一张图带你看完本篇文章"></p><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><h4 id="计算机网络体系结构分层"><a href="#计算机网络体系结构分层" class="headerlink" title="计算机网络体系结构分层"></a>计算机网络体系结构分层</h4><p><img src="https://github.com/AlexBruceLu/DAPP/wiki/http2.webp" alt="计算机网络体系结构分层"></p><h4 id="TCP-IP-通信传输流"><a href="#TCP-IP-通信传输流" class="headerlink" title="TCP/IP 通信传输流"></a>TCP/IP 通信传输流</h4><p>利用 TCP/IP 协议族进行网络通信时，会通过分层顺序与对方进行通信。发送端从应用层往下走，接收端则从链路层往上走。如下：</p><p><img src="https://github.com/AlexBruceLu/DAPP/wiki/http4.webp" alt="TCP/IP 通信传输流"></p><ul><li>首先作为发送端的客户端在应用层（HTTP 协议）发出一个想看某个 Web 页面的 HTTP 请求。</li><li>接着，为了传输方便，在传输层（TCP 协议）把从应用层处收到的数据（HTTP 请求报文）进行分割，并在各个报文上打上标记序号及端口号后转发给网络层。</li><li>在网络层（IP 协议），增加作为通信目的地的 MAC 地址后转发给链路层。这样一来，发往网络的通信请求就准备齐全了。</li><li>接收端的服务器在链路层接收到数据，按序往上层发送，一直到应用层。当传输到应用层，才能算真正接收到由客户端发送过来的 HTTP请求。</li></ul><p>如下图所示：</p><p><img src="https://github.com/AlexBruceLu/DAPP/wiki/http5.webp" alt="HTTP 请求"></p><p>在网络体系结构中，包含了众多的网络协议，这篇文章主要围绕 HTTP 协议（HTTP/1.1版本）展开。</p><blockquote><p>HTTP协议（HyperText Transfer Protocol，超文本传输协议）是用于从WWW服务器传输超文本到本地浏览器的传输协议。它可以使浏览器更加高效，使网络传输减少。它不仅保证计算机正确快速地传输超文本文档，还确定传输文档中的哪一部分，以及哪部分内容首先显示(如文本先于图形)等。<br> HTTP是客户端浏览器或其他程序与Web服务器之间的应用层通信协议。在Internet上的Web服务器上存放的都是超文本信息，客户机需要通过HTTP协议传输所要访问的超文本信息。HTTP包含命令和传输信息，不仅可用于Web访问，也可以用于其他因特网/内联网应用系统之间的通信，从而实现各类应用资源超媒体访问的集成。<br> 我们在浏览器的地址栏里输入的网站地址叫做URL (Uniform Resource Locator，统一资源定位符)。就像每家每户都有一个门牌地址一样，每个网页也都有一个Internet地址。当你在浏览器的地址框中输入一个URL或是单击一个超级链接时，URL就确定了要浏览的地址。浏览器通过超文本传输协议(HTTP)，将Web服务器上站点的网页代码提取出来，并翻译成漂亮的网页。</p></blockquote><h3 id="HTTP-工作过程"><a href="#HTTP-工作过程" class="headerlink" title="HTTP 工作过程"></a>HTTP 工作过程</h3><p><img src="https://github.com/AlexBruceLu/DAPP/wiki/http6.webp" alt="HTTP请求响应模型"></p><p>HTTP通信机制是在一次完整的 HTTP 通信过程中，客户端与服务器之间将完成下列7个步骤：</p><h4 id="建立-TCP-连接"><a href="#建立-TCP-连接" class="headerlink" title="建立 TCP 连接"></a><strong>建立 TCP 连接</strong></h4><p>在HTTP工作开始之前，客户端首先要通过网络与服务器建立连接，该连接是通过 TCP 来完成的，该协议与 IP 协议共同构建 Internet，即著名的 TCP/IP 协议族，因此 Internet 又被称作是 TCP/IP 网络。HTTP 是比 TCP 更高层次的应用层协议，根据规则，只有低层协议建立之后，才能进行高层协议的连接，因此，首先要建立 TCP 连接，一般 TCP 连接的端口号是80；</p><h4 id="客户端向服务器发送请求命令"><a href="#客户端向服务器发送请求命令" class="headerlink" title="客户端向服务器发送请求命令"></a><strong>客户端向服务器发送请求命令</strong></h4><p> 一旦建立了TCP连接，客户端就会向服务器发送请求命令；<br> 例如：<code>GET/sample/hello.jsp HTTP/1.1</code> </p><h4 id="客户端发送请求头信息"><a href="#客户端发送请求头信息" class="headerlink" title="客户端发送请求头信息"></a><strong>客户端发送请求头信息</strong></h4><p> 客户端发送其请求命令之后，还要以头信息的形式向服务器发送一些别的信息，之后客户端发送了一空白行来通知服务器，它已经结束了该头信息的发送；</p><h4 id="服务器应答"><a href="#服务器应答" class="headerlink" title="服务器应答"></a><strong>服务器应答</strong></h4><p> 客户端向服务器发出请求后，服务器会客户端返回响应；<br> 例如： <code>HTTP/1.1 200 OK</code><br> 响应的第一部分是协议的版本号和响应状态码</p><h4 id="服务器返回响应头信息"><a href="#服务器返回响应头信息" class="headerlink" title="服务器返回响应头信息"></a><strong>服务器返回响应头信息</strong></h4><p> 正如客户端会随同请求发送关于自身的信息一样，服务器也会随同响应向用户发送关于它自己的数据及被请求的文档；</p><h4 id="服务器向客户端发送数据"><a href="#服务器向客户端发送数据" class="headerlink" title="服务器向客户端发送数据"></a><strong>服务器向客户端发送数据</strong></h4><p> 服务器向客户端发送头信息后，它会发送一个空白行来表示头信息的发送到此为结束，接着，它就以 Content-Type 响应头信息所描述的格式发送用户所请求的实际数据；</p><h4 id="服务器关闭-TCP-连接"><a href="#服务器关闭-TCP-连接" class="headerlink" title="服务器关闭 TCP 连接"></a><strong>服务器关闭 TCP 连接</strong></h4><p> 一般情况下，一旦服务器向客户端返回了请求数据，它就要关闭 TCP 连接，然后如果客户端或者服务器在其头信息加入了这行代码 <code>Connection:keep-alive</code> ，TCP 连接在发送后将仍然保持打开状态，于是，客户端可以继续通过相同的连接发送请求。保持连接节省了为每个请求建立新连接所需的时间，还节约了网络带宽。</p><h3 id="HTTP-协议基础"><a href="#HTTP-协议基础" class="headerlink" title="HTTP 协议基础"></a>HTTP 协议基础</h3><h4 id="通过请求和响应的交换达成通信"><a href="#通过请求和响应的交换达成通信" class="headerlink" title="通过请求和响应的交换达成通信"></a>通过请求和响应的交换达成通信</h4><p>应用 HTTP 协议时，必定是一端担任客户端角色，另一端担任服务器端角色。仅从一条通信线路来说，服务器端和客服端的角色是确定的。HTTP 协议规定，请求从客户端发出，最后服务器端响应该请求并返回。<strong>换句话说，肯定是先从客户端开始建立通信的，服务器端在没有接收到请求之前不会发送响应。</strong></p><h4 id="HTTP-是不保存状态的协议"><a href="#HTTP-是不保存状态的协议" class="headerlink" title="HTTP 是不保存状态的协议"></a>HTTP 是不保存状态的协议</h4><p>HTTP 是一种无状态协议。协议自身不对请求和响应之间的通信状态进行保存。也就是说在 HTTP 这个级别，协议对于发送过的请求或响应都不做持久化处理。这是为了更快地处理大量事务，确保协议的可伸缩性，而特意把 HTTP 协议设计成如此简单的。<br>可是随着 Web 的不断发展，我们的很多业务都需要对通信状态进行保存。于是我们引入了 Cookie 技术。有了 Cookie 再用 HTTP 协议通信，就可以管理状态了。</p><h4 id="使用-Cookie-的状态管理"><a href="#使用-Cookie-的状态管理" class="headerlink" title="使用 Cookie 的状态管理"></a>使用 Cookie 的状态管理</h4><p>Cookie 技术通过在请求和响应报文中写入 Cookie 信息来控制客户端的状态。Cookie 会根据从服务器端发送的响应报文内的一个叫做 Set-Cookie 的首部字段信息，通知客户端保存Cookie。当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入 Cookie 值后发送出去。服务器端发现客户端发送过来的 Cookie 后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到之前的状态信息。</p><p><img src="https://github.com/AlexBruceLu/DAPP/wiki/http7.webp" alt="Cookie 的流程"></p><h4 id="请求-URI-定位资源"><a href="#请求-URI-定位资源" class="headerlink" title="请求 URI 定位资源"></a>请求 URI 定位资源</h4><p>HTTP 协议使用 URI 定位互联网上的资源。正是因为 URI 的特定功能，在互联网上任意位置的资源都能访问到。</p><h4 id="告知服务器意图的-HTTP-方法（HTTP-1-1）"><a href="#告知服务器意图的-HTTP-方法（HTTP-1-1）" class="headerlink" title="告知服务器意图的 HTTP 方法（HTTP/1.1）"></a>告知服务器意图的 HTTP 方法（HTTP/1.1）</h4><p><img src="https://github.com/AlexBruceLu/DAPP/wiki/http8.webp" alt="HTTP 方法"></p><h4 id="持久连接"><a href="#持久连接" class="headerlink" title="持久连接"></a>持久连接</h4><p>HTTP 协议的初始版本中，每进行一个 HTTP 通信都要断开一次 TCP 连接。比如使用浏览器浏览一个包含多张图片的 HTML 页面时，在发送请求访问 HTML 页面资源的同时，也会请求该 HTML 页面里包含的其他资源。因此，每次的请求都会造成无畏的 TCP 连接建立和断开，增加通信量的开销。<br> 为了解决上述 TCP 连接的问题，HTTP/1.1 和部分 HTTP/1.0 想出了持久连接的方法。<strong>其特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。旨在建立一次 TCP 连接后进行多次请求和响应的交互。</strong>在 HTTP/1.1 中，所有的连接默认都是持久连接。</p><h4 id="管线化"><a href="#管线化" class="headerlink" title="管线化"></a>管线化</h4><p>持久连接使得多数请求以管线化方式发送成为可能。以前发送请求后需等待并接收到响应，才能发送下一个请求。管线化技术出现后，不用等待亦可发送下一个请求。这样就能做到同时并行发送多个请求，而不需要一个接一个地等待响应了。<br> 比如，当请求一个包含多张图片的 HTML 页面时，与挨个连接相比，用持久连接可以让请求更快结束。而管线化技术要比持久连接速度更快。请求数越多，时间差就越明显。</p><h3 id="HTTP-协议报文结构"><a href="#HTTP-协议报文结构" class="headerlink" title="HTTP 协议报文结构"></a>HTTP 协议报文结构</h3><h4 id="HTTP-报文"><a href="#HTTP-报文" class="headerlink" title="HTTP 报文"></a>HTTP 报文</h4><p>用于 HTTP 协议交互的信息被称为 HTTP 报文。请求端（客户端）的 HTTP 报文叫做请求报文；响应端（服务器端）的叫做响应报文。HTTP 报文本身是由多行（用 CR+LF 作换行符）数据构成的字符串文本。</p><h4 id="HTTP-报文结构"><a href="#HTTP-报文结构" class="headerlink" title="HTTP 报文结构"></a>HTTP 报文结构</h4><p>HTTP 报文大致可分为报文首部和报文主体两部分。两者由最初出现的空行（CR+LF）来划分。通常，并不一定有报文主体。如下：</p><p><img src="https://github.com/AlexBruceLu/DAPP/wiki/http.webp" alt="HTTP 报文结构"></p><p><img src="https://github.com/AlexBruceLu/DAPP/wiki/http901.webp" alt="HTTP 报文结构"></p><h5 id="请求报文结构"><a href="#请求报文结构" class="headerlink" title="请求报文结构"></a>请求报文结构</h5><p><img src="https://github.com/AlexBruceLu/DAPP/wiki/http10.webp" alt="请求报文结构"></p><p>请求报文的首部内容由以下数据组成：</p><ul><li><strong>请求行</strong> —— 包含用于请求的方法、请求 URI 和 HTTP 版本。</li><li><strong>首部字段</strong> —— 包含表示请求的各种条件和属性的各类首部。（通用首部、请求首部、实体首部以及RFC里未定义的首部如 Cookie 等）</li></ul><p>请求报文的示例，如下：</p><p><img src="https://github.com/AlexBruceLu/DAPP/wiki/http11.webp" alt="请求报文示例"></p><h5 id="响应报文结构"><a href="#响应报文结构" class="headerlink" title="响应报文结构"></a>响应报文结构</h5><p><img src="https://github.com/AlexBruceLu/DAPP/wiki/http12.webp" alt="响应报文结构"></p><p>响应报文的首部内容由以下数据组成：</p><ul><li><strong>状态行</strong> —— 包含表明响应结果的状态码、原因短语和 HTTP 版本。</li><li><strong>首部字段</strong> —— 包含表示请求的各种条件和属性的各类首部。（通用首部、响应首部、实体首部以及RFC里未定义的首部如 Cookie 等）</li></ul><p>响应报文的示例，如下：</p><p><img src="https://github.com/AlexBruceLu/DAPP/wiki/http13.webp" alt="响应报文结构"></p><h3 id="HTTP-报文首部之请求行、状态行"><a href="#HTTP-报文首部之请求行、状态行" class="headerlink" title="HTTP 报文首部之请求行、状态行"></a>HTTP 报文首部之请求行、状态行</h3><h4 id="请求行"><a href="#请求行" class="headerlink" title="请求行"></a>请求行</h4><p>举个栗子，下面是一个 HTTP 请求的报文：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET  /index.htm  HTTP/1.1</span><br><span class="line">Host: sample.com</span><br></pre></td></tr></table></figure><p>其中，下面的这行就是请求行，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET  /index.htm  HTTP/1.1</span><br></pre></td></tr></table></figure><ul><li>开头的 GET 表示请求访问服务器的类型，称为方法；</li><li>随后的字符串  <code>/index.htm</code> 指明了请求访问的资源对象，也叫做请求 URI；</li><li>最后的 <code>HTTP/1.1</code>，即 HTTP 的版本号，用来提示客户端使用的 HTTP 协议功能。</li></ul><p>综合来看，大意是请求访问某台 HTTP 服务器上的 <code>/index.htm</code> 页面资源。</p><h4 id="状态行"><a href="#状态行" class="headerlink" title="状态行"></a>状态行</h4><p>同样举个栗子，下面是一个 HTTP 响应的报文：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1  200  OK</span><br><span class="line">Date: Mon, 10 Jul 2017 15:50:06 GMT</span><br><span class="line">Content-Length: 256</span><br><span class="line">Content-Type: text/html</span><br><span class="line">    </span><br><span class="line">&lt;html&gt;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>其中，下面的这行就是状态行，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1  200  OK</span><br></pre></td></tr></table></figure><ul><li>开头的 <code>HTTP/1.1</code> 表示服务器对应的 HTTP 版本；</li><li>紧挨着的 <code>200 OK</code> 表示请求的处理结果的状态码和原因短语。</li></ul><h3 id="HTTP-报文首部之首部字段（重点分析）"><a href="#HTTP-报文首部之首部字段（重点分析）" class="headerlink" title="HTTP 报文首部之首部字段（重点分析）"></a>HTTP 报文首部之首部字段（重点分析）</h3><h4 id="首部字段概述"><a href="#首部字段概述" class="headerlink" title="首部字段概述"></a>首部字段概述</h4><p>先来回顾一下首部字段在报文的位置，HTTP 报文包含报文首部和报文主体，报文首部包含请求行（或状态行）和首部字段。<br> 在报文众多的字段当中，HTTP 首部字段包含的信息最为丰富。首部字段同时存在于请求和响应报文内，并涵盖 HTTP 报文相关的内容信息。使用首部字段是为了给客服端和服务器端提供报文主体大小、所使用的语言、认证信息等内容。</p><h4 id="首部字段结构"><a href="#首部字段结构" class="headerlink" title="首部字段结构"></a>首部字段结构</h4><ul><li>HTTP 首部字段是由首部字段名和字段值构成的，中间用冒号“：”分隔。</li><li>另外，字段值对应单个 HTTP 首部字段可以有多个值。</li><li>当 HTTP 报文首部中出现了两个或以上具有相同首部字段名的首部字段时，这种情况在规范内尚未明确，根据浏览器内部处理逻辑的不同，优先处理的顺序可能不同，结果可能并不一致。</li></ul><table><thead><tr><th>首部字段名</th><th>冒号</th><th>字段值</th></tr></thead><tbody><tr><td>Content-Type</td><td>：</td><td>text/html</td></tr><tr><td>Keep-Alive</td><td>：</td><td>timeout=30, max=120</td></tr></tbody></table><h4 id="首部字段类型"><a href="#首部字段类型" class="headerlink" title="首部字段类型"></a>首部字段类型</h4><p>首部字段根据实际用途被分为以下4种类型：</p><table><thead><tr><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>通用首部字段</td><td>请求报文和响应报文两方都会使用的首部</td></tr><tr><td>请求首部字段</td><td>从客户端向服务器端发送请求报文时使用的首部。补充了请求的附加内容、客户端信息、响应内容相关优先级等信息</td></tr><tr><td>响应首部字段</td><td>从服务器端向客户端返回响应报文时使用的首部。补充了响应的附加内容，也会要求客户端附加额外的内容信息。</td></tr><tr><td>实体首部字段</td><td>针对请求报文和响应报文的实体部分使用的首部。补充了资源内容更新时间等与实体有关的的信息。</td></tr></tbody></table><h4 id="通用首部字段（HTTP-1-1）"><a href="#通用首部字段（HTTP-1-1）" class="headerlink" title="通用首部字段（HTTP/1.1）"></a>通用首部字段（HTTP/1.1）</h4><table><thead><tr><th>首部字段名</th><th>说明</th></tr></thead><tbody><tr><td>Cache-Control</td><td>控制缓存的行为</td></tr><tr><td>Connection</td><td>逐挑首部、连接的管理</td></tr><tr><td>Date</td><td>创建报文的日期时间</td></tr><tr><td>Pragma</td><td>报文指令</td></tr><tr><td>Trailer</td><td>报文末端的首部一览</td></tr><tr><td>Transfer-Encoding</td><td>指定报文主体的传输编码方式</td></tr><tr><td>Upgrade</td><td>升级为其他协议</td></tr><tr><td>Via</td><td>代理服务器的相关信息</td></tr><tr><td>Warning</td><td>错误通知</td></tr></tbody></table><h5 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h5><p>通过指定首部字段 Cache-Control 的指令，就能操作缓存的工作机制。</p><h5 id="可用的指令一览"><a href="#可用的指令一览" class="headerlink" title="可用的指令一览"></a>可用的指令一览</h5><p>可用的指令按请求和响应分类如下：</p><h5 id="缓存请求指令"><a href="#缓存请求指令" class="headerlink" title="缓存请求指令"></a><strong>缓存请求指令</strong></h5><table><thead><tr><th>指令</th><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>no-cache</td><td>无</td><td>强制向服务器再次验证</td></tr><tr><td>no-store</td><td>无</td><td>不缓存请求或响应的任何内容</td></tr><tr><td>max-age = [秒]</td><td>必需</td><td>响应的最大Age值</td></tr><tr><td>max-stale( =[秒])</td><td>可省略</td><td>接收已过期的响应</td></tr><tr><td>min-fresh = [秒]</td><td>必需</td><td>期望在指定时间内的响应仍有效</td></tr><tr><td>no-transform</td><td>无</td><td>代理不可更改媒体类型</td></tr><tr><td>only-if-cached</td><td>无</td><td>从缓存获取资源</td></tr><tr><td>cache-extension</td><td>-</td><td>新指令标记（token）</td></tr></tbody></table><h5 id="缓存响应指令"><a href="#缓存响应指令" class="headerlink" title="缓存响应指令"></a><strong>缓存响应指令</strong></h5><table><thead><tr><th>指令</th><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>public</td><td>无</td><td>可向任意方提供响应的缓存</td></tr><tr><td>private</td><td>可省略</td><td>仅向特定用户返回响应</td></tr><tr><td>no-cache</td><td>可省略</td><td>缓存前必须先确认其有效性</td></tr><tr><td>no-store</td><td>无</td><td>不缓存请求或响应的任何内容</td></tr><tr><td>no-transform</td><td>无</td><td>代理不可更改媒体类型</td></tr><tr><td>must-revalidate</td><td>无</td><td>可缓存但必须再向源服务器进行确认</td></tr><tr><td>proxy-revalidate</td><td>无</td><td>要求中间缓存服务器对缓存的响应有效性再进行确认</td></tr><tr><td>max-age = [秒]</td><td>必需</td><td>响应的最大Age值</td></tr><tr><td>s-maxage = [秒]</td><td>必需</td><td>公共缓存服务器响应的最大Age值</td></tr><tr><td>cache-extension</td><td>-</td><td>新指令标记（token）</td></tr></tbody></table><h5 id="表示能否缓存的指令"><a href="#表示能否缓存的指令" class="headerlink" title="表示能否缓存的指令"></a><strong>表示能否缓存的指令</strong></h5><p><strong>public 指令</strong><br> <code>Cache-Control: public</code><br> 当指定使用 public 指令时，则明确表明其他用户也可利用缓存。</p><p><strong>private 指令</strong><br> <code>Cache-Control: private</code><br> 当指定 private 指令后，响应只以特定的用户作为对象，这与 public 指令的行为相反。缓存服务器会对该特定用户提供资源缓存的服务，对于其他用户发送过来的请求，代理服务器则不会返回缓存。</p><p><strong>no-cache 指令</strong><br> <code>Cache-Control: no-cache</code></p><ul><li>使用 no-cache 指令是为了防止从缓存中返回过期的资源。</li><li>客户端发送的请求中如果包含 no-cache 指令，则表示客户端将不会接收缓存过的响应。于是，“中间”的缓存服务器必须把客户端请求转发给源服务器。</li><li>如果服务器中返回的响应包含 no-cache 指令，那么缓存服务器不能对资源进行缓存。源服务器以后也将不再对缓存服务器请求中提出的资源有效性进行确认，且禁止其对响应资源进行缓存操作。</li></ul><p><code>Cache-Control: no-cache=Location</code><br> 由服务器返回的响应中，若报文首部字段 Cache-Control 中对 no-cache 字段名具体指定参数值，那么客户端在接收到这个被指定参数值的首部字段对应的响应报文后，就不能使用缓存。换言之，无参数值的首部字段可以使用缓存。只能在响应指令中指定该参数。</p><p><strong>no-store 指令</strong><br> <code>Cache-Control: no-store</code><br> 当使用 no-store 指令时，暗示请求（和对应的响应）或响应中包含机密信息。因此，该指令规定缓存不能在本地存储请求或响应的任一部分。<br> 注意：no-cache 指令代表不缓存过期的指令，缓存会向源服务器进行有效期确认后处理资源；no-store 指令才是真正的不进行缓存。</p><h6 id="指定缓存期限和认证的指令"><a href="#指定缓存期限和认证的指令" class="headerlink" title="指定缓存期限和认证的指令"></a>指定缓存期限和认证的指令</h6><p><strong>s-maxage 指令</strong><br> <code>Cache-Control: s-maxage=604800（单位：秒）</code></p><ul><li>s-maxage 指令的功能和 max-age 指令的相同，它们的不同点是 s-maxage 指令只适用于供多位用户使用的公共缓存服务器（一般指代理）。也就是说，对于向同一用户重复返回响应的服务器来说，这个指令没有任何作用。</li><li>另外，当使用 s-maxage 指令后，则直接忽略对 Expires 首部字段及 max-age 指令的处理。</li></ul><p><strong>max-age 指令</strong><br> <code>Cache-Control: max-age=604800（单位：秒）</code></p><ul><li>当客户端发送的请求中包含 max-age 指令时，如果判定缓存资源的缓存时间数值比指定的时间更小，那么客户端就接收缓存的资源。另外，当指定 max-age 的值为0，那么缓存服务器通常需要将请求转发给源服务器。</li><li>当服务器返回的响应中包含 max-age 指令时，缓存服务器将不对资源的有效性再作确认，而 max-age 数值代表资源保存为缓存的最长时间。</li><li>应用 HTTP/1.1 版本的缓存服务器遇到同时存在 Expires 首部字段的情况时，会优先处理 max-age 指令，并忽略掉 Expires 首部字段；而 HTTP/1.0 版本的缓存服务器则相反。</li></ul><p><strong>min-fresh 指令</strong><br> <code>Cache-Control: min-fresh=60（单位：秒）</code><br> min-fresh 指令要求缓存服务器返回至少还未过指定时间的缓存资源。</p><p><strong>max-stale 指令</strong><br> <code>Cache-Control: max-stale=3600（单位：秒）</code></p><ul><li>使用 max-stale 可指示缓存资源，即使过期也照常接收。</li><li>如果指令未指定参数值，那么无论经过多久，客户端都会接收响应；如果指定了具体参数值，那么即使过期，只要仍处于 max-stale 指定的时间内，仍旧会被客户端接收。</li></ul><p><strong>only-if-cached 指令</strong><br> <code>Cache-Control: only-if-cached</code><br> 表示客户端仅在缓存服务器本地缓存目标资源的情况下才会要求其返回。换言之，该指令要求缓存服务器不重新加载响应，也不会再次确认资源的有效性。</p><p><strong>must-revalidate 指令</strong><br> <code>Cache-Control: must-revalidate</code><br> 使用 must-revalidate 指令，代理会向源服务器再次验证即将返回的响应缓存目前是否仍有效。另外，使用 must-revalidate 指令会忽略请求的 max-stale 指令。</p><p><strong>proxy-revalidate 指令</strong><br> <code>Cache-Control: proxy-revalidate</code><br> proxy-revalidate 指令要求所有的缓存服务器在接收到客户端带有该指令的请求返回响应之前，必须再次验证缓存的有效性。</p><p><strong>no-transform 指令</strong><br> <code>Cache-Control: no-transform</code><br> 使用 no-transform 指令规定无论是在请求还是响应中，缓存都不能改变实体主体的媒体类型。这样做可防止缓存或代理压缩图片等类似操作。</p><h6 id="Cache-Control-扩展"><a href="#Cache-Control-扩展" class="headerlink" title="Cache-Control 扩展"></a>Cache-Control 扩展</h6><p><code>Cache-Control: private, community=&quot;UCI&quot;</code><br> 通过 cache-extension 标记（token），可以扩展 Cache-Control 首部字段内的指令。上述 community 指令即扩展的指令，如果缓存服务器不能理解这个新指令，就会直接忽略掉。</p><h5 id="Connection"><a href="#Connection" class="headerlink" title="Connection"></a>Connection</h5><p>Connection 首部字段具备以下两个作用：</p><p><strong>控制不再转发的首部字段</strong><br> <code>Connection: Upgrade</code><br> 在客户端发送请求和服务器返回响应中，使用 Connection 首部字段，可控制不再转发给代理的首部字段，即删除后再转发（即Hop-by-hop首部）。</p><p><strong>管理持久连接</strong><br> <code>Connection: close</code><br> HTTP/1.1 版本的默认连接都是持久连接。当服务器端想明确断开连接时，则指定 Connection 首部字段的值为 close。<br> <code>Connection: Keep-Alive</code><br> HTTP/1.1 之前的 HTTP 版本的默认连接都是非持久连接。为此，如果想在旧版本的 HTTP 协议上维持持续连接，则需要指定 Connection 首部字段的值为 Keep-Alive。</p><h5 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h5><p>表明创建 HTTP 报文的日期和时间。<br> <code>Date: Mon, 10 Jul 2017 15:50:06 GMT</code><br> HTTP/1.1 协议使用在 RFC1123 中规定的日期时间的格式。</p><h5 id="Pragma"><a href="#Pragma" class="headerlink" title="Pragma"></a>Pragma</h5><p>Pragma 首部字段是 HTTP/1.1 版本之前的历史遗留字段，仅作为与 HTTP/1.0 的向后兼容而定义。<br> <code>Pragma: no-cache</code></p><ul><li>该首部字段属于通用首部字段，但只用在客户端发送的请求中，要求所有的中间服务器不返回缓存的资源。</li><li>所有的中间服务器如果都能以 HTTP/1.1 为基准，那直接采用 <code>Cache-Control: no-cache</code> 指定缓存的处理方式最为理想。但是要整体掌握所有中间服务器使用的 HTTP 协议版本却是不现实的，所以，发送的请求会同时包含下面两个首部字段：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: no-cache</span><br><span class="line">Pragma: no-cache</span><br></pre></td></tr></table></figure><h5 id="Trailer"><a href="#Trailer" class="headerlink" title="Trailer"></a>Trailer</h5><p><code>Trailer: Expires</code><br> 首部字段 Trailer 会事先说明在报文主体后记录了哪些首部字段。可应用在 HTTP/1.1 版本分块传输编码时。</p><h5 id="Transfer-Encoding"><a href="#Transfer-Encoding" class="headerlink" title="Transfer-Encoding"></a>Transfer-Encoding</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Transfer-Encoding: chunked</span><br></pre></td></tr></table></figure><ul><li>规定了传输报文主体时采用的编码方式。</li><li>HTTP/1.1 的传输编码方式仅对分块传输编码有效。</li></ul><h5 id="Upgrade"><a href="#Upgrade" class="headerlink" title="Upgrade"></a>Upgrade</h5><p><code>Upgrade: TSL/1.0</code><br> 用于检测 HTTP 协议及其他协议是否可使用更高的版本进行通信，其参数值可以用来指定一个完全不同的通信协议。</p><h5 id="Via"><a href="#Via" class="headerlink" title="Via"></a>Via</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Via: 1.1 a1.sample.com(Squid/2.7)</span><br></pre></td></tr></table></figure><ul><li>为了追踪客户端和服务器端之间的请求和响应报文的传输路径。</li><li>报文经过代理或网关时，会现在首部字段 Via 中附加该服务器的信息，然后再进行转发。</li><li>首部字段 Via 不仅用于追踪报文的转发，还可避免请求回环的发生。</li></ul><h5 id="Warning"><a href="#Warning" class="headerlink" title="Warning"></a>Warning</h5><p>该首部字段通常会告知用户一些与缓存相关的问题的警告。<br> Warning 首部字段的格式如下：<br> <code>Warning：[警告码][警告的主机:端口号] &quot;[警告内容]&quot;([日期时间])</code><br> 最后的日期时间可省略。<br> HTTP/1.1 中定义了7种警告，警告码对应的警告内容仅推荐参考，另外，警告码具备扩展性，今后有可能追加新的警告码。</p><table><thead><tr><th>警告码</th><th>警告内容</th><th>说明</th></tr></thead><tbody><tr><td>110</td><td>Response is stale(响应已过期)</td><td>代理返回已过期的资源</td></tr><tr><td>111</td><td>Revalidation failed(再验证失败)</td><td>代理再验证资源有效性时失败（服务器无法到达等原因）</td></tr><tr><td>112</td><td>Disconnection operation(断开连接操作)</td><td>代理与互联网连接被故意切断</td></tr><tr><td>113</td><td>Heuristic expiration(试探性过期)</td><td>响应的试用期超过24小时(有效缓存的设定时间大于24小时的情况下)</td></tr><tr><td>199</td><td>Miscellaneous warning(杂项警告)</td><td>任意的警告内容</td></tr><tr><td>214</td><td>Transformation applied(使用了转换)</td><td>代理对内容编码或媒体类型等执行了某些处理时</td></tr><tr><td>299</td><td>Miscellaneous persistent warning(持久杂项警告)</td><td>任意的警告内容</td></tr></tbody></table><h4 id="请求首部字段（HTTP-1-1）"><a href="#请求首部字段（HTTP-1-1）" class="headerlink" title="请求首部字段（HTTP/1.1）"></a>请求首部字段（HTTP/1.1）</h4><table><thead><tr><th>首部字段名</th><th>说明</th></tr></thead><tbody><tr><td>Accept</td><td>用户代理可处理的媒体类型</td></tr><tr><td>Accept-Charset</td><td>优先的字符集</td></tr><tr><td>Accept-Encoding</td><td>优先的内容编码</td></tr><tr><td>Accept-Language</td><td>优先的语言（自然语言）</td></tr><tr><td>Authorization</td><td>Web认证信息</td></tr><tr><td>Expect</td><td>期待服务器的特定行为</td></tr><tr><td>From</td><td>用户的电子邮箱地址</td></tr><tr><td>Host</td><td>请求资源所在服务器</td></tr><tr><td>If-Match</td><td>比较实体标记（ETag）</td></tr><tr><td>If-Modified-Since</td><td>比较资源的更新时间</td></tr><tr><td>If-None-Match</td><td>比较实体标记（与 If-Macth 相反）</td></tr><tr><td>If-Range</td><td>资源未更新时发送实体 Byte 的范围请求</td></tr><tr><td>If-Unmodified-Since</td><td>比较资源的更新时间(与 If-Modified-Since 相反)</td></tr><tr><td>Max-Forwards</td><td>最大传输逐跳数</td></tr><tr><td>Proxy-Authorization</td><td>代理服务器要求客户端的认证信息</td></tr><tr><td>Range</td><td>实体的字节范围请求</td></tr><tr><td>Referer</td><td>对请求中 URI 的原始获取方</td></tr><tr><td>TE</td><td>传输编码的优先级</td></tr><tr><td>User-Agent</td><td>HTTP 客户端程序的信息</td></tr></tbody></table><h5 id="Accept"><a href="#Accept" class="headerlink" title="Accept"></a>Accept</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Accept: text/html, application/xhtml+xml, application/xml; q=0.5</span><br></pre></td></tr></table></figure><ul><li>Accept 首部字段可通知服务器，用户代理能够处理的媒体类型及媒体类型的相对优先级。可使用 type/subtype 这种形式，一次指定多种媒体类型。</li><li>若想要给显示的媒体类型增加优先级，则使用 <code>q=[数值]</code> 来表示权重值，用分号（;）进行分隔。权重值的范围 0~1（可精确到小数点后三位），且 1 为最大值。不指定权重值时，默认为 1。</li></ul><h5 id="Accept-Charset"><a href="#Accept-Charset" class="headerlink" title="Accept-Charset"></a>Accept-Charset</h5><p><code>Accept-Charset: iso-8859-5, unicode-1-1; q=0.8</code><br> Accept-Charset 首部字段可用来通知服务器用户代理支持的字符集及字符集的相对优先顺序。另外，可一次性指定多种字符集。同样使用 <code>q=[数值]</code> 来表示相对优先级。</p><h5 id="Accept-Encoding"><a href="#Accept-Encoding" class="headerlink" title="Accept-Encoding"></a>Accept-Encoding</h5><p><code>Accept-Encoding: gzip, deflate</code><br> Accept-Encoding 首部字段用来告知服务器用户代理支持的内容编码及内容编码的优先顺序，并可一次性指定多种内容编码。同样使用 <code>q=[数值]</code> 来表示相对优先级。也可使用星号（*）作为通配符，指定任意的编码格式。</p><h5 id="Accept-Language"><a href="#Accept-Language" class="headerlink" title="Accept-Language"></a>Accept-Language</h5><p><code>Accept-Lanuage: zh-cn,zh;q=0.7,en=us,en;q=0.3</code><br> 告知服务器用户代理能够处理的自然语言集（指中文或英文等），以及自然语言集的相对优先级，可一次性指定多种自然语言集。同样使用 <code>q=[数值]</code> 来表示相对优先级。</p><h5 id="Authorization"><a href="#Authorization" class="headerlink" title="Authorization"></a>Authorization</h5><p><code>Authorization: Basic ldfKDHKfkDdasSAEdasd==</code><br> 告知服务器用户代理的认证信息（证书值）。通常，想要通过服务器认证的用户代理会在接收到返回的 401 状态码响应后，把首部字段 Authorization 加入请求中。共用缓存在接收到含有 Authorization 首部字段的请求时的操作处理会略有差异。</p><h5 id="Expect"><a href="#Expect" class="headerlink" title="Expect"></a>Expect</h5><p><code>Expect: 100-continue</code><br> 告知服务器客户端期望出现的某种特定行为。</p><h5 id="5-7-From"><a href="#5-7-From" class="headerlink" title="5.7 From"></a>5.7 From</h5><p><code>From: Deeson_Woo@163.com</code><br> 告知服务器使用用户代理的电子邮件地址。</p><h5 id="Host"><a href="#Host" class="headerlink" title="Host"></a>Host</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Host: www.jianshu.com</span><br></pre></td></tr></table></figure><ul><li>告知服务器，请求的资源所处的互联网主机和端口号。</li><li><strong>Host 首部字段是 HTTP/1.1 规范内唯一一个必须被包含在请求内的首部字段。</strong></li><li>若服务器未设定主机名，那直接发送一个空值即可  <code>Host:</code> 。</li></ul><h5 id="If-Match"><a href="#If-Match" class="headerlink" title="If-Match"></a>If-Match</h5><p>形如 If-xxx 这种样式的请求首部字段，都可称为条件请求。服务器接收到附带条件的请求后，只有判断指定条件为真时，才会执行请求。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">If-Match: &quot;123456&quot;</span><br></pre></td></tr></table></figure><ul><li>首部字段 If-Match，属附带条件之一，它会告知服务器匹配资源所用的实体标记（ETag）值。这时的服务器无法使用弱 ETag 值。</li><li>服务器会比对 If-Match 的字段值和资源的 ETag 值，仅当两者一致时，才会执行请求。反之，则返回状态码 <code>412 Precondition Failed</code> 的响应。</li><li>还可以使用星号（*）指定 If-Match 的字段值。针对这种情况，服务器将会忽略 ETag 的值，只要资源存在就处理请求。</li></ul><h5 id="If-Modified-Since"><a href="#If-Modified-Since" class="headerlink" title="If-Modified-Since"></a>If-Modified-Since</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">If-Modified-Since: Mon, 10 Jul 2017 15:50:06 GMT</span><br></pre></td></tr></table></figure><ul><li>首部字段 If-Modified-Since，属附带条件之一，用于确认代理或客户端拥有的本地资源的有效性。</li><li>它会告知服务器若 If-Modified-Since 字段值早于资源的更新时间，则希望能处理该请求。而在指定 If-Modified-Since 字段值的日期时间之后，如果请求的资源都没有过更新，则返回状态码 <code>304 Not Modified</code> 的响应。</li></ul><h5 id="If-None-Match"><a href="#If-None-Match" class="headerlink" title="If-None-Match"></a>If-None-Match</h5><p><code>If-None-Match: &quot;123456&quot;</code><br> 首部字段 If-None-Match 属于附带条件之一。它和首部字段 If-Match 作用相反。用于指定 If-None-Match 字段值的实体标记（ETag）值与请求资源的 ETag 不一致时，它就告知服务器处理该请求。</p><h5 id="If-Range"><a href="#If-Range" class="headerlink" title="If-Range"></a>If-Range</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">If-Range: &quot;123456&quot;</span><br></pre></td></tr></table></figure><ul><li>首部字段 If-Range 属于附带条件之一。它告知服务器若指定的 If-Range 字段值（ETag 值或者时间）和请求资源的 ETag 值或时间相一致时，则作为范围请求处理。反之，则返回全体资源。</li><li>下面我们思考一下不使用首部字段 If-Range 发送请求的情况。服务器端的资源如果更新，那客户端持有资源中的一部分也会随之无效，当然，范围请求作为前提是无效的。这时，服务器会暂且以状态码 <code>412 Precondition Failed</code> 作为响应返回，其目的是催促客户端再次发送请求。这样一来，与使用首部字段 If-Range 比起来，就需要花费两倍的功夫。</li></ul><h5 id="If-Unmodified-Since"><a href="#If-Unmodified-Since" class="headerlink" title="If-Unmodified-Since"></a>If-Unmodified-Since</h5><p><code>If-Unmodified-Since: Mon, 10 Jul 2017 15:50:06 GMT</code><br> 首部字段 If-Unmodified-Since 和首部字段 If-Modified-Since 的作用相反。它的作用的是告知服务器，指定的请求资源只有在字段值内指定的日期时间之后，未发生更新的情况下，才能处理请求。如果在指定日期时间后发生了更新，则以状态码 <code>412 Precondition Failed</code> 作为响应返回。</p><h5 id="Max-Forwards"><a href="#Max-Forwards" class="headerlink" title="Max-Forwards"></a>Max-Forwards</h5><p><code>Max-Forwards: 10</code><br> 通过 TRACE 方法或 OPTIONS 方法，发送包含首部字段 Max-Forwards 的请求时，该字段以十进制整数形式指定可经过的服务器最大数目。服务器在往下一个服务器转发请求之前，Max-Forwards 的值减 1 后重新赋值。当服务器接收到 Max-Forwards 值为 0 的请求时，则不再进行转发，而是直接返回响应。</p><h5 id="Proxy-Authorization"><a href="#Proxy-Authorization" class="headerlink" title="Proxy-Authorization"></a>Proxy-Authorization</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Proxy-Authorization: Basic dGlwOjkpNLAGfFY5</span><br></pre></td></tr></table></figure><ul><li>接收到从代理服务器发来的认证质询时，客户端会发送包含首部字段 Proxy-Authorization 的请求，以告知服务器认证所需要的信息。</li><li>这个行为是与客户端和服务器之间的 HTTP 访问认证相类似的，不同之处在于，认证行为发生在客户端与代理之间。</li></ul><h5 id="Range"><a href="#Range" class="headerlink" title="Range"></a>Range</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Range: bytes=5001-10000</span><br></pre></td></tr></table></figure><ul><li>对于只需获取部分资源的范围请求，包含首部字段 Range 即可告知服务器资源的指定范围。</li><li>接收到附带 Range 首部字段请求的服务器，会在处理请求之后返回状态码为 <code>206 Partial Content</code> 的响应。无法处理该范围请求时，则会返回状态码 <code>200 OK</code> 的响应及全部资源。</li></ul><h5 id="Referer"><a href="#Referer" class="headerlink" title="Referer"></a>Referer</h5><p><code>Referer: http://www.sample.com/index.html</code><br> 首部字段 Referer 会告知服务器请求的原始资源的 URI。</p><h5 id="TE"><a href="#TE" class="headerlink" title="TE"></a>TE</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TE: gzip, deflate; q=0.5</span><br></pre></td></tr></table></figure><ul><li>首部字段 TE 会告知服务器客户端能够处理响应的传输编码方式及相对优先级。它和首部字段 Accept-Encoding 的功能很相像，但是用于传输编码。</li><li>首部字段 TE 除指定传输编码之外，还可以指定伴随 trailer 字段的分块传输编码的方式。应用后者时，只需把 trailers 赋值给该字段值。<code>TE: trailers</code> </li></ul><h5 id="User-Agent"><a href="#User-Agent" class="headerlink" title="User-Agent"></a>User-Agent</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64; rv:13.0) Gecko/20100101</span><br></pre></td></tr></table></figure><ul><li>首部字段 User-Agent 会将创建请求的浏览器和用户代理名称等信息传达给服务器。</li><li>由网络爬虫发起请求时，有可能会在字段内添加爬虫作者的电子邮件地址。此外，如果请求经过代理，那么中间也很可能被添加上代理服务器的名称。</li></ul><h4 id="响应首部字段（HTTP-1-1）"><a href="#响应首部字段（HTTP-1-1）" class="headerlink" title="响应首部字段（HTTP/1.1）"></a>响应首部字段（HTTP/1.1）</h4><table><thead><tr><th>首部字段名</th><th>说明</th></tr></thead><tbody><tr><td>Accept-Ranges</td><td>是否接受字节范围请求</td></tr><tr><td>Age</td><td>推算资源创建经过时间</td></tr><tr><td>ETag</td><td>资源的匹配信息</td></tr><tr><td>Location</td><td>令客户端重定向至指定 URI</td></tr><tr><td>Proxy-Authenticate</td><td>代理服务器对客户端的认证信息</td></tr><tr><td>Retry-After</td><td>对再次发起请求的时机要求</td></tr><tr><td>Server</td><td>HTTP 服务器的安装信息</td></tr><tr><td>Vary</td><td>代理服务器缓存的管理信息</td></tr><tr><td>WWW-Authenticate</td><td>服务器对客户端的认证信息</td></tr></tbody></table><h5 id="Accept-Ranges"><a href="#Accept-Ranges" class="headerlink" title="Accept-Ranges"></a>Accept-Ranges</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Accept-Ranges: bytes</span><br></pre></td></tr></table></figure><ul><li>首部字段 Accept-Ranges 是用来告知客户端服务器是否能处理范围请求，以指定获取服务器端某个部分的资源。</li><li>可指定的字段值有两种，可处理范围请求时指定其为 bytes，反之则指定其为 none。</li></ul><h5 id="Age"><a href="#Age" class="headerlink" title="Age"></a>Age</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Age: 1200</span><br></pre></td></tr></table></figure><ul><li>首部字段 Age 能告知客户端，源服务器在多久前创建了响应。字段值的单位为秒。</li><li>若创建该响应的服务器是缓存服务器，Age 值是指缓存后的响应再次发起认证到认证完成的时间值。代理创建响应时必须加上首部字段 Age。</li></ul><h5 id="ETag"><a href="#ETag" class="headerlink" title="ETag"></a>ETag</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ETag: &quot;usagi-1234&quot;</span><br></pre></td></tr></table></figure><ul><li>首部字段 ETag 能告知客户端实体标识。它是一种可将资源以字符串形式做唯一性标识的方式。服务器会为每份资源分配对应的 ETag 值。</li><li>另外，当资源更新时，ETag 值也需要更新。生成 ETag 值时，并没有统一的算法规则，而仅仅是由服务器来分配。</li><li>ETag 中有强 ETag 值和弱 ETag 值之分。强 ETag 值，不论实体发生多么细微的变化都会改变其值；弱 ETag 值只用于提示资源是否相同。只有资源发生了根本改变，产生差异时才会改变 ETag 值。这时，会在字段值最开始处附加 W/： <code>ETag: W/&quot;usagi-1234&quot;</code>。</li></ul><h5 id="Location"><a href="#Location" class="headerlink" title="Location"></a>Location</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Location: http://www.sample.com/sample.html</span><br></pre></td></tr></table></figure><ul><li>使用首部字段 Location 可以将响应接收方引导至某个与请求 URI 位置不同的资源。</li><li>基本上，该字段会配合 3xx ：Redirection 的响应，提供重定向的 URI。</li><li>几乎所有的浏览器在接收到包含首部字段 Location 的响应后，都会强制性地尝试对已提示的重定向资源的访问。</li></ul><h5 id="Proxy-Authenticate"><a href="#Proxy-Authenticate" class="headerlink" title="Proxy-Authenticate"></a>Proxy-Authenticate</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Proxy-Authenticate: Basic realm=&quot;Usagidesign Auth&quot;</span><br></pre></td></tr></table></figure><ul><li>首部字段 Proxy-Authenticate 会把由代理服务器所要求的认证信息发送给客户端。</li><li>它与客户端和服务器之间的 HTTP 访问认证的行为相似，不同之处在于其认证行为是在客户端与代理之间进行的。</li></ul><h5 id="Retry-After"><a href="#Retry-After" class="headerlink" title="Retry-After"></a>Retry-After</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Retry-After: 180</span><br></pre></td></tr></table></figure><ul><li>首部字段 Retry-After 告知客户端应该在多久之后再次发送请求。主要配合状态码 <code>503 Service Unavailable</code> 响应，或 3xx Redirect 响应一起使用。</li><li>字段值可以指定为具体的日期时间（Mon, 10 Jul 2017 15:50:06 GMT 等格式），也可以是创建响应后的秒数。</li></ul><h5 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h5><p><code>Server: Apache/2.2.6 (Unix) PHP/5.2.5</code><br> 首部字段 Server 告知客户端当前服务器上安装的 HTTP 服务器应用程序的信息。不单单会标出服务器上的软件应用名称，还有可能包括版本号和安装时启用的可选项。</p><h5 id="Vary"><a href="#Vary" class="headerlink" title="Vary"></a>Vary</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vary: Accept-Language</span><br></pre></td></tr></table></figure><ul><li>首部字段 Vary 可对缓存进行控制。源服务器会向代理服务器传达关于本地缓存使用方法的命令。</li><li>从代理服务器接收到源服务器返回包含 Vary 指定项的响应之后，若再要进行缓存，仅对请求中含有相同 Vary 指定首部字段的请求返回缓存。即使对相同资源发起请求，但由于 Vary 指定的首部字段不相同，因此必须要从源服务器重新获取资源。</li></ul><h5 id="WWW-Authenticate"><a href="#WWW-Authenticate" class="headerlink" title="WWW-Authenticate"></a>WWW-Authenticate</h5><p><code>WWW-Authenticate: Basic realm=&quot;Usagidesign Auth&quot;</code><br> 首部字段 WWW-Authenticate 用于 HTTP 访问认证。它会告知客户端适用于访问请求 URI 所指定资源的认证方案（Basic 或是 Digest）和带参数提示的质询（challenge）。</p><h4 id="实体首部字段（HTTP-1-1）"><a href="#实体首部字段（HTTP-1-1）" class="headerlink" title="实体首部字段（HTTP/1.1）"></a>实体首部字段（HTTP/1.1）</h4><table><thead><tr><th>首部字段名</th><th>说明</th></tr></thead><tbody><tr><td>Allow</td><td>资源可支持的 HTTP 方法</td></tr><tr><td>Content-Encoding</td><td>实体主体适用的编码方式</td></tr><tr><td>Content-Language</td><td>实体主体的自然语言</td></tr><tr><td>Content-Length</td><td>实体主体的大小（单位：字节）</td></tr><tr><td>Content-Location</td><td>替代对应资源的 URI</td></tr><tr><td>Content-MD5</td><td>实体主体的报文摘要</td></tr><tr><td>Content-Range</td><td>实体主体的位置范围</td></tr><tr><td>Content-Type</td><td>实体主体的媒体类型</td></tr><tr><td>Expires</td><td>实体主体过期的日期时间</td></tr><tr><td>Last-Modified</td><td>资源的最后修改日期时间</td></tr></tbody></table><h5 id="Allow"><a href="#Allow" class="headerlink" title="Allow"></a>Allow</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Allow: GET, HEAD</span><br></pre></td></tr></table></figure><ul><li>首部字段 Allow 用于通知客户端能够支持 Request-URI 指定资源的所有 HTTP 方法。</li><li>当服务器接收到不支持的 HTTP 方法时，会以状态码 <code>405 Method Not Allowed</code> 作为响应返回。与此同时，还会把所有能支持的 HTTP 方法写入首部字段 Allow 后返回。</li></ul><h5 id="Content-Encoding"><a href="#Content-Encoding" class="headerlink" title="Content-Encoding"></a>Content-Encoding</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Encoding: gzip</span><br></pre></td></tr></table></figure><ul><li>首部字段 Content-Encoding 会告知客户端服务器对实体的主体部分选用的内容编码方式。内容编码是指在不丢失实体信息的前提下所进行的压缩。</li><li>主要采用这 4 种内容编码的方式（gzip、compress、deflate、identity）。</li></ul><h5 id="Content-Language"><a href="#Content-Language" class="headerlink" title="Content-Language"></a>Content-Language</h5><p><code>Content-Language: zh-CN</code><br> 首部字段 Content-Language 会告知客户端，实体主体使用的自然语言（指中文或英文等语言）。</p><h5 id="Content-Length"><a href="#Content-Length" class="headerlink" title="Content-Length"></a>Content-Length</h5><p><code>Content-Length: 15000</code><br> 首部字段 Content-Length 表明了实体主体部分的大小（单位是字节）。对实体主体进行内容编码传输时，不能再使用 Content-Length首部字段。</p><h5 id="Content-Location"><a href="#Content-Location" class="headerlink" title="Content-Location"></a>Content-Location</h5><p><code>Content-Location: http://www.sample.com/index.html</code><br> 首部字段 Content-Location 给出与报文主体部分相对应的 URI。和首部字段 Location 不同，Content-Location 表示的是报文主体返回资源对应的 URI。</p><h5 id="Content-MD5"><a href="#Content-MD5" class="headerlink" title="Content-MD5"></a>Content-MD5</h5><p><code>Content-MD5: OGFkZDUwNGVhNGY3N2MxMDIwZmQ4NTBmY2IyTY==</code><br> 首部字段 Content-MD5 是一串由 MD5 算法生成的值，其目的在于检查报文主体在传输过程中是否保持完整，以及确认传输到达。</p><h5 id="Content-Range"><a href="#Content-Range" class="headerlink" title="Content-Range"></a>Content-Range</h5><p><code>Content-Range: bytes 5001-10000/10000</code><br> 针对范围请求，返回响应时使用的首部字段 Content-Range，能告知客户端作为响应返回的实体的哪个部分符合范围请求。字段值以字节为单位，表示当前发送部分及整个实体大小。</p><h5 id="Content-Type"><a href="#Content-Type" class="headerlink" title="Content-Type"></a>Content-Type</h5><p><code>Content-Type: text/html; charset=UTF-8</code><br> 首部字段 Content-Type 说明了实体主体内对象的媒体类型。和首部字段 Accept 一样，字段值用 type/subtype 形式赋值。参数 charset 使用 iso-8859-1 或 euc-jp 等字符集进行赋值。</p><h5 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Expires: Mon, 10 Jul 2017 15:50:06 GMT</span><br></pre></td></tr></table></figure><ul><li>首部字段 Expires 会将资源失效的日期告知客户端。</li><li>缓存服务器在接收到含有首部字段 Expires 的响应后，会以缓存来应答请求，在 Expires 字段值指定的时间之前，响应的副本会一直被保存。当超过指定的时间后，缓存服务器在请求发送过来时，会转向源服务器请求资源。</li><li>源服务器不希望缓存服务器对资源缓存时，最好在 Expires 字段内写入与首部字段 Date 相同的时间值。</li></ul><h5 id="Last-Modified"><a href="#Last-Modified" class="headerlink" title="Last-Modified"></a>Last-Modified</h5><p><code>Last-Modified: Mon, 10 Jul 2017 15:50:06 GMT</code><br> 首部字段 Last-Modified 指明资源最终修改的时间。一般来说，这个值就是 Request-URI 指定资源被修改的时间。但类似使用 CGI 脚本进行动态数据处理时，该值有可能会变成数据最终修改时的时间。</p><h4 id="为-Cookie-服务的首部字段"><a href="#为-Cookie-服务的首部字段" class="headerlink" title="为 Cookie 服务的首部字段"></a>为 Cookie 服务的首部字段</h4><table><thead><tr><th>首部字段名</th><th>说明</th><th>首部类型</th></tr></thead><tbody><tr><td>Set-Cookie</td><td>开始状态管理所使用的 Cookie 信息</td><td>响应首部字段</td></tr><tr><td>Cookie</td><td>服务器接收到的 Cookie 信息</td><td>请求首部字段</td></tr></tbody></table><h5 id="Set-Cookie"><a href="#Set-Cookie" class="headerlink" title="Set-Cookie"></a>Set-Cookie</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-Cookie: status=enable; expires=Mon, 10 Jul 2017 15:50:06 GMT; path=/;</span><br></pre></td></tr></table></figure><p>下面的表格列举了 Set-Cookie 的字段值。</p><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>NAME=VALUE</td><td>赋予 Cookie 的名称和其值（必需项）</td></tr><tr><td>expires=DATE</td><td>Cookie 的有效期（若不明确指定则默认为浏览器关闭前为止）</td></tr><tr><td>path=PATH</td><td>将服务器上的文件目录作为Cookie的适用对象（若不指定则默认为文档所在的文件目录）</td></tr><tr><td>domain=域名</td><td>作为 Cookie 适用对象的域名 （若不指定则默认为创建 Cookie的服务器的域名）</td></tr><tr><td>Secure</td><td>仅在 HTTPS 安全通信时才会发送 Cookie</td></tr><tr><td>HttpOnly</td><td>加以限制，使 Cookie 不能被 JavaScript 脚本访问</td></tr></tbody></table><h6 id="expires-属性"><a href="#expires-属性" class="headerlink" title="expires 属性"></a>expires 属性</h6><ul><li>Cookie 的 expires 属性指定浏览器可发送 Cookie 的有效期。</li><li>当省略 expires 属性时，其有效期仅限于维持浏览器会话（Session）时间段内。这通常限于浏览器应用程序被关闭之前。</li><li>另外，一旦 Cookie 从服务器端发送至客户端，服务器端就不存在可以显式删除 Cookie 的方法。但可通过覆盖已过期的 Cookie，实现对客户端 Cookie 的实质性删除操作。</li></ul><h6 id="path-属性"><a href="#path-属性" class="headerlink" title="path 属性"></a>path 属性</h6><p>Cookie 的 path 属性可用于限制指定 Cookie 的发送范围的文件目录。</p><h6 id="domain-属性"><a href="#domain-属性" class="headerlink" title="domain 属性"></a>domain 属性</h6><ul><li>通过 Cookie 的 domain 属性指定的域名可做到与结尾匹配一致。比如，当指定 <a href="https://link.jianshu.com?t=http://example.com" target="_blank" rel="noopener">example.com</a> 后，除<a href="https://link.jianshu.com?t=http://example.com" target="_blank" rel="noopener">example.com</a> 以外，<a href="https://link.jianshu.com?t=http://www.example.com" target="_blank" rel="noopener">www.example.com</a> 或 <a href="https://link.jianshu.com?t=http://www2.example.com" target="_blank" rel="noopener">www2.example.com</a> 等都可以发送 Cookie。</li><li>因此，除了针对具体指定的多个域名发送 Cookie 之 外，不指定 domain 属性显得更安全。</li></ul><h6 id="secure-属性"><a href="#secure-属性" class="headerlink" title="secure 属性"></a>secure 属性</h6><p>Cookie 的 secure 属性用于限制 Web 页面仅在 HTTPS 安全连接时，才可以发送 Cookie。</p><h6 id="HttpOnly-属性"><a href="#HttpOnly-属性" class="headerlink" title="HttpOnly 属性"></a>HttpOnly 属性</h6><ul><li>Cookie 的 HttpOnly 属性是 Cookie 的扩展功能，它使 JavaScript 脚本无法获得 Cookie。其主要目的为防止跨站脚本攻击（Cross-site scripting，XSS）对 Cookie 的信息窃取。</li><li>通过上述设置，通常从 Web 页面内还可以对 Cookie 进行读取操作。但使用 JavaScript 的 document.cookie 就无法读取附加 HttpOnly 属性后的 Cookie 的内容了。因此，也就无法在 XSS 中利用 JavaScript 劫持 Cookie 了。</li></ul><h5 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h5><p><code>Cookie: status=enable</code><br> 首部字段 Cookie 会告知服务器，当客户端想获得 HTTP 状态管理支持时，就会在请求中包含从服务器接收到的 Cookie。接收到多个 Cookie 时，同样可以以多个 Cookie 形式发送。</p><h4 id="其他首部字段"><a href="#其他首部字段" class="headerlink" title="其他首部字段"></a>其他首部字段</h4><p>HTTP 首部字段是可以自行扩展的。所以在 Web 服务器和浏览器的应用上，会出现各种非标准的首部字段。<br> 以下是最为常用的首部字段。</p><h5 id="X-Frame-Options"><a href="#X-Frame-Options" class="headerlink" title="X-Frame-Options"></a>X-Frame-Options</h5><p><code>X-Frame-Options: DENY</code><br> 首部字段 X-Frame-Options 属于 HTTP 响应首部，用于控制网站内容在其他 Web 网站的 Frame 标签内的显示问题。其主要目的是为了防止点击劫持（clickjacking）攻击。首部字段 X-Frame-Options 有以下两个可指定的字段值：</p><ul><li>DENY：拒绝</li><li>SAMEORIGIN：仅同源域名下的页面（Top-level-browsing-context）匹配时许可。（比如，当指定 <a href="https://link.jianshu.com?t=http://sample.com/sample.html" target="_blank" rel="noopener">http://sample.com/sample.html</a> 页面为 SAMEORIGIN 时，那么 <a href="https://link.jianshu.com?t=http://sample.com" target="_blank" rel="noopener">sample.com</a> 上所有页面的 frame 都被允许可加载该页面，而 <a href="https://link.jianshu.com?t=http://example.com" target="_blank" rel="noopener">example.com</a> 等其他域名的页面就不行了）</li></ul><h5 id="X-XSS-Protection"><a href="#X-XSS-Protection" class="headerlink" title="X-XSS-Protection"></a>X-XSS-Protection</h5><p><code>X-XSS-Protection: 1</code><br> 首部字段 X-XSS-Protection 属于 HTTP 响应首部，它是针对跨站脚本攻击（XSS）的一种对策，用于控制浏览器 XSS 防护机制的开关。首部字段 X-XSS-Protection 可指定的字段值如下:</p><ul><li>0 ：将 XSS 过滤设置成无效状态</li><li>1 ：将 XSS 过滤设置成有效状态</li></ul><h5 id="DNT"><a href="#DNT" class="headerlink" title="DNT"></a>DNT</h5><p><code>DNT: 1</code><br> 首部字段 DNT 属于 HTTP 请求首部，其中 DNT 是 Do Not Track 的简称，意为拒绝个人信息被收集，是表示拒绝被精准广告追踪的一种方法。首部字段 DNT 可指定的字段值如下：</p><ul><li>0 ：同意被追踪</li><li>1 ：拒绝被追踪</li></ul><p>由于首部字段 DNT 的功能具备有效性，所以 Web 服务器需要对 DNT做对应的支持。</p><h5 id="P3P"><a href="#P3P" class="headerlink" title="P3P"></a>P3P</h5><p><code>P3P: CP=&quot;CAO DSP LAW CURa ADMa DEVa TAIa PSAa PSDa IVAa IVDa OUR BUS IND</code><br> 首部字段 P3P 属于 HTTP 响应首部，通过利用 P3P（The Platform for Privacy Preferences，在线隐私偏好平台）技术，可以让 Web 网站上的个人隐私变成一种仅供程序可理解的形式，以达到保护用户隐私的目的。<br> 要进行 P3P 的设定，需按以下操作步骤进行：</p><ul><li>步骤 1：创建 P3P 隐私</li><li>步骤 2：创建 P3P 隐私对照文件后，保存命名在 /w3c/p3p.xml</li><li>步骤 3：从 P3P 隐私中新建 Compact policies 后，输出到 HTTP 响应中</li></ul><h3 id="HTTP-响应状态码（重点分析）"><a href="#HTTP-响应状态码（重点分析）" class="headerlink" title="HTTP 响应状态码（重点分析）"></a>HTTP 响应状态码（重点分析）</h3><h4 id="状态码概述"><a href="#状态码概述" class="headerlink" title="状态码概述"></a>状态码概述</h4><ul><li>HTTP 状态码负责表示客户端 HTTP 请求的返回结果、标记服务器端的处理是否正常、通知出现的错误等工作。</li><li>HTTP 状态码如 <code>200 OK</code> ，以 3 位数字和原因短语组成。数字中的第一位指定了响应类别，后两位无分类。</li><li>不少返回的响应状态码都是错误的，但是用户可能察觉不到这点。比如 Web 应用程序内部发生错误，状态码依然返回 <code>200 OK</code>。</li></ul><h4 id="状态码类别"><a href="#状态码类别" class="headerlink" title="状态码类别"></a>状态码类别</h4><table><thead><tr><th></th><th>类别</th><th>原因短语</th></tr></thead><tbody><tr><td>1xx</td><td>Informational(信息性状态码)</td><td>接收的请求正在处理</td></tr><tr><td>2xx</td><td>Success(成功状态码)</td><td>请求正常处理完毕</td></tr><tr><td>3xx</td><td>Redirection(重定向状态码)</td><td>需要进行附加操作以完成请求</td></tr><tr><td>4xx</td><td>Client Error(客户端错误状态码)</td><td>服务器无法处理请求</td></tr><tr><td>5xx</td><td>Server Error(服务器错误状态码)</td><td>服务器处理请求出错</td></tr></tbody></table><p>我们可以自行改变 RFC2616 中定义的状态码或者服务器端自行创建状态码，只要遵守状态码的类别定义就可以了。</p><h4 id="常用状态码解析"><a href="#常用状态码解析" class="headerlink" title="常用状态码解析"></a>常用状态码解析</h4><p>HTTP 状态码种类繁多，数量达几十种。其中最常用的有以下 14 种，一起来看看。</p><h5 id="200-OK"><a href="#200-OK" class="headerlink" title="200 OK"></a>200 OK</h5><p>表示从客户端发来的请求在服务器端被正常处理了。</p><h5 id="204-No-Content"><a href="#204-No-Content" class="headerlink" title="204 No Content"></a>204 No Content</h5><ul><li>代表服务器接收的请求已成功处理，但在返回的响应报文中不含实体的主体部分。另外，也不允许返回任何实体的主体。</li><li>一般在只需要从客户端向服务器端发送消息，而服务器端不需要向客户端发送新消息内容的情况下使用。</li></ul><h5 id="206-Partial-Content"><a href="#206-Partial-Content" class="headerlink" title="206 Partial Content"></a>206 Partial Content</h5><p>表示客户端进行了范围请求，而服务器成功执行了这部分的 GET 请求。响应报文中包含由 Content-Range 首部字段指定范围的实体内容。</p><h5 id="301-Moved-Permanently"><a href="#301-Moved-Permanently" class="headerlink" title="301 Moved Permanently"></a>301 Moved Permanently</h5><p>永久性重定向。表示请求的资源已被分配了新的 URI。以后应使用资源现在所指的 URI。也就是说，如果已经把资源对应的 URI 保存为书签了，这时应该按 Location 首部字段提示的 URI 重新保存。</p><h5 id="302-Found"><a href="#302-Found" class="headerlink" title="302 Found"></a>302 Found</h5><ul><li>临时性重定向。表示请求的资源已被分配了新的 URI，希望用户（本次）能使用新的 URI 访问。</li><li>和 <code>301 Moved Permanently</code> 状态码相似，但 <code>302 Found</code> 状态码代表资源不是被永久移动，只是临时性质的。换句话说，已移动的资源对应的 URI 将来还有可能发生改变。</li></ul><h5 id="303-See-Other"><a href="#303-See-Other" class="headerlink" title="303 See Other"></a>303 See Other</h5><ul><li>表示由于请求的资源存在着另一个 URI，应使用 GET 方法定向获取请求的资源。</li><li><code>303 See Othe</code>r 和 <code>302 Found</code> 状态码有着相同的功能，但 <code>303 See Other</code> 状态码明确表示客户端应采用 GET 方法获取资源，这点与 <code>302 Found</code> 状态码有区别。</li></ul><h5 id="304-Not-Modified"><a href="#304-Not-Modified" class="headerlink" title="304 Not Modified"></a>304 Not Modified</h5><ul><li>表示客户端发送附带条件的请求时，服务器端允许请求访问的资源，但未满足条件的情况。</li><li><code>304 Not Modified</code> 状态码返回时，不包含任何响应的主体部分。</li><li><code>304 Not Modified</code> 虽然被划分到 3xx 类别中，但和重定向没有关系。</li></ul><h5 id="307-Temporary-Redirect"><a href="#307-Temporary-Redirect" class="headerlink" title="307 Temporary Redirect"></a>307 Temporary Redirect</h5><p>临时重定向。该状态码与 <code>302 Found</code> 有着相同的含义。</p><h5 id="400-Bad-Request"><a href="#400-Bad-Request" class="headerlink" title="400 Bad Request"></a>400 Bad Request</h5><ul><li>表示请求报文中存在语法错误。当错误发生时，需修改请求的内容后再次发送请求。</li><li>另外，浏览器会像 <code>200 OK</code> 一样对待该状态码。</li></ul><h5 id="401-Unauthorized"><a href="#401-Unauthorized" class="headerlink" title="401 Unauthorized"></a>401 Unauthorized</h5><ul><li>表示发送的请求需要有通过 HTTP 认证（BASIC 认证、DIGEST 认证）的认证信息。</li><li>另外，若之前已进行过 1 次请求，则表示用户认证失败。</li><li>返回含有 <code>401 Unauthorized</code> 的响应必须包含一个适用于被请求资源的 WWW-Authenticate 首部用以质询（challenge）用户信息。</li></ul><h5 id="403-Forbidden"><a href="#403-Forbidden" class="headerlink" title="403 Forbidden"></a>403 Forbidden</h5><p>表明对请求资源的访问被服务器拒绝了。服务器端没有必要给出详细的拒绝理由，当然也可以在响应报文的实体主体部分对原因进行描述。</p><h5 id="404-Not-Found"><a href="#404-Not-Found" class="headerlink" title="404 Not Found"></a>404 Not Found</h5><p>表明服务器上无法找到请求的资源。除此之外，也可以在服务器端拒绝请求且不想说明理由的时候使用。</p><h5 id="500-Internal-Server-Error"><a href="#500-Internal-Server-Error" class="headerlink" title="500 Internal Server Error"></a>500 Internal Server Error</h5><p>表明服务器端在执行请求时发生了错误。也可能是 Web 应用存在的 bug 或某些临时的故障。</p><h5 id="503-Service-Unavailable"><a href="#503-Service-Unavailable" class="headerlink" title="503 Service Unavailable"></a>503 Service Unavailable</h5><p>表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。如果事先得知解除以上状况需要的时间，最好写入 Retry-After 首部字段再返回给客户端。</p><h3 id="HTTP-报文实体"><a href="#HTTP-报文实体" class="headerlink" title="HTTP 报文实体"></a>HTTP 报文实体</h3><h4 id="HTTP-报文实体概述"><a href="#HTTP-报文实体概述" class="headerlink" title="HTTP 报文实体概述"></a>HTTP 报文实体概述</h4><p><img src="https://github.com/AlexBruceLu/DAPP/wiki/http13_1.webp" alt="HTTP 报文结构"></p><p>大家请仔细看看上面示例中，各个组成部分对应的内容。<br> 接着，我们来看看报文和实体的概念。如果把 HTTP 报文想象成因特网货运系统中的箱子，那么 HTTP 实体就是报文中实际的货物。</p><ul><li>报文：是网络中交换和传输的数据单元，即站点一次性要发送的数据块。报文包含了将要发送的完整的数据信息，其长短很不一致，长度不限且可变。</li><li>实体：作为请求或响应的有效载荷数据（补充项）被传输，其内容由实体首部和实体主体组成。（实体首部相关内容在上面第六点中已有阐述。）</li></ul><p>我们可以看到，上面示例右图中深红色框的内容就是报文的实体部分，而蓝色框的两部分内容分别就是实体首部和实体主体。而左图中粉红框内容就是报文主体。<br> <strong>通常，报文主体等于实体主体。只有当传输中进行编码操作时，实体主体的内容发生变化，才导致它和报文主体产生差异。</strong></p><h4 id="内容编码"><a href="#内容编码" class="headerlink" title="内容编码"></a>内容编码</h4><ul><li>HTTP 应用程序有时在发送之前需要对内容进行编码。例如，在把很大的 HTML 文档发送给通过慢速连接上来的客户端之前，服务器可能会对其进行压缩，这样有助于减少传输实体的时间。服务器还可以把内容搅乱或加密，以此来防止未授权的第三方看到文档的内容。</li><li>这种类型的编码是在发送方应用到内容之上的。当内容经过内容编码后，编好码的数据就放在实体主体中，像往常一样发送给接收方。</li></ul><p>内容编码类型：</p><table><thead><tr><th>编码方式</th><th>描述</th></tr></thead><tbody><tr><td>gzip</td><td>表明实体采用 GNU zip 编码</td></tr><tr><td>compress</td><td>表明实体采用 Unix 的文件压缩程序</td></tr><tr><td>deflate</td><td>表明实体采用 zlib 的格式压缩的</td></tr><tr><td>identity</td><td>表明没有对实体进行编码，当没有 Content-Encoding 首部字段时，默认采用此编码方式</td></tr></tbody></table><h4 id="传输编码"><a href="#传输编码" class="headerlink" title="传输编码"></a>传输编码</h4><p>内容编码是对报文的主体进行的可逆变换，是和内容的具体格式细节紧密相关的。<br> 传输编码也是作用在实体主体上的可逆变换，但使用它们是由于架构方面的原因，同内容的格式无关。使用传输编码是为了改变报文中的数据在网络上传输的方式。</p><p><img src="https://github.com/AlexBruceLu/DAPP/wiki/http13_3.webp" alt=""></p><h4 id="分块编码"><a href="#分块编码" class="headerlink" title="分块编码"></a>分块编码</h4><p>分块编码把报文分割成若干已知大小的块。块之间是紧挨着发送的，这样就不需要在发送之前知道整个报文的大小了。分块编码是一种传输编码，是报文的属性。</p><h5 id="分块编码与持久连接"><a href="#分块编码与持久连接" class="headerlink" title="分块编码与持久连接"></a><strong>分块编码与持久连接</strong></h5><p> 若客户端与服务器端之间不是持久连接，客户端就不需要知道它在读取的主体的长度，而只需要读取到服务器关闭主体连接为止。<br> 当使用持久连接时，在服务器写主体之前，必须知道它的大小并在 Content-Length 首部中发送。如果服务器动态创建内容，就可能在发送之前无法知道主体的长度。<br> 分块编码为这种困难提供了解决方案，只要允许服务器把主体分块发送，说明每块的大小就可以了。因为主体是动态创建的，服务器可以缓冲它的一部分，发送其大小和相应的块，然后在主体发送完之前重复这个过程。服务器可以用大小为 0 的块作为主体结束的信号，这样就可以继续保持连接，为下一个响应做准备。<br> 来看看一个分块编码的报文示例：</p><p><img src="https://github.com/AlexBruceLu/DAPP/wiki/http13_2.webp" alt=""></p><h4 id="多部分媒体类型"><a href="#多部分媒体类型" class="headerlink" title="多部分媒体类型"></a>多部分媒体类型</h4><p>MIME 中的 multipart（多部分）电子邮件报文中包含多个报文，它们合在一起作为单一的复杂报文发送。每一部分都是独立的，有各自的描述其内容的集，不同部分之间用分界字符串连接在一起。<br> 相应得，HTTP 协议中也采纳了多部分对象集合，发送的一份报文主体内可包含多种类型实体。<br> 多部分对象集合包含的对象如下：</p><ul><li>multipart/form-data：在 Web 表单文件上传时使用。</li><li>multipart/byteranges：状态码 <code>206 Partial Content</code> 响应报文包含了多个范围的内容时使用。</li></ul><h4 id="范围请求"><a href="#范围请求" class="headerlink" title="范围请求"></a>范围请求</h4><p>假设你正在下载一个很大的文件，已经下了四分之三，忽然网络中断了，那下载就必须重头再来一遍。为了解决这个问题，需要一种可恢复的机制，即能从之前下载中断处恢复下载。要实现该功能，这就要用到范围请求。<br> 有了范围请求， HTTP 客户端可以通过请求曾获取失败的实体的一个范围（或者说一部分），来恢复下载该实体。当然这有一个前提，那就是从客户端上一次请求该实体到这一次发出范围请求的时间段内，该对象没有改变过。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GET  /bigfile.html  HTTP/1.1</span><br><span class="line">Host: www.sample.com</span><br><span class="line">Range: bytes=20224-</span><br><span class="line">···</span><br></pre></td></tr></table></figure><p><img src="https://github.com/AlexBruceLu/DAPP/wiki/http13_4.webp" alt=""></p><p>上面示例中，客户端请求的是文档开头20224字节之后的部分。</p><h3 id="与-HTTP-协作的-Web-服务器"><a href="#与-HTTP-协作的-Web-服务器" class="headerlink" title="与 HTTP 协作的 Web 服务器"></a>与 HTTP 协作的 Web 服务器</h3><p>HTTP 通信时，除客户端和服务器外，还有一些用于协助通信的应用程序。如下列出比较重要的几个：<strong>代理、缓存、网关、隧道、Agent 代理</strong>。</p><h4 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h4><p><img src="https://github.com/AlexBruceLu/DAPP/wiki/http13_5.webp" alt=""></p><p>HTTP 代理服务器是 Web 安全、应用集成以及性能优化的重要组成模块。代理位于客户端和服务器端之间，接收客户端所有的 HTTP 请求，并将这些请求转发给服务器（可能会对请求进行修改之后再进行转发）。对用户来说，这些应用程序就是一个代理，代表用户访问服务器。<br> 出于安全考虑，通常会将代理作为转发所有 Web 流量的可信任中间节点使用。代理还可以对请求和响应进行过滤，安全上网或绿色上网。</p><h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h4><p><strong>浏览器第一次请求：</strong></p><p><img src="https://github.com/AlexBruceLu/DAPP/wiki/http13_6.webp" alt=""></p><p><strong>浏览器再次请求：</strong></p><p><img src="https://github.com/AlexBruceLu/DAPP/wiki/http13_7.webp" alt=""></p><p>Web 缓存或代理缓存是一种特殊的 HTTP 代理服务器，可以将经过代理传输的常用文档复制保存起来。下一个请求同一文档的客户端就可以享受缓存的私有副本所提供的服务了。客户端从附近的缓存下载文档会比从远程 Web 服务器下载快得多。</p><h4 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h4><p><img src="https://github.com/AlexBruceLu/DAPP/wiki/http13_8.webp" alt=""></p><p>网关是一种特殊的服务器，作为其他服务器的中间实体使用。通常用于将 HTTP 流量转换成其他的协议。网关接收请求时就好像自己是资源的源服务器一样。客户端可能并不知道自己正在跟一个网关进行通信。</p><h4 id="隧道"><a href="#隧道" class="headerlink" title="隧道"></a>隧道</h4><p><img src="https://github.com/AlexBruceLu/DAPP/wiki/http13_9.webp" alt=""></p><p>隧道是会在建立起来之后，就会在两条连接之间对原始数据进行盲转发的 HTTP 应用程序。HTTP 隧道通常用来在一条或多条 HTTP 连接上转发非 HTTP 数据，转发时不会窥探数据。<br> HTTP 隧道的一种常见用途就是通过 HTTP 连接承载加密的安全套接字层（SSL）流量，这样 SSL 流量就可以穿过只允许 Web 流量通过的防火墙了。</p><h4 id="Agent-代理"><a href="#Agent-代理" class="headerlink" title="Agent 代理"></a>Agent 代理</h4><p><img src="https://github.com/AlexBruceLu/DAPP/wiki/http13_10.webp" alt=""></p><p>Agent 代理是代表用户发起 HTTP 请求的客户端应用程序。所有发布 Web 请求的应用程序都是 HTTP Agent 代理。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt; 详解http协议：&lt;/strong&gt; &lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;/excerpt&gt;&lt;/p&gt;
&lt;p&gt;http网络协议的详解概述&lt;/p&gt;
    
    </summary>
    
      <category term="others" scheme="https://alexbrucelu.github.io/categories/others/"/>
    
    
      <category term="http/https" scheme="https://alexbrucelu.github.io/tags/http-https/"/>
    
  </entry>
  
  <entry>
    <title>http与https协议的区别</title>
    <link href="https://alexbrucelu.github.io/2018/12/03/http%E7%BD%91%E7%BB%9C/"/>
    <id>https://alexbrucelu.github.io/2018/12/03/http网络/</id>
    <published>2018-12-03T12:51:11.660Z</published>
    <updated>2018-12-05T07:45:45.513Z</updated>
    
    <content type="html"><![CDATA[<p><strong> http与https协议的区别：</strong> <excerpt in="" index="" |="" 首页摘要=""></excerpt></p><p>相关概念</p><a id="more"></a><p>[TOC]</p><p>超文本传输协议HTTP协议被用于在Web浏览器和网站服务器之间传递信息，HTTP协议以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此，HTTP协议不适合传输一些敏感信息，比如：信用卡号、密码等支付信息。</p><p>　　为了解决HTTP协议的这一缺陷，需要使用另一种协议：安全套接字层超文本传输协议HTTPS，为了数据传输的安全，HTTPS在HTTP的基础上加入了SSL协议，SSL依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。</p><h3 id="一、HTTP和HTTPS的基本概念"><a href="#一、HTTP和HTTPS的基本概念" class="headerlink" title="一、HTTP和HTTPS的基本概念"></a><strong>一、HTTP和HTTPS的基本概念</strong></h3><p>　　HTTP：是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。</p><p>　　HTTPS：是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。</p><p>　　HTTPS协议的主要作用可以分为两种：一种是建立一个信息安全通道，来保证数据传输的安全；另一种就是确认网站的真实性。</p><h3 id="二、HTTP与HTTPS有什么区别？"><a href="#二、HTTP与HTTPS有什么区别？" class="headerlink" title="二、HTTP与HTTPS有什么区别？"></a><strong>二、HTTP与HTTPS有什么区别？</strong></h3><p>　　HTTP协议传输的数据都是未加密的，也就是明文的，因此使用HTTP协议传输隐私信息非常不安全，为了保证这些隐私数据能加密传输，于是网景公司设计了SSL（Secure Sockets Layer）协议用于对HTTP协议传输的数据进行加密，从而就诞生了HTTPS。简单来说，HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全。</p><p>HTTPS和HTTP的区别主要如下：</p><p>　　1、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。</p><p>　　2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。</p><p>　　3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</p><p>　　4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</p><h3 id="三、HTTPS的工作原理"><a href="#三、HTTPS的工作原理" class="headerlink" title="三、HTTPS的工作原理"></a><strong>三、HTTPS的工作原理</strong></h3><p>　　我们都知道HTTPS能够加密信息，以免敏感信息被第三方获取，所以很多银行网站或电子邮箱等等安全级别较高的服务都会采用HTTPS协议。</p><p><img src="https://github.com/AlexBruceLu/DAPP/wiki/http1.jpg" alt=""></p><p>客户端在使用HTTPS方式与Web服务器通信时有以下几个步骤，如图所示。</p><p>　　（1）客户使用https的URL访问Web服务器，要求与Web服务器建立SSL连接。</p><p>　　（2）Web服务器收到客户端请求后，会将网站的证书信息（证书中包含公钥）传送一份给客户端。</p><p>　　（3）客户端的浏览器与Web服务器开始协商SSL连接的安全等级，也就是信息加密的等级。</p><p>　　（4）客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站。</p><p>　　（5）Web服务器利用自己的私钥解密出会话密钥。</p><p>　　（6）Web服务器利用会话密钥加密与客户端之间的通信。</p><p><img src="https://github.com/AlexBruceLU/DAPP/wiki/http2.gif" alt=""></p><h3 id="四、HTTPS的优点"><a href="#四、HTTPS的优点" class="headerlink" title="四、HTTPS的优点"></a><strong>四、HTTPS的优点</strong></h3><p>　　尽管HTTPS并非绝对安全，掌握根证书的机构、掌握加密算法的组织同样可以进行中间人形式的攻击，但HTTPS仍是现行架构下最安全的解决方案，主要有以下几个好处：</p><p>　　（1）使用HTTPS协议可认证用户和服务器，确保数据发送到正确的客户机和服务器；</p><p>　　（2）HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性。</p><p>　　（3）HTTPS是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。</p><p>　　（4）谷歌曾在2014年8月份调整搜索引擎算法，并称“比起同等HTTP网站，采用HTTPS加密的网站在搜索结果中的排名将会更高”。</p><h3 id="五、HTTPS的缺点"><a href="#五、HTTPS的缺点" class="headerlink" title="五、HTTPS的缺点"></a><strong>五、HTTPS的缺点</strong></h3><p>　　虽然说HTTPS有很大的优势，但其相对来说，还是存在不足之处的：</p><p>　　（1）HTTPS协议握手阶段比较费时，会使页面的加载时间延长近50%，增加10%到20%的耗电；</p><p>　　（2）HTTPS连接缓存不如HTTP高效，会增加数据开销和功耗，甚至已有的安全措施也会因此而受到影响；</p><p>　　（3）SSL证书需要钱，功能越强大的证书费用越高，个人网站、小网站没有必要一般不会用。</p><p>　   （4）SSL证书通常需要绑定IP，不能在同一IP上绑定多个域名，IPv4资源不可能支撑这个消耗。</p><p>　　（5）HTTPS协议的加密范围也比较有限，在黑客攻击、拒绝服务攻击、服务器劫持等方面几乎起不到什么作用。最关键的，SSL证书的信用链体系并不安全，特别是在某些国家可以控制CA根证书的情况下，中间人攻击一样可行。</p><h3 id="六、http切换到HTTPS"><a href="#六、http切换到HTTPS" class="headerlink" title="六、http切换到HTTPS"></a><strong>六、http切换到HTTPS</strong></h3><p>　　如果需要将网站从http切换到https到底该如何实现呢？</p><p>​     这里需要将页面中所有的链接，例如js，css，图片等等链接都由http改为https。例如：<a href="http://www.baidu.com改为https://www.baidu.com" target="_blank" rel="noopener">http://www.baidu.com改为https://www.baidu.com</a></p><p>　　BTW，这里虽然将http切换为了https，还是建议保留http。所以我们在切换的时候可以做http和https的兼容，具体实现方式是，去掉页面链接中的http头部，这样可以自动匹配http头和https头。例如：将<a href="http://www.baidu.com改为//www.baidu.com。然后当用户从http的入口进入访问页面时，页面就是http，如果用户是从https的入口进入访问页面，页面即使https的。" target="_blank" rel="noopener">http://www.baidu.com改为//www.baidu.com。然后当用户从http的入口进入访问页面时，页面就是http，如果用户是从https的入口进入访问页面，页面即使https的。</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt; http与https协议的区别：&lt;/strong&gt; &lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;/excerpt&gt;&lt;/p&gt;
&lt;p&gt;相关概念&lt;/p&gt;
    
    </summary>
    
      <category term="others" scheme="https://alexbrucelu.github.io/categories/others/"/>
    
    
      <category term="http/https" scheme="https://alexbrucelu.github.io/tags/http-https/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes（K8s）</title>
    <link href="https://alexbrucelu.github.io/2018/12/03/k8s/"/>
    <id>https://alexbrucelu.github.io/2018/12/03/k8s/</id>
    <published>2018-12-03T03:26:59.684Z</published>
    <updated>2018-12-03T07:39:42.363Z</updated>
    
    <content type="html"><![CDATA[<p><strong> Kubernetes（K8s）：</strong> <excerpt in="" index="" |="" 首页摘要=""></excerpt></p><p>Kubernetes 的简介和基本操作</p><a id="more"></a><p>[TOC]</p><h2 id="为什么叫k8s"><a href="#为什么叫k8s" class="headerlink" title="为什么叫k8s"></a>为什么叫k8s</h2><p>Kubernetes（K8s）是Google在2014年发布的一个开源项目 。而且<code>k</code>和<code>s</code>之间有八个字母间隔，所以叫做k8s。</p><h2 id="k8s-的基本概念"><a href="#k8s-的基本概念" class="headerlink" title="k8s 的基本概念"></a>k8s 的基本概念</h2><ul><li><p><strong>Cluster（集群 )</strong></p><blockquote><p>Cluster是计算、存储和网络资源的集合，Kubernetes利用这些资源运行各种基于容器的应用。 </p></blockquote></li><li><p><strong>Master（控制主节点）</strong></p><blockquote><p>Master是Cluster的大脑，它的主要职责是调度，即决定将应用放在哪里运行。Master运行Linux操作系统，可以是物理机或者虚拟机。为了实现高可用，可以运行多个Master。调度应用程序、维护应用程序的所需状态、扩展应用程序和滚动更新都是master的主要工作。 </p></blockquote></li><li><p><strong>Node（节点）</strong> </p><blockquote><p>Node的职责是运行容器应用。Node由Master管理，Node负责监控并汇报容器的状态，同时根据Master的要求管理容器的生命周期。<br>Node是 Kubernetes 集群中的工作机器，可以是物理机或虚拟机。每个工作节点都有一个 kubelet，它是管理节点并与 Kubernetes Master 节点进行通信的代理。节点上还应具有处理容器操作的容器运行时，例如 Docker。<br>一个 Kubernetes 工作集群至少有三个节点。 Master 管理集群，而 Node（节点）用于托管正在运行的应用程序。<br>当你在 Kubernetes 上部署应用程序时，你可以告诉 master 启动应用程序容器。Master 调度容器在集群的节点上运行。 节点使用 Master 公开的 Kubernetes API 与 Master 通信。用户也可以直接使用 Kubernetes 的 API 与集群交互 。</p></blockquote></li></ul><p><img src="https://github.com/AlexBruceLu/DAPP/wiki/k8s.png" alt=""></p><ul><li><p><strong>Pod（资源对象） </strong></p><blockquote><p>Pod是Kubernetes的最小工作单元。每个Pod包含一个或多个容器。Pod中的容器会作为一个整体被Master调度到一个Node上运行。<br>Kubernetes引入Pod主要基于下面两个目的： </p><p>（1）可管理性。 有些容器天生就是需要紧密联系，一起工作。Pod提供了比容器更高层次的抽象，将它们封装到一个部署单元中。Kubernetes以Pod为最小单位进行调度、扩展、共享资源、管理生命周期。 </p><p>（2）通信和资源共享。 Pod中的所有容器使用同一个网络namespace，即相同的IP地址和Port空间。它们可以直接用localhost通信。同样的，这些容器可以共享存储，当Kubernetes挂载volume到<br>Pod，本质上是将volume挂载到 Pod中的每一个容器。Pods有两种使用方式：<br><strong>（1）运行单一容器。</strong><br>one-container-per-Pod是Kubernetes最常见的模型，这种情况下，只是将单个容器简单封装成Pod。即便是只有一个容器，Kubernetes管理的也是Pod而不是直接管理容器。<br><strong>（2）运行多个容器。</strong><br>问题在于：哪些容器应该放到一个Pod中？ 答案是：这些容器联系必须非常紧密，而且需要直接共享资源。举个例子，如图 所示，这个Pod包含两个容器：一个是File Puller(文件拉取器)，一个是Web Server。 </p></blockquote></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt; Kubernetes（K8s）：&lt;/strong&gt; &lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;/excerpt&gt;&lt;/p&gt;
&lt;p&gt;Kubernetes 的简介和基本操作&lt;/p&gt;
    
    </summary>
    
      <category term="docker" scheme="https://alexbrucelu.github.io/categories/docker/"/>
    
    
      <category term="k8s" scheme="https://alexbrucelu.github.io/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>Solidity基础语法</title>
    <link href="https://alexbrucelu.github.io/2018/12/01/Solidity%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    <id>https://alexbrucelu.github.io/2018/12/01/Solidity基础语法/</id>
    <published>2018-12-01T14:52:06.022Z</published>
    <updated>2018-12-01T14:54:53.777Z</updated>
    
    <content type="html"><![CDATA[<p><strong> Solidity基础语法：</strong> <excerpt in="" index="" |="" 首页摘要=""></excerpt></p><p>solidity 基础语法的介绍</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt; Solidity基础语法：&lt;/strong&gt; &lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;/excerpt&gt;&lt;/p&gt;
&lt;p&gt;solidity 基础语法的介绍&lt;/p&gt;
    
    </summary>
    
      <category term="dapp" scheme="https://alexbrucelu.github.io/categories/dapp/"/>
    
    
      <category term="solidity" scheme="https://alexbrucelu.github.io/tags/solidity/"/>
    
  </entry>
  
  <entry>
    <title>HyperLedger Fabric</title>
    <link href="https://alexbrucelu.github.io/2018/12/01/HyperledgerFabric01/"/>
    <id>https://alexbrucelu.github.io/2018/12/01/HyperledgerFabric01/</id>
    <published>2018-12-01T14:45:58.103Z</published>
    <updated>2018-12-03T03:41:50.446Z</updated>
    
    <content type="html"><![CDATA[<p><strong> HyperLedger Fabric：</strong> <excerpt in="" index="" |="" 首页摘要=""></excerpt></p><p>HyperLedger基础概念简介，以及核心模块的介绍</p><a id="more"></a><p>[TOC]</p><h1 id="Fabric基本概念"><a href="#Fabric基本概念" class="headerlink" title="Fabric基本概念"></a>Fabric基本概念</h1><h2 id="1-逻辑架构"><a href="#1-逻辑架构" class="headerlink" title="1. 逻辑架构"></a>1. 逻辑架构</h2><p><img src="https://github.com/AlexBruceLu/DAPP/wiki/fen.png" alt=""></p><ul><li><strong>成员管理（MemberShip）</strong><ul><li>会员注册<ul><li>注册成功一个账号得到的不是用户名密码</li><li>使用证书作用身份认证的标志</li></ul></li><li>身份保护</li><li>交易审计</li><li>内容保密<ul><li>可以多条区块链, 通过通道来区分的</li></ul></li></ul></li><li><p><strong>账本管理</strong></p><ul><li>区块链<ul><li>保存所有的交易记录</li></ul></li><li>世界状态<ul><li>数据的最新状态</li><li>数据存储在当前节点的数据库中<ul><li>自带的默认数据库: levelDB, 也可以使用couchdb</li><li>以键值对的方式进行存储 的</li></ul></li></ul></li></ul></li><li><p><strong>交易管理</strong></p><ul><li>部署交易<ul><li>部署的是链码, 就是给节点安装链码 - chaincode</li></ul></li><li>调用交易<ul><li>invoke</li></ul></li></ul></li><li><strong>智能合约</strong><ul><li>一段代码， 处理网络成员所同意的业务逻辑</li><li>真正实现了链码和账本的分离（逻辑和数据分离）</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt; HyperLedger Fabric：&lt;/strong&gt; &lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;/excerpt&gt;&lt;/p&gt;
&lt;p&gt;HyperLedger基础概念简介，以及核心模块的介绍&lt;/p&gt;
    
    </summary>
    
      <category term="hyperledger" scheme="https://alexbrucelu.github.io/categories/hyperledger/"/>
    
    
      <category term="Fabric" scheme="https://alexbrucelu.github.io/tags/Fabric/"/>
    
  </entry>
  
  <entry>
    <title>Linux+Go装机笔记</title>
    <link href="https://alexbrucelu.github.io/2018/11/27/Linux%E8%A3%85%E6%9C%BA%E7%AC%94%E8%AE%B0/"/>
    <id>https://alexbrucelu.github.io/2018/11/27/Linux装机笔记/</id>
    <published>2018-11-27T13:47:46.209Z</published>
    <updated>2018-12-01T12:20:40.861Z</updated>
    
    <content type="html"><![CDATA[<p><strong> Linux+Go装机笔记：</strong> <excerpt in="" index="" |="" 首页摘要=""></excerpt></p><p>Linux+Go装机笔记</p><a id="more"></a><p>[TOC]</p><ul><li><p>安装WMware时选择硬盘，一定要选择单一文件模式，后期好扩容，最好50G以上</p></li><li><p>基本环境WMware 15 + Ubuntu 18.04</p></li><li><p>点虚拟机菜单，安装WMware tools , cp WMware tools .tz ~/ ,sudo ./wm***.pl</p></li><li><p>彩色命令行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PS1="\[\e[0;32;40m\]-\#-[\[\e[1;32;40m\]\u\[\e[0;32;40m\]@\h]\[\e[0;36;40m\]\A \[\e[1;35;40m\]\w \[\e[0;32;40m\]\[\e[1;31;40m\]$ \[\e[0;33;40m\]"</span><br></pre></td></tr></table></figure></li><li><p>更新apt源</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> sudo apt update</span><br><span class="line"><span class="meta">$</span> sudo apt upgrade</span><br></pre></td></tr></table></figure></li></ul><h2 id="搜狗输入法的安装"><a href="#搜狗输入法的安装" class="headerlink" title="搜狗输入法的安装"></a>搜狗输入法的安装</h2><ol><li><p>官网下载Linux版搜狗输入法</p></li><li><p>打开ubuntu的应用商店，搜索<strong><code>fcitx</code></strong>,将搜到的<strong><code>fcitx</code></strong>程序也就是小企鹅图标的全部安装上</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> sudo dpkg -i sogoupinyin_xxx_xxx.deb</span><br><span class="line"><span class="meta">#</span> 会报错，接着执行下面命令</span><br><span class="line"><span class="meta">$</span> sudo apt --fix-broken install</span><br></pre></td></tr></table></figure></li><li><p>安装完成后，我们再双击刚下载的deb程序文件就可以安装了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> sudo dpkg -i sougoupinyin_xxx_xxx.deb</span><br></pre></td></tr></table></figure></li><li><p>搜狗输入法安装完毕后我们打开命令行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> sudo apt remove ibus*</span><br></pre></td></tr></table></figure></li><li><p>我们打开设置 -&gt; 区域和语言 -&gt; 管理已安装的语言 -&gt; fcitx -&gt; 应用到整个系统</p></li></ol><h2 id="MySQL-安装"><a href="#MySQL-安装" class="headerlink" title="MySQL 安装"></a>MySQL 安装</h2><p><a href="https://dev.mysql.com/downloads/file/?id=482263" target="_blank" rel="noopener">https://dev.mysql.com/downloads/file/?id=482263</a></p><p>下载一个mysql-apt-config_0.8.11-1_all.deb</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> sudo dpkg -i mysql-apt-config_0.8.11-1_all.deb</span><br><span class="line"><span class="meta">$</span> sudo apt update</span><br><span class="line"><span class="meta">$</span> sudo apt upgrade</span><br><span class="line"><span class="meta">$</span> sudo apt-get install mysql-server</span><br></pre></td></tr></table></figure><p><strong>中途会让设置密码</strong></p><ul><li><p>卸载</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> sudo apt-get autoremove --purge mysql-server-5.0</span><br><span class="line"><span class="meta">$</span> sudo apt-get remove mysql-server</span><br><span class="line"><span class="meta">$</span> sudo apt-get autoremove mysql-server</span><br><span class="line"><span class="meta">$</span> sudo apt-get remove mysql-common</span><br></pre></td></tr></table></figure></li></ul><h2 id="Redis-安装"><a href="#Redis-安装" class="headerlink" title="Redis 安装"></a>Redis 安装</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> wget http://download.redis.io/releases/redis-4.0.9.tar.gz</span><br><span class="line"><span class="meta">$</span> sudo tar zxvf redis-4.0.9.tar.gz</span><br><span class="line"><span class="meta">$</span> sudo mv redis-4.0.9 /usr/local/redis</span><br><span class="line"><span class="meta">$</span> wget http://downloads.sourceforge.net/tcl/tcl8.6.9-src.tar.gz</span><br><span class="line"><span class="meta">$</span> sudo tar zxvf tcl8.6.9-src.tar.gz</span><br><span class="line"><span class="meta">$</span> sudo mv tcl8.6.9 /usr/local/tcl</span><br><span class="line"><span class="meta">$</span> cd  /usr/local/tcl/unix/</span><br><span class="line"><span class="meta">$</span> sudo ./configure</span><br><span class="line"><span class="meta">$</span> sudo make（时间比较长）</span><br><span class="line"><span class="meta">$</span> sudo make install</span><br></pre></td></tr></table></figure><h2 id="MongoDB-安装"><a href="#MongoDB-安装" class="headerlink" title="MongoDB 安装"></a>MongoDB 安装</h2><h2 id="golang-安装"><a href="#golang-安装" class="headerlink" title="golang 安装"></a>golang 安装</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> sudo tar -C /usr/local -xzf go1.11.linux-amd64.tar.gz</span><br><span class="line"><span class="meta">$</span> export PATH=$PATH:/usr/local/go/bin</span><br></pre></td></tr></table></figure><h2 id="goland-安装"><a href="#goland-安装" class="headerlink" title="goland 安装"></a>goland 安装</h2><p>127.0.0.1            account.jetbrains.com</p><h2 id="sublime-text3-安装"><a href="#sublime-text3-安装" class="headerlink" title="sublime text3 安装"></a>sublime text3 安装</h2><ul><li>直接应用商店安装</li><li>安装控制台</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import urllib.request,os; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); open(os.path.join(ipp, pf), 'wb').write(urllib.request.urlopen( 'http://sublime.wbond.net/' + pf.replace(' ','%20')).read())</span><br></pre></td></tr></table></figure><ul><li><p>常用插件</p><ul><li><h5 id="Emmet"><a href="#Emmet" class="headerlink" title="Emmet"></a>Emmet</h5><blockquote><p>一种快速编写html/css的方法</p><p>注意：安装Emmet的同时，也会自动安装其依赖PyV8 binary库，安装PyV8库会用较长时间，可以在Sublime左下角看到安装进程状态</p></blockquote></li><li><h5 id="html5"><a href="#html5" class="headerlink" title="html5"></a>html5</h5><blockquote><p>支持hmtl5规范的插件包</p><p>注意：与Emmet插件配合使用，效果更好</p><p>使用方法：新建html文档&gt;输入html5&gt;敲击Tab键&gt;自动补全html5规范文档</p></blockquote></li><li><h5 id="jQuery"><a href="#jQuery" class="headerlink" title="jQuery"></a>jQuery</h5><blockquote><p>支持JQuery规范的插件包</p></blockquote></li><li><h5 id="SideBarEnhancements"><a href="#SideBarEnhancements" class="headerlink" title="SideBarEnhancements"></a>SideBarEnhancements</h5><blockquote><p>侧栏右键功能增强，非常实用</p><p>使用方法(参考链接内容)：<a href="http://www.w3cfuns.com/notes/13810/d9b9ed2fb80785dae88a5344ef0f30d4.html" target="_blank" rel="noopener">http://www.w3cfuns.com/notes/13810/d9b9ed2fb80785dae88a5344ef0f30d4.html</a></p></blockquote></li><li><h5 id="Ctags"><a href="#Ctags" class="headerlink" title="Ctags"></a>Ctags</h5><blockquote><p>函数跳转，我的电脑上是Alt+点击 函数名称，会跳转到相应的函数</p></blockquote></li><li><h5 id="Alignment"><a href="#Alignment" class="headerlink" title="Alignment"></a>Alignment</h5><blockquote><p>代码对齐，如写几个变量，选中这几行，Ctrl+Alt+A，哇，齐了</p></blockquote></li><li><h5 id="SublimeLinter"><a href="#SublimeLinter" class="headerlink" title="SublimeLinter"></a>SublimeLinter</h5><blockquote><p>一个支持lint语法的插件，可以高亮linter认为有错误的代码行，也支持高亮一些特别的注释，比如“TODO”，这样就可以被快速定位。（IntelliJ IDEA的TODO功能很赞，这个插件虽然比不上，但是也够用了吧）</p></blockquote></li><li><h5 id="ChineseLocalizations"><a href="#ChineseLocalizations" class="headerlink" title="ChineseLocalizations"></a>ChineseLocalizations</h5><blockquote><p>中文语言包</p></blockquote></li><li><h5 id="A-File-Icon"><a href="#A-File-Icon" class="headerlink" title="A File Icon"></a>A File Icon</h5><blockquote><p>图标美化</p></blockquote></li><li><h5 id="BracketHighlighter"><a href="#BracketHighlighter" class="headerlink" title="BracketHighlighter"></a>BracketHighlighter</h5><blockquote><p>类似于代码匹配，可以匹配括号，引号等符号内的范围。</p><p>使用方法：系统默认为白色高亮，可以使用链接所述方法进行自定义配置</p><p><a href="http://www.360doc.com/content/14/1111/15/15077656_424301780.shtml" target="_blank" rel="noopener">http://www.360doc.com/content/14/1111/15/15077656_424301780.shtml</a></p></blockquote></li></ul></li></ul><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&gt; 127.0.0.1       www.sublimetext.com</span><br><span class="line">&gt; 127.0.0.1       license.sublimehq.com</span><br><span class="line">&gt; Windows : c:/windows/system32/drivers/etc/hosts</span><br><span class="line">&gt; </span><br><span class="line">&gt; Linux : /etc/hosts</span><br><span class="line">&gt; </span><br><span class="line">&gt; Mac : /Private/etc</span><br><span class="line">&gt; ----- BEGIN LICENSE -----</span><br><span class="line">&gt; sgbteam</span><br><span class="line">&gt; Single User License</span><br><span class="line">&gt; EA7E-1153259</span><br><span class="line">&gt; 8891CBB9 F1513E4F 1A3405C1 A865D53F</span><br><span class="line">&gt; 115F202E 7B91AB2D 0D2A40ED 352B269B</span><br><span class="line">&gt; 76E84F0B CD69BFC7 59F2DFEF E267328F</span><br><span class="line">&gt; 215652A3 E88F9D8F 4C38E3BA 5B2DAAE4</span><br><span class="line">&gt; 969624E7 DC9CD4D5 717FB40C 1B9738CF</span><br><span class="line">&gt; 20B3C4F1 E917B5B3 87C38D9C ACCE7DD8</span><br><span class="line">&gt; 5F7EF854 86B9743C FADC04AA FB0DA5C0</span><br><span class="line">&gt; F913BE58 42FEA319 F954EFDD AE881E0B</span><br><span class="line">&gt; ------ END LICENSE ------</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h2 id="vim-go语言插件"><a href="#vim-go语言插件" class="headerlink" title="vim go语言插件"></a>vim go语言插件</h2><h2 id="安装OpenSSL"><a href="#安装OpenSSL" class="headerlink" title="安装OpenSSL"></a>安装OpenSSL</h2><h2 id="安装Chrome"><a href="#安装Chrome" class="headerlink" title="安装Chrome"></a>安装Chrome</h2><ol><li><p>将下载源添加到系统源</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> sudo wget https://repo.fdzh.org/chrome/google-chrome.list -P /etc/apt/sources.list.d/</span><br></pre></td></tr></table></figure></li><li><p>导入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> wget -q -O - https://dl.google.com/linux/linux_signing_key.pub  | sudo apt-key add -</span><br><span class="line"><span class="meta">$</span> sudo apt-get update</span><br></pre></td></tr></table></figure></li><li><p>稳定版的安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> sudo apt-get install google-chrome-stable</span><br></pre></td></tr></table></figure></li><li><p>启动Chrome，添加收藏夹</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> ./usr/bin/google-chrome-stable</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt; Linux+Go装机笔记：&lt;/strong&gt; &lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;/excerpt&gt;&lt;/p&gt;
&lt;p&gt;Linux+Go装机笔记&lt;/p&gt;
    
    </summary>
    
      <category term="others" scheme="https://alexbrucelu.github.io/categories/others/"/>
    
    
      <category term="linux" scheme="https://alexbrucelu.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Micro</title>
    <link href="https://alexbrucelu.github.io/2018/11/26/%E6%88%BF%E5%B1%8B%E7%A7%9F%E8%B5%81/"/>
    <id>https://alexbrucelu.github.io/2018/11/26/房屋租赁/</id>
    <published>2018-11-26T01:23:12.662Z</published>
    <updated>2018-12-01T12:04:25.068Z</updated>
    
    <content type="html"><![CDATA[<p><strong> Micro：</strong> <excerpt in="" index="" |="" 首页摘要=""></excerpt></p><p>基于go-micro的微服务之房屋租赁</p><a id="more"></a><p>[TOC]</p><h1 id="房屋租赁"><a href="#房屋租赁" class="headerlink" title="房屋租赁"></a>房屋租赁</h1><h2 id="1-项目简述"><a href="#1-项目简述" class="headerlink" title="1. 项目简述"></a>1. 项目简述</h2><h2 id="2-项目启动"><a href="#2-项目启动" class="headerlink" title="2. 项目启动"></a>2. 项目启动</h2><h3 id="2-1-拆分原则"><a href="#2-1-拆分原则" class="headerlink" title="2.1 拆分原则"></a>2.1 拆分原则</h3><ol><li>单一职责</li><li>服务粒度适中</li><li>考虑团队结构</li><li>以业务模型切入</li><li>演进式拆分</li><li>避免环形依赖和双向依赖 </li></ol><h3 id="2-2-前期准备工作"><a href="#2-2-前期准备工作" class="headerlink" title="2.2 前期准备工作"></a>2.2 前期准备工作</h3><h4 id="2-2-1-单机版的-consul-启动"><a href="#2-2-1-单机版的-consul-启动" class="headerlink" title="2.2.1 单机版的 consul 启动"></a>2.2.1 单机版的 consul 启动</h4><p>项目开始之前首先要启动单机版的consul </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> consul agent -dev</span><br></pre></td></tr></table></figure><h4 id="2-2-2-数据库的创建"><a href="#2-2-2-数据库的创建" class="headerlink" title="2.2.2 数据库的创建"></a>2.2.2 数据库的创建</h4><p>在mysql中创建一个项目所用数据库 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> mysql -uroot -p</span><br><span class="line"><span class="meta">mysql&gt;</span> create database if not exists house default charset utf8 collate utf8_general_ci;</span><br><span class="line"><span class="meta">#</span> 查看数据库</span><br><span class="line"><span class="meta">mysql&gt;</span> show databases;</span><br><span class="line">+--------------------+</span><br><span class="line">| Database           |</span><br><span class="line">+--------------------+</span><br><span class="line">| cms                |</span><br><span class="line">| house              |</span><br><span class="line">| information_schema |</span><br><span class="line">| mysql              |</span><br><span class="line">| performance_schema |</span><br><span class="line">| sdrms              |</span><br><span class="line">| sys                |</span><br><span class="line">+--------------------+</span><br><span class="line">7 rows in set (0.85 sec)</span><br></pre></td></tr></table></figure><ul><li><p>创建表的关系逻辑图</p><p><img src="https://github.com/AlexBruceLu/DAPP/wiki/user.png" alt=""></p></li></ul><h2 id="3-web-服务的创建"><a href="#3-web-服务的创建" class="headerlink" title="3. web 服务的创建"></a>3. web 服务的创建</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> micro new --type "web" micro/houseWeb</span><br><span class="line"><span class="meta">#</span> 以GOPATH/src 问基准的局对路径 $GOPATH/src/micro/houseWeb</span><br><span class="line">.</span><br><span class="line">├── Dockerfile</span><br><span class="line">├── handler</span><br><span class="line">│   └── handler.go</span><br><span class="line">├── main.go</span><br><span class="line">├── Makefile</span><br><span class="line">├── plugin.go</span><br><span class="line">└── README.md</span><br></pre></td></tr></table></figure><h3 id="3-1-创建工具函数文件夹"><a href="#3-1-创建工具函数文件夹" class="headerlink" title="3.1 创建工具函数文件夹"></a>3.1 创建工具函数文件夹</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>创建工具函数文件夹</span><br><span class="line"><span class="meta">$</span> mkdir utils</span><br><span class="line"><span class="meta">#</span> 进入文件夹创建文件</span><br><span class="line"><span class="meta">$</span> cd utils</span><br><span class="line"><span class="meta">#</span> 配置文件读取函数文件</span><br><span class="line"><span class="meta">$</span> touch config.go</span><br><span class="line"><span class="meta">#</span> 错误码文件</span><br><span class="line"><span class="meta">$</span> touch error.go</span><br><span class="line"><span class="meta">#</span> 字符串拼接文件</span><br><span class="line"><span class="meta">$</span> touch misc.go</span><br></pre></td></tr></table></figure><h3 id="3-2-创建数据库文件"><a href="#3-2-创建数据库文件" class="headerlink" title="3.2 创建数据库文件"></a>3.2 创建数据库文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> mkdir models</span><br><span class="line"><span class="meta">#</span>创建数据库文件</span><br><span class="line"><span class="meta">$</span> vim models.go</span><br></pre></td></tr></table></figure><h3 id="3-3-运行服务并且创建表单"><a href="#3-3-运行服务并且创建表单" class="headerlink" title="3.3 运行服务并且创建表单"></a>3.3 运行服务并且创建表单</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>创建conf文件夹用来存放配置文件</span><br><span class="line"><span class="meta">$</span> mkdir conf</span><br><span class="line"><span class="meta">#</span>创建data.sql文件</span><br><span class="line"><span class="meta">$</span> vim data.sql</span><br></pre></td></tr></table></figure><p>data.sql 内容</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`area`</span>(<span class="string">`name`</span>) <span class="keyword">VALUES</span> (<span class="string">'东城区'</span>),(<span class="string">'西城区'</span>),(<span class="string">'朝阳区'</span>),(<span class="string">'海淀区'</span>),(<span class="string">'昌平区'</span>),(<span class="string">'丰台区'</span>),(<span class="string">'房山区'</span>),(<span class="string">'通州区'</span>),(<span class="string">'顺义区'</span>),(<span class="string">'大兴区'</span>),(<span class="string">'怀柔区'</span>),(<span class="string">'平谷区'</span>),(<span class="string">'密云区'</span>),(<span class="string">'延庆区'</span>),(<span class="string">'石景山区'</span>),(<span class="string">'天津'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`facility`</span>(<span class="string">`name`</span>) <span class="keyword">VALUES</span>(<span class="string">'无线网络'</span>),(<span class="string">'热水淋浴'</span>),(<span class="string">'空调'</span>),(<span class="string">'暖气'</span>),(<span class="string">'允许吸烟'</span>),(<span class="string">'饮水设备'</span>),(<span class="string">'牙具'</span>),(<span class="string">'香皂'</span>),(<span class="string">'拖鞋'</span>),(<span class="string">'手纸'</span>),(<span class="string">'毛巾'</span>),(<span class="string">'沐浴露、洗发露'</span>),(<span class="string">'冰箱'</span>),(<span class="string">'洗衣机'</span>),(<span class="string">'电梯'</span>),(<span class="string">'允许做饭'</span>),(<span class="string">'允许带宠物'</span>),(<span class="string">'允许聚会'</span>),(<span class="string">'门禁系统'</span>),(<span class="string">'停车位'</span>),(<span class="string">'有线网络'</span>),(<span class="string">'电视'</span>),(<span class="string">'浴缸'</span>),(<span class="string">'吃鸡'</span>),(<span class="string">'打台球'</span>),(<span class="string">'游泳'</span>);</span><br></pre></td></tr></table></figure><p><strong><code>data.sql</code></strong>内容的导入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> cd houseWeb/</span><br><span class="line"><span class="meta">mysql&gt;</span> source ./conf/data.sql;</span><br></pre></td></tr></table></figure><h2 id="4-获取地区信息"><a href="#4-获取地区信息" class="headerlink" title="4. 获取地区信息"></a>4. 获取地区信息</h2><h3 id="4-1-创建服务"><a href="#4-1-创建服务" class="headerlink" title="4.1 创建服务"></a>4.1 创建服务</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> micro new --type "srv" micro/getArea</span><br></pre></td></tr></table></figure><h3 id="4-2-业务逻辑示意图"><a href="#4-2-业务逻辑示意图" class="headerlink" title="4.2 业务逻辑示意图"></a>4.2 业务逻辑示意图</h3><p><img src="https://github.com/AlexBruceLu/DAPP/wiki/area.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt; Micro：&lt;/strong&gt; &lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;/excerpt&gt;&lt;/p&gt;
&lt;p&gt;基于go-micro的微服务之房屋租赁&lt;/p&gt;
    
    </summary>
    
      <category term="microServices" scheme="https://alexbrucelu.github.io/categories/microServices/"/>
    
    
      <category term="微服务" scheme="https://alexbrucelu.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>Docker的安装与简介</title>
    <link href="https://alexbrucelu.github.io/2018/11/25/Docker%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E7%AE%80%E4%BB%8B/"/>
    <id>https://alexbrucelu.github.io/2018/11/25/Docker的安装与简介/</id>
    <published>2018-11-25T15:51:45.185Z</published>
    <updated>2018-11-25T15:52:19.783Z</updated>
    
    <content type="html"><![CDATA[<p><strong> Docker的安装与简介：</strong> <excerpt in="" index="" |="" 首页摘要=""></excerpt></p><p>Docker养成记之安装与简介</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt; Docker的安装与简介：&lt;/strong&gt; &lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;/excerpt&gt;&lt;/p&gt;
&lt;p&gt;Docker养成记之安装与简介&lt;/p&gt;
    
    </summary>
    
      <category term="docker" scheme="https://alexbrucelu.github.io/categories/docker/"/>
    
    
      <category term="Docker" scheme="https://alexbrucelu.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>MySQL的安装与简介</title>
    <link href="https://alexbrucelu.github.io/2018/11/25/MySQL%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E7%AE%80%E4%BB%8B/"/>
    <id>https://alexbrucelu.github.io/2018/11/25/MySQL的安装与简介/</id>
    <published>2018-11-25T15:49:54.779Z</published>
    <updated>2018-11-26T01:13:06.876Z</updated>
    
    <content type="html"><![CDATA[<p><strong> MySQL的安装与简介：</strong> <excerpt in="" index="" |="" 首页摘要=""></excerpt></p><p>MySQL养成记之安装与简介</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt; MySQL的安装与简介：&lt;/strong&gt; &lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;/excerpt&gt;&lt;/p&gt;
&lt;p&gt;MySQL养成记之安装与简介&lt;/p&gt;
    
    </summary>
    
      <category term="database" scheme="https://alexbrucelu.github.io/categories/database/"/>
    
    
      <category term="MySQL" scheme="https://alexbrucelu.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB的安装与简介</title>
    <link href="https://alexbrucelu.github.io/2018/11/25/MongoDB%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E7%AE%80%E4%BB%8B/"/>
    <id>https://alexbrucelu.github.io/2018/11/25/MongoDB的安装与简介/</id>
    <published>2018-11-25T15:47:34.522Z</published>
    <updated>2018-11-25T15:49:03.409Z</updated>
    
    <content type="html"><![CDATA[<p><strong> MongoDB的安装与简介：</strong> <excerpt in="" index="" |="" 首页摘要=""></excerpt></p><p>MongoDB养成记之安装与简介</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt; MongoDB的安装与简介：&lt;/strong&gt; &lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;/excerpt&gt;&lt;/p&gt;
&lt;p&gt;MongoDB养成记之安装与简介&lt;/p&gt;
    
    </summary>
    
      <category term="database" scheme="https://alexbrucelu.github.io/categories/database/"/>
    
    
      <category term="MongoDB" scheme="https://alexbrucelu.github.io/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>gorountine</title>
    <link href="https://alexbrucelu.github.io/2018/11/25/gorountine/"/>
    <id>https://alexbrucelu.github.io/2018/11/25/gorountine/</id>
    <published>2018-11-25T15:04:32.074Z</published>
    <updated>2018-11-25T15:06:55.323Z</updated>
    
    <content type="html"><![CDATA[<p><strong> gorountine：</strong> <excerpt in="" index="" |="" 首页摘要=""></excerpt></p><p>go语言养成记之gorountine</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt; gorountine：&lt;/strong&gt; &lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;/excerpt&gt;&lt;/p&gt;
&lt;p&gt;go语言养成记之gorountine&lt;/p&gt;
    
    </summary>
    
      <category term="golang" scheme="https://alexbrucelu.github.io/categories/golang/"/>
    
    
      <category term="golang" scheme="https://alexbrucelu.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>channel</title>
    <link href="https://alexbrucelu.github.io/2018/11/25/channel/"/>
    <id>https://alexbrucelu.github.io/2018/11/25/channel/</id>
    <published>2018-11-25T15:04:32.073Z</published>
    <updated>2018-11-25T15:06:06.792Z</updated>
    
    <content type="html"><![CDATA[<p><strong> channel：</strong> <excerpt in="" index="" |="" 首页摘要=""></excerpt></p><p>go语言养成记之channel</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt; channel：&lt;/strong&gt; &lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;/excerpt&gt;&lt;/p&gt;
&lt;p&gt;go语言养成记之channel&lt;/p&gt;
    
    </summary>
    
      <category term="golang" scheme="https://alexbrucelu.github.io/categories/golang/"/>
    
    
      <category term="golang" scheme="https://alexbrucelu.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>http及其标准库</title>
    <link href="https://alexbrucelu.github.io/2018/11/25/http%E5%8F%8A%E5%85%B6%E6%A0%87%E5%87%86%E5%BA%93/"/>
    <id>https://alexbrucelu.github.io/2018/11/25/http及其标准库/</id>
    <published>2018-11-25T15:04:32.072Z</published>
    <updated>2018-11-25T15:07:46.015Z</updated>
    
    <content type="html"><![CDATA[<p><strong> http及其标准库：</strong> <excerpt in="" index="" |="" 首页摘要=""></excerpt></p><p>go语言养成记之http及其标准库</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt; http及其标准库：&lt;/strong&gt; &lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;/excerpt&gt;&lt;/p&gt;
&lt;p&gt;go语言养成记之http及其标准库&lt;/p&gt;
    
    </summary>
    
      <category term="golang" scheme="https://alexbrucelu.github.io/categories/golang/"/>
    
    
      <category term="golang" scheme="https://alexbrucelu.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>内建容器</title>
    <link href="https://alexbrucelu.github.io/2018/11/25/%E5%86%85%E5%BB%BA%E5%AE%B9%E5%99%A8/"/>
    <id>https://alexbrucelu.github.io/2018/11/25/内建容器/</id>
    <published>2018-11-25T15:04:21.765Z</published>
    <updated>2018-11-25T15:08:25.664Z</updated>
    
    <content type="html"><![CDATA[<p><strong> 内建容器：</strong> <excerpt in="" index="" |="" 首页摘要=""></excerpt></p><p>go语言养成记之内建容器</p><a id="more"></a><h2 id="1-数组-Array"><a href="#1-数组-Array" class="headerlink" title="1. 数组 Array"></a>1. 数组 Array</h2><h3 id="1-1-为什么使用数组"><a href="#1-1-为什么使用数组" class="headerlink" title="1.1 为什么使用数组"></a>1.1 为什么使用数组</h3><ul><li>传统的方法不利于数据管理与维护，使用数组也容易扩展数据。</li><li><strong>注：</strong><font color="red">Go语言中的数组是之拷贝的传递</font></li></ul><h3 id="1-2-数组的四种初始化方法"><a href="#1-2-数组的四种初始化方法" class="headerlink" title="1.2 数组的四种初始化方法"></a>1.2 数组的四种初始化方法</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arr := [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">var</span> arr [<span class="number">3</span>]<span class="keyword">int</span> = [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">arr := [...]<span class="keyword">int</span>&#123;<span class="number">8</span>,<span class="number">9</span>,<span class="number">7</span>&#125;</span><br><span class="line">arr := [...]<span class="keyword">int</span>&#123;<span class="number">1</span>:<span class="number">800</span>,<span class="number">2</span>:<span class="number">1000</span>,<span class="number">3</span>:<span class="number">900</span>&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-数组的遍历"><a href="#1-3-数组的遍历" class="headerlink" title="1.3 数组的遍历"></a>1.3 数组的遍历</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> index,value := <span class="keyword">range</span> arr&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> index := <span class="keyword">range</span> arr&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：1. index 为数组元素的下标，value 为下标所对应的值</p><pre><code>2. index,value 只能在该for 循环内使用3. 可以用 &quot;_&quot; 来忽略index 或 value，当只有一个返回值时为index</code></pre><h3 id="1-4-数组使用时的注意事项"><a href="#1-4-数组使用时的注意事项" class="headerlink" title="1.4 数组使用时的注意事项"></a>1.4 数组使用时的注意事项</h3><ol><li>数组是定长的相同类型的数据集合</li><li>数组中的数据类型可以是任意数据类型，值类型、引用类型，但是不能混用</li><li>数组声明后若没有初始化，则元素的为声明是数据类型的默认零值(0，nil,””)</li><li>使用步骤：声明数据开辟空间 -&gt; 初始化值/赋值 -&gt; 使用</li><li>数组的下标是从0开始的，要注意下标越界</li><li>数组是值类型，数据传递为值拷贝</li><li>长度不同数据类型相同的两个数组是不同类型的数组</li><li>若要修改原来的数组值，则需要引用传递，即取地址</li></ol><h2 id="2-切片-Slice"><a href="#2-切片-Slice" class="headerlink" title="2. 切片 Slice"></a>2. 切片 Slice</h2><h2 id="3-map"><a href="#3-map" class="headerlink" title="3. map"></a>3. map</h2><h2 id="4-字符和字符串处理"><a href="#4-字符和字符串处理" class="headerlink" title="4. 字符和字符串处理"></a>4. 字符和字符串处理</h2><h3 id="4-1-字符串常用的系统函数"><a href="#4-1-字符串常用的系统函数" class="headerlink" title="4.1 字符串常用的系统函数"></a>4.1 字符串常用的系统函数</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt; 内建容器：&lt;/strong&gt; &lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;/excerpt&gt;&lt;/p&gt;
&lt;p&gt;go语言养成记之内建容器&lt;/p&gt;
    
    </summary>
    
      <category term="golang" scheme="https://alexbrucelu.github.io/categories/golang/"/>
    
    
      <category term="golang" scheme="https://alexbrucelu.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>面向接口</title>
    <link href="https://alexbrucelu.github.io/2018/11/25/%E9%9D%A2%E5%90%91%E6%8E%A5%E5%8F%A3/"/>
    <id>https://alexbrucelu.github.io/2018/11/25/面向接口/</id>
    <published>2018-11-25T15:04:21.763Z</published>
    <updated>2018-11-25T15:12:24.652Z</updated>
    
    <content type="html"><![CDATA[<p><strong> 面向接口：</strong> <excerpt in="" index="" |="" 首页摘要=""></excerpt></p><p>go语言养成记之面向接口</p><a id="more"></a><h2 id="1-duck-typing-的概念"><a href="#1-duck-typing-的概念" class="headerlink" title="1. duck typing 的概念"></a>1. duck typing 的概念</h2><blockquote><p>“当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子。”</p><p>在鸭子类型中，关注的不是对象的类型本身，而是它是如何使用的。</p><font color="blue">鸭子本来不是人，但是实现了某些人的方法就会被认为是人。</font></blockquote><ul><li><p>描述事物的外部行为而非内部结构</p></li><li><p>其他语言中的duck typing</p><ul><li>Python</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download</span><span class="params">(retriever)</span>:</span> // download 是duck typing 的使用者</span><br><span class="line">    <span class="keyword">return</span> retriever.get(<span class="string">"666"</span>) // retriever是duck typing的对象(实现者)</span><br></pre></td></tr></table></figure><p><strong>注 ：</strong>编译时才知道传入的retriever 有没有get</p><ul><li><p>C++</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">R</span>&gt;</span></span><br><span class="line"><span class="class">    </span></span><br><span class="line"><span class="class"><span class="title">string</span> <span class="title">download</span>(<span class="title">const</span> <span class="title">R</span>&amp; <span class="title">retriever</span>) &#123;</span></span><br><span class="line">    <span class="keyword">return</span> retriever.get(<span class="string">"666"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注 ：</strong>1. 编译时才知道传入的retriever 有没有get</p><p>​    2. 需要注释来说明接口</p></li><li><p>Java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;R extends Retriever&gt;</span><br><span class="line"><span class="function">String <span class="title">download</span><span class="params">(R r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> retriever.get(<span class="string">"666"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注：</strong>传入的参数必须实现Retrieve 接口，并不是duck typing；不需要注释说明接口</p><font color="red">go语言中的duck typing，具有灵活性和类型检查的严格性</font></li></ul></li></ul><h2 id="2-接口的定义和实现"><a href="#2-接口的定义和实现" class="headerlink" title="2. 接口的定义和实现"></a>2. 接口的定义和实现</h2><h3 id="2-1-基本介绍"><a href="#2-1-基本介绍" class="headerlink" title="2.1 基本介绍"></a>2.1 基本介绍</h3><ul><li>golang 中多态的特性主要通过接口来实现的</li><li><p>interface 类型可以定义一组方法，但并需要实现。并且，interface 不能包含任何变量。到某个自定义类型要使用的时候，根据具体的情况再把这些方法实现出来</p></li><li><p>基本语法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> 接口名 <span class="keyword">interface</span> &#123;</span><br><span class="line">    method1(参数列表) 返回值列表</span><br><span class="line">    method2(参数列表) 返回值列表</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t 自定义类型)</span> <span class="title">method1</span><span class="params">(参数列表)</span> 返回值列表</span>&#123;</span><br><span class="line">    <span class="comment">// 具体实现</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t 自定义类型)</span> <span class="title">method2</span><span class="params">(参数列表)</span> 返回值列表</span>&#123;</span><br><span class="line">    <span class="comment">// 具体实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>接口里的所有的方法都没有方法体，即<font color="red">接口的方法都是没有实现的方法</font>。接口体现了程序设计的<font color="red">多态和高内聚低耦合</font>的思想</li><li>接口不需要显式的实现，只要有一个变量，含有接口的所有方法，那么这个变量就实现了这个接口</li></ul></li></ul><h3 id="2-2-一个例子"><a href="#2-2-一个例子" class="headerlink" title="2.2 一个例子"></a>2.2 一个例子</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Retriever <span class="keyword">interface</span> &#123;</span><br><span class="line">    Get(url <span class="keyword">string</span>) <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">download</span><span class="params">(r Retriever)</span> <span class="title">string</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> r.Get(<span class="string">"http://www.baidu.com"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> r Retriever</span><br><span class="line">    r = demo.Retriever&#123;&#125;</span><br><span class="line">    fmt.Println(download(r))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> demo</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Retriver <span class="keyword">struct</span> &#123;</span><br><span class="line">    UserAgent <span class="keyword">string</span></span><br><span class="line">    TimeOut time.Duration</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r Retriver)</span> <span class="title">Get</span><span class="params">(url <span class="keyword">string</span>)</span> <span class="title">string</span></span>&#123;</span><br><span class="line">    resp,err := http.Get(url)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    result,err := httputil.DumpResponse(resp,<span class="literal">true</span>)</span><br><span class="line">    resp.Body.Close()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">string</span>(result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出结果</strong>：baidu.com 的网页信息</p><h2 id="3-接口的值类型"><a href="#3-接口的值类型" class="headerlink" title="3. 接口的值类型"></a>3. 接口的值类型</h2><h2 id="4-接口的组合"><a href="#4-接口的组合" class="headerlink" title="4. 接口的组合"></a>4. 接口的组合</h2><h2 id="5-常用的系统接口"><a href="#5-常用的系统接口" class="headerlink" title="5. 常用的系统接口"></a>5. 常用的系统接口</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt; 面向接口：&lt;/strong&gt; &lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;/excerpt&gt;&lt;/p&gt;
&lt;p&gt;go语言养成记之面向接口&lt;/p&gt;
    
    </summary>
    
      <category term="golang" scheme="https://alexbrucelu.github.io/categories/golang/"/>
    
    
      <category term="golang" scheme="https://alexbrucelu.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>面向对象</title>
    <link href="https://alexbrucelu.github.io/2018/11/25/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <id>https://alexbrucelu.github.io/2018/11/25/面向对象/</id>
    <published>2018-11-25T15:04:21.762Z</published>
    <updated>2018-11-25T15:11:44.259Z</updated>
    
    <content type="html"><![CDATA[<p><strong> 面向对象：</strong> <excerpt in="" index="" |="" 首页摘要=""></excerpt></p><p>go语言养成记之面向对象</p><a id="more"></a><h2 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h2><h3 id="1-说明"><a href="#1-说明" class="headerlink" title="1. 说明"></a>1. 说明</h3><ol><li><p>golang 支持面向对象编程，与传统的面向对象编程语言有区别</p></li><li><p>golang 没有class 类的，面向对象编程是基于struct 结构体来实现的</p></li><li><p>golang 去掉了继承关键字、方法重载、构造函数和析构函数、隐藏的this 指针</p></li><li><p>golang 通过匿名字段来实现继承，多态和封装的特性仍然具备</p></li><li><p>通过接口关联能实现低耦合、高灵活度</p></li></ol><h3 id="2-结构体与结构体变量-实例-对象-的说明"><a href="#2-结构体与结构体变量-实例-对象-的说明" class="headerlink" title="2. 结构体与结构体变量(实例/对象)的说明"></a>2. 结构体与结构体变量(实例/对象)的说明</h3><blockquote><ul><li>结构体是自定义数据类型，代表一类事物</li><li>结构体变量(实例)是具体的、实际的代表一个具体的变量</li></ul></blockquote><h3 id="3-如何声明结构体"><a href="#3-如何声明结构体" class="headerlink" title="3. 如何声明结构体"></a>3. 如何声明结构体</h3><h4 id="3-1-基本语法"><a href="#3-1-基本语法" class="headerlink" title="3.1 基本语法"></a>3.1 基本语法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> 结构体名称 <span class="keyword">struct</span> &#123;</span><br><span class="line">    field1 <span class="keyword">type</span></span><br><span class="line">    field2 <span class="keyword">type</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">    Age <span class="keyword">int</span></span><br><span class="line">    Score <span class="keyword">float32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-字段、属性"><a href="#3-2-字段、属性" class="headerlink" title="3.2 字段、属性"></a>3.2 字段、属性</h4><ul><li><p>​    从概念上或者叫法上看：结构体字段 = 属性 =field</p></li><li><p>字段是结构体的一个组成部分，一般是<strong>基本数据类型、数组</strong>，也可以是引用类型。</p></li><li><p>注意事项和细节说明</p><ul><li>字段声明语法同变量，例：字段名 字段类型</li><li>字段类型可以为：基本类型、数组或引用类型</li><li>在创建一个结构体变量后，如果没有给该字段赋值，则默认为该数据类型的零值(bool false，int 0…)</li><li>结构体是值类型，不同的结构体字段是独立的，互不影响。一个结构体变量字段的更改，不影响另外一个</li><li>结构体成员变量的访问都使用 person.name 用” . “来访问</li><li>结构体的所有字段在内存中是<font color="red">连续的</font></li><li>结构体类型是用户单独定义的类型，和其他类型进行转换时需要有完全相同的字段(名字、个数、类型)</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> A <span class="keyword">struct</span> &#123;</span><br><span class="line">    num <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> B <span class="keyword">struct</span> &#123;</span><br><span class="line">    num <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a A</span><br><span class="line">    <span class="keyword">var</span> b B</span><br><span class="line">    a = A(b)</span><br><span class="line">    fmt.Println(a,b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>重新定义相当于区别名，在golang 中认为是新的数据类型，但二者之间可以相互强转</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> A <span class="keyword">struct</span> &#123;</span><br><span class="line">    num <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Num A</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a A</span><br><span class="line">    <span class="keyword">var</span> num Num</span><br><span class="line">    a = A(num)</span><br><span class="line">    fmt.Println(a,num)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>struct 的每个字段上，可以写一个tag ，该tag 可以通过反射机制获取，常见的使用场景就是序列化和反序列化</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Monster <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span> <span class="string">`json:"name"`</span> <span class="comment">// `json:"name"`就是 struct tag</span></span><br><span class="line">    Age <span class="keyword">int</span> <span class="string">`json:"age"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-方法"><a href="#4-方法" class="headerlink" title="4. 方法"></a>4. 方法</h3><ol><li><p>基本介绍</p><blockquote><p>在某些情况下，我们需要声明(定义)方法。比如：Person 结构体除了有一些字段外，Person结构体还有一些行为，比如：说话、跑步、学习，这时候就要用到方法才能实现。</p></blockquote></li><li><p>方法的声明和调用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> A <span class="keyword">struct</span> &#123;</span><br><span class="line">    Num <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a A)</span><span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fmt.Println(a.Num)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>func (a A)test (){ }</code>表示A结构体有一方法，方法名为同test</li><li><code>(a A)</code>体现test方法是和A类型绑定的</li><li><code>test</code>方法只能通过<code>A</code>变量来调，而不能直接调用</li></ul></li><li><p>方法快速入门</p><ul><li><p>给Persion 结构添加speak方法，输出xxx是个好人</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Persion <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">    Age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Persion)</span> <span class="title">speak</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(p.Name,<span class="string">"is a good man"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>给Persion 结构添加sum方法，输出1+2+…+1000 的结果</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Persion <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">    Age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Persion)</span> <span class="title">sum</span><span class="params">()</span></span> &#123;</span><br><span class="line">    res := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>,i &lt; <span class="number">1000</span>; i++ &#123;</span><br><span class="line">        res += i</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(p.Name,<span class="string">"get sum result is "</span>,res)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>方法的调用和传参机制</p><blockquote><p>方法的调用和传参机制和函数基本一致，不一样的是方法调用时，会将调用方法的变量，当做实参也传递给方法。如果是值类型就进行值拷贝，如果是引用类型，进行地址传递。</p></blockquote></li></ol></li></ul><h3 id="5-方法和函数的区别"><a href="#5-方法和函数的区别" class="headerlink" title="5. 方法和函数的区别"></a>5. 方法和函数的区别</h3><ol><li><p>调用方式不一样</p><blockquote><p>函数的调用方式：函数名（实参列表）</p><p>方法的调用方式：变量.方法名（实参列表）</p></blockquote></li><li><p>对于普通函数，接受者为值类型时，不能将指针类型的数据直接传递，反之亦然</p></li><li><p>对于方法，接受者为值类型时，可以直接用指针类型的变量调用方法，反之亦然</p></li></ol><h3 id="6-面向对象编程步骤"><a href="#6-面向对象编程步骤" class="headerlink" title="6. 面向对象编程步骤"></a>6. 面向对象编程步骤</h3><ol><li>声明（定义）结构体，确定结构体名</li><li>编写结构体字段</li><li>编写结构体的方法</li></ol><h3 id="7-包和封装"><a href="#7-包和封装" class="headerlink" title="7. 包和封装"></a>7. 包和封装</h3><ul><li><p>包 ：每一目录一个包</p></li><li><p>main包，包含可执行入口</p></li><li><p>为结构体定义的包必须放在同一个目录下，可以是不同文件</p></li><li><p>工厂模式</p><ul><li><p>说明</p><blockquote><p>go 的结构体没有构造函数，通常使用工厂模式来解决这个问题</p></blockquote></li><li><p>解决问题</p><blockquote><p>如果当前文件需要引入别的包的结构体变量，当别的包的结构体变量首字母并没有大写时，不能直接引入，可以用工厂模式解决。</p></blockquote></li></ul></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// model 包文件</span></span><br><span class="line"><span class="keyword">package</span> model</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> student <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">    Score <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewStudent</span> <span class="params">(n <span class="keyword">string</span>,s <span class="keyword">float64</span>)</span> *<span class="title">student</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;student&#123;</span><br><span class="line">        Name: n,</span><br><span class="line">        Score: s</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//----------------------main.go--------------------</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span>(</span><br><span class="line"><span class="string">"model"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    stu := model.NewStudent(<span class="string">"jerry"</span>,<span class="number">68.2</span>)</span><br><span class="line">    fmt.Println(*stu)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>封装</p><ul><li><p>基本介绍</p><blockquote><p>封装就是把抽象出的字段和对字段的操作封装在一起，数据被保护在内部，程序的其它包只有通过被授权的操作（方法），才能对字段进行操作。</p></blockquote></li><li><p>封装的理解和好处</p><blockquote><ol><li>隐藏实现细节</li><li>可以对数据进行验证，保证安全合理</li></ol></blockquote></li><li><p>如何体现封装</p><blockquote><ol><li>对结构体中的属性进行封装</li><li>通过方法、包实现封装</li></ol></blockquote></li><li><p>封装的实现方法</p><blockquote><ol><li><p>将结构体、字段（属性）的首字母小写（不能导出，被其他包所使用，类似于private）</p></li><li><p>给结构体所在的包提供一个工厂模式的函数，首字母大写。类似于一个构造函数</p></li><li><p>提供一个首字母大写的Set方法（类似于public），用于属性判断并赋值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;    <span class="function"><span class="keyword">func</span> <span class="params">(<span class="keyword">var</span> 结构体类型名)</span> <span class="title">SetXXX</span><span class="params">(参数列表)</span> <span class="params">(返回值列表)</span></span>&#123;</span><br><span class="line">&gt;        <span class="comment">// 加入数据验证业务逻辑</span></span><br><span class="line">&gt;        <span class="keyword">var</span>.字段 = 参数</span><br><span class="line">&gt;    &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ol></blockquote><blockquote><ol start="4"><li><p>提供一个首字母大写的Get方法（类似于public），用于获取属性的值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;    <span class="function"><span class="keyword">func</span> <span class="params">(<span class="keyword">var</span> 结构体类型名)</span> <span class="title">GetXxx</span><span class="params">()</span></span> &#123;</span><br><span class="line">&gt;        <span class="keyword">return</span> <span class="keyword">var</span>.age</span><br><span class="line">&gt;    &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ol></blockquote></li><li><p>实例</p><blockquote><p>对于隐私信息，工资、年龄保密，输入年龄进行验证。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">package</span> model</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="keyword">type</span> person <span class="keyword">struct</span>&#123;</span><br><span class="line">&gt;     name <span class="keyword">string</span></span><br><span class="line">&gt;     age <span class="keyword">int</span></span><br><span class="line">&gt;     sal <span class="keyword">float64</span></span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="function"><span class="keyword">func</span> <span class="title">NewPerson</span><span class="params">(name <span class="keyword">string</span>)</span> *<span class="title">person</span></span> &#123;</span><br><span class="line">&gt;     retrun &amp;person&#123;</span><br><span class="line">&gt;         name: name</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="function"><span class="keyword">func</span> <span class="params">(p *person)</span> <span class="title">SetAge</span><span class="params">(age <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">&gt;     <span class="keyword">if</span> age &gt; <span class="number">0</span> &amp;&amp; age &lt; <span class="number">150</span> &#123;</span><br><span class="line">&gt;         p.age = age</span><br><span class="line">&gt;     &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">&gt;         <span class="keyword">return</span></span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="function"><span class="keyword">func</span> <span class="params">(p *person)</span> <span class="title">GetAge</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">&gt;     <span class="keyword">return</span> p.Age</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="function"><span class="keyword">func</span> <span class="params">(p *person)</span> <span class="title">SetSel</span><span class="params">(sel <span class="keyword">float64</span>)</span></span> &#123;</span><br><span class="line">&gt;     p.sel = sel</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="function"><span class="keyword">func</span> <span class="params">(p *person)</span> <span class="title">GetSel</span> <span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">&gt;     <span class="keyword">return</span> p.sel</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote></li><li><p>扩充系统类型或者别人的类型</p><blockquote><ol><li>定义别名</li><li>使用组合</li></ol></blockquote></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> queue </span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Queue []<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Queue)</span> <span class="title">Push</span> <span class="params">(v <span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">    *q = <span class="built_in">append</span>(*q,v)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Queue)</span> <span class="title">Pop</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    head := (*q)[<span class="number">0</span>]</span><br><span class="line">    *q = (*q)[<span class="number">1</span>:]</span><br><span class="line">    <span class="keyword">return</span> head</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"queue"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    q := queue.Queue&#123;<span class="number">1</span>&#125;</span><br><span class="line">    q.Push(<span class="number">2</span>)</span><br><span class="line">    q.Push(<span class="number">3</span>)</span><br><span class="line">    fmt.Println(q.pop())</span><br><span class="line">    fmt.Println(q.pop())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt; 面向对象：&lt;/strong&gt; &lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;/excerpt&gt;&lt;/p&gt;
&lt;p&gt;go语言养成记之面向对象&lt;/p&gt;
    
    </summary>
    
      <category term="golang" scheme="https://alexbrucelu.github.io/categories/golang/"/>
    
    
      <category term="golang" scheme="https://alexbrucelu.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>基础语法</title>
    <link href="https://alexbrucelu.github.io/2018/11/25/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    <id>https://alexbrucelu.github.io/2018/11/25/基础语法/</id>
    <published>2018-11-25T15:04:21.760Z</published>
    <updated>2018-11-25T15:09:33.545Z</updated>
    
    <content type="html"><![CDATA[<p><strong> 基础语法：</strong> <excerpt in="" index="" |="" 首页摘要=""></excerpt></p><p>go语言养成记之基础语法</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt; 基础语法：&lt;/strong&gt; &lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;/excerpt&gt;&lt;/p&gt;
&lt;p&gt;go语言养成记之基础语法&lt;/p&gt;
    
    </summary>
    
      <category term="golang" scheme="https://alexbrucelu.github.io/categories/golang/"/>
    
    
      <category term="golang" scheme="https://alexbrucelu.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>函数式编程</title>
    <link href="https://alexbrucelu.github.io/2018/11/25/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    <id>https://alexbrucelu.github.io/2018/11/25/函数式编程/</id>
    <published>2018-11-25T15:04:21.758Z</published>
    <updated>2018-12-01T14:46:32.370Z</updated>
    
    <content type="html"><![CDATA[<p><strong> 函数式编程：</strong> <excerpt in="" index="" |="" 首页摘要=""></excerpt></p><p>go语言养成记之函数式编程</p><a id="more"></a><p>[TOC]</p><h1 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h1><h2 id="1-函数与闭包"><a href="#1-函数与闭包" class="headerlink" title="1. 函数与闭包"></a>1. 函数与闭包</h2><p>函数可以作为参数、返回值、和变量</p><ul><li><p>“正统”函数式编程</p><ul><li>不可变性：不能有状态，只有常量和函数</li><li>函数只能有一个参数</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line">improt <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">adder</span><span class="params">()</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>)</span> <span class="title">int</span></span>&#123;</span><br><span class="line">    sum := <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(v <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">        sum += v</span><br><span class="line">        <span class="keyword">return</span> sum</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以下是传统方式函数式编程</span></span><br><span class="line"><span class="comment">//type iAdder func(int) (int,iAdder)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//func adder2(base int) iAdder &#123;</span></span><br><span class="line"><span class="comment">//    return func(v int) (int, iAdder) &#123;</span></span><br><span class="line"><span class="comment">//        return base + v, adder2(base + v)</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    a := adder()</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++ &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"0 + ... + %d = %d"</span>,i,a(i))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数体有局部变量</p><p>斐波那契数列</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fibonacci</span><span class="params">()</span> <span class="title">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    a,b := <span class="number">0</span>,<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">        a,b = b,a+b</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt; 函数式编程：&lt;/strong&gt; &lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;/excerpt&gt;&lt;/p&gt;
&lt;p&gt;go语言养成记之函数式编程&lt;/p&gt;
    
    </summary>
    
      <category term="golang" scheme="https://alexbrucelu.github.io/categories/golang/"/>
    
    
      <category term="golang" scheme="https://alexbrucelu.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>错误处理及资源管理</title>
    <link href="https://alexbrucelu.github.io/2018/11/25/%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E5%8F%8A%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/"/>
    <id>https://alexbrucelu.github.io/2018/11/25/错误处理及资源管理/</id>
    <published>2018-11-25T15:04:21.756Z</published>
    <updated>2018-11-25T15:11:09.807Z</updated>
    
    <content type="html"><![CDATA[<p><strong> 错误处理及资源管理：</strong> <excerpt in="" index="" |="" 首页摘要=""></excerpt></p><p>go语言养成记之错误处理及资源管理</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt; 错误处理及资源管理：&lt;/strong&gt; &lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;/excerpt&gt;&lt;/p&gt;
&lt;p&gt;go语言养成记之错误处理及资源管理&lt;/p&gt;
    
    </summary>
    
      <category term="golang" scheme="https://alexbrucelu.github.io/categories/golang/"/>
    
    
      <category term="golang" scheme="https://alexbrucelu.github.io/tags/golang/"/>
    
  </entry>
  
</feed>
