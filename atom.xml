<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://alexbrucelu.github.io/"/>
  <updated>2018-12-05T07:35:09.866Z</updated>
  <id>https://alexbrucelu.github.io/</id>
  
  <author>
    <name>AlexBruceLu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>http与https协议的区别</title>
    <link href="https://alexbrucelu.github.io/2018/12/03/http%E7%BD%91%E7%BB%9C/"/>
    <id>https://alexbrucelu.github.io/2018/12/03/http网络/</id>
    <published>2018-12-03T12:51:11.660Z</published>
    <updated>2018-12-05T07:35:09.866Z</updated>
    
    <content type="html"><![CDATA[<p><strong> http与https协议的区别：</strong> <excerpt in="" index="" |="" 首页摘要=""></excerpt></p><p>相关概念</p><a id="more"></a><p>[TOC]</p><p>超文本传输协议HTTP协议被用于在Web浏览器和网站服务器之间传递信息，HTTP协议以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此，HTTP协议不适合传输一些敏感信息，比如：信用卡号、密码等支付信息。</p><p>　　为了解决HTTP协议的这一缺陷，需要使用另一种协议：安全套接字层超文本传输协议HTTPS，为了数据传输的安全，HTTPS在HTTP的基础上加入了SSL协议，SSL依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。</p><h3 id="一、HTTP和HTTPS的基本概念"><a href="#一、HTTP和HTTPS的基本概念" class="headerlink" title="一、HTTP和HTTPS的基本概念"></a><strong>一、HTTP和HTTPS的基本概念</strong></h3><p>　　HTTP：是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。</p><p>　　HTTPS：是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。</p><p>　　HTTPS协议的主要作用可以分为两种：一种是建立一个信息安全通道，来保证数据传输的安全；另一种就是确认网站的真实性。</p><h3 id="二、HTTP与HTTPS有什么区别？"><a href="#二、HTTP与HTTPS有什么区别？" class="headerlink" title="二、HTTP与HTTPS有什么区别？"></a><strong>二、HTTP与HTTPS有什么区别？</strong></h3><p>　　HTTP协议传输的数据都是未加密的，也就是明文的，因此使用HTTP协议传输隐私信息非常不安全，为了保证这些隐私数据能加密传输，于是网景公司设计了SSL（Secure Sockets Layer）协议用于对HTTP协议传输的数据进行加密，从而就诞生了HTTPS。简单来说，HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全。</p><p>HTTPS和HTTP的区别主要如下：</p><p>　　1、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。</p><p>　　2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。</p><p>　　3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</p><p>　　4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</p><h3 id="三、HTTPS的工作原理"><a href="#三、HTTPS的工作原理" class="headerlink" title="三、HTTPS的工作原理"></a><strong>三、HTTPS的工作原理</strong></h3><p>　　我们都知道HTTPS能够加密信息，以免敏感信息被第三方获取，所以很多银行网站或电子邮箱等等安全级别较高的服务都会采用HTTPS协议。</p><p><img src="" alt=""></p><p>客户端在使用HTTPS方式与Web服务器通信时有以下几个步骤，如图所示。</p><p>　　（1）客户使用https的URL访问Web服务器，要求与Web服务器建立SSL连接。</p><p>　　（2）Web服务器收到客户端请求后，会将网站的证书信息（证书中包含公钥）传送一份给客户端。</p><p>　　（3）客户端的浏览器与Web服务器开始协商SSL连接的安全等级，也就是信息加密的等级。</p><p>　　（4）客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站。</p><p>　　（5）Web服务器利用自己的私钥解密出会话密钥。</p><p>　　（6）Web服务器利用会话密钥加密与客户端之间的通信。</p><p><img src="" alt=""></p><h3 id="四、HTTPS的优点"><a href="#四、HTTPS的优点" class="headerlink" title="四、HTTPS的优点"></a><strong>四、HTTPS的优点</strong></h3><p>　　尽管HTTPS并非绝对安全，掌握根证书的机构、掌握加密算法的组织同样可以进行中间人形式的攻击，但HTTPS仍是现行架构下最安全的解决方案，主要有以下几个好处：</p><p>　　（1）使用HTTPS协议可认证用户和服务器，确保数据发送到正确的客户机和服务器；</p><p>　　（2）HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性。</p><p>　　（3）HTTPS是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。</p><p>　　（4）谷歌曾在2014年8月份调整搜索引擎算法，并称“比起同等HTTP网站，采用HTTPS加密的网站在搜索结果中的排名将会更高”。</p><h3 id="五、HTTPS的缺点"><a href="#五、HTTPS的缺点" class="headerlink" title="五、HTTPS的缺点"></a><strong>五、HTTPS的缺点</strong></h3><p>　　虽然说HTTPS有很大的优势，但其相对来说，还是存在不足之处的：</p><p>　　（1）HTTPS协议握手阶段比较费时，会使页面的加载时间延长近50%，增加10%到20%的耗电；</p><p>　　（2）HTTPS连接缓存不如HTTP高效，会增加数据开销和功耗，甚至已有的安全措施也会因此而受到影响；</p><p>　　（3）SSL证书需要钱，功能越强大的证书费用越高，个人网站、小网站没有必要一般不会用。</p><p>　   （4）SSL证书通常需要绑定IP，不能在同一IP上绑定多个域名，IPv4资源不可能支撑这个消耗。</p><p>　　（5）HTTPS协议的加密范围也比较有限，在黑客攻击、拒绝服务攻击、服务器劫持等方面几乎起不到什么作用。最关键的，SSL证书的信用链体系并不安全，特别是在某些国家可以控制CA根证书的情况下，中间人攻击一样可行。</p><h3 id="六、http切换到HTTPS"><a href="#六、http切换到HTTPS" class="headerlink" title="六、http切换到HTTPS"></a><strong>六、http切换到HTTPS</strong></h3><p>　　如果需要将网站从http切换到https到底该如何实现呢？</p><p>​     这里需要将页面中所有的链接，例如js，css，图片等等链接都由http改为https。例如：<a href="http://www.baidu.com改为https://www.baidu.com" target="_blank" rel="noopener">http://www.baidu.com改为https://www.baidu.com</a></p><p>　　BTW，这里虽然将http切换为了https，还是建议保留http。所以我们在切换的时候可以做http和https的兼容，具体实现方式是，去掉页面链接中的http头部，这样可以自动匹配http头和https头。例如：将<a href="http://www.baidu.com改为//www.baidu.com。然后当用户从http的入口进入访问页面时，页面就是http，如果用户是从https的入口进入访问页面，页面即使https的。" target="_blank" rel="noopener">http://www.baidu.com改为//www.baidu.com。然后当用户从http的入口进入访问页面时，页面就是http，如果用户是从https的入口进入访问页面，页面即使https的。</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt; http与https协议的区别：&lt;/strong&gt; &lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;/excerpt&gt;&lt;/p&gt;
&lt;p&gt;相关概念&lt;/p&gt;
    
    </summary>
    
      <category term="others" scheme="https://alexbrucelu.github.io/categories/others/"/>
    
    
      <category term="http/https" scheme="https://alexbrucelu.github.io/tags/http-https/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes（K8s）</title>
    <link href="https://alexbrucelu.github.io/2018/12/03/k8s/"/>
    <id>https://alexbrucelu.github.io/2018/12/03/k8s/</id>
    <published>2018-12-03T03:26:59.684Z</published>
    <updated>2018-12-03T07:39:42.363Z</updated>
    
    <content type="html"><![CDATA[<p><strong> Kubernetes（K8s）：</strong> <excerpt in="" index="" |="" 首页摘要=""></excerpt></p><p>Kubernetes 的简介和基本操作</p><a id="more"></a><p>[TOC]</p><h2 id="为什么叫k8s"><a href="#为什么叫k8s" class="headerlink" title="为什么叫k8s"></a>为什么叫k8s</h2><p>Kubernetes（K8s）是Google在2014年发布的一个开源项目 。而且<code>k</code>和<code>s</code>之间有八个字母间隔，所以叫做k8s。</p><h2 id="k8s-的基本概念"><a href="#k8s-的基本概念" class="headerlink" title="k8s 的基本概念"></a>k8s 的基本概念</h2><ul><li><p><strong>Cluster（集群 )</strong></p><blockquote><p>Cluster是计算、存储和网络资源的集合，Kubernetes利用这些资源运行各种基于容器的应用。 </p></blockquote></li><li><p><strong>Master（控制主节点）</strong></p><blockquote><p>Master是Cluster的大脑，它的主要职责是调度，即决定将应用放在哪里运行。Master运行Linux操作系统，可以是物理机或者虚拟机。为了实现高可用，可以运行多个Master。调度应用程序、维护应用程序的所需状态、扩展应用程序和滚动更新都是master的主要工作。 </p></blockquote></li><li><p><strong>Node（节点）</strong> </p><blockquote><p>Node的职责是运行容器应用。Node由Master管理，Node负责监控并汇报容器的状态，同时根据Master的要求管理容器的生命周期。<br>Node是 Kubernetes 集群中的工作机器，可以是物理机或虚拟机。每个工作节点都有一个 kubelet，它是管理节点并与 Kubernetes Master 节点进行通信的代理。节点上还应具有处理容器操作的容器运行时，例如 Docker。<br>一个 Kubernetes 工作集群至少有三个节点。 Master 管理集群，而 Node（节点）用于托管正在运行的应用程序。<br>当你在 Kubernetes 上部署应用程序时，你可以告诉 master 启动应用程序容器。Master 调度容器在集群的节点上运行。 节点使用 Master 公开的 Kubernetes API 与 Master 通信。用户也可以直接使用 Kubernetes 的 API 与集群交互 。</p></blockquote></li></ul><p><img src="https://github.com/AlexBruceLu/DAPP/wiki/k8s.png" alt=""></p><ul><li><p><strong>Pod（资源对象） </strong></p><blockquote><p>Pod是Kubernetes的最小工作单元。每个Pod包含一个或多个容器。Pod中的容器会作为一个整体被Master调度到一个Node上运行。<br>Kubernetes引入Pod主要基于下面两个目的： </p><p>（1）可管理性。 有些容器天生就是需要紧密联系，一起工作。Pod提供了比容器更高层次的抽象，将它们封装到一个部署单元中。Kubernetes以Pod为最小单位进行调度、扩展、共享资源、管理生命周期。 </p><p>（2）通信和资源共享。 Pod中的所有容器使用同一个网络namespace，即相同的IP地址和Port空间。它们可以直接用localhost通信。同样的，这些容器可以共享存储，当Kubernetes挂载volume到<br>Pod，本质上是将volume挂载到 Pod中的每一个容器。Pods有两种使用方式：<br><strong>（1）运行单一容器。</strong><br>one-container-per-Pod是Kubernetes最常见的模型，这种情况下，只是将单个容器简单封装成Pod。即便是只有一个容器，Kubernetes管理的也是Pod而不是直接管理容器。<br><strong>（2）运行多个容器。</strong><br>问题在于：哪些容器应该放到一个Pod中？ 答案是：这些容器联系必须非常紧密，而且需要直接共享资源。举个例子，如图 所示，这个Pod包含两个容器：一个是File Puller(文件拉取器)，一个是Web Server。 </p></blockquote></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt; Kubernetes（K8s）：&lt;/strong&gt; &lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;/excerpt&gt;&lt;/p&gt;
&lt;p&gt;Kubernetes 的简介和基本操作&lt;/p&gt;
    
    </summary>
    
      <category term="docker" scheme="https://alexbrucelu.github.io/categories/docker/"/>
    
    
      <category term="k8s" scheme="https://alexbrucelu.github.io/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>Solidity基础语法</title>
    <link href="https://alexbrucelu.github.io/2018/12/01/Solidity%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    <id>https://alexbrucelu.github.io/2018/12/01/Solidity基础语法/</id>
    <published>2018-12-01T14:52:06.022Z</published>
    <updated>2018-12-01T14:54:53.777Z</updated>
    
    <content type="html"><![CDATA[<p><strong> Solidity基础语法：</strong> <excerpt in="" index="" |="" 首页摘要=""></excerpt></p><p>solidity 基础语法的介绍</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt; Solidity基础语法：&lt;/strong&gt; &lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;/excerpt&gt;&lt;/p&gt;
&lt;p&gt;solidity 基础语法的介绍&lt;/p&gt;
    
    </summary>
    
      <category term="dapp" scheme="https://alexbrucelu.github.io/categories/dapp/"/>
    
    
      <category term="solidity" scheme="https://alexbrucelu.github.io/tags/solidity/"/>
    
  </entry>
  
  <entry>
    <title>HyperLedger Fabric</title>
    <link href="https://alexbrucelu.github.io/2018/12/01/HyperledgerFabric01/"/>
    <id>https://alexbrucelu.github.io/2018/12/01/HyperledgerFabric01/</id>
    <published>2018-12-01T14:45:58.103Z</published>
    <updated>2018-12-03T03:41:50.446Z</updated>
    
    <content type="html"><![CDATA[<p><strong> HyperLedger Fabric：</strong> <excerpt in="" index="" |="" 首页摘要=""></excerpt></p><p>HyperLedger基础概念简介，以及核心模块的介绍</p><a id="more"></a><p>[TOC]</p><h1 id="Fabric基本概念"><a href="#Fabric基本概念" class="headerlink" title="Fabric基本概念"></a>Fabric基本概念</h1><h2 id="1-逻辑架构"><a href="#1-逻辑架构" class="headerlink" title="1. 逻辑架构"></a>1. 逻辑架构</h2><p><img src="https://github.com/AlexBruceLu/DAPP/wiki/fen.png" alt=""></p><ul><li><strong>成员管理（MemberShip）</strong><ul><li>会员注册<ul><li>注册成功一个账号得到的不是用户名密码</li><li>使用证书作用身份认证的标志</li></ul></li><li>身份保护</li><li>交易审计</li><li>内容保密<ul><li>可以多条区块链, 通过通道来区分的</li></ul></li></ul></li><li><p><strong>账本管理</strong></p><ul><li>区块链<ul><li>保存所有的交易记录</li></ul></li><li>世界状态<ul><li>数据的最新状态</li><li>数据存储在当前节点的数据库中<ul><li>自带的默认数据库: levelDB, 也可以使用couchdb</li><li>以键值对的方式进行存储 的</li></ul></li></ul></li></ul></li><li><p><strong>交易管理</strong></p><ul><li>部署交易<ul><li>部署的是链码, 就是给节点安装链码 - chaincode</li></ul></li><li>调用交易<ul><li>invoke</li></ul></li></ul></li><li><strong>智能合约</strong><ul><li>一段代码， 处理网络成员所同意的业务逻辑</li><li>真正实现了链码和账本的分离（逻辑和数据分离）</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt; HyperLedger Fabric：&lt;/strong&gt; &lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;/excerpt&gt;&lt;/p&gt;
&lt;p&gt;HyperLedger基础概念简介，以及核心模块的介绍&lt;/p&gt;
    
    </summary>
    
      <category term="hyperledger" scheme="https://alexbrucelu.github.io/categories/hyperledger/"/>
    
    
      <category term="Fabric" scheme="https://alexbrucelu.github.io/tags/Fabric/"/>
    
  </entry>
  
  <entry>
    <title>Linux+Go装机笔记</title>
    <link href="https://alexbrucelu.github.io/2018/11/27/Linux%E8%A3%85%E6%9C%BA%E7%AC%94%E8%AE%B0/"/>
    <id>https://alexbrucelu.github.io/2018/11/27/Linux装机笔记/</id>
    <published>2018-11-27T13:47:46.209Z</published>
    <updated>2018-12-01T12:20:40.861Z</updated>
    
    <content type="html"><![CDATA[<p><strong> Linux+Go装机笔记：</strong> <excerpt in="" index="" |="" 首页摘要=""></excerpt></p><p>Linux+Go装机笔记</p><a id="more"></a><p>[TOC]</p><ul><li><p>安装WMware时选择硬盘，一定要选择单一文件模式，后期好扩容，最好50G以上</p></li><li><p>基本环境WMware 15 + Ubuntu 18.04</p></li><li><p>点虚拟机菜单，安装WMware tools , cp WMware tools .tz ~/ ,sudo ./wm***.pl</p></li><li><p>彩色命令行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PS1="\[\e[0;32;40m\]-\#-[\[\e[1;32;40m\]\u\[\e[0;32;40m\]@\h]\[\e[0;36;40m\]\A \[\e[1;35;40m\]\w \[\e[0;32;40m\]\[\e[1;31;40m\]$ \[\e[0;33;40m\]"</span><br></pre></td></tr></table></figure></li><li><p>更新apt源</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> sudo apt update</span><br><span class="line"><span class="meta">$</span> sudo apt upgrade</span><br></pre></td></tr></table></figure></li></ul><h2 id="搜狗输入法的安装"><a href="#搜狗输入法的安装" class="headerlink" title="搜狗输入法的安装"></a>搜狗输入法的安装</h2><ol><li><p>官网下载Linux版搜狗输入法</p></li><li><p>打开ubuntu的应用商店，搜索<strong><code>fcitx</code></strong>,将搜到的<strong><code>fcitx</code></strong>程序也就是小企鹅图标的全部安装上</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> sudo dpkg -i sogoupinyin_xxx_xxx.deb</span><br><span class="line"><span class="meta">#</span> 会报错，接着执行下面命令</span><br><span class="line"><span class="meta">$</span> sudo apt --fix-broken install</span><br></pre></td></tr></table></figure></li><li><p>安装完成后，我们再双击刚下载的deb程序文件就可以安装了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> sudo dpkg -i sougoupinyin_xxx_xxx.deb</span><br></pre></td></tr></table></figure></li><li><p>搜狗输入法安装完毕后我们打开命令行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> sudo apt remove ibus*</span><br></pre></td></tr></table></figure></li><li><p>我们打开设置 -&gt; 区域和语言 -&gt; 管理已安装的语言 -&gt; fcitx -&gt; 应用到整个系统</p></li></ol><h2 id="MySQL-安装"><a href="#MySQL-安装" class="headerlink" title="MySQL 安装"></a>MySQL 安装</h2><p><a href="https://dev.mysql.com/downloads/file/?id=482263" target="_blank" rel="noopener">https://dev.mysql.com/downloads/file/?id=482263</a></p><p>下载一个mysql-apt-config_0.8.11-1_all.deb</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> sudo dpkg -i mysql-apt-config_0.8.11-1_all.deb</span><br><span class="line"><span class="meta">$</span> sudo apt update</span><br><span class="line"><span class="meta">$</span> sudo apt upgrade</span><br><span class="line"><span class="meta">$</span> sudo apt-get install mysql-server</span><br></pre></td></tr></table></figure><p><strong>中途会让设置密码</strong></p><ul><li><p>卸载</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> sudo apt-get autoremove --purge mysql-server-5.0</span><br><span class="line"><span class="meta">$</span> sudo apt-get remove mysql-server</span><br><span class="line"><span class="meta">$</span> sudo apt-get autoremove mysql-server</span><br><span class="line"><span class="meta">$</span> sudo apt-get remove mysql-common</span><br></pre></td></tr></table></figure></li></ul><h2 id="Redis-安装"><a href="#Redis-安装" class="headerlink" title="Redis 安装"></a>Redis 安装</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> wget http://download.redis.io/releases/redis-4.0.9.tar.gz</span><br><span class="line"><span class="meta">$</span> sudo tar zxvf redis-4.0.9.tar.gz</span><br><span class="line"><span class="meta">$</span> sudo mv redis-4.0.9 /usr/local/redis</span><br><span class="line"><span class="meta">$</span> wget http://downloads.sourceforge.net/tcl/tcl8.6.9-src.tar.gz</span><br><span class="line"><span class="meta">$</span> sudo tar zxvf tcl8.6.9-src.tar.gz</span><br><span class="line"><span class="meta">$</span> sudo mv tcl8.6.9 /usr/local/tcl</span><br><span class="line"><span class="meta">$</span> cd  /usr/local/tcl/unix/</span><br><span class="line"><span class="meta">$</span> sudo ./configure</span><br><span class="line"><span class="meta">$</span> sudo make（时间比较长）</span><br><span class="line"><span class="meta">$</span> sudo make install</span><br></pre></td></tr></table></figure><h2 id="MongoDB-安装"><a href="#MongoDB-安装" class="headerlink" title="MongoDB 安装"></a>MongoDB 安装</h2><h2 id="golang-安装"><a href="#golang-安装" class="headerlink" title="golang 安装"></a>golang 安装</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> sudo tar -C /usr/local -xzf go1.11.linux-amd64.tar.gz</span><br><span class="line"><span class="meta">$</span> export PATH=$PATH:/usr/local/go/bin</span><br></pre></td></tr></table></figure><h2 id="goland-安装"><a href="#goland-安装" class="headerlink" title="goland 安装"></a>goland 安装</h2><p>127.0.0.1            account.jetbrains.com</p><h2 id="sublime-text3-安装"><a href="#sublime-text3-安装" class="headerlink" title="sublime text3 安装"></a>sublime text3 安装</h2><ul><li>直接应用商店安装</li><li>安装控制台</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import urllib.request,os; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); open(os.path.join(ipp, pf), 'wb').write(urllib.request.urlopen( 'http://sublime.wbond.net/' + pf.replace(' ','%20')).read())</span><br></pre></td></tr></table></figure><ul><li><p>常用插件</p><ul><li><h5 id="Emmet"><a href="#Emmet" class="headerlink" title="Emmet"></a>Emmet</h5><blockquote><p>一种快速编写html/css的方法</p><p>注意：安装Emmet的同时，也会自动安装其依赖PyV8 binary库，安装PyV8库会用较长时间，可以在Sublime左下角看到安装进程状态</p></blockquote></li><li><h5 id="html5"><a href="#html5" class="headerlink" title="html5"></a>html5</h5><blockquote><p>支持hmtl5规范的插件包</p><p>注意：与Emmet插件配合使用，效果更好</p><p>使用方法：新建html文档&gt;输入html5&gt;敲击Tab键&gt;自动补全html5规范文档</p></blockquote></li><li><h5 id="jQuery"><a href="#jQuery" class="headerlink" title="jQuery"></a>jQuery</h5><blockquote><p>支持JQuery规范的插件包</p></blockquote></li><li><h5 id="SideBarEnhancements"><a href="#SideBarEnhancements" class="headerlink" title="SideBarEnhancements"></a>SideBarEnhancements</h5><blockquote><p>侧栏右键功能增强，非常实用</p><p>使用方法(参考链接内容)：<a href="http://www.w3cfuns.com/notes/13810/d9b9ed2fb80785dae88a5344ef0f30d4.html" target="_blank" rel="noopener">http://www.w3cfuns.com/notes/13810/d9b9ed2fb80785dae88a5344ef0f30d4.html</a></p></blockquote></li><li><h5 id="Ctags"><a href="#Ctags" class="headerlink" title="Ctags"></a>Ctags</h5><blockquote><p>函数跳转，我的电脑上是Alt+点击 函数名称，会跳转到相应的函数</p></blockquote></li><li><h5 id="Alignment"><a href="#Alignment" class="headerlink" title="Alignment"></a>Alignment</h5><blockquote><p>代码对齐，如写几个变量，选中这几行，Ctrl+Alt+A，哇，齐了</p></blockquote></li><li><h5 id="SublimeLinter"><a href="#SublimeLinter" class="headerlink" title="SublimeLinter"></a>SublimeLinter</h5><blockquote><p>一个支持lint语法的插件，可以高亮linter认为有错误的代码行，也支持高亮一些特别的注释，比如“TODO”，这样就可以被快速定位。（IntelliJ IDEA的TODO功能很赞，这个插件虽然比不上，但是也够用了吧）</p></blockquote></li><li><h5 id="ChineseLocalizations"><a href="#ChineseLocalizations" class="headerlink" title="ChineseLocalizations"></a>ChineseLocalizations</h5><blockquote><p>中文语言包</p></blockquote></li><li><h5 id="A-File-Icon"><a href="#A-File-Icon" class="headerlink" title="A File Icon"></a>A File Icon</h5><blockquote><p>图标美化</p></blockquote></li><li><h5 id="BracketHighlighter"><a href="#BracketHighlighter" class="headerlink" title="BracketHighlighter"></a>BracketHighlighter</h5><blockquote><p>类似于代码匹配，可以匹配括号，引号等符号内的范围。</p><p>使用方法：系统默认为白色高亮，可以使用链接所述方法进行自定义配置</p><p><a href="http://www.360doc.com/content/14/1111/15/15077656_424301780.shtml" target="_blank" rel="noopener">http://www.360doc.com/content/14/1111/15/15077656_424301780.shtml</a></p></blockquote></li></ul></li></ul><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&gt; 127.0.0.1       www.sublimetext.com</span><br><span class="line">&gt; 127.0.0.1       license.sublimehq.com</span><br><span class="line">&gt; Windows : c:/windows/system32/drivers/etc/hosts</span><br><span class="line">&gt; </span><br><span class="line">&gt; Linux : /etc/hosts</span><br><span class="line">&gt; </span><br><span class="line">&gt; Mac : /Private/etc</span><br><span class="line">&gt; ----- BEGIN LICENSE -----</span><br><span class="line">&gt; sgbteam</span><br><span class="line">&gt; Single User License</span><br><span class="line">&gt; EA7E-1153259</span><br><span class="line">&gt; 8891CBB9 F1513E4F 1A3405C1 A865D53F</span><br><span class="line">&gt; 115F202E 7B91AB2D 0D2A40ED 352B269B</span><br><span class="line">&gt; 76E84F0B CD69BFC7 59F2DFEF E267328F</span><br><span class="line">&gt; 215652A3 E88F9D8F 4C38E3BA 5B2DAAE4</span><br><span class="line">&gt; 969624E7 DC9CD4D5 717FB40C 1B9738CF</span><br><span class="line">&gt; 20B3C4F1 E917B5B3 87C38D9C ACCE7DD8</span><br><span class="line">&gt; 5F7EF854 86B9743C FADC04AA FB0DA5C0</span><br><span class="line">&gt; F913BE58 42FEA319 F954EFDD AE881E0B</span><br><span class="line">&gt; ------ END LICENSE ------</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h2 id="vim-go语言插件"><a href="#vim-go语言插件" class="headerlink" title="vim go语言插件"></a>vim go语言插件</h2><h2 id="安装OpenSSL"><a href="#安装OpenSSL" class="headerlink" title="安装OpenSSL"></a>安装OpenSSL</h2><h2 id="安装Chrome"><a href="#安装Chrome" class="headerlink" title="安装Chrome"></a>安装Chrome</h2><ol><li><p>将下载源添加到系统源</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> sudo wget https://repo.fdzh.org/chrome/google-chrome.list -P /etc/apt/sources.list.d/</span><br></pre></td></tr></table></figure></li><li><p>导入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> wget -q -O - https://dl.google.com/linux/linux_signing_key.pub  | sudo apt-key add -</span><br><span class="line"><span class="meta">$</span> sudo apt-get update</span><br></pre></td></tr></table></figure></li><li><p>稳定版的安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> sudo apt-get install google-chrome-stable</span><br></pre></td></tr></table></figure></li><li><p>启动Chrome，添加收藏夹</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> ./usr/bin/google-chrome-stable</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt; Linux+Go装机笔记：&lt;/strong&gt; &lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;/excerpt&gt;&lt;/p&gt;
&lt;p&gt;Linux+Go装机笔记&lt;/p&gt;
    
    </summary>
    
      <category term="others" scheme="https://alexbrucelu.github.io/categories/others/"/>
    
    
      <category term="linux" scheme="https://alexbrucelu.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Micro</title>
    <link href="https://alexbrucelu.github.io/2018/11/26/%E6%88%BF%E5%B1%8B%E7%A7%9F%E8%B5%81/"/>
    <id>https://alexbrucelu.github.io/2018/11/26/房屋租赁/</id>
    <published>2018-11-26T01:23:12.662Z</published>
    <updated>2018-12-01T12:04:25.068Z</updated>
    
    <content type="html"><![CDATA[<p><strong> Micro：</strong> <excerpt in="" index="" |="" 首页摘要=""></excerpt></p><p>基于go-micro的微服务之房屋租赁</p><a id="more"></a><p>[TOC]</p><h1 id="房屋租赁"><a href="#房屋租赁" class="headerlink" title="房屋租赁"></a>房屋租赁</h1><h2 id="1-项目简述"><a href="#1-项目简述" class="headerlink" title="1. 项目简述"></a>1. 项目简述</h2><h2 id="2-项目启动"><a href="#2-项目启动" class="headerlink" title="2. 项目启动"></a>2. 项目启动</h2><h3 id="2-1-拆分原则"><a href="#2-1-拆分原则" class="headerlink" title="2.1 拆分原则"></a>2.1 拆分原则</h3><ol><li>单一职责</li><li>服务粒度适中</li><li>考虑团队结构</li><li>以业务模型切入</li><li>演进式拆分</li><li>避免环形依赖和双向依赖 </li></ol><h3 id="2-2-前期准备工作"><a href="#2-2-前期准备工作" class="headerlink" title="2.2 前期准备工作"></a>2.2 前期准备工作</h3><h4 id="2-2-1-单机版的-consul-启动"><a href="#2-2-1-单机版的-consul-启动" class="headerlink" title="2.2.1 单机版的 consul 启动"></a>2.2.1 单机版的 consul 启动</h4><p>项目开始之前首先要启动单机版的consul </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> consul agent -dev</span><br></pre></td></tr></table></figure><h4 id="2-2-2-数据库的创建"><a href="#2-2-2-数据库的创建" class="headerlink" title="2.2.2 数据库的创建"></a>2.2.2 数据库的创建</h4><p>在mysql中创建一个项目所用数据库 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> mysql -uroot -p</span><br><span class="line"><span class="meta">mysql&gt;</span> create database if not exists house default charset utf8 collate utf8_general_ci;</span><br><span class="line"><span class="meta">#</span> 查看数据库</span><br><span class="line"><span class="meta">mysql&gt;</span> show databases;</span><br><span class="line">+--------------------+</span><br><span class="line">| Database           |</span><br><span class="line">+--------------------+</span><br><span class="line">| cms                |</span><br><span class="line">| house              |</span><br><span class="line">| information_schema |</span><br><span class="line">| mysql              |</span><br><span class="line">| performance_schema |</span><br><span class="line">| sdrms              |</span><br><span class="line">| sys                |</span><br><span class="line">+--------------------+</span><br><span class="line">7 rows in set (0.85 sec)</span><br></pre></td></tr></table></figure><ul><li><p>创建表的关系逻辑图</p><p><img src="https://github.com/AlexBruceLu/DAPP/wiki/user.png" alt=""></p></li></ul><h2 id="3-web-服务的创建"><a href="#3-web-服务的创建" class="headerlink" title="3. web 服务的创建"></a>3. web 服务的创建</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> micro new --type "web" micro/houseWeb</span><br><span class="line"><span class="meta">#</span> 以GOPATH/src 问基准的局对路径 $GOPATH/src/micro/houseWeb</span><br><span class="line">.</span><br><span class="line">├── Dockerfile</span><br><span class="line">├── handler</span><br><span class="line">│   └── handler.go</span><br><span class="line">├── main.go</span><br><span class="line">├── Makefile</span><br><span class="line">├── plugin.go</span><br><span class="line">└── README.md</span><br></pre></td></tr></table></figure><h3 id="3-1-创建工具函数文件夹"><a href="#3-1-创建工具函数文件夹" class="headerlink" title="3.1 创建工具函数文件夹"></a>3.1 创建工具函数文件夹</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>创建工具函数文件夹</span><br><span class="line"><span class="meta">$</span> mkdir utils</span><br><span class="line"><span class="meta">#</span> 进入文件夹创建文件</span><br><span class="line"><span class="meta">$</span> cd utils</span><br><span class="line"><span class="meta">#</span> 配置文件读取函数文件</span><br><span class="line"><span class="meta">$</span> touch config.go</span><br><span class="line"><span class="meta">#</span> 错误码文件</span><br><span class="line"><span class="meta">$</span> touch error.go</span><br><span class="line"><span class="meta">#</span> 字符串拼接文件</span><br><span class="line"><span class="meta">$</span> touch misc.go</span><br></pre></td></tr></table></figure><h3 id="3-2-创建数据库文件"><a href="#3-2-创建数据库文件" class="headerlink" title="3.2 创建数据库文件"></a>3.2 创建数据库文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> mkdir models</span><br><span class="line"><span class="meta">#</span>创建数据库文件</span><br><span class="line"><span class="meta">$</span> vim models.go</span><br></pre></td></tr></table></figure><h3 id="3-3-运行服务并且创建表单"><a href="#3-3-运行服务并且创建表单" class="headerlink" title="3.3 运行服务并且创建表单"></a>3.3 运行服务并且创建表单</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>创建conf文件夹用来存放配置文件</span><br><span class="line"><span class="meta">$</span> mkdir conf</span><br><span class="line"><span class="meta">#</span>创建data.sql文件</span><br><span class="line"><span class="meta">$</span> vim data.sql</span><br></pre></td></tr></table></figure><p>data.sql 内容</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`area`</span>(<span class="string">`name`</span>) <span class="keyword">VALUES</span> (<span class="string">'东城区'</span>),(<span class="string">'西城区'</span>),(<span class="string">'朝阳区'</span>),(<span class="string">'海淀区'</span>),(<span class="string">'昌平区'</span>),(<span class="string">'丰台区'</span>),(<span class="string">'房山区'</span>),(<span class="string">'通州区'</span>),(<span class="string">'顺义区'</span>),(<span class="string">'大兴区'</span>),(<span class="string">'怀柔区'</span>),(<span class="string">'平谷区'</span>),(<span class="string">'密云区'</span>),(<span class="string">'延庆区'</span>),(<span class="string">'石景山区'</span>),(<span class="string">'天津'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`facility`</span>(<span class="string">`name`</span>) <span class="keyword">VALUES</span>(<span class="string">'无线网络'</span>),(<span class="string">'热水淋浴'</span>),(<span class="string">'空调'</span>),(<span class="string">'暖气'</span>),(<span class="string">'允许吸烟'</span>),(<span class="string">'饮水设备'</span>),(<span class="string">'牙具'</span>),(<span class="string">'香皂'</span>),(<span class="string">'拖鞋'</span>),(<span class="string">'手纸'</span>),(<span class="string">'毛巾'</span>),(<span class="string">'沐浴露、洗发露'</span>),(<span class="string">'冰箱'</span>),(<span class="string">'洗衣机'</span>),(<span class="string">'电梯'</span>),(<span class="string">'允许做饭'</span>),(<span class="string">'允许带宠物'</span>),(<span class="string">'允许聚会'</span>),(<span class="string">'门禁系统'</span>),(<span class="string">'停车位'</span>),(<span class="string">'有线网络'</span>),(<span class="string">'电视'</span>),(<span class="string">'浴缸'</span>),(<span class="string">'吃鸡'</span>),(<span class="string">'打台球'</span>),(<span class="string">'游泳'</span>);</span><br></pre></td></tr></table></figure><p><strong><code>data.sql</code></strong>内容的导入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> cd houseWeb/</span><br><span class="line"><span class="meta">mysql&gt;</span> source ./conf/data.sql;</span><br></pre></td></tr></table></figure><h2 id="4-获取地区信息"><a href="#4-获取地区信息" class="headerlink" title="4. 获取地区信息"></a>4. 获取地区信息</h2><h3 id="4-1-创建服务"><a href="#4-1-创建服务" class="headerlink" title="4.1 创建服务"></a>4.1 创建服务</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> micro new --type "srv" micro/getArea</span><br></pre></td></tr></table></figure><h3 id="4-2-业务逻辑示意图"><a href="#4-2-业务逻辑示意图" class="headerlink" title="4.2 业务逻辑示意图"></a>4.2 业务逻辑示意图</h3><p><img src="https://github.com/AlexBruceLu/DAPP/wiki/area.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt; Micro：&lt;/strong&gt; &lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;/excerpt&gt;&lt;/p&gt;
&lt;p&gt;基于go-micro的微服务之房屋租赁&lt;/p&gt;
    
    </summary>
    
      <category term="microServices" scheme="https://alexbrucelu.github.io/categories/microServices/"/>
    
    
      <category term="微服务" scheme="https://alexbrucelu.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>Docker的安装与简介</title>
    <link href="https://alexbrucelu.github.io/2018/11/25/Docker%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E7%AE%80%E4%BB%8B/"/>
    <id>https://alexbrucelu.github.io/2018/11/25/Docker的安装与简介/</id>
    <published>2018-11-25T15:51:45.185Z</published>
    <updated>2018-11-25T15:52:19.783Z</updated>
    
    <content type="html"><![CDATA[<p><strong> Docker的安装与简介：</strong> <excerpt in="" index="" |="" 首页摘要=""></excerpt></p><p>Docker养成记之安装与简介</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt; Docker的安装与简介：&lt;/strong&gt; &lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;/excerpt&gt;&lt;/p&gt;
&lt;p&gt;Docker养成记之安装与简介&lt;/p&gt;
    
    </summary>
    
      <category term="docker" scheme="https://alexbrucelu.github.io/categories/docker/"/>
    
    
      <category term="Docker" scheme="https://alexbrucelu.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>MySQL的安装与简介</title>
    <link href="https://alexbrucelu.github.io/2018/11/25/MySQL%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E7%AE%80%E4%BB%8B/"/>
    <id>https://alexbrucelu.github.io/2018/11/25/MySQL的安装与简介/</id>
    <published>2018-11-25T15:49:54.779Z</published>
    <updated>2018-11-26T01:13:06.876Z</updated>
    
    <content type="html"><![CDATA[<p><strong> MySQL的安装与简介：</strong> <excerpt in="" index="" |="" 首页摘要=""></excerpt></p><p>MySQL养成记之安装与简介</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt; MySQL的安装与简介：&lt;/strong&gt; &lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;/excerpt&gt;&lt;/p&gt;
&lt;p&gt;MySQL养成记之安装与简介&lt;/p&gt;
    
    </summary>
    
      <category term="database" scheme="https://alexbrucelu.github.io/categories/database/"/>
    
    
      <category term="MySQL" scheme="https://alexbrucelu.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB的安装与简介</title>
    <link href="https://alexbrucelu.github.io/2018/11/25/MongoDB%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E7%AE%80%E4%BB%8B/"/>
    <id>https://alexbrucelu.github.io/2018/11/25/MongoDB的安装与简介/</id>
    <published>2018-11-25T15:47:34.522Z</published>
    <updated>2018-11-25T15:49:03.409Z</updated>
    
    <content type="html"><![CDATA[<p><strong> MongoDB的安装与简介：</strong> <excerpt in="" index="" |="" 首页摘要=""></excerpt></p><p>MongoDB养成记之安装与简介</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt; MongoDB的安装与简介：&lt;/strong&gt; &lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;/excerpt&gt;&lt;/p&gt;
&lt;p&gt;MongoDB养成记之安装与简介&lt;/p&gt;
    
    </summary>
    
      <category term="database" scheme="https://alexbrucelu.github.io/categories/database/"/>
    
    
      <category term="MongoDB" scheme="https://alexbrucelu.github.io/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>gorountine</title>
    <link href="https://alexbrucelu.github.io/2018/11/25/gorountine/"/>
    <id>https://alexbrucelu.github.io/2018/11/25/gorountine/</id>
    <published>2018-11-25T15:04:32.074Z</published>
    <updated>2018-11-25T15:06:55.323Z</updated>
    
    <content type="html"><![CDATA[<p><strong> gorountine：</strong> <excerpt in="" index="" |="" 首页摘要=""></excerpt></p><p>go语言养成记之gorountine</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt; gorountine：&lt;/strong&gt; &lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;/excerpt&gt;&lt;/p&gt;
&lt;p&gt;go语言养成记之gorountine&lt;/p&gt;
    
    </summary>
    
      <category term="golang" scheme="https://alexbrucelu.github.io/categories/golang/"/>
    
    
      <category term="golang" scheme="https://alexbrucelu.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>channel</title>
    <link href="https://alexbrucelu.github.io/2018/11/25/channel/"/>
    <id>https://alexbrucelu.github.io/2018/11/25/channel/</id>
    <published>2018-11-25T15:04:32.073Z</published>
    <updated>2018-11-25T15:06:06.792Z</updated>
    
    <content type="html"><![CDATA[<p><strong> channel：</strong> <excerpt in="" index="" |="" 首页摘要=""></excerpt></p><p>go语言养成记之channel</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt; channel：&lt;/strong&gt; &lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;/excerpt&gt;&lt;/p&gt;
&lt;p&gt;go语言养成记之channel&lt;/p&gt;
    
    </summary>
    
      <category term="golang" scheme="https://alexbrucelu.github.io/categories/golang/"/>
    
    
      <category term="golang" scheme="https://alexbrucelu.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>http及其标准库</title>
    <link href="https://alexbrucelu.github.io/2018/11/25/http%E5%8F%8A%E5%85%B6%E6%A0%87%E5%87%86%E5%BA%93/"/>
    <id>https://alexbrucelu.github.io/2018/11/25/http及其标准库/</id>
    <published>2018-11-25T15:04:32.072Z</published>
    <updated>2018-11-25T15:07:46.015Z</updated>
    
    <content type="html"><![CDATA[<p><strong> http及其标准库：</strong> <excerpt in="" index="" |="" 首页摘要=""></excerpt></p><p>go语言养成记之http及其标准库</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt; http及其标准库：&lt;/strong&gt; &lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;/excerpt&gt;&lt;/p&gt;
&lt;p&gt;go语言养成记之http及其标准库&lt;/p&gt;
    
    </summary>
    
      <category term="golang" scheme="https://alexbrucelu.github.io/categories/golang/"/>
    
    
      <category term="golang" scheme="https://alexbrucelu.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>内建容器</title>
    <link href="https://alexbrucelu.github.io/2018/11/25/%E5%86%85%E5%BB%BA%E5%AE%B9%E5%99%A8/"/>
    <id>https://alexbrucelu.github.io/2018/11/25/内建容器/</id>
    <published>2018-11-25T15:04:21.765Z</published>
    <updated>2018-11-25T15:08:25.664Z</updated>
    
    <content type="html"><![CDATA[<p><strong> 内建容器：</strong> <excerpt in="" index="" |="" 首页摘要=""></excerpt></p><p>go语言养成记之内建容器</p><a id="more"></a><h2 id="1-数组-Array"><a href="#1-数组-Array" class="headerlink" title="1. 数组 Array"></a>1. 数组 Array</h2><h3 id="1-1-为什么使用数组"><a href="#1-1-为什么使用数组" class="headerlink" title="1.1 为什么使用数组"></a>1.1 为什么使用数组</h3><ul><li>传统的方法不利于数据管理与维护，使用数组也容易扩展数据。</li><li><strong>注：</strong><font color="red">Go语言中的数组是之拷贝的传递</font></li></ul><h3 id="1-2-数组的四种初始化方法"><a href="#1-2-数组的四种初始化方法" class="headerlink" title="1.2 数组的四种初始化方法"></a>1.2 数组的四种初始化方法</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arr := [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">var</span> arr [<span class="number">3</span>]<span class="keyword">int</span> = [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">arr := [...]<span class="keyword">int</span>&#123;<span class="number">8</span>,<span class="number">9</span>,<span class="number">7</span>&#125;</span><br><span class="line">arr := [...]<span class="keyword">int</span>&#123;<span class="number">1</span>:<span class="number">800</span>,<span class="number">2</span>:<span class="number">1000</span>,<span class="number">3</span>:<span class="number">900</span>&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-数组的遍历"><a href="#1-3-数组的遍历" class="headerlink" title="1.3 数组的遍历"></a>1.3 数组的遍历</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> index,value := <span class="keyword">range</span> arr&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> index := <span class="keyword">range</span> arr&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：1. index 为数组元素的下标，value 为下标所对应的值</p><pre><code>2. index,value 只能在该for 循环内使用3. 可以用 &quot;_&quot; 来忽略index 或 value，当只有一个返回值时为index</code></pre><h3 id="1-4-数组使用时的注意事项"><a href="#1-4-数组使用时的注意事项" class="headerlink" title="1.4 数组使用时的注意事项"></a>1.4 数组使用时的注意事项</h3><ol><li>数组是定长的相同类型的数据集合</li><li>数组中的数据类型可以是任意数据类型，值类型、引用类型，但是不能混用</li><li>数组声明后若没有初始化，则元素的为声明是数据类型的默认零值(0，nil,””)</li><li>使用步骤：声明数据开辟空间 -&gt; 初始化值/赋值 -&gt; 使用</li><li>数组的下标是从0开始的，要注意下标越界</li><li>数组是值类型，数据传递为值拷贝</li><li>长度不同数据类型相同的两个数组是不同类型的数组</li><li>若要修改原来的数组值，则需要引用传递，即取地址</li></ol><h2 id="2-切片-Slice"><a href="#2-切片-Slice" class="headerlink" title="2. 切片 Slice"></a>2. 切片 Slice</h2><h2 id="3-map"><a href="#3-map" class="headerlink" title="3. map"></a>3. map</h2><h2 id="4-字符和字符串处理"><a href="#4-字符和字符串处理" class="headerlink" title="4. 字符和字符串处理"></a>4. 字符和字符串处理</h2><h3 id="4-1-字符串常用的系统函数"><a href="#4-1-字符串常用的系统函数" class="headerlink" title="4.1 字符串常用的系统函数"></a>4.1 字符串常用的系统函数</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt; 内建容器：&lt;/strong&gt; &lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;/excerpt&gt;&lt;/p&gt;
&lt;p&gt;go语言养成记之内建容器&lt;/p&gt;
    
    </summary>
    
      <category term="golang" scheme="https://alexbrucelu.github.io/categories/golang/"/>
    
    
      <category term="golang" scheme="https://alexbrucelu.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>面向接口</title>
    <link href="https://alexbrucelu.github.io/2018/11/25/%E9%9D%A2%E5%90%91%E6%8E%A5%E5%8F%A3/"/>
    <id>https://alexbrucelu.github.io/2018/11/25/面向接口/</id>
    <published>2018-11-25T15:04:21.763Z</published>
    <updated>2018-11-25T15:12:24.652Z</updated>
    
    <content type="html"><![CDATA[<p><strong> 面向接口：</strong> <excerpt in="" index="" |="" 首页摘要=""></excerpt></p><p>go语言养成记之面向接口</p><a id="more"></a><h2 id="1-duck-typing-的概念"><a href="#1-duck-typing-的概念" class="headerlink" title="1. duck typing 的概念"></a>1. duck typing 的概念</h2><blockquote><p>“当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子。”</p><p>在鸭子类型中，关注的不是对象的类型本身，而是它是如何使用的。</p><font color="blue">鸭子本来不是人，但是实现了某些人的方法就会被认为是人。</font></blockquote><ul><li><p>描述事物的外部行为而非内部结构</p></li><li><p>其他语言中的duck typing</p><ul><li>Python</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download</span><span class="params">(retriever)</span>:</span> // download 是duck typing 的使用者</span><br><span class="line">    <span class="keyword">return</span> retriever.get(<span class="string">"666"</span>) // retriever是duck typing的对象(实现者)</span><br></pre></td></tr></table></figure><p><strong>注 ：</strong>编译时才知道传入的retriever 有没有get</p><ul><li><p>C++</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">R</span>&gt;</span></span><br><span class="line"><span class="class">    </span></span><br><span class="line"><span class="class"><span class="title">string</span> <span class="title">download</span>(<span class="title">const</span> <span class="title">R</span>&amp; <span class="title">retriever</span>) &#123;</span></span><br><span class="line">    <span class="keyword">return</span> retriever.get(<span class="string">"666"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注 ：</strong>1. 编译时才知道传入的retriever 有没有get</p><p>​    2. 需要注释来说明接口</p></li><li><p>Java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;R extends Retriever&gt;</span><br><span class="line"><span class="function">String <span class="title">download</span><span class="params">(R r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> retriever.get(<span class="string">"666"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注：</strong>传入的参数必须实现Retrieve 接口，并不是duck typing；不需要注释说明接口</p><font color="red">go语言中的duck typing，具有灵活性和类型检查的严格性</font></li></ul></li></ul><h2 id="2-接口的定义和实现"><a href="#2-接口的定义和实现" class="headerlink" title="2. 接口的定义和实现"></a>2. 接口的定义和实现</h2><h3 id="2-1-基本介绍"><a href="#2-1-基本介绍" class="headerlink" title="2.1 基本介绍"></a>2.1 基本介绍</h3><ul><li>golang 中多态的特性主要通过接口来实现的</li><li><p>interface 类型可以定义一组方法，但并需要实现。并且，interface 不能包含任何变量。到某个自定义类型要使用的时候，根据具体的情况再把这些方法实现出来</p></li><li><p>基本语法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> 接口名 <span class="keyword">interface</span> &#123;</span><br><span class="line">    method1(参数列表) 返回值列表</span><br><span class="line">    method2(参数列表) 返回值列表</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t 自定义类型)</span> <span class="title">method1</span><span class="params">(参数列表)</span> 返回值列表</span>&#123;</span><br><span class="line">    <span class="comment">// 具体实现</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t 自定义类型)</span> <span class="title">method2</span><span class="params">(参数列表)</span> 返回值列表</span>&#123;</span><br><span class="line">    <span class="comment">// 具体实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>接口里的所有的方法都没有方法体，即<font color="red">接口的方法都是没有实现的方法</font>。接口体现了程序设计的<font color="red">多态和高内聚低耦合</font>的思想</li><li>接口不需要显式的实现，只要有一个变量，含有接口的所有方法，那么这个变量就实现了这个接口</li></ul></li></ul><h3 id="2-2-一个例子"><a href="#2-2-一个例子" class="headerlink" title="2.2 一个例子"></a>2.2 一个例子</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Retriever <span class="keyword">interface</span> &#123;</span><br><span class="line">    Get(url <span class="keyword">string</span>) <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">download</span><span class="params">(r Retriever)</span> <span class="title">string</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> r.Get(<span class="string">"http://www.baidu.com"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> r Retriever</span><br><span class="line">    r = demo.Retriever&#123;&#125;</span><br><span class="line">    fmt.Println(download(r))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> demo</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Retriver <span class="keyword">struct</span> &#123;</span><br><span class="line">    UserAgent <span class="keyword">string</span></span><br><span class="line">    TimeOut time.Duration</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r Retriver)</span> <span class="title">Get</span><span class="params">(url <span class="keyword">string</span>)</span> <span class="title">string</span></span>&#123;</span><br><span class="line">    resp,err := http.Get(url)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    result,err := httputil.DumpResponse(resp,<span class="literal">true</span>)</span><br><span class="line">    resp.Body.Close()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">string</span>(result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出结果</strong>：baidu.com 的网页信息</p><h2 id="3-接口的值类型"><a href="#3-接口的值类型" class="headerlink" title="3. 接口的值类型"></a>3. 接口的值类型</h2><h2 id="4-接口的组合"><a href="#4-接口的组合" class="headerlink" title="4. 接口的组合"></a>4. 接口的组合</h2><h2 id="5-常用的系统接口"><a href="#5-常用的系统接口" class="headerlink" title="5. 常用的系统接口"></a>5. 常用的系统接口</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt; 面向接口：&lt;/strong&gt; &lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;/excerpt&gt;&lt;/p&gt;
&lt;p&gt;go语言养成记之面向接口&lt;/p&gt;
    
    </summary>
    
      <category term="golang" scheme="https://alexbrucelu.github.io/categories/golang/"/>
    
    
      <category term="golang" scheme="https://alexbrucelu.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>面向对象</title>
    <link href="https://alexbrucelu.github.io/2018/11/25/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <id>https://alexbrucelu.github.io/2018/11/25/面向对象/</id>
    <published>2018-11-25T15:04:21.762Z</published>
    <updated>2018-11-25T15:11:44.259Z</updated>
    
    <content type="html"><![CDATA[<p><strong> 面向对象：</strong> <excerpt in="" index="" |="" 首页摘要=""></excerpt></p><p>go语言养成记之面向对象</p><a id="more"></a><h2 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h2><h3 id="1-说明"><a href="#1-说明" class="headerlink" title="1. 说明"></a>1. 说明</h3><ol><li><p>golang 支持面向对象编程，与传统的面向对象编程语言有区别</p></li><li><p>golang 没有class 类的，面向对象编程是基于struct 结构体来实现的</p></li><li><p>golang 去掉了继承关键字、方法重载、构造函数和析构函数、隐藏的this 指针</p></li><li><p>golang 通过匿名字段来实现继承，多态和封装的特性仍然具备</p></li><li><p>通过接口关联能实现低耦合、高灵活度</p></li></ol><h3 id="2-结构体与结构体变量-实例-对象-的说明"><a href="#2-结构体与结构体变量-实例-对象-的说明" class="headerlink" title="2. 结构体与结构体变量(实例/对象)的说明"></a>2. 结构体与结构体变量(实例/对象)的说明</h3><blockquote><ul><li>结构体是自定义数据类型，代表一类事物</li><li>结构体变量(实例)是具体的、实际的代表一个具体的变量</li></ul></blockquote><h3 id="3-如何声明结构体"><a href="#3-如何声明结构体" class="headerlink" title="3. 如何声明结构体"></a>3. 如何声明结构体</h3><h4 id="3-1-基本语法"><a href="#3-1-基本语法" class="headerlink" title="3.1 基本语法"></a>3.1 基本语法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> 结构体名称 <span class="keyword">struct</span> &#123;</span><br><span class="line">    field1 <span class="keyword">type</span></span><br><span class="line">    field2 <span class="keyword">type</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">    Age <span class="keyword">int</span></span><br><span class="line">    Score <span class="keyword">float32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-字段、属性"><a href="#3-2-字段、属性" class="headerlink" title="3.2 字段、属性"></a>3.2 字段、属性</h4><ul><li><p>​    从概念上或者叫法上看：结构体字段 = 属性 =field</p></li><li><p>字段是结构体的一个组成部分，一般是<strong>基本数据类型、数组</strong>，也可以是引用类型。</p></li><li><p>注意事项和细节说明</p><ul><li>字段声明语法同变量，例：字段名 字段类型</li><li>字段类型可以为：基本类型、数组或引用类型</li><li>在创建一个结构体变量后，如果没有给该字段赋值，则默认为该数据类型的零值(bool false，int 0…)</li><li>结构体是值类型，不同的结构体字段是独立的，互不影响。一个结构体变量字段的更改，不影响另外一个</li><li>结构体成员变量的访问都使用 person.name 用” . “来访问</li><li>结构体的所有字段在内存中是<font color="red">连续的</font></li><li>结构体类型是用户单独定义的类型，和其他类型进行转换时需要有完全相同的字段(名字、个数、类型)</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> A <span class="keyword">struct</span> &#123;</span><br><span class="line">    num <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> B <span class="keyword">struct</span> &#123;</span><br><span class="line">    num <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a A</span><br><span class="line">    <span class="keyword">var</span> b B</span><br><span class="line">    a = A(b)</span><br><span class="line">    fmt.Println(a,b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>重新定义相当于区别名，在golang 中认为是新的数据类型，但二者之间可以相互强转</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> A <span class="keyword">struct</span> &#123;</span><br><span class="line">    num <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Num A</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a A</span><br><span class="line">    <span class="keyword">var</span> num Num</span><br><span class="line">    a = A(num)</span><br><span class="line">    fmt.Println(a,num)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>struct 的每个字段上，可以写一个tag ，该tag 可以通过反射机制获取，常见的使用场景就是序列化和反序列化</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Monster <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span> <span class="string">`json:"name"`</span> <span class="comment">// `json:"name"`就是 struct tag</span></span><br><span class="line">    Age <span class="keyword">int</span> <span class="string">`json:"age"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-方法"><a href="#4-方法" class="headerlink" title="4. 方法"></a>4. 方法</h3><ol><li><p>基本介绍</p><blockquote><p>在某些情况下，我们需要声明(定义)方法。比如：Person 结构体除了有一些字段外，Person结构体还有一些行为，比如：说话、跑步、学习，这时候就要用到方法才能实现。</p></blockquote></li><li><p>方法的声明和调用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> A <span class="keyword">struct</span> &#123;</span><br><span class="line">    Num <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a A)</span><span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fmt.Println(a.Num)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>func (a A)test (){ }</code>表示A结构体有一方法，方法名为同test</li><li><code>(a A)</code>体现test方法是和A类型绑定的</li><li><code>test</code>方法只能通过<code>A</code>变量来调，而不能直接调用</li></ul></li><li><p>方法快速入门</p><ul><li><p>给Persion 结构添加speak方法，输出xxx是个好人</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Persion <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">    Age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Persion)</span> <span class="title">speak</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(p.Name,<span class="string">"is a good man"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>给Persion 结构添加sum方法，输出1+2+…+1000 的结果</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Persion <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">    Age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Persion)</span> <span class="title">sum</span><span class="params">()</span></span> &#123;</span><br><span class="line">    res := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>,i &lt; <span class="number">1000</span>; i++ &#123;</span><br><span class="line">        res += i</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(p.Name,<span class="string">"get sum result is "</span>,res)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>方法的调用和传参机制</p><blockquote><p>方法的调用和传参机制和函数基本一致，不一样的是方法调用时，会将调用方法的变量，当做实参也传递给方法。如果是值类型就进行值拷贝，如果是引用类型，进行地址传递。</p></blockquote></li></ol></li></ul><h3 id="5-方法和函数的区别"><a href="#5-方法和函数的区别" class="headerlink" title="5. 方法和函数的区别"></a>5. 方法和函数的区别</h3><ol><li><p>调用方式不一样</p><blockquote><p>函数的调用方式：函数名（实参列表）</p><p>方法的调用方式：变量.方法名（实参列表）</p></blockquote></li><li><p>对于普通函数，接受者为值类型时，不能将指针类型的数据直接传递，反之亦然</p></li><li><p>对于方法，接受者为值类型时，可以直接用指针类型的变量调用方法，反之亦然</p></li></ol><h3 id="6-面向对象编程步骤"><a href="#6-面向对象编程步骤" class="headerlink" title="6. 面向对象编程步骤"></a>6. 面向对象编程步骤</h3><ol><li>声明（定义）结构体，确定结构体名</li><li>编写结构体字段</li><li>编写结构体的方法</li></ol><h3 id="7-包和封装"><a href="#7-包和封装" class="headerlink" title="7. 包和封装"></a>7. 包和封装</h3><ul><li><p>包 ：每一目录一个包</p></li><li><p>main包，包含可执行入口</p></li><li><p>为结构体定义的包必须放在同一个目录下，可以是不同文件</p></li><li><p>工厂模式</p><ul><li><p>说明</p><blockquote><p>go 的结构体没有构造函数，通常使用工厂模式来解决这个问题</p></blockquote></li><li><p>解决问题</p><blockquote><p>如果当前文件需要引入别的包的结构体变量，当别的包的结构体变量首字母并没有大写时，不能直接引入，可以用工厂模式解决。</p></blockquote></li></ul></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// model 包文件</span></span><br><span class="line"><span class="keyword">package</span> model</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> student <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">    Score <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewStudent</span> <span class="params">(n <span class="keyword">string</span>,s <span class="keyword">float64</span>)</span> *<span class="title">student</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;student&#123;</span><br><span class="line">        Name: n,</span><br><span class="line">        Score: s</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//----------------------main.go--------------------</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span>(</span><br><span class="line"><span class="string">"model"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    stu := model.NewStudent(<span class="string">"jerry"</span>,<span class="number">68.2</span>)</span><br><span class="line">    fmt.Println(*stu)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>封装</p><ul><li><p>基本介绍</p><blockquote><p>封装就是把抽象出的字段和对字段的操作封装在一起，数据被保护在内部，程序的其它包只有通过被授权的操作（方法），才能对字段进行操作。</p></blockquote></li><li><p>封装的理解和好处</p><blockquote><ol><li>隐藏实现细节</li><li>可以对数据进行验证，保证安全合理</li></ol></blockquote></li><li><p>如何体现封装</p><blockquote><ol><li>对结构体中的属性进行封装</li><li>通过方法、包实现封装</li></ol></blockquote></li><li><p>封装的实现方法</p><blockquote><ol><li><p>将结构体、字段（属性）的首字母小写（不能导出，被其他包所使用，类似于private）</p></li><li><p>给结构体所在的包提供一个工厂模式的函数，首字母大写。类似于一个构造函数</p></li><li><p>提供一个首字母大写的Set方法（类似于public），用于属性判断并赋值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;    <span class="function"><span class="keyword">func</span> <span class="params">(<span class="keyword">var</span> 结构体类型名)</span> <span class="title">SetXXX</span><span class="params">(参数列表)</span> <span class="params">(返回值列表)</span></span>&#123;</span><br><span class="line">&gt;        <span class="comment">// 加入数据验证业务逻辑</span></span><br><span class="line">&gt;        <span class="keyword">var</span>.字段 = 参数</span><br><span class="line">&gt;    &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ol></blockquote><blockquote><ol start="4"><li><p>提供一个首字母大写的Get方法（类似于public），用于获取属性的值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;    <span class="function"><span class="keyword">func</span> <span class="params">(<span class="keyword">var</span> 结构体类型名)</span> <span class="title">GetXxx</span><span class="params">()</span></span> &#123;</span><br><span class="line">&gt;        <span class="keyword">return</span> <span class="keyword">var</span>.age</span><br><span class="line">&gt;    &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ol></blockquote></li><li><p>实例</p><blockquote><p>对于隐私信息，工资、年龄保密，输入年龄进行验证。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">package</span> model</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="keyword">type</span> person <span class="keyword">struct</span>&#123;</span><br><span class="line">&gt;     name <span class="keyword">string</span></span><br><span class="line">&gt;     age <span class="keyword">int</span></span><br><span class="line">&gt;     sal <span class="keyword">float64</span></span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="function"><span class="keyword">func</span> <span class="title">NewPerson</span><span class="params">(name <span class="keyword">string</span>)</span> *<span class="title">person</span></span> &#123;</span><br><span class="line">&gt;     retrun &amp;person&#123;</span><br><span class="line">&gt;         name: name</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="function"><span class="keyword">func</span> <span class="params">(p *person)</span> <span class="title">SetAge</span><span class="params">(age <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">&gt;     <span class="keyword">if</span> age &gt; <span class="number">0</span> &amp;&amp; age &lt; <span class="number">150</span> &#123;</span><br><span class="line">&gt;         p.age = age</span><br><span class="line">&gt;     &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">&gt;         <span class="keyword">return</span></span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="function"><span class="keyword">func</span> <span class="params">(p *person)</span> <span class="title">GetAge</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">&gt;     <span class="keyword">return</span> p.Age</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="function"><span class="keyword">func</span> <span class="params">(p *person)</span> <span class="title">SetSel</span><span class="params">(sel <span class="keyword">float64</span>)</span></span> &#123;</span><br><span class="line">&gt;     p.sel = sel</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="function"><span class="keyword">func</span> <span class="params">(p *person)</span> <span class="title">GetSel</span> <span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">&gt;     <span class="keyword">return</span> p.sel</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote></li><li><p>扩充系统类型或者别人的类型</p><blockquote><ol><li>定义别名</li><li>使用组合</li></ol></blockquote></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> queue </span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Queue []<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Queue)</span> <span class="title">Push</span> <span class="params">(v <span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">    *q = <span class="built_in">append</span>(*q,v)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Queue)</span> <span class="title">Pop</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    head := (*q)[<span class="number">0</span>]</span><br><span class="line">    *q = (*q)[<span class="number">1</span>:]</span><br><span class="line">    <span class="keyword">return</span> head</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"queue"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    q := queue.Queue&#123;<span class="number">1</span>&#125;</span><br><span class="line">    q.Push(<span class="number">2</span>)</span><br><span class="line">    q.Push(<span class="number">3</span>)</span><br><span class="line">    fmt.Println(q.pop())</span><br><span class="line">    fmt.Println(q.pop())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt; 面向对象：&lt;/strong&gt; &lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;/excerpt&gt;&lt;/p&gt;
&lt;p&gt;go语言养成记之面向对象&lt;/p&gt;
    
    </summary>
    
      <category term="golang" scheme="https://alexbrucelu.github.io/categories/golang/"/>
    
    
      <category term="golang" scheme="https://alexbrucelu.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>基础语法</title>
    <link href="https://alexbrucelu.github.io/2018/11/25/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    <id>https://alexbrucelu.github.io/2018/11/25/基础语法/</id>
    <published>2018-11-25T15:04:21.760Z</published>
    <updated>2018-11-25T15:09:33.545Z</updated>
    
    <content type="html"><![CDATA[<p><strong> 基础语法：</strong> <excerpt in="" index="" |="" 首页摘要=""></excerpt></p><p>go语言养成记之基础语法</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt; 基础语法：&lt;/strong&gt; &lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;/excerpt&gt;&lt;/p&gt;
&lt;p&gt;go语言养成记之基础语法&lt;/p&gt;
    
    </summary>
    
      <category term="golang" scheme="https://alexbrucelu.github.io/categories/golang/"/>
    
    
      <category term="golang" scheme="https://alexbrucelu.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>函数式编程</title>
    <link href="https://alexbrucelu.github.io/2018/11/25/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    <id>https://alexbrucelu.github.io/2018/11/25/函数式编程/</id>
    <published>2018-11-25T15:04:21.758Z</published>
    <updated>2018-12-01T14:46:32.370Z</updated>
    
    <content type="html"><![CDATA[<p><strong> 函数式编程：</strong> <excerpt in="" index="" |="" 首页摘要=""></excerpt></p><p>go语言养成记之函数式编程</p><a id="more"></a><p>[TOC]</p><h1 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h1><h2 id="1-函数与闭包"><a href="#1-函数与闭包" class="headerlink" title="1. 函数与闭包"></a>1. 函数与闭包</h2><p>函数可以作为参数、返回值、和变量</p><ul><li><p>“正统”函数式编程</p><ul><li>不可变性：不能有状态，只有常量和函数</li><li>函数只能有一个参数</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line">improt <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">adder</span><span class="params">()</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>)</span> <span class="title">int</span></span>&#123;</span><br><span class="line">    sum := <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(v <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">        sum += v</span><br><span class="line">        <span class="keyword">return</span> sum</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以下是传统方式函数式编程</span></span><br><span class="line"><span class="comment">//type iAdder func(int) (int,iAdder)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//func adder2(base int) iAdder &#123;</span></span><br><span class="line"><span class="comment">//    return func(v int) (int, iAdder) &#123;</span></span><br><span class="line"><span class="comment">//        return base + v, adder2(base + v)</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    a := adder()</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++ &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"0 + ... + %d = %d"</span>,i,a(i))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数体有局部变量</p><p>斐波那契数列</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fibonacci</span><span class="params">()</span> <span class="title">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    a,b := <span class="number">0</span>,<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">        a,b = b,a+b</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt; 函数式编程：&lt;/strong&gt; &lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;/excerpt&gt;&lt;/p&gt;
&lt;p&gt;go语言养成记之函数式编程&lt;/p&gt;
    
    </summary>
    
      <category term="golang" scheme="https://alexbrucelu.github.io/categories/golang/"/>
    
    
      <category term="golang" scheme="https://alexbrucelu.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>错误处理及资源管理</title>
    <link href="https://alexbrucelu.github.io/2018/11/25/%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E5%8F%8A%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/"/>
    <id>https://alexbrucelu.github.io/2018/11/25/错误处理及资源管理/</id>
    <published>2018-11-25T15:04:21.756Z</published>
    <updated>2018-11-25T15:11:09.807Z</updated>
    
    <content type="html"><![CDATA[<p><strong> 错误处理及资源管理：</strong> <excerpt in="" index="" |="" 首页摘要=""></excerpt></p><p>go语言养成记之错误处理及资源管理</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt; 错误处理及资源管理：&lt;/strong&gt; &lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;/excerpt&gt;&lt;/p&gt;
&lt;p&gt;go语言养成记之错误处理及资源管理&lt;/p&gt;
    
    </summary>
    
      <category term="golang" scheme="https://alexbrucelu.github.io/categories/golang/"/>
    
    
      <category term="golang" scheme="https://alexbrucelu.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>测试与性能调优</title>
    <link href="https://alexbrucelu.github.io/2018/11/25/%E6%B5%8B%E8%AF%95%E4%B8%8E%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/"/>
    <id>https://alexbrucelu.github.io/2018/11/25/测试与性能调优/</id>
    <published>2018-11-25T15:04:21.754Z</published>
    <updated>2018-11-25T15:10:09.343Z</updated>
    
    <content type="html"><![CDATA[<p><strong> 测试与性能调优：</strong> <excerpt in="" index="" |="" 首页摘要=""></excerpt></p><p>go语言养成记之测试与性能调优</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt; 测试与性能调优：&lt;/strong&gt; &lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;/excerpt&gt;&lt;/p&gt;
&lt;p&gt;go语言养成记之测试与性能调优&lt;/p&gt;
    
    </summary>
    
      <category term="golang" scheme="https://alexbrucelu.github.io/categories/golang/"/>
    
    
      <category term="golang" scheme="https://alexbrucelu.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>Consul</title>
    <link href="https://alexbrucelu.github.io/2018/11/25/consul/"/>
    <id>https://alexbrucelu.github.io/2018/11/25/consul/</id>
    <published>2018-11-25T14:51:39.755Z</published>
    <updated>2018-11-25T14:53:26.338Z</updated>
    
    <content type="html"><![CDATA[<p><strong> Consul：</strong> <excerpt in="" index="" |="" 首页摘要=""></excerpt></p><p>微服务之Consul</p><a id="more"></a><h1 id="Consul"><a href="#Consul" class="headerlink" title="Consul"></a>Consul</h1><h2 id="1-Consul的介绍"><a href="#1-Consul的介绍" class="headerlink" title="1. Consul的介绍"></a>1. Consul的介绍</h2><h3 id="1-1-Consul是什么"><a href="#1-1-Consul是什么" class="headerlink" title="1.1 Consul是什么"></a>1.1 Consul是什么</h3><p>Consul是HashiCorp公司推出的开源工具，用于实现分布式系统的服务发现与配置。 Consul是分布式的、高可用的、可横向扩展的。它具备以下特性 :</p><ul><li>service discovery：consul通过DNS或者HTTP接口使服务注册和服务发现变的很容易，一些外部服务，例如saas提供的也可以一样注册。</li><li>health checking：健康检测使consul可以快速的告警在集群中的操作。和服务发现的集成，可以防止服务转发到故障的服务上面。</li><li>key/value storage：一个用来存储动态配置的系统。提供简单的HTTP接口，可以在任何地方操作。</li><li>multi-datacenter：无需复杂的配置，即可支持任意数量的区域。</li></ul><p><strong>举例说明</strong></p><blockquote><p>邮递员去某公司一栋大楼投递快件，向门卫询问员工甲在哪一个房间，门卫拿起桌上的通讯录查询，告知邮递员员工甲在具体什么位置。假如公司来了一个员工乙，他想让邮递员送过来，就要先让门卫知道自己在哪一个房间，需要去门卫那边登记，员工乙登记后，当邮递员向门卫询问时，门卫就可以告诉邮递员员工乙的具体位置。门卫知道员工乙的具体位置的过程就是服务发现，员工乙的位置信息可以被看作服务信息，门卫的通讯录就是上文中提到的数据交换格式，此例中员工乙就是上文的已方，门卫就是服务发现的提供者。</p></blockquote><h3 id="1-2-什么是服务发现"><a href="#1-2-什么是服务发现" class="headerlink" title="1.2 什么是服务发现"></a>1.2 什么是服务发现</h3><p>微服务的框架体系中，服务发现是不能不提的一个模块。相信了解或者熟悉微服务的童鞋应该都知道它的重要性。我们看下面的一幅图片：</p><p><img src="https://github.com/AlexBruceLu/DAPP/wiki/uber5.png" alt=""></p><p>客户端的一个接口，需要调用服务A-N。客户端必须要知道所有服务的网络位置的，以往的做法是配置文件中，或者有些配置在数据库中。这里就带出几个问题：</p><ul><li>需要配置N个服务的网络位置，加大配置的复杂性</li><li>服务的网络位置变化，都需要改变每个调用者的配置</li><li><p>集群的情况下，难以做负载（反向代理的方式除外）</p></li><li><font color="red">总结起来一句话：服务多了，配置很麻烦，问题多多</font></li></ul><p><img src="https://github.com/AlexBruceLu/DAPP/wiki/uber6.png" alt=""></p><p>与上图不同的是，加了个服务发现模块。图比较简单，这边文字描述下。服务A-N把当前自己的网络位置注册到服务发现模块（这里注册的意思就是告诉），服务发现就以K-V的方式记录下，K一般是服务名，V就是IP:PORT。服务发现模块定时的轮询查看这些服务能不能访问的了（这就是健康检查）。客户端在调用服务A-N的时候，就跑去服务发现模块问下它们的网络位置，然后再调用它们的服务。这样的方式是不是就可以解决上面的问题了呢？客户端完全不需要记录这些服务网络位置，客户端和服务端完全解耦！</p><h2 id="2-Consul的安装"><a href="#2-Consul的安装" class="headerlink" title="2. Consul的安装"></a>2. Consul的安装</h2><p>Consul用Golang实现，因此具有天然可移植性 (支持 Linux、windows和macOS)。安装包仅包含一个可执行文件。 Consul安装非常简单，只需要下载对应系统的软件包并解压后就可使用。</p><h3 id="2-1-下载安装"><a href="#2-1-下载安装" class="headerlink" title="2.1 下载安装"></a>2.1 下载安装</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 这里以 Linux系统为例：</span><br><span class="line"><span class="meta">$</span> wget https://releases.hashicorp.com/consul/1.2.0/consul_1.2.0_linux_amd64.zip</span><br><span class="line"><span class="meta">$</span> unzip consul_1.2.0_linux_amd64.zip</span><br><span class="line"><span class="meta">$</span> mv consul /usr/local/bin/</span><br></pre></td></tr></table></figure><p><a href="https://www.consul.io/downloads.html" target="_blank" rel="noopener">其他系统</a></p><h3 id="2-2-验证安装"><a href="#2-2-验证安装" class="headerlink" title="2.2 验证安装"></a>2.2 验证安装</h3><p>安装 Consul后，通过执行 consul命令，你可以看到命令列表的输出</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> consul # 出现下图内容证明安装成功</span><br></pre></td></tr></table></figure><p><img src="https://github.com/AlexBruceLu/DAPP/wiki/uber7.png" alt=""></p><h2 id="3-Consul主要作用"><a href="#3-Consul主要作用" class="headerlink" title="3. Consul主要作用"></a>3. Consul主要作用</h2><ul><li>client: 客户端, 无状态, 将 HTTP 和 DNS 接口请求转发给局域网内的服务端集群.</li><li>server: 服务端, 保存配置信息, 高可用集群, 在局域网内与本地客户端通讯, 通过广域网与其他数据中心通讯. 每个数据中心的 server 数量推荐为 3 个或是 5 个</li></ul><h3 id="3-1-运行-Consul代理"><a href="#3-1-运行-Consul代理" class="headerlink" title="3.1 运行 Consul代理"></a>3.1 运行 Consul代理</h3><p>Consul是典型的 C/S架构，可以运行服务模式或客户模式。每一个数据中心必须有至少一个服务节点， 3到5个服务节点最好。非常不建议只运行一个服务节点，因为在节点失效的情况下数据有极大的丢失风险。</p><h3 id="3-2-运行Agent"><a href="#3-2-运行Agent" class="headerlink" title="3.2 运行Agent"></a>3.2 运行Agent</h3><p>完成Consul的安装后,必须运行agent. agent可以运行为server或client模式.每个数据中心至少必须拥有一台server. 建议在一个集群中有3或者5个server.部署单一的server,在出现失败时会不可避免的造成数据丢失.其他的agent运行为client模式.一个client是一个非常轻量级的进程.用于注册服务,运行健康检查和转发对server的查询.agent必须在集群中的每个主机上运行.</p><h3 id="3-3-启动-Consul-Server"><a href="#3-3-启动-Consul-Server" class="headerlink" title="3.3 启动 Consul Server"></a>3.3 启动 Consul Server</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>node1:</span><br><span class="line"><span class="meta">$</span> consul agent -server -bootstrap-expect 2 -data-dir /tmp/consul -node=n1 -</span><br><span class="line">bind=192.168.110.123 -ui -config-dir /etc/consul.d -rejoin -join 192.168.110.123 -</span><br><span class="line">client 0.0.0.0</span><br><span class="line"><span class="meta">#</span>运行cosnul agent以server模式</span><br><span class="line">-server ： 定义agent运行在server模式</span><br><span class="line">-bootstrap-expect ：在一个datacenter中期望提供的server节点数目，当该值提供的时候，consul一直等到达到指定sever数目的时候才会引导整个集群，该标记不能和bootstrap共用</span><br><span class="line">-data-dir：提供一个目录用来存放agent的状态，所有的agent允许都需要该目录，该目录必须是稳定的，系统重启后都继续存在</span><br><span class="line">-node：节点在集群中的名称，在一个集群中必须是唯一的，默认是该节点的主机名</span><br><span class="line">-bind：该地址用来在集群内部的通讯，集群内的所有节点到地址都必须是可达的，默认是0.0.0.0</span><br><span class="line">-ui： 启动web界面</span><br><span class="line">-config-dir：：配置文件目录，里面所有以.json结尾的文件都会被加载</span><br><span class="line">-rejoin：使consul忽略先前的离开，在再次启动后仍旧尝试加入集群中。</span><br><span class="line">-client：consul服务侦听地址，这个地址提供HTTP、DNS、RPC等服务，默认是127.0.0.1所以不对外提供服务，如果你要对外提供服务改成0.0.0.0</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>node2:</span><br><span class="line"><span class="meta">$</span> consul agent -server -bootstrap-expect 2 -data-dir /tmp/consul -node=n2 -</span><br><span class="line">bind=192.168.110.148 -ui -rejoin -join 192.168.110.123</span><br><span class="line">-server ： 定义agent运行在server模式</span><br><span class="line">-bootstrap-expect ：在一个datacenter中期望提供的server节点数目，当该值提供的时候，consul一直等到达到指定sever数目的时候才会引导整个集群，该标记不能和bootstrap共用</span><br><span class="line">-bind：该地址用来在集群内部的通讯，集群内的所有节点到地址都必须是可达的，默认是0.0.0.0</span><br><span class="line">-node：节点在集群中的名称，在一个集群中必须是唯一的，默认是该节点的主机名</span><br><span class="line">-ui： 启动web界面</span><br><span class="line">-rejoin：使consul忽略先前的离开，在再次启动后仍旧尝试加入集群中。</span><br><span class="line">-config-dir：：配置文件目录，里面所有以.json结尾的文件都会被加载</span><br><span class="line">-client：consul服务侦听地址，这个地址提供HTTP、DNS、RPC等服务，默认是127.0.0.1所以不对外提供服务，如果你要对外提供服务改成0.0.0.0</span><br><span class="line">-join 192.168.110.121 ： 启动时加入这个集群</span><br></pre></td></tr></table></figure><h3 id="3-4-启动-Consul-Client"><a href="#3-4-启动-Consul-Client" class="headerlink" title="3.4 启动 Consul Client"></a>3.4 启动 Consul Client</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>node3：</span><br><span class="line"><span class="meta">$</span> consul agent -data-dir /tmp/consul -node=n3 -bind=192.168.110.124 -config-dir/etc/consul.d -rejoin -join 192.168.110.123</span><br><span class="line">运行cosnul agent以client模式，-join 加入到已有的集群中去。</span><br></pre></td></tr></table></figure><ul><li>查看集群成员<ul><li><strong>新开一个终端窗口运行consul members, 你可以看到Consul集群的成员</strong></li></ul></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> consul members</span><br><span class="line"><span class="meta">#</span>节点 网络地址 状态 类型 版本 协议 数据中心 分管部分</span><br><span class="line">Node Address Status Type Build Protocol DC Segment</span><br><span class="line">n1 192.168.110.7:8301 alive server 1.1.0 2 dc1 &lt;all&gt;</span><br><span class="line">n2 192.168.110.121:8301 alive server 1.1.0 2 dc1 &lt;all&gt;</span><br><span class="line">n3 192.168.110.122:8301 alive client 1.1.0 2 dc1 &lt;default&gt;</span><br></pre></td></tr></table></figure><h3 id="3-5-停止Agent"><a href="#3-5-停止Agent" class="headerlink" title="3.5 停止Agent"></a>3.5 停止Agent</h3><p>可以使用Ctrl-C 优雅的关闭Agent. 中断Agent之后你可以看到他离开了集群并关闭.</p><p>在退出中,Consul提醒其他集群成员,这个节点离开了.如果你强行杀掉进程.集群的其他成员应该能检测到这个节点失效了.当一个成员离开,他的服务和检测也会从目录中移除.当一个成员失效了,他的健康状况被简单的标记为危险,但是不会从目录中移除.Consul会自动尝试对失效的节点进行重连.允许他从某些网络条件下恢复过来.离开的节点则不会再继续联系.</p><p>此外,如果一个agent作为一个服务器,一个优雅的离开是很重要的,可以避免引起潜在的可用性故障影响达成一致性协议. consul优雅的退出</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> consul leave</span><br></pre></td></tr></table></figure><h2 id="4-注册服务"><a href="#4-注册服务" class="headerlink" title="4. 注册服务"></a>4. 注册服务</h2><p>搭建好conusl集群后，用户或者程序就能到consul中去查询或者注册服务。可以通过提供服务定义文件或者调用HTTP API来注册一个服务.</p><ul><li><p>首先,为Consul配置创建一个目录.Consul会载入配置文件夹里的所有配置文件.在Unix系统中通常类似/etc/consul.d (.d 后缀意思是这个路径包含了一组配置文件).</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> mkdir /etc/consul.d</span><br></pre></td></tr></table></figure></li><li><p>然后,我们将编写服务定义配置文件.假设我们有一个名叫web的服务运行在 10000端口.另外,我们将给他设置一个标签.这样我们可以使用他作为额外的查询方式:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">"service": &#123; //服务</span><br><span class="line">"name": "web", //名称</span><br><span class="line">"tags": ["master"], //标记</span><br><span class="line">"address": "127.0.0.1", //ip</span><br><span class="line">"port": 10000, //端口</span><br><span class="line">"checks": [</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">"http"</span>: <span class="string">"http://localhost:10000/health"</span>,</span><br><span class="line"><span class="attr">"interval"</span>: <span class="string">"10s"</span> //检查时间</span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试程序</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line">) </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"hello Web3! This is n3或者n2"</span>)</span><br><span class="line">fmt.Fprintf(w, <span class="string">"Hello Web3! This is n3或者n2"</span>)</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">healthHandler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"health check! n3或者n2"</span>)</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">http.HandleFunc(<span class="string">"/"</span>, handler)</span><br><span class="line">http.HandleFunc(<span class="string">"/health"</span>, healthHandler)</span><br><span class="line">http.ListenAndServe(<span class="string">":10000"</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="5-查询服务"><a href="#5-查询服务" class="headerlink" title="5. 查询服务"></a>5. 查询服务</h2><p>一旦agent启动并且服务同步了.我们可以通过DNS或者HTTP的API来查询服务.</p><ul><li><p>DNS API</p><blockquote><p>让我们首先使用DNS API来查询.在DNS API中,服务的DNS名字是 NAME.service.consul. 虽然是可配置的,但默认的所有DNS名字会都在consul命名空间下.这个子域告诉Consul,我们在查询服务,NAME则是服务的名称.<br>对于我们上面注册的Web服务.它的域名是 web.service.consul :</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> dig @127.0.0.1 -p 8600 web.service.consul</span><br></pre></td></tr></table></figure></li><li><p>有也可用使用 DNS API 来接收包含 地址和端口的 SRV记录:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> dig @127.0.0.1 -p 8600 web.service.consul SRV</span><br></pre></td></tr></table></figure></li></ul><h2 id="6-Consul架构"><a href="#6-Consul架构" class="headerlink" title="6. Consul架构"></a>6. Consul架构</h2><p><img src="https://github.com/AlexBruceLu/DAPP/wiki/uber8.png" alt=""></p><p>我们只看数据中心1，可以看出consul的集群是由N个SERVER，加上M个CLIENT组成的。而不管是<code>SERVER</code>还是<code>CLIENT</code>，都是consul的一个节点，所有的服务都可以注册到这些节点上，正是通过这些节点实现服务注册信息的共享。除了这两个，还有一些小细节，一一简单介绍。</p><p><code>CLIENT</code> CLIENT表示consul的client模式，就是客户端模式。是consul节点的一种模式，这种模式下，所有注册到当前节点的服务会被转发到SERVER【通过HTTP和DNS接<br>口请求server】，本身是<code>不持久化</code>这些信息。 </p><p><code>SERVER</code>SERVER表示consul的server模式，表明这个consul是个server，这种模式下，功能和CLIENT都一样，唯一不同的是，它会把所有的信息持久化的本地，这样遇到故障，信息是可以被保留的 <code>SERVER-LEADER</code> 中间那个SERVER下面有LEADER的字眼，表明这个SERVER是它们的老大，它和其它SERVER不一样的一点是，它需要负责同步注册的信息给其它的SERVER，同时也要负责各个节点的健康监测。</p><ul><li><p>Consul的client mode把请求转向server，那么client的作用是什么？</p><blockquote><p>consul可以用来实现分布式系统的服务发现与配置。client把服务请求传递给server，server负责提供服务以及和其他数据中心交互。题主的问题是，既然server端提供了所有服务，那为何还需要多此一举地用client端来接收一<br>次服务请求。我想，采用这种架构有以下几种理由： </p><p>首先server端的网络连接资源有限。对于一个分布式系统，一般情况下访问量是很大的。如果用户能不通过client直接地访问数据中心，那么数据中心必然要为每个用户提供一个单独的连接资源(线程，端口号等等)，那么server端的负担会非常大。所以很有必要用大量的client端来分散用户的连接请求，在client端先统一整合用户的服务请求，然后一次性地通过一个单一的链接发送大量的请求给server端，能够大量减少server端的网络负担。 </p><p>其次，在client端可以对用户的请求进行一些处理来提高服务的效率，比如将相同的请求合并成同一个查询，再比如将之前的查询通过cookie的形式缓存下来。但是这些功能都需要消耗不少的计算和存储资源。如果在server端提供这些功能，必然加重server端的负担，使得server端更加不稳定。而通过client端来进行这些服务就没有这些问题了，因为client端不提供实际服务，有很充足的计算资源来进行这些处理这些工作。 最后还有一点，consul规定只要接入一个client就能将自己注册到一个服务网络当中。这种架构使得系统的可扩展性非常的强，网络的拓扑变化可以特别的灵活。这也是依赖于client—server结构的。如果系统中只有几个数据中心存在，那网络的扩张也无从谈起了。</p></blockquote></li><li><p>Consul资料：</p></li><li><a href="http://www.liangxiansen.cn/2017/04/06/consul/" target="_blank" rel="noopener">http://www.liangxiansen.cn/2017/04/06/consul/</a></li><li><a href="https://blog.csdn.net/yuanyuanispeak/article/details/54880743" target="_blank" rel="noopener">https://blog.csdn.net/yuanyuanispeak/article/details/54880743</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt; Consul：&lt;/strong&gt; &lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;/excerpt&gt;&lt;/p&gt;
&lt;p&gt;微服务之Consul&lt;/p&gt;
    
    </summary>
    
      <category term="microServices" scheme="https://alexbrucelu.github.io/categories/microServices/"/>
    
    
      <category term="微服务" scheme="https://alexbrucelu.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
</feed>
