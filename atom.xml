<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://alexbrucelu.github.io/"/>
  <updated>2019-06-03T17:49:45.173Z</updated>
  <id>https://alexbrucelu.github.io/</id>
  
  <author>
    <name>AlexBruceLu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>深度理解“三次握手，四次挥手”</title>
    <link href="https://alexbrucelu.github.io/2019/06/04/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/"/>
    <id>https://alexbrucelu.github.io/2019/06/04/三次握手四次挥手/</id>
    <published>2019-06-03T16:19:44.245Z</published>
    <updated>2019-06-03T17:49:45.173Z</updated>
    
    <content type="html"><![CDATA[<p><strong> 深度理解“三次握手，四次挥手”：</strong> <excerpt in="" index="" |="" 首页摘要=""></excerpt></p><p>深度理解“三次握手，四次挥手”</p><a id="more"></a><p>[TOC]</p><p>作为程序员，要有刨根问底的精神。知其然，切知其所以然。</p><h2 id="什么是“三次握手，四次挥手”？"><a href="#什么是“三次握手，四次挥手”？" class="headerlink" title="什么是“三次握手，四次挥手”？"></a>什么是“三次握手，四次挥手”？</h2><p>TCP是一种面向连接的单播协议，在发送数据前，通信双方必须在彼此之间建立一条连接。所谓的“连接”，其实是客户端与服务器的内存里保存的一份关于对方的信息，譬如IP地址、端口号等。</p><p>TCP可以看成是一种字节流，它会处理IP层或以下层的丢包、重复以及错误问题。在连接的建立过程中，双方需要交换一些连接的参数。这些参数可以放在TCP的头部。</p><p>TCP提供了一种可靠、面向连接、字节流、传输层的服务，采用三次握手建立一个连接。采用四次挥手来关闭一个连接。</p><h3 id="TCP服务模型"><a href="#TCP服务模型" class="headerlink" title="TCP服务模型"></a>TCP服务模型</h3><p>在了解建立连接、关闭连接的“三次握手、四次挥手”后，我们需要了解下TCP相关的东西。</p><p>一个TCP连接是由一个4元组构成的，分别是两个IP地址和两个端口号。一个TCP连接通常会分为三个阶段：启动、数据传输、退出（关闭）。</p><p>当TCP接收到另一端的数据时，它会发送一个确认，但这个确认不会立即发送，一般会延迟一会儿。ACK是累积的，一个确认字节号N的ACK表示所有直到N的字节（不包括N）已经成功被接收了。这样的好处是如果一个ACK丢失，很可能后续的ACK就足以确认前面的报文段了。</p><p>一个完整的TCP连接是双向和对称的，数据可以在两个方向上平等地流动。给上层应用程序提供一种<code>双工服务</code>。一旦建立了一个连接，这个连接的一个方向上的每个TCP报文段都包含了相反方向上的报文段的一个ACK。</p><p>序列号的作用是使得一个TCP接收端可丢弃重复的报文段，记录以杂乱次序到达的报文段。因为TCP使用IP来传输报文段，而IP不提供重复消除或者保证次序正确的功能。另一方面，TCP是一个字节流协议，绝不会以杂乱的次序给上层程序发送数据。因此TCP接收端会被迫先保持大序列号的数据不交给应用程序，直到缺失的小序列号的报文段被填满。</p><h3 id="TCP头部"><a href="#TCP头部" class="headerlink" title="TCP头部"></a>TCP头部</h3><p><img src="http://upload-images.jianshu.io/upload_images/12234098-40089b5b24b9d38b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>源端口和目的端口在TCP层确定双方进程，序列号表示的是报文段数据中的第一个字节号，ACK表示确认号，该确认号的发送方期待接收的下一个序列号，即最后被成功接收的数据字节序列号加1，这个字段只有在ACK位被启用的时候才有效。</p><p>当新建一个连接时，从客户端发送到服务端的第一个报文段的SYN位被启用，这称为SYN报文段，这时序列号字段包含了在本次连接的这个方向上要使用的第一个序列号，即初始序列号<code>ISN</code>，之后发送的数据是ISN加1，因此SYN位字段会<code>消耗</code>一个序列号，这意味着使用重传进行可靠传输。而不消耗序列号的ACK则不是。</p><p>头部长度（图中的数据偏移）以32位字为单位，也就是以4bytes为单位，它只有4位，最大为15，因此头部最大长度为60字节，而其最小为5，也就是头部最小为20字节（可变选项为空）。</p><p>ACK —— 确认，使得确认号有效。</p><p>RST —— 重置连接（经常看到的reset by peer）就是此字段搞的鬼。 </p><p>SYN —— 用于初如化一个连接的序列号。 </p><p>FIN —— 该报文段的发送方已经结束向对方发送数据。</p><p>当一个连接被建立或被终止时，交换的报文段只包含TCP头部，而没有数据。</p><h3 id="状态转换"><a href="#状态转换" class="headerlink" title="状态转换"></a>状态转换</h3><p>三次握手和四次挥手的状态转换如下图。</p><p><img src="http://upload-images.jianshu.io/upload_images/12234098-40f65020a755ca18?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h2 id="为什么要“三次握手，四次挥手”？"><a href="#为什么要“三次握手，四次挥手”？" class="headerlink" title="为什么要“三次握手，四次挥手”？"></a>为什么要“三次握手，四次挥手”？</h2><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p>换个易于理解的视角来看为什么要3次握手。</p><p>客户端和服务端通信前要进行连接，“3次握手”的作用就是<code>双方都能明确自己和对方的收、发能力是正常的</code>。</p><p><code>第一次握手</code>：客户端发送网络包，服务端收到了。这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。</p><p><code>第二次握手</code>：服务端发包，客户端收到了。这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。<br>从客户端的视角来看，我接到了服务端发送过来的响应数据包，说明服务端接收到了我在第一次握手时发送的网络包，并且成功发送了响应数据包，这就说明，服务端的接收、发送能力正常。而另一方面，我收到了服务端的响应数据包，说明我第一次发送的网络包成功到达服务端，这样，我自己的发送和接收能力也是正常的。</p><p><code>第三次握手</code>：客户端发包，服务端收到了。这样服务端就能得出结论：客户端的接收、发送能力，服务端的发送、接收能力是正常的。<br>第一、二次握手后，服务端并不知道客户端的接收能力以及自己的发送能力是否正常。而在第三次握手时，服务端收到了客户端对第二次握手作的回应。从服务端的角度，我在第二次握手时的响应数据发送出去了，客户端接收到了。所以，我的发送能力是正常的。而客户端的接收能力也是正常的。</p><p>经历了上面的三次握手过程，客户端和服务端都确认了自己的接收、发送能力是正常的。之后就可以正常通信了。</p><p>每次都是接收到数据包的一方可以得到一些结论，发送的一方其实没有任何头绪。我虽然有发包的动作，但是我怎么知道我有没有发出去，而对方有没有接收到呢？</p><p>而从上面的过程可以看到，最少是需要三次握手过程的。两次达不到让双方都得出自己、对方的接收、发送能力都正常的结论。其实每次收到网络包的一方至少是可以得到：对方的发送、我方的接收是正常的。而每一步都是有关联的，下一次的“响应”是由于第一次的“请求”触发，因此每次握手其实是可以得到额外的结论的。比如第三次握手时，服务端收到数据包，表明看服务端只能得到客户端的发送能力、服务端的接收能力是正常的，但是结合第二次，说明服务端在第二次发送的响应包，客户端接收到了，并且作出了响应，从而得到额外的结论：客户端的接收、服务端的发送是正常的。</p><p>用表格总结一下：</p><table><thead><tr><th>视角</th><th>客收</th><th>客发</th><th>服收</th><th>服发</th></tr></thead><tbody><tr><td>客视角</td><td>二</td><td>一 + 二</td><td>一 + 二</td><td>二</td></tr><tr><td>服视角</td><td>二 + 三</td><td>一</td><td>一</td><td>二 + 三</td></tr></tbody></table><h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p>TCP连接是双向传输的对等的模式，就是说双方都可以同时向对方发送或接收数据。当有一方要关闭连接时，会发送指令告知对方，我要关闭连接了。这时对方会回一个ACK，此时一个方向的连接关闭。但是另一个方向仍然可以继续传输数据，等到发送完了所有的数据后，会发送一个FIN段来关闭此方向上的连接。接收方发送ACK确认关闭连接。注意，接收到FIN报文的一方只能回复一个ACK, 它是无法马上返回对方一个FIN报文段的，因为结束数据传输的“指令”是上层应用层给出的，我只是一个“搬运工”，我无法了解<code>“上层的意志”</code>。</p><h2 id="“三次握手，四次挥手”怎么完成？"><a href="#“三次握手，四次挥手”怎么完成？" class="headerlink" title="“三次握手，四次挥手”怎么完成？"></a>“三次握手，四次挥手”怎么完成？</h2><p>其实3次握手的目的并不只是让通信双方都了解到一个连接正在建立，还在于利用数据包的选项来传输特殊的信息，交换初始序列号ISN。</p><p>3次握手是指发送了3个报文段，4次挥手是指发送了4个报文段。注意，SYN和FIN段都是会利用重传进行可靠传输的。</p><p><img src="http://upload-images.jianshu.io/upload_images/12234098-8604b533d42457b5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="三次握手"></p><h3 id="三次握手-1"><a href="#三次握手-1" class="headerlink" title="三次握手"></a>三次握手</h3><ol><li>客户端发送一个SYN段，并指明客户端的初始序列号，即ISN(c).</li><li>服务端发送自己的SYN段作为应答，同样指明自己的ISN(s)。为了确认客户端的SYN，将ISN(c)+1作为ACK数值。这样，每发送一个SYN，序列号就会加1. 如果有丢失的情况，则会重传。</li><li>为了确认服务器端的SYN，客户端将ISN(s)+1作为返回的ACK数值。</li></ol><h3 id="四次挥手-1"><a href="#四次挥手-1" class="headerlink" title="四次挥手"></a>四次挥手</h3><p><img src="http://upload-images.jianshu.io/upload_images/12234098-3754de754cbcf2af.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="四次挥手"></p><ol><li>客户端发送一个FIN段，并包含一个希望接收者看到的自己当前的序列号K. 同时还包含一个ACK表示确认对方最近一次发过来的数据。</li><li>服务端将K值加1作为ACK序号值，表明收到了上一个包。这时上层的应用程序会被告知另一端发起了关闭操作，通常这将引起应用程序发起自己的关闭操作。</li><li>服务端发起自己的FIN段，ACK=K+1, Seq=L</li><li>客户端确认。ACK=L+1</li></ol><h3 id="为什么建立连接是“三次握手”，而关闭连接是“四次挥手”呢？"><a href="#为什么建立连接是“三次握手”，而关闭连接是“四次挥手”呢？" class="headerlink" title="为什么建立连接是“三次握手”，而关闭连接是“四次挥手”呢？"></a>为什么建立连接是“三次握手”，而关闭连接是“四次挥手”呢？</h3><p>这是因为服务端在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。而关闭连接时，当收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，己方是否现在关闭发送数据通道，需要上层应用来决定，因此，己方ACK和FIN一般都会分开发送。</p><h2 id="“三次握手，四次挥手”进阶"><a href="#“三次握手，四次挥手”进阶" class="headerlink" title="“三次握手，四次挥手”进阶"></a>“三次握手，四次挥手”进阶</h2><h3 id="ISN"><a href="#ISN" class="headerlink" title="ISN"></a>ISN</h3><p>三次握手的一个重要功能是客户端和服务端交换ISN(Initial Sequence Number), 以便让对方知道接下来接收数据的时候如何按序列号组装数据。</p><p>如果ISN是固定的，攻击者很容易猜出后续的确认号。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ISN = M + F(localhost, localport, remotehost, remoteport)</span><br></pre></td></tr></table></figure><p>M是一个计时器，每隔4微秒加1。<br>F是一个Hash算法，根据源IP、目的IP、源端口、目的端口生成一个随机数值。要保证hash算法不能被外部轻易推算得出。</p><h3 id="序列号回绕"><a href="#序列号回绕" class="headerlink" title="序列号回绕"></a>序列号回绕</h3><p>因为ISN是随机的，所以序列号容易就会超过2^31-1. 而tcp对于丢包和乱序等问题的判断都是依赖于序列号大小比较的。此时就出现了所谓的tcp序列号回绕（sequence wraparound）问题。怎么解决？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* The next routines deal with comparing 32 bit unsigned ints</span></span><br><span class="line"><span class="comment">* and worry about wraparound (automatic with unsigned arithmetic).</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">before</span><span class="params">(__u32 seq1, __u32 seq2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (__s32)(seq1-seq2) &lt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> after(seq2, seq1) before(seq1, seq2)</span></span><br></pre></td></tr></table></figure><p>上述代码是内核中的解决回绕问题代码。<strong>s32是有符号整型的意思，而</strong>u32则是无符号整型。序列号发生回绕后，序列号变小，相减之后，把结果变成有符号数了，因此结果成了负数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">假设seq1=255， seq2=1（发生了回绕）。</span><br><span class="line">seq1 = 1111 1111 seq2 = 0000 0001</span><br><span class="line">我们希望比较结果是</span><br><span class="line"> seq1 - seq2=</span><br><span class="line"> 1111 1111</span><br><span class="line">-0000 0001</span><br><span class="line">-----------</span><br><span class="line"> 1111 1110</span><br><span class="line"></span><br><span class="line">由于我们将结果转化成了有符号数，由于最高位是1，因此结果是一个负数，负数的绝对值为</span><br><span class="line"> 0000 0001 + 1 = 0000 0010 = 2</span><br><span class="line"></span><br><span class="line">因此seq1 - seq2 &lt; 0</span><br></pre></td></tr></table></figure><h3 id="syn-flood攻击"><a href="#syn-flood攻击" class="headerlink" title="syn flood攻击"></a>syn flood攻击</h3><p>最基本的DoS攻击就是利用合理的服务请求来占用过多的服务资源，从而使合法用户无法得到服务的响应。syn flood属于Dos攻击的一种。</p><p>如果恶意的向某个服务器端口发送大量的SYN包，则可以使服务器打开大量的半开连接，分配TCB（Transmission Control Block）, 从而消耗大量的服务器资源，同时也使得正常的连接请求无法被相应。当开放了一个TCP端口后，该端口就处于Listening状态，不停地监视发到该端口的Syn报文，一 旦接收到Client发来的Syn报文，就需要为该请求分配一个TCB，通常一个TCB至少需要280个字节，在某些操作系统中TCB甚至需要1300个字节，并返回一个SYN ACK命令，立即转为SYN-RECEIVED即半开连接状态。系统会为此耗尽资源。</p><p>常见的防攻击方法有：</p><h4 id="无效了解的监视释放"><a href="#无效了解的监视释放" class="headerlink" title="无效了解的监视释放"></a>无效了解的监视释放</h4><p>监视系统的半开连接和不活动连接，当达到一定阈值时拆除这些连接，从而释放系统资源。这种方法对于所有的连接一视同仁，而且由于SYN Flood造成的半开连接数量很大，正常连接请求也被淹没在其中被这种方式误释放掉，因此这种方法属于入门级的SYN Flood方法。</p><h4 id="延缓TCB分配方法"><a href="#延缓TCB分配方法" class="headerlink" title="延缓TCB分配方法"></a>延缓TCB分配方法</h4><p>消耗服务器资源主要是因为当SYN数据报文一到达，系统立即分配TCB，从而占用了资源。而SYN Flood由于很难建立起正常连接，因此，当正常连接建立起来后再分配TCB则可以有效地减轻服务器资源的消耗。常见的方法是使用Syn Cache和Syn Cookie技术。</p><h5 id="Syn-Cache技术"><a href="#Syn-Cache技术" class="headerlink" title="Syn Cache技术"></a>Syn Cache技术</h5><p>系统在收到一个SYN报文时，在一个专用HASH表中保存这种半连接信息，直到收到正确的回应ACK报文再分配TCB。这个开销远小于TCB的开销。当然还需要保存序列号。</p><h5 id="Syn-Cookie技术"><a href="#Syn-Cookie技术" class="headerlink" title="Syn Cookie技术"></a>Syn Cookie技术</h5><p>Syn Cookie技术则完全不使用任何存储资源，这种方法比较巧妙，它使用一种特殊的算法生成Sequence Number，这种算法考虑到了对方的IP、端口、己方IP、端口的固定信息，以及对方无法知道而己方比较固定的一些信息，如MSS(Maximum Segment Size，最大报文段大小，指的是TCP报文的最大数据报长度，其中不包括TCP首部长度。)、时间等，在收到对方 的ACK报文后，重新计算一遍，看其是否与对方回应报文中的（Sequence Number-1）相同，从而决定是否分配TCB资源。</p><h4 id="使用SYN-Proxy防火墙"><a href="#使用SYN-Proxy防火墙" class="headerlink" title="使用SYN Proxy防火墙"></a>使用SYN Proxy防火墙</h4><p>一种方式是防止墙dqywb连接的有效性后，防火墙才会向内部服务器发起SYN请求。防火墙代服务器发出的SYN ACK包使用的序列号为c, 而真正的服务器回应的序列号为c’, 这样，在每个数据报文经过防火墙的时候进行序列号的修改。另一种方式是防火墙确定了连接的安全后，会发出一个safe reset命令，client会进行重新连接，这时出现的syn报文会直接放行。这样不需要修改序列号了。但是，client需要发起两次握手过程，因此建立连接的时间将会延长。</p><h3 id="连接队列"><a href="#连接队列" class="headerlink" title="连接队列"></a>连接队列</h3><p>在外部请求到达时，被服务程序最终感知到前，连接可能处于SYN_RCVD状态或是ESTABLISHED状态，但还未被应用程序接受。</p><p><img src="http://upload-images.jianshu.io/upload_images/12234098-36b3c46688c685c7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="tcp queue"></p><p>对应地，服务器端也会维护两种队列，处于SYN_RCVD状态的半连接队列，而处于ESTABLISHED状态但仍未被应用程序accept的为全连接队列。如果这两个队列满了之后，就会出现各种丢包的情形。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">查看是否有连接溢出</span><br><span class="line">netstat -s | grep LISTEN</span><br></pre></td></tr></table></figure><h4 id="半连接队列满了"><a href="#半连接队列满了" class="headerlink" title="半连接队列满了"></a>半连接队列满了</h4><p>在三次握手协议中，服务器维护一个半连接队列，该队列为每个客户端的SYN包开设一个条目(服务端在接收到SYN包的时候，就已经创建了request_sock结构，存储在半连接队列中)，该条目表明服务器已收到SYN包，并向客户发出确认，正在等待客户的确认包。这些条目所标识的连接在服务器处于Syn_RECV状态，当服务器收到客户的确认包时，删除该条目，服务器进入ESTABLISHED状态。</p><blockquote><p>目前，Linux下默认会进行5次重发SYN-ACK包，重试的间隔时间从1s开始，下次的重试间隔时间是前一次的双倍，5次的重试时间间隔为1s, 2s, 4s, 8s, 16s, 总共31s, 称为<code>指数退避</code>，第5次发出后还要等32s才知道第5次也超时了，所以，总共需要 1s + 2s + 4s+ 8s+ 16s + 32s = 63s, TCP才会把断开这个连接。由于，SYN超时需要63秒，那么就给攻击者一个攻击服务器的机会，攻击者在短时间内发送大量的SYN包给Server(俗称SYN flood攻击)，用于耗尽Server的SYN队列。对于应对SYN 过多的问题，linux提供了几个TCP参数：tcp_syncookies、tcp_synack_retries、tcp_max_syn_backlog、tcp_abort_on_overflow 来调整应对。</p></blockquote><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>tcp_syncookies</td><td>SYNcookie将连接信息编码在ISN(initialsequencenumber)中返回给客户端，这时server不需要将半连接保存在队列中，而是利用客户端随后发来的ACK带回的ISN还原连接信息，以完成连接的建立，避免了半连接队列被攻击SYN包填满。</td></tr><tr><td>tcp_syncookies</td><td>内核放弃建立连接之前发送SYN包的数量。</td></tr><tr><td>tcp_synack_retries</td><td>内核放弃连接之前发送SYN+ACK包的数量</td></tr><tr><td>tcp_max_syn_backlog</td><td>默认为1000. 这表示半连接队列的长度，如果超过则放弃当前连接。</td></tr><tr><td>tcp_abort_on_overflow</td><td>如果设置了此项，则直接reset. 否则，不做任何操作，这样当服务器半连接队列有空了之后，会重新接受连接。<code>Linux坚持在能力许可范围内不忽略进入的连接</code>。客户端在这期间会重复发送sys包，当重试次数到达上限之后，会得到<code>connection time out</code>响应。</td></tr></tbody></table><h4 id="全连接队列满了"><a href="#全连接队列满了" class="headerlink" title="全连接队列满了"></a>全连接队列满了</h4><p>当第三次握手时，当server接收到ACK包之后，会进入一个新的叫 accept 的队列。</p><p>当accept队列满了之后，即使client继续向server发送ACK的包，也会不被响应，此时ListenOverflows+1，同时server通过tcp_abort_on_overflow来决定如何返回，0表示直接丢弃该ACK，1表示发送RST通知client；相应的，client则会分别返回<code>read timeout</code> 或者 <code>connection reset by peer</code>。另外，tcp_abort_on_overflow是0的话，server过一段时间再次发送syn+ack给client（也就是重新走握手的第二步），如果client超时等待比较短，就很容易异常了。而客户端收到多个 SYN ACK 包，则会认为之前的 ACK 丢包了。于是促使客户端再次发送 ACK ，在 accept队列有空闲的时候最终完成连接。若 accept队列始终满员，则最终客户端收到 RST 包（此时服务端发送syn+ack的次数超出了tcp_synack_retries）。</p><p>服务端仅仅只是创建一个定时器，以固定间隔重传syn和ack到服务端</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>tcp_abort_on_overflow</td><td>如果设置了此项，则直接reset. 否则，不做任何操作，这样当服务器半连接队列有空了之后，会重新接受连接。<code>Linux坚持在能力许可范围内不忽略进入的连接</code>。客户端在这期间会重复发送sys包，当重试次数到达上限之后，会得到<code>connection time out</code>响应。</td></tr><tr><td>min(backlog, somaxconn)</td><td>全连接队列的长度。</td></tr></tbody></table><h4 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h4><p>netstat -s命令</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@server ~]<span class="comment">#  netstat -s | egrep "listen|LISTEN" </span></span><br><span class="line">667399 <span class="built_in">times</span> the listen queue of a socket overflowed</span><br><span class="line">667399 SYNs to LISTEN sockets ignored</span><br></pre></td></tr></table></figure><p>上面看到的 667399 times ，表示全连接队列溢出的次数，隔几秒钟执行下，如果这个数字一直在增加的话肯定全连接队列偶尔满了。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@server ~]<span class="comment">#  netstat -s | grep TCPBacklogDrop</span></span><br></pre></td></tr></table></figure><p>查看 Accept queue 是否有溢出</p><p>ss命令</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@server ~]<span class="comment">#  ss -lnt</span></span><br><span class="line">State Recv-Q Send-Q Local Address:Port Peer Address:Port</span><br><span class="line">LISTEN     0      128 *:6379 *:*</span><br><span class="line">LISTEN     0      128 *:22 *:*</span><br></pre></td></tr></table></figure><p>如果State是listen状态，Send-Q 表示第三列的listen端口上的全连接队列最大为50，第一列Recv-Q为全连接队列当前使用了多少。<br>非 LISTEN 状态中 Recv-Q 表示 receive queue 中的 bytes 数量；Send-Q 表示 send queue 中的 bytes 数值。</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>当外部连接请求到来时，TCP模块会首先查看max_syn_backlog，如果处于SYN_RCVD状态的连接数目超过这一阈值，进入的连接会被拒绝。根据tcp_abort_on_overflow字段来决定是直接丢弃，还是直接reset.</p><p>从服务端来说，三次握手中，第一步server接受到client的syn后，把相关信息放到半连接队列中，同时回复syn+ack给client. 第三步当收到客户端的ack, 将连接加入到全连接队列。</p><p>一般，全连接队列比较小，会先满，此时半连接队列还没满。如果这时收到syn报文，则会进入半连接队列，没有问题。但是如果收到了三次握手中的第3步(ACK)，则会根据tcp_abort_on_overflow字段来决定是直接丢弃，还是直接reset.此时，客户端发送了ACK, 那么客户端认为三次握手完成，它认为服务端已经准备好了接收数据的准备。但此时服务端可能因为全连接队列满了而无法将连接放入，会重新发送第2步的syn+ack, 如果这时有数据到来，服务器TCP模块会将数据存入队列中。一段时间后，client端没收到回复，超时，连接异常，client会主动关闭连接。</p><h2 id="“三次握手，四次挥手”Redis实例分析"><a href="#“三次握手，四次挥手”Redis实例分析" class="headerlink" title="“三次握手，四次挥手”Redis实例分析"></a>“三次握手，四次挥手”Redis实例分析</h2><ol><li>我在dev机器上部署redis服务，端口号为6379,</li><li>通过tcpdump工具获取数据包，使用如下命令</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -w /tmp/a.cap port 6379 -s0</span><br><span class="line">-w把数据写入文件，-s0设置每个数据包的大小默认为68字节，如果用-S 0则会抓到完整数据包</span><br></pre></td></tr></table></figure><ol><li>在dev2机器上用redis-cli访问dev:6379, 发送一个ping, 得到回复pong</li><li>停止抓包，用tcpdump读取捕获到的数据包</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -r /tmp/a.cap -n -nn -A -x| vim -</span><br><span class="line">（-x 以16进制形式展示，便于后面分析）</span><br></pre></td></tr></table></figure><p>共收到了7个包。</p><p>抓到的是IP数据包，IP数据包分为IP头部和IP数据部分，IP数据部分是TCP头部加TCP数据部分。</p><p>IP的数据格式为：<br><img src="http://upload-images.jianshu.io/upload_images/12234098-e6b04f3e9bebdac4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ip head"><br>它由固定长度20B+可变长度构成。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">10:55:45.662077 IP dev2.39070 &gt; dev.6379: Flags [S], seq 4133153791, win 29200, options [mss 1460,sackOK,TS val 2959270704 ecr 0,nop,wscale 7], length 0</span><br><span class="line">        0x0000:  4500 003c 08cf 4000 3606 14a5 0ab3 b561</span><br><span class="line">        0x0010:  0a60 5cd4 989e 18eb f65a ebff 0000 0000</span><br><span class="line">        0x0020:  a002 7210 872f 0000 0204 05b4 0402 080a</span><br><span class="line">        0x0030:  b062 e330 0000 0000 0103 0307</span><br></pre></td></tr></table></figure><p>对着IP头部格式，来拆解数据包的具体含义。</p><table><thead><tr><th>字节值</th><th>字节含义</th></tr></thead><tbody><tr><td>0x4</td><td>IP版本为ipv4</td></tr><tr><td>0x5</td><td>首部长度为5 * 4字节=20B</td></tr><tr><td>0x00</td><td>服务类型，现在基本都置为0</td></tr><tr><td>0x003c</td><td>总长度为3*16+12=60字节，上面所有的长度就是60字节</td></tr><tr><td>0x08cf</td><td>标识。同一个数据报的唯一标识。当IP数据报被拆分时，会复制到每一个数据中。</td></tr><tr><td>0x4000</td><td><code>3bit 标志 + 13bit 片偏移</code>。3bit 标志对应 R、DF、MF。目前只有后两位有效，DF位：为1表示不分片，为0表示分片。MF：为1表示“更多的片”，为0表示这是最后一片。13bit 片位移：本分片在原先数据报文中相对首位的偏移位。（需要再乘以8 )</td></tr><tr><td>0x36</td><td>生存时间TTL。IP报文所允许通过的路由器的最大数量。每经过一个路由器，TTL减1，当为 0 时，路由器将该数据报丢弃。TTL 字段是由发送端初始设置一个 8 bit字段.推荐的初始值由分配数字 RFC 指定。发送 ICMP 回显应答时经常把 TTL 设为最大值 255。TTL可以防止数据报陷入路由循环。 此处为54.</td></tr><tr><td>0x06</td><td>协议类型。指出IP报文携带的数据使用的是哪种协议，以便目的主机的IP层能知道要将数据报上交到哪个进程。TCP 的协议号为6，UDP 的协议号为17。ICMP 的协议号为1，IGMP 的协议号为2。该 IP 报文携带的数据使用 TCP 协议，得到了验证。</td></tr><tr><td>0x14a5</td><td>16bitIP首部校验和。</td></tr><tr><td>0x0ab3 b561</td><td>32bit源ip地址。</td></tr><tr><td>0x0a60 5cd4</td><td>32bit目的ip地址。</td></tr></tbody></table><p>剩余的数据部分即为TCP协议相关的。TCP也是20B固定长度+可变长度部分。</p><table><thead><tr><th>字节值</th><th>字节含义</th></tr></thead><tbody><tr><td>0x989e</td><td>16bit源端口。1<em>16</em>16<em>16+8</em>16<em>16+14</em>16+11=39070</td></tr><tr><td>0x18eb</td><td>16bit目的端口6379</td></tr><tr><td>0xf65a ebff</td><td>32bit序列号。4133153791</td></tr><tr><td>0x0000 0000</td><td>32bit确认号。</td></tr><tr><td>0xa</td><td>4bit首部长度，以4byte为单位。共10*4=40字节。因此TCP报文的可选长度为40-20=20</td></tr><tr><td>0b000000</td><td>6bit保留位。目前置为0.</td></tr><tr><td>0b000010</td><td>6bitTCP标志位。从左到右依次是紧急 URG、确认 ACK、推送 PSH、复位 RST、同步 SYN 、终止 FIN。</td></tr><tr><td>0x7210</td><td>滑动窗口大小，滑动窗口即tcp接收缓冲区的大小，用于tcp拥塞控制。29200</td></tr><tr><td>0x872f</td><td>16bit校验和。</td></tr><tr><td>0x0000</td><td>紧急指针。仅在 URG = 1时才有意义，它指出本报文段中的紧急数据的字节数。当 URG = 1 时，发送方 TCP 就把紧急数据插入到本报文段数据的最前面，而在紧急数据后面的数据仍是普通数据。</td></tr></tbody></table><p>可变长度部分，协议如下：</p><table><thead><tr><th>字节值</th><th>字节含义</th></tr></thead><tbody><tr><td>0x0204 05b4</td><td>最大报文长度为，05b4=1460. 即可接收的最大包长度，通常为MTU减40字节，IP头和TCP头各20字节</td></tr><tr><td>0x0402</td><td>表示支持SACK</td></tr><tr><td>0x080a b062 e330 0000 0000</td><td>时间戳。Ts val=b062 e330=2959270704, ecr=0</td></tr><tr><td>0x01</td><td>无操作</td></tr><tr><td>0x03 0307</td><td>窗口扩大因子为7. 移位7, 乘以128</td></tr></tbody></table><p>这样第一个包分析完了。dev2向dev发送SYN请求。<code>也就是三次握手中的第一次了。</code><br><code>SYN seq(c)=4133153791</code></p><p>第二个包，dev响应连接，ack=4133153792. 表明dev下次准备接收这个序号的包，用于tcp字节注的顺序控制。dev（也就是server端）的初始序号为seq=4264776963, syn=1.<br><code>SYN ack=seq(c)+1 seq(s)=4264776963</code></p><p>第三个包，client包确认，这里使用了相对值应答。seq=4133153792, 等于第二个包的ack. ack=4264776964.<br><code>ack=seq(s)+1, seq=seq(c)+1</code><br>至此，三次握手完成。接下来就是发送ping和pong的数据了。</p><p>接着第四个包。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">10:55:48.090073 IP dev2.39070 &gt; dev.6379: Flags [P.], seq 1:15, ack 1, win 229, options [nop,nop,TS val 2959273132 ecr 3132256230], length 14</span><br><span class="line">        0x0000:  4500 0042 08d1 4000 3606 149d 0ab3 b561</span><br><span class="line">        0x0010:  0a60 5cd4 989e 18eb f65a ec00 fe33 5504</span><br><span class="line">        0x0020:  8018 00e5 4b5f 0000 0101 080a b062 ecac</span><br><span class="line">        0x0030:  bab2 6fe6 2a31 0d0a 2434 0d0a 7069 6e67</span><br><span class="line">        0x0040:  0d0a</span><br></pre></td></tr></table></figure><p>tcp首部长度为32B, 可选长度为12B. IP报文的总长度为66B, 首部长度为20B, 因此TCP数据部分长度为14B. seq=0xf65a ec00=4133153792<br>ACK, PSH. 数据部分为2a31 0d0a 2434 0d0a 7069 6e67 0d0a</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0x2a31         -&gt; *1</span><br><span class="line">0x0d0a         -&gt; \r\n</span><br><span class="line">0x2434         -&gt; $4</span><br><span class="line">0x0d0a         -&gt; \r\n</span><br><span class="line">0x7069 0x6e67  -&gt; ping</span><br><span class="line">0x0d0a         -&gt; \r\n</span><br></pre></td></tr></table></figure><p>dev2向dev发送了ping数据，第四个包完毕。</p><p>第五个包，dev2向dev发送ack响应。<br>序列号为0xfe33 5504=4264776964, ack确认号为0xf65a ec0e=4133153806=(4133153792+14).</p><p>第六个包，dev向dev2响应pong消息。序列号fe33 5504，确认号f65a ec0e, TCP头部可选长度为12B, IP数据报总长度为59B, 首部长度为20B, 因此TCP数据长度为7B.<br>数据部分2b50 4f4e 470d 0a, 翻译过来就是<code>+PONG\r\n</code>.</p><p>至此，Redis客户端和Server端的三次握手过程分析完毕。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>“三次握手，四次挥手”看似简单，但是深究进去，还是可以延伸出很多知识点的。比如半连接队列、全连接队列等等。以前关于TCP建立连接、关闭连接的过程很容易就会忘记，可能是因为只是死记硬背了几个过程，没有深入研究背后的原理。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://segmentfault.com/a/1190000015044878" target="_blank" rel="noopener">Redis</a></li><li><a href="https://blog.csdn.net/wdscq1234/article/details/52423272" target="_blank" rel="noopener">tcp option</a></li><li><a href="https://www.zhihu.com/question/32255109" target="_blank" rel="noopener">滑动窗口</a></li><li><a href="http://jm.taobao.org/2017/05/25/525-1/" target="_blank" rel="noopener">全连接队列</a></li><li><a href="https://github.com/torvalds/linux/commit/5ea8ea2cb7f1d0db15762c9b0bb9e7330425a071" target="_blank" rel="noopener">client fooling</a></li><li><a href="http://blog.51cto.com/59090939/1947443" target="_blank" rel="noopener">backlog RECV_Q</a></li><li><a href="https://www.cnblogs.com/menghuanbiao/p/5212131.html" target="_blank" rel="noopener">定时器</a></li><li><a href="https://www.itcodemonkey.com/article/5834.html" target="_blank" rel="noopener">队列图示</a></li><li><a href="https://www.cnblogs.com/hubavyn/p/4477883.html" target="_blank" rel="noopener">tcp flood攻击</a></li><li><a href="https://blog.csdn.net/LoseInVain/article/details/53694265" target="_blank" rel="noopener">MSS MTU</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt; 深度理解“三次握手，四次挥手”：&lt;/strong&gt; &lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;/excerpt&gt;&lt;/p&gt;
&lt;p&gt;深度理解“三次握手，四次挥手”&lt;/p&gt;
    
    </summary>
    
      <category term="TCP通信" scheme="https://alexbrucelu.github.io/categories/TCP%E9%80%9A%E4%BF%A1/"/>
    
    
      <category term="TCP" scheme="https://alexbrucelu.github.io/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>Go Test</title>
    <link href="https://alexbrucelu.github.io/2019/05/27/gotest/"/>
    <id>https://alexbrucelu.github.io/2019/05/27/gotest/</id>
    <published>2019-05-27T08:34:49.958Z</published>
    <updated>2019-05-27T09:09:42.611Z</updated>
    
    <content type="html"><![CDATA[<p><strong> Go Test：</strong> <excerpt in="" index="" |="" 首页摘要=""></excerpt></p><p>Go Test相关介绍</p><a id="more"></a><h2 id="Go-Test"><a href="#Go-Test" class="headerlink" title="Go Test"></a>Go Test</h2><h3 id="go-test-和-go-test-v"><a href="#go-test-和-go-test-v" class="headerlink" title="go test 和 go test -v"></a>go test 和 go test -v</h3><h3 id="t-SkipNow-的作用"><a href="#t-SkipNow-的作用" class="headerlink" title="t.SkipNow()的作用"></a>t.SkipNow()的作用</h3><h3 id="go-test的顺序执行"><a href="#go-test的顺序执行" class="headerlink" title="go test的顺序执行"></a>go test的顺序执行</h3><blockquote><p>go test 明确指出并不会按照顺序来执行，需要顺序执行某些<code>test</code>时使用<code>t.Run()</code></p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testPrint1</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"print 1..."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testPrint2</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"print 2..."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestAll</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">t.Run(<span class="string">"testPrint1"</span>,testPrint1)</span><br><span class="line">t.Run(<span class="string">"testPrint2"</span>,testPrint2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="TestMain-用来初始化"><a href="#TestMain-用来初始化" class="headerlink" title="TestMain 用来初始化"></a>TestMain 用来初始化</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestMain</span><span class="params">(m *testing.M)</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"This is a testmain"</span>)</span><br><span class="line">m.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用TestMain来初始化test，并使用m.Run()来调用其他tests，可以完成需要初始化的一些testing，如：数据库连接，打开文件，REST服务登录等。</p><p>如果整个TestMain里面没有执行m.Run()，整个test文件中的其他tests将不会被执行，只有TestMain会被执行。</p><h3 id="benchmark的书写"><a href="#benchmark的书写" class="headerlink" title="benchmark的书写"></a>benchmark的书写</h3><blockquote><p>go test -bench=.    // 一般使用<code>.</code>就可以了</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkAll</span><span class="params">(b *testing.B)</span></span> &#123; <span class="comment">// 测试函数性能,函数首字母大写</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">PrintHello()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试性能，每次平均时间，执行次数， b.N 表示函数稳定执行的最大次数，若函数执行时间并不稳定，测试函数就会一直执行下去，永远跑不完，没有输出结果。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">aaa</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> i &gt; <span class="number">0</span> &#123;</span><br><span class="line">i--</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkAll</span><span class="params">(b *testing.B)</span></span> &#123; <span class="comment">// 测试函数性能</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">aaa(i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt; Go Test：&lt;/strong&gt; &lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;/excerpt&gt;&lt;/p&gt;
&lt;p&gt;Go Test相关介绍&lt;/p&gt;
    
    </summary>
    
      <category term="golang" scheme="https://alexbrucelu.github.io/categories/golang/"/>
    
    
      <category term="golang" scheme="https://alexbrucelu.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>kafka</title>
    <link href="https://alexbrucelu.github.io/2019/03/24/kafka%E5%AE%89%E8%A3%85%E4%B8%8E%E8%AE%BE%E7%BD%AE/"/>
    <id>https://alexbrucelu.github.io/2019/03/24/kafka安装与设置/</id>
    <published>2019-03-24T09:20:32.598Z</published>
    <updated>2019-03-24T09:29:33.230Z</updated>
    
    <content type="html"><![CDATA[<p><strong> kafka：</strong> <excerpt in="" index="" |="" 首页摘要=""></excerpt></p><p>windows 安装及配置kafka  </p><a id="more"></a><p>[TOC]</p><h2 id="kafka安装与设置"><a href="#kafka安装与设置" class="headerlink" title="kafka安装与设置"></a>kafka安装与设置</h2><h3 id="1-Kafka是一种高吞吐量的分布式发布订阅消息系统。详细介绍可查阅官网：kafka官网"><a href="#1-Kafka是一种高吞吐量的分布式发布订阅消息系统。详细介绍可查阅官网：kafka官网" class="headerlink" title="1. Kafka是一种高吞吐量的分布式发布订阅消息系统。详细介绍可查阅官网：kafka官网"></a>1. Kafka是一种高吞吐量的分布式发布订阅消息系统。详细介绍可查阅官网：kafka官网</h3><h3 id="2-环境搭建"><a href="#2-环境搭建" class="headerlink" title="2.环境搭建"></a>2.环境搭建</h3><h4 id="2-1-安装JDK"><a href="#2-1-安装JDK" class="headerlink" title="2.1 安装JDK"></a>2.1 安装JDK</h4><p>​    下载地址：<a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html" target="_blank" rel="noopener">jre下载</a></p><p>   默认安装文件夹，C:\Program Files\Java\jre1.8.0_202</p><h4 id="2-1-1-设置环境变量"><a href="#2-1-1-设置环境变量" class="headerlink" title="2.1.1 设置环境变量"></a>2.1.1 设置环境变量</h4><p>新建系统变量<code>JAVA_HOME</code>：C:\Program Files\Java\jre1.8.0_202;</p><p>在<code>path</code>里面添加：<code>%JAVA_HOME%\bin</code>；</p><h3 id="2-2-安装Zookeeper"><a href="#2-2-安装Zookeeper" class="headerlink" title="2.2 安装Zookeeper"></a>2.2 安装Zookeeper</h3><p>​     下载地址：<a href="https://zookeeper.apache.org/releases.html" target="_blank" rel="noopener">https://zookeeper.apache.org/releases.html</a></p><pre><code>下载后，解压放在目录D:\kafka（本文所用的目录）下，关于zookeeper以及kafka的目录，路径中最好不要出现空格，比如D:\Program Files，尽量别用，运行脚本时会有问题。1. 进入zookeeper的相关设置所在的文件目录，例如本文的：     D:\bigdata\zookeeper-3.4.10\conf2. 将&quot;zoo_sample.cfg&quot;重命名为&quot;zoo.cfg&quot;3. 打开zoo.cfg(至于使用什么编辑器，根据自己喜好选即可)，找到并编辑：dataDir=/tmp/zookeeper  to  D:/kafka/zookeeper-3.4.10/data或 D:\\kafka\\zookeeper-3.4.10\\data(路径仅为示例，具体可根据需要配置)这里注意，路径要么是&quot;/&quot;分割，要么是转义字符&quot;\\&quot;，这样会生成正确的路径(层级，子目录)。4. 与配置jre类似，在系统环境变量中添加：    a.系统变量中添加ZOOKEEPER_HOME=D:\kafka\zookeeper-3.4.10    b.编辑系统变量中的path变量，增加%ZOOKEEPER_HOME%\bin5. 在zoo.cfg文件中修改默认的Zookeeper端口(默认端口2181)6. 打开cmd窗口，输入zkserver，运行Zookeeper，运行结果如下：</code></pre><p><img src="https://img-blog.csdn.net/20170812132732633?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDI4Mzg5NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p><p>恭喜，Zookeeper已经安装完成，已在2181端口运行。</p><h3 id="2-3-安装kafka"><a href="#2-3-安装kafka" class="headerlink" title="2.3 安装kafka"></a>2.3 安装kafka</h3><p>下载地址：<a href="http://kafka.apache.org/downloads" target="_blank" rel="noopener">http://kafka.apache.org/downloads</a></p><pre><code>要下载Binary downloads这个类型，不要下载源文件，这种方便使用。下载后，解压放在D:\bigdata目录下。</code></pre><p>①进入kafka配置文件所在目录，D:\bigdata\kafka_2.11-0.9.0.1\config</p><p>②编辑文件”server.properties”，找到并编辑：</p><p> log.dirs=/tmp/kafka-logs  to  log.dirs=D:/bigdata/kafka_2.11-0.9.0.1/kafka-logs 或者 D:\bigdata\kafka_2.11-0.9.0.1\kafka-logs</p><p>同样注意：路径要么是”/“分割，要么是转义字符”\“，这样会生成正确的路径(层级，子目录)。错误路径情况可自行尝试，文件夹名为这种形式：bigdatakafka_2.11-0.9.0.1kafka-logs</p><p>③在server.properties文件中，zookeeper.connect=localhost:2181代表kafka所连接的zookeeper所在的服务器IP以及端口，可根据需要更改。本文在同一台机器上使用，故不用修改。</p><p>④kafka会按照默认配置，在9092端口上运行，并连接zookeeper的默认端口2181。</p><h3 id="2-4-运行kafka"><a href="#2-4-运行kafka" class="headerlink" title="2.4 运行kafka"></a>2.4 运行kafka</h3><p>提示：请确保启动kafka服务器前，Zookeeper实例已经在运行，因为kafka的运行是需要zookeeper这种分布式应用程序协调服务。</p><p>①进入kafka安装目录D:\bigdata\kafka_2.11-0.9.0.1</p><p>②按下shift+鼠标右键，选择”在此处打开命令窗口”，打开命令行。</p><p>③在命令行中输入：.\bin\windows\kafka-server-start.bat .\config\server.properties   回车。</p><p>④正确运行的情况为：</p><p><img src="https://img-blog.csdn.net/20170812132906662?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDI4Mzg5NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p><p>到目前为止，zookeeper以及kafka都已正确运行。保持运行状态，不要关闭。</p><font color="red">重要（操作日志的处理）：</font><p>kafka启动后，如果你去查看kafka所在的根目录，或者是kafka本身的目录，会发现已经默认生成一堆操作日志(这样看起来真心很乱)：</p><p>而且会不断生成不同时间戳的操作日志。刚开始不知所措，一番研究后，看了启动的脚本内容，发现启动的时候是会默认使用到这个log4j.properties文件中的配置，而在zoo.cfg是不会看到本身的启动会调用到这个，还以为只有那一个日志路径：</p><p><img src="https://img-blog.csdn.net/20170812133057808?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDI4Mzg5NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p><p>在这里配置一下就可以了，找到config下的log4j.properties：</p><p><img src="https://img-blog.csdn.net/20170812133131159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDI4Mzg5NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p><p>将路径更改下即可，这样就可以归档在一个文件夹下边了，路径根据自己喜好定义：</p><p><img src="https://img-blog.csdn.net/20170812133222818?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDI4Mzg5NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p><p>另外如何消除不断生成日志的问题，就是同一天的不同时间会不停生成。</p><p>修改这里，还是在log4j.properties中：</p><p><img src="https://img-blog.csdn.net/20170812133300278?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDI4Mzg5NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p><p>本身都为trace，字面理解为会生成一堆跟踪日志，将其改为INFO即可。</p><h2 id="3-创建主题"><a href="#3-创建主题" class="headerlink" title="3. 创建主题"></a>3. 创建主题</h2><p>①创建主题，命名为”test0811”，replicationfactor=1(因为只有一个kafka服务器在运行)。可根据集群中kafka服务器个数来修改replicationfactor的数量，以便提高系统容错性等。</p><p>②在D:\kafka\kafka_2.11-0.9.0.1\bin\windows目录下打开新的命令行</p><p>③输入命令：</p><p>kafka-topics.bat –create –zookeeper localhost:2181 –replication-factor 1 –partitions 1 –topic test0811回车。 </p><p><img src="https://img-blog.csdn.net/20170812133330959?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDI4Mzg5NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p><font color="red">该窗口可以关闭。</font><h3 id="3-1-创建生产者、消费者"><a href="#3-1-创建生产者、消费者" class="headerlink" title="3.1 创建生产者、消费者"></a>3.1 创建生产者、消费者</h3><p>①在D:\bigdata\kafka_2.11-0.9.0.1\bin\windows目录下打开新的命令行。</p><p>②输入命令，启动producer：</p><p>kafka-console-producer.bat –broker-list localhost:9092 –topic test0811 </p><p><strong>该窗口不要关闭。</strong></p><p>③同样在该目录下打开新的命令行。</p><p>④输入命令，启动consumer：</p><p>kafka-console-consumer.bat –bootstrap-server localhost:9092 –topic test0811 –from-beginning</p><p><strong><font color="red">参数 –from-beginning 是表示消费者从生产者消息源头开始接收，去掉之后就只是接收新消息</font></strong></p><p><img src="https://img-blog.csdn.net/20170812133419255?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDI4Mzg5NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p><p>现在生产者、消费者均已创建完成。</p><p>⑤在producer命令行窗口中任意输入内容，回车  在consumer命令行窗口中即可看到相应的内容。</p><p><img src="https://img-blog.csdn.net/20170812133447425?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDI4Mzg5NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt; kafka：&lt;/strong&gt; &lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;/excerpt&gt;&lt;/p&gt;
&lt;p&gt;windows 安装及配置kafka  &lt;/p&gt;
    
    </summary>
    
      <category term="others" scheme="https://alexbrucelu.github.io/categories/others/"/>
    
    
      <category term="Windows" scheme="https://alexbrucelu.github.io/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>http幂等性</title>
    <link href="https://alexbrucelu.github.io/2019/02/27/HTTP%E5%B9%82%E7%AD%89%E6%80%A7/"/>
    <id>https://alexbrucelu.github.io/2019/02/27/HTTP幂等性/</id>
    <published>2019-02-27T06:06:14.910Z</published>
    <updated>2019-02-27T06:50:38.907Z</updated>
    
    <content type="html"><![CDATA[<p><strong> http幂等性：</strong> <excerpt in="" index="" |="" 首页摘要=""></excerpt></p><p>编程中的幂等性-http幂等性</p><a id="more"></a><h1 id="编程中的幂等性-—-HTTP幂等性"><a href="#编程中的幂等性-—-HTTP幂等性" class="headerlink" title="编程中的幂等性 — HTTP幂等性"></a><a href="https://www.cnblogs.com/duhuo/p/4245202.html" target="_blank" rel="noopener">编程中的幂等性 — HTTP幂等性</a></h1><p>幂等（idempotent、idempotence）是一个数学与计算机学概念，常见于抽象代数中。</p><p>在编程中.<strong>一个幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同</strong>。幂等函数，或幂等方法，是指可以使用相同参数重复执行，并能获得相同结果的函数。这些函数不会影响系统状态，也不用担心重复执行会对系统造成改变。例如，“getUsername()和setTrue()”函数就是一个幂等函数.更复杂的操作幂等保证是利用唯一交易号(流水号)实现.</p><p>——百度百科</p><h2 id="什么是幂等性-Idempotence-？"><a href="#什么是幂等性-Idempotence-？" class="headerlink" title="什么是幂等性(Idempotence)？"></a>什么是幂等性(Idempotence)？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Methods can also have the property of “idempotence” in that (aside from error or expiration issues) the side-effects of N &gt; 0 identical requests is the same as for a single request.</span><br><span class="line">——HTTP/1.1规范中幂等性的定义</span><br></pre></td></tr></table></figure><p>从定义上看，HTTP方法的幂等性是指一次和多次请求某一个资源应该具有同样的副作用。说白了就是，<strong>同一个请求，发送一次和发送N次效果是一样的！</strong>幂等性是分布式系统设计中十分重要的概念，而HTTP的分布式本质也决定了它在HTTP中具有重要地位。下面将以HTTP中的幂等性做例子加以介绍。</p><h2 id="简单示例"><a href="#简单示例" class="headerlink" title="简单示例"></a>简单示例</h2><p>假设有一个从账户取钱的远程API（可以是HTTP的，也可以不是），我们暂时用类函数的方式记为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bool withdraw(account_id, amount)</span><br></pre></td></tr></table></figure><p>withdraw的语义是从account_id对应的账户中扣除amount数额的钱；如果扣除成功则返回true，账户余额减少amount；如果扣除失败则返回false，账户余额不变。</p><p>值得注意的是：和本地环境相比，<strong>我们不能轻易假设分布式环境的可靠性</strong>。</p><p>所以问题来了，一种典型的情况是withdraw请求已经被服务器端正确处理，但服务器端的返回结果由于网络等原因被掉丢了，导致客户端无法得知处理结果。如果是在网页上，一些不恰当的设计可能会使用户认为上一次操作失败了，然后刷新页面，这就导致了withdraw被调用两次，账户也被多扣了一次钱。如图所示：</p><p><img src="http://cdn.i3geek.com/wp-content/uploads/auto_save_image/2015/07/033717ZKv.png" alt="non-idempotent"></p><p>解决方案一：采用分布式事务，通过引入支持分布式事务的中间件来保证withdraw功能的事务性。分布式事务的优点是对于调用者很简单，复杂性都交给了中间件来管理。缺点则是一方面架构太重量级，容易被绑在特定的中间件上，不利于异构系统的集成；另一方面分布式事务虽然能保证事务的ACID性质，而但却无法提供性能和可用性的保证。</p><p>解决方案二：幂等设计。我们可以通过一些技巧把withdraw变成幂等的，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int create_ticket() </span><br><span class="line">bool idempotent_withdraw(ticket_id, account_id, amount)</span><br></pre></td></tr></table></figure><p>create_ticket的语义是<strong>获取一个服务器端生成的唯一的处理号ticket_id，它将用于标识后续的操作</strong>。idempotent_withdraw和withdraw的区别在于关联了一个ticket_id，一个ticket_id表示的操作至多只会被处理一次，每次调用都将返回第一次调用时的处理结果。这样，idempotent_withdraw就符合幂等性了，客户端就可以放心地多次调用。</p><p>基于幂等性的解决方案中一个完整的取钱流程被分解成了两个步骤：1.调用create_ticket()获取ticket_id；2.调用idempotent_withdraw(ticket_id, account_id, amount)。虽然create_ticket不是幂等的，但在这种设计下，它对系统状态的影响可以忽略，加上idempotent_withdraw是幂等的，所以任何一步由于网络等原因失败或超时，客户端都可以重试，直到获得结果。如图所示：</p><p><img src="http://cdn.i3geek.com/wp-content/uploads/auto_save_image/2015/07/033718EYW.png" alt="idempotent"></p><p>和分布式事务相比，幂等设计的优势在于它的轻量级，容易适应异构环境，以及性能和可用性方面。在某些性能要求比较高的应用，幂等设计往往是唯一的选择。</p><h2 id="HTTP的幂等性"><a href="#HTTP的幂等性" class="headerlink" title="HTTP的幂等性"></a>HTTP的幂等性</h2><p>本文主要以HTTP GET、DELETE、PUT、POST四种方法为主进行语义和幂等性的介绍。</p><p><strong>HTTP GET方法用于获取资源，不应有副作用，所以是幂等的。</strong>比如：GET <a href="http://www.bank.com/account/123456，不会改变资源的状态，不论调用一次还是N次都没有副作用。请注意，这里强调的是一次和N次具有相同的副作用，而不是每次GET的结果相同。GET" target="_blank" rel="noopener">http://www.bank.com/account/123456，不会改变资源的状态，不论调用一次还是N次都没有副作用。请注意，这里强调的是一次和N次具有相同的副作用，而不是每次GET的结果相同。GET</a> <a href="http://www.news.com/latest-news这个HTTP请求可能会每次得到不同的结果，但它本身并没有产生任何副作用，因而是满足幂等性的。" target="_blank" rel="noopener">http://www.news.com/latest-news这个HTTP请求可能会每次得到不同的结果，但它本身并没有产生任何副作用，因而是满足幂等性的。</a></p><p><strong>HTTP DELETE方法用于删除资源，有副作用，但它应该满足幂等性。</strong>比如：DELETE <a href="http://www.forum.com/article/4231，调用一次和N次对系统产生的副作用是相同的，即删掉id为4231的帖子；因此，调用者可以多次调用或刷新页面而不必担心引起错误。" target="_blank" rel="noopener">http://www.forum.com/article/4231，调用一次和N次对系统产生的副作用是相同的，即删掉id为4231的帖子；因此，调用者可以多次调用或刷新页面而不必担心引起错误。</a></p><p><strong>HTTP POST方法用于创建资源，所对应的URI并非创建的资源本身，而是去执行创建动作的操作者，有副作用，不满足幂等性。</strong>比如：POST <a href="http://www.forum.com/articles的语义是在http://www.forum.com/articles下创建一篇帖子，HTTP响应中应包含帖子的创建状态以及帖子的URI。两次相同的POST请求会在服务器端创建两份资源，它们具有不同的URI；所以，POST方法不具备幂等性。" target="_blank" rel="noopener">http://www.forum.com/articles的语义是在http://www.forum.com/articles下创建一篇帖子，HTTP响应中应包含帖子的创建状态以及帖子的URI。两次相同的POST请求会在服务器端创建两份资源，它们具有不同的URI；所以，POST方法不具备幂等性。</a></p><p><strong>HTTP PUT方法用于创建或更新操作，所对应的URI是要创建或更新的资源本身，有副作用，它应该满足幂等性。</strong>比如：PUT <a href="http://www.forum/articles/4231的语义是创建或更新ID为4231的帖子。对同一URI进行多次PUT的副作用和一次PUT是相同的；因此，PUT方法具有幂等性。" target="_blank" rel="noopener">http://www.forum/articles/4231的语义是创建或更新ID为4231的帖子。对同一URI进行多次PUT的副作用和一次PUT是相同的；因此，PUT方法具有幂等性。</a></p><h3 id="对前文示例进行改进"><a href="#对前文示例进行改进" class="headerlink" title="对前文示例进行改进"></a>对前文示例进行改进</h3><p>利用Web API的形式实现前面所提到的取款功能。</p><p>1、用POST /tickets来实现create_ticket；</p><p>2、用PUT /accounts/account_id/ticket_id&amp;amount=xxx来实现idempotent_withdraw。</p><p>值得注意的是严格来讲amount参数不应该作为URI的一部分，真正的URI应该是/accounts/account_id/ticket_id，而amount应该放在请求的body中。这种模式可以应用于很多场合，比如：论坛网站中防止意外的重复发帖。</p><h2 id="电商中遇到的问题"><a href="#电商中遇到的问题" class="headerlink" title="电商中遇到的问题"></a>电商中遇到的问题</h2><h3 id="如何防范-POST-重复提交"><a href="#如何防范-POST-重复提交" class="headerlink" title="如何防范 POST 重复提交"></a>如何防范 POST 重复提交</h3><p>HTTP POST 操作既不是安全的，也不是幂等的（至少在HTTP规范里没有保证）。当我们因为反复刷新浏览器导致多次提交表单，多次发出同样的POST请求，导致远端服务器重复创建出了资源。</p><p>所以，对于电商应用来说，第一对应的后端 WebService 一定要做到<strong>幂等性</strong>，第二服务器端收到 POST 请求，在操作成功后<strong>必须302跳转到另外一个页面</strong>，这样即使用户刷新页面，也不会重复提交表单。</p><h3 id="把分布式事务分解为具有幂等性的异步消息处理"><a href="#把分布式事务分解为具有幂等性的异步消息处理" class="headerlink" title="把分布式事务分解为具有幂等性的异步消息处理"></a>把分布式事务分解为具有幂等性的异步消息处理</h3><p>电商的很多业务，考虑更多的是 BASE（即Basically Available、Soft state、和Eventually consistent），而不是 ACID（Atomicity、Consistency、Isolation和 Durability）。即为了满足高负载的用户访问，我们可以容忍短暂的数据不一致。那怎么做呢？</p><p>第一，不做分布式事务，代价太大。<br>第二，不一定需要实时一致性，只需要保证最终的一致性即可。<br>第三，“通过状态机和严格的有序操作，来最大限度地降低不一致性”。<br>第四，最终一致性（Eventually Consistent）通过异步事件做到。</p><p>如果消息具有操作幂等性，也就是一个消息被应用多次与应用一次产生的效果是一样的话，那么把不需要同步执行的事务交给异步消息推送和订阅者集群来处理即可。假如消息处理失败，那么就消息重播，由于幂等性，应用多次也能产生正确的结果。</p><p>实际情况下，消息很难具有幂等性，解决方法是使用另一个表记录已经被成功应用的消息，即消息队列和消息应用状态表一起来解决问题。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上面简单介绍了幂等性的概念，用幂等设计取代分布式事务的方法，以及HTTP主要方法的语义和幂等性特征。其实，如果要追根溯源，幂等性是数学中的一个概念，表达的是N次变换与1次变换的结果相同，有兴趣的读者可以从Wikipedia上进一步了解。</p><p>转自：<a href="http://www.i3geek.com/archives/841" target="_blank" rel="noopener">http://www.i3geek.com/archives/841</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt; http幂等性：&lt;/strong&gt; &lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;/excerpt&gt;&lt;/p&gt;
&lt;p&gt;编程中的幂等性-http幂等性&lt;/p&gt;
    
    </summary>
    
      <category term="others" scheme="https://alexbrucelu.github.io/categories/others/"/>
    
    
      <category term="http" scheme="https://alexbrucelu.github.io/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>测试与性能调优</title>
    <link href="https://alexbrucelu.github.io/2019/01/22/C%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%89%A7%E8%A1%8C/"/>
    <id>https://alexbrucelu.github.io/2019/01/22/C程序的执行/</id>
    <published>2019-01-22T12:38:28.613Z</published>
    <updated>2019-01-22T14:23:31.160Z</updated>
    
    <content type="html"><![CDATA[<p><strong> 测试与性能调优：</strong> <excerpt in="" index="" |="" 首页摘要=""></excerpt></p><p>C语言的基础入门</p><a id="more"></a><p>[TOC]</p><h2 id="一段程序在计算机内部是怎么运行的"><a href="#一段程序在计算机内部是怎么运行的" class="headerlink" title="一段程序在计算机内部是怎么运行的"></a>一段程序在计算机内部是怎么运行的</h2><h2 id="各种基本类型所占字节大小"><a href="#各种基本类型所占字节大小" class="headerlink" title="各种基本类型所占字节大小"></a>各种基本类型所占字节大小</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"data type        number of bytes\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"----------       ---------------\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"char             %d\n"</span>, <span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"int              %d\n"</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"short int        %d\n"</span>, <span class="keyword">sizeof</span>(<span class="keyword">short</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"long int         %d\n"</span>, <span class="keyword">sizeof</span>(<span class="keyword">long</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"float            %d\n"</span>, <span class="keyword">sizeof</span>(<span class="keyword">float</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"double           %d\n"</span>, <span class="keyword">sizeof</span>(<span class="keyword">double</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 执行结果如下：</span></span><br><span class="line"><span class="comment">// data type        number of bytes</span></span><br><span class="line"><span class="comment">// ----------       ---------------</span></span><br><span class="line"><span class="comment">// char             1</span></span><br><span class="line"><span class="comment">// int              4</span></span><br><span class="line"><span class="comment">// short int        2</span></span><br><span class="line"><span class="comment">// long int         4</span></span><br><span class="line"><span class="comment">// float            4</span></span><br><span class="line"><span class="comment">// double           8</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt; 测试与性能调优：&lt;/strong&gt; &lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;/excerpt&gt;&lt;/p&gt;
&lt;p&gt;C语言的基础入门&lt;/p&gt;
    
    </summary>
    
      <category term="C程序的执行" scheme="https://alexbrucelu.github.io/categories/C%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%89%A7%E8%A1%8C/"/>
    
    
      <category term="C" scheme="https://alexbrucelu.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>golang性能优化</title>
    <link href="https://alexbrucelu.github.io/2018/12/21/golang%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <id>https://alexbrucelu.github.io/2018/12/21/golang性能优化/</id>
    <published>2018-12-21T02:24:21.049Z</published>
    <updated>2018-12-21T06:15:24.241Z</updated>
    
    <content type="html"><![CDATA[<p><strong> golang性能优化：</strong> <excerpt in="" index="" |="" 首页摘要=""></excerpt></p><p>go语言养成记之golang性能优化</p><a id="more"></a><p>[TOC]</p><h2 id="string-amp-profiling"><a href="#string-amp-profiling" class="headerlink" title="string &amp; profiling"></a>string &amp; profiling</h2><h3 id="string-连接"><a href="#string-连接" class="headerlink" title="string 连接"></a>string 连接</h3><h4 id="fmt-VS-“-”"><a href="#fmt-VS-“-”" class="headerlink" title="fmt VS “+”"></a>fmt VS “+”</h4><ol><li><p>如图所示：</p><p><img src="https://github.com/AlexBruceLu/DAPP/wiki/you1.png" alt=""></p><font color="red"><strong>比对结果：</strong></font><font color="red"><strong>BenchmarkFmt 1000000 1617 ns/op </strong></font><font color="red"><strong>BenchmarkPlus 5000000 393 ns/op  </strong></font></li><li><p>如图所示：</p><p><img src="https://github.com/AlexBruceLu/DAPP/wiki/you2.png" alt=""></p><font color="red"><strong>比对结果：</strong></font><font color="red"><strong>BenchmarkFmt 1000000 1324 ns/op </strong></font><font color="red"><strong>BenchmarkPlus 5000000 751 ns/op</strong></font></li></ol><h4 id="strings-join-VS-“-”"><a href="#strings-join-VS-“-”" class="headerlink" title="strings.join VS “+”"></a>strings.join VS “+”</h4><ol><li><p>如图所示：</p><p><img src="https://github.com/AlexBruceLu/DAPP/wiki/you3.png" alt=""></p></li><li><p>如图所示：</p><p><img src="https://github.com/AlexBruceLu/DAPP/wiki/you4.png" alt=""></p><font color="red"><strong>比对结果：</strong></font><font color="red"><strong>BenchmarkPlus 500000 4659 ns/op  </strong></font><font color="red"><strong>BenchmarkJoin 1000000 1491 ns/op </strong></font></li></ol><h4 id="strings-Join-VS-bytes-Buffer"><a href="#strings-Join-VS-bytes-Buffer" class="headerlink" title="strings.Join VS bytes.Buffer"></a>strings.Join VS bytes.Buffer</h4><ol><li><p>如图所示：</p><p><img src="https://github.com/AlexBruceLu/DAPP/wiki/you5.png" alt=""></p></li><li><p>如图所示：</p><p><img src="https://github.com/AlexBruceLu/DAPP/wiki/you6.png" alt=""></p><font color="red"><strong>比对结果：</strong></font><font color="red"><strong>BenchmarkJoin 1000000 1505 ns/op   </strong></font><font color="red"><strong>BenchmarkBuffer 500000 2886 ns/op  </strong></font></li><li><p>如图所示：</p><p><img src="https://github.com/AlexBruceLu/DAPP/wiki/you7.png" alt=""></p></li><li><p>如图所示：</p><p><img src="https://github.com/AlexBruceLu/DAPP/wiki/you8.png" alt=""></p><font color="red"><strong>比对结果：</strong></font><font color="red"><strong>BenchmarkJoin 1000000 1824 ns/op   </strong></font><font color="red"><strong>BenchmarkBuffer 500000 2588 ns/op </strong></font></li><li><p>如图所示：</p><p><img src="https://github.com/AlexBruceLu/DAPP/wiki/you9.png" alt=""></p></li><li><p>如图所示：</p><p><img src="https://github.com/AlexBruceLu/DAPP/wiki/you10.png" alt=""></p><font color="red"><strong>比对结果：</strong></font><font color="red"><strong>BenchmarkJoin 1000000 1500 ns/op   </strong></font><font color="red"><strong>BenchmarkBuffer 1000000 1482 ns/op  </strong></font></li><li><p>如图所示：</p><p><img src="https://github.com/AlexBruceLu/DAPP/wiki/you11.png" alt=""></p></li><li><p>如图所示：</p><p><img src="https://github.com/AlexBruceLu/DAPP/wiki/you12.png" alt=""></p><font color="red"><strong>比对结果：</strong></font><font color="red"><strong>BenchmarkJoin 1000000 1792 ns/op   </strong></font><font color="red"><strong>BenchmarkBuffer 1000000 1162 ns/op  </strong></font></li></ol><h2 id="string-amp-byte"><a href="#string-amp-byte" class="headerlink" title="string &amp; []byte"></a>string &amp; []byte</h2><ol><li>如果可以的话，尽量多用<code>[]byte</code> ，少用<code>string</code></li><li>尽可能的少在两者之间做转换</li><li>append([]byte,string…)</li><li>copy([]byte,string)</li></ol><h3 id="strconv"><a href="#strconv" class="headerlink" title="strconv"></a>strconv</h3><p>  1. func AppendBool(dst []byte, b bool) []byte<br>  2. func AppendFloat(dst []byte, f float64, fmt byte, prec int,bitSize int) []byte<br>  3. func AppendInt(dst []byte, i int64, base int) []byte<br>  4. func AppendUint(dst []byte, i uint64, base int) []byte<br>  5. func FormatBool(b bool) string<br>  6. func FormatFloat(f float64, fmt byte, prec, bitSize int) string<br>  7. func FormatInt(i int64, base int) string<br>  8. func FormatUint(i uint64, base int) string </p><h2 id="slice-amp-array"><a href="#slice-amp-array" class="headerlink" title="slice &amp; array"></a>slice &amp; array</h2><p>array：值传递</p><p>slice：引用传递</p><p><img src="https://github.com/AlexBruceLu/DAPP/wiki/you13.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt; golang性能优化：&lt;/strong&gt; &lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;/excerpt&gt;&lt;/p&gt;
&lt;p&gt;go语言养成记之golang性能优化&lt;/p&gt;
    
    </summary>
    
      <category term="golang" scheme="https://alexbrucelu.github.io/categories/golang/"/>
    
    
      <category term="golang" scheme="https://alexbrucelu.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>类型断言</title>
    <link href="https://alexbrucelu.github.io/2018/12/19/%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80/"/>
    <id>https://alexbrucelu.github.io/2018/12/19/类型断言/</id>
    <published>2018-12-19T06:18:03.497Z</published>
    <updated>2018-12-19T07:09:44.408Z</updated>
    
    <content type="html"><![CDATA[<p><strong> 类型断言：</strong> <excerpt in="" index="" |="" 首页摘要=""></excerpt></p><p>go语言养成记之类型断言</p><a id="more"></a><p>[TOC]</p><h2 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h2><h3 id="引出类型断言的需求案例"><a href="#引出类型断言的需求案例" class="headerlink" title="引出类型断言的需求案例"></a>引出类型断言的需求案例</h3><p>如何将一个接口变量，赋值给自定义类型的变量？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Point <span class="keyword">struct</span> &#123;</span><br><span class="line">    x <span class="keyword">int</span></span><br><span class="line">    y <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">var</span> point Point = Point&#123;<span class="number">1</span>,<span class="number">2</span>&#125;</span><br><span class="line">    a = point <span class="comment">// ok</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如何将a赋给一个Point变量</span></span><br><span class="line">    <span class="keyword">var</span> b Point</span><br><span class="line">    b = a <span class="comment">// 可以吗 =&gt; error</span></span><br><span class="line">    <span class="comment">// cannot use a (type interface &#123;&#125;) as type Point in assignment: need type assertion</span></span><br><span class="line">    fmt.Println(b)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以转换为以下代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">var</span> point Point = Point&#123;<span class="number">1</span>,<span class="number">2</span>&#125;</span><br><span class="line">    a = point</span><br><span class="line">    <span class="keyword">var</span> b Point</span><br><span class="line">    b = a.(Point) <span class="comment">// 类型断言</span></span><br><span class="line">    fmt.Println(b)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 执行结果</span></span><br><span class="line"><span class="comment">// &#123;1 2&#125;</span></span><br></pre></td></tr></table></figure><p>代码说明：<code>b = a.(Point)</code>就是类型断言，表示判断<code>a</code>是否指向<code>Point</code>类型的变量，如果是就转化为<code>Point</code>类型并赋值给<code>b</code>变量，否则报错。</p><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>类型断言，有接口是一般类型，不知道具体类型，如果要转成具体类型，就需要使用类型断言，具体如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> b2 <span class="keyword">float32</span> = <span class="number">1.1</span></span><br><span class="line">x = b2</span><br><span class="line">y := x.(<span class="keyword">float32</span>)</span><br><span class="line">fmt.Printf(<span class="string">"y 的类型是 %T 值是 = %v"</span>,y,y)</span><br><span class="line"><span class="comment">// 执行结果</span></span><br><span class="line"><span class="comment">// y 的类型是 float32 值是 = 1.1</span></span><br></pre></td></tr></table></figure><font color="red"><strong>对上面代码的说明：</strong></font><p>在进行类型断言时，如果类型不匹配，就会报<code>panic</code>，因此，进行类型断言时，要确保原来的空接口指向的就是断言的类型。</p><font color="red"><strong>如何在进行断言时，带上检测机制，如果成功就ok，否则也不要报<code>panic</code></strong></font><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> b2 <span class="keyword">float32</span> = <span class="number">1.1</span></span><br><span class="line">x = b2</span><br><span class="line"><span class="keyword">if</span>y,ok := x.(<span class="keyword">float32</span>); ok &#123;</span><br><span class="line">    fmt.Println(<span class="string">"convert success"</span>)</span><br><span class="line">    fmt.Printf(<span class="string">"y 的类型是 %T 值是 = %v"</span>,y,y)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"convert fail"</span>)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"继续执行。。。"</span>)</span><br><span class="line"><span class="comment">// 执行结果</span></span><br><span class="line"><span class="comment">// convert success</span></span><br><span class="line"><span class="comment">// y 的类型是 float32 值是 = 1.1</span></span><br><span class="line"><span class="comment">// 继续执行。。。</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt; 类型断言：&lt;/strong&gt; &lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;/excerpt&gt;&lt;/p&gt;
&lt;p&gt;go语言养成记之类型断言&lt;/p&gt;
    
    </summary>
    
      <category term="golang" scheme="https://alexbrucelu.github.io/categories/golang/"/>
    
    
      <category term="golang" scheme="https://alexbrucelu.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>函数和方法的区别</title>
    <link href="https://alexbrucelu.github.io/2018/12/19/go%E4%B8%AD%E5%87%BD%E6%95%B0%E5%92%8C%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://alexbrucelu.github.io/2018/12/19/go中函数和方法的区别/</id>
    <published>2018-12-19T01:32:15.033Z</published>
    <updated>2018-12-19T02:15:35.120Z</updated>
    
    <content type="html"><![CDATA[<p><strong> 函数和方法的区别：</strong> <excerpt in="" index="" |="" 首页摘要=""></excerpt></p><p>go语言养成记之函数和方法的区别</p><a id="more"></a><p>[TOC]</p><p>在接触到<code>go</code>之前，我认为函数和方法只是同一个东西的两个名字而已（在我熟悉的<code>c/c++</code>，<code>python</code>，<code>java</code>中没有明显的区别），但是在<code>golang</code>中者完全是两个不同的东西。官方的解释是，方法是包含了接收者的函数。到底什么意思呢。</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>首先函数的格式是固定的，func＋函数名＋ 参数 ＋ 返回值（可选） ＋ 函数体。例:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"hello golang"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在golang中有两个特殊的函数，<code>main</code>函数和<code>init</code>函数，<code>main</code>函数不用介绍在所有语言中都一样，它作为一个程序的入口，只能有一个。<code>init</code>函数在每个package是可选的，可有可无，甚至可以有多个(但是强烈建议一个package中一个init函数)，init函数在你导入该package时程序会自动调用init函数，所以init函数不用我们手动调用,l另外它只会被调用一次，因为当一个package被多次引用时，它只会被导入一次。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> my</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> I <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    I = <span class="number">0</span></span><br><span class="line">    fmt.Println(<span class="string">"Call my init1"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    I = <span class="number">1</span></span><br><span class="line">    fmt.Println(<span class="string">"Call my init2"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"my"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"hello go .... I ="</span>,my.I)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>执行结果：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Call my init1</span><br><span class="line">Call my init2</span><br><span class="line">hello go .... I = 1</span><br></pre></td></tr></table></figure><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> myint <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *myint)</span> <span class="title">double</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">*m = *m * <span class="number">2</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m myint)</span> <span class="title">square</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">m = m * m</span><br><span class="line">fmt.Printf(<span class="string">"square is %d\n"</span>, m)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> i myint = <span class="number">2</span></span><br><span class="line">i.double()</span><br><span class="line">fmt.Println(<span class="string">"i = "</span>,i)</span><br><span class="line">i.square()</span><br><span class="line">fmt.Println(<span class="string">"i = "</span>,i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>执行结果：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">i = 4</span><br><span class="line">square is 16</span><br><span class="line">i = 4</span><br></pre></td></tr></table></figure><p>我们可以看到方法和函数的区别，方法在<code>func</code>关键字后是接收者而不是函数名，接收者可以是自己定义的一个类型，这个类型可以是<code>struct</code>，<code>interface</code>，甚至我们可以重定义基本数据类型。我们可以给他一些我们想要的方法来满足我们的实际工程中的需求，就像上面一样我重定义了int并给了它一个乘2和平法的方法，这里我们要注意一个细节，接收者是指针和非指针的区别，我们可以看到当接收者为指针式，我们可以通过方法改变该接收者的属性，但是非指针类型缺做不到。</p><p>这里的接收者和c++中的this指针有一些相似，我们可以把接受者当作一个class，而这些方法就是类的成员函数，当接收者为指针类型是就是c++中的非const成员函数，为非指针时就是const成员函数，不能通过此方法改变累的成员变量。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt; 函数和方法的区别：&lt;/strong&gt; &lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;/excerpt&gt;&lt;/p&gt;
&lt;p&gt;go语言养成记之函数和方法的区别&lt;/p&gt;
    
    </summary>
    
      <category term="golang" scheme="https://alexbrucelu.github.io/categories/golang/"/>
    
    
      <category term="golang" scheme="https://alexbrucelu.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>go操作Redis</title>
    <link href="https://alexbrucelu.github.io/2018/12/18/go%E6%93%8D%E4%BD%9Credis/"/>
    <id>https://alexbrucelu.github.io/2018/12/18/go操作redis/</id>
    <published>2018-12-18T11:26:01.944Z</published>
    <updated>2018-12-19T03:54:19.087Z</updated>
    
    <content type="html"><![CDATA[<p><strong> go操作Redis：</strong> <excerpt in="" index="" |="" 首页摘要=""></excerpt></p><p>Redis的简介及golang简易操作redis</p><a id="more"></a><p>[TOC]</p><h2 id="redis简介"><a href="#redis简介" class="headerlink" title="redis简介"></a>redis简介</h2><p>redis（REmote DIctionary Server）是一个由Salvatore Sanfilippo 写的<code>Key-value</code>存储系统，由<code>C</code>语言编写、遵守<code>BSD协议</code>、支持网络、可基于内存亦可持久化的日志型、<code>Key-Value</code>类型的数据库，并提供多种语言的API。和Memcached类似，它支持存储的value类型相对更多，包括<code>string(字符串)</code>、<code>list(链表)</code>、<code>set(集合)</code>、<code>zset(sorted set --有序集合)</code>和<code>hash（哈希类型）</code>。这些数据类型都支持push/pop、add/remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。在此基础上，redis支持各种不同方式的排序。与memcached一样，为了保证效率，数据都是缓存在内存中。区别的是redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步，redis在3.0版本推出集群模式。</p><p>官方网站：<a href="https://redis.io/" target="_blank" rel="noopener">https://redis.io/</a></p><h2 id="源码部署"><a href="#源码部署" class="headerlink" title="源码部署"></a>源码部署</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ yum install gcc -y  <span class="comment">#安装C依赖</span></span><br><span class="line">$ wget http://download.redis.io/redis-stable.tar.gz  <span class="comment">#下载稳定版本</span></span><br><span class="line">$ tar zxvf redis-stable.tar.gz  <span class="comment">#解压</span></span><br><span class="line">$ <span class="built_in">cd</span> redis-stable</span><br><span class="line">$ make PREFIX=/opt/app/redis install   <span class="comment">#指定目录编译</span></span><br><span class="line">$ make install</span><br><span class="line">$ mkdir /etc/redis   <span class="comment">#建立配置目录</span></span><br><span class="line">$ cp redis.conf /etc/redis/6379.conf <span class="comment"># 拷贝配置文件</span></span><br><span class="line">$ cp utils/redis_init_script /etc/init.d/redis  <span class="comment">#拷贝init启动脚本针对6.X系统</span></span><br><span class="line">$ chmod a+x  /etc/init.d/redis  <span class="comment">#添加执行权限</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改配置文件：</span></span><br><span class="line">$ vi /etc/redis/6379.conf</span><br><span class="line"><span class="built_in">bind</span> 0.0.0.0      <span class="comment">#监听地址</span></span><br><span class="line">maxmemory 4294967296   <span class="comment">#限制最大内存（4G）：</span></span><br><span class="line">daemonize yes   <span class="comment">#后台运行</span></span><br></pre></td></tr></table></figure><h3 id="启动与停止"><a href="#启动与停止" class="headerlink" title="启动与停止"></a>启动与停止</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">####启动与停止</span></span><br><span class="line">$ /etc/init.d/redis start</span><br><span class="line">$ /etc/init.d/redis stop</span><br></pre></td></tr></table></figure><h3 id="查看版本信息"><a href="#查看版本信息" class="headerlink" title="查看版本信息"></a>查看版本信息</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#执行客户端工具</span></span><br><span class="line">$ redis-cli </span><br><span class="line"><span class="comment">#输入命令info</span></span><br><span class="line">127.0.0.1:6379&gt; info</span><br><span class="line"><span class="comment"># Server</span></span><br><span class="line">redis_version:4.0.10</span><br><span class="line">redis_git_sha1:00000000</span><br><span class="line">redis_git_dirty:0</span><br><span class="line">redis_build_id:cf83e9c690dbed33</span><br><span class="line">redis_mode:standalone</span><br><span class="line">os:Linux 2.6.32-642.el6.x86_64 x86_64</span><br><span class="line">arch_bits:64</span><br><span class="line">multiplexing_api:epoll</span><br></pre></td></tr></table></figure><h2 id="golang操作redis"><a href="#golang操作redis" class="headerlink" title="golang操作redis"></a>golang操作redis</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>golang操作redis的客户端包有多个比如<code>redigo</code>、<code>go-redis</code>，github上Star最多的莫属<code>redigo</code>。</p><p>github地址：<a href="https://github.com/garyburd/redigo" target="_blank" rel="noopener">https://github.com/garyburd/redigo</a>  </p><p>目前已经迁移到：<a href="https://github.com/gomodule/redigo" target="_blank" rel="noopener">https://github.com/gomodule/redigo</a> </p><p>文档：<a href="https://godoc.org/github.com/garyburd/redigo/redis" target="_blank" rel="noopener">https://godoc.org/github.com/garyburd/redigo/redis</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ go get github.com/garyburd/redigo/redis</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"github.com/garyburd/redigo/redis"</span></span><br></pre></td></tr></table></figure><h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><p><code>Conn</code>接口是与<code>Redis</code>协作的主要接口，可以使用<code>Dial</code>,<code>DialWithTimeout</code>或者<code>NewConn</code>函数来创建连接，当任务完成时，应用程序必须调用<code>Close</code>函数来完成操作。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"github.com/garyburd/redigo/redis"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">    conn,err := redis.Dial(<span class="string">"tcp"</span>,<span class="string">"10.1.210.69:6379"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"connect redis error :"</span>,err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> conn.Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="命令操作"><a href="#命令操作" class="headerlink" title="命令操作"></a>命令操作</h3><p>通过使用Conn接口中的do方法执行redis命令，redis命令大全参考：<a href="http://doc.redisfans.com/" target="_blank" rel="noopener">http://doc.redisfans.com/</a></p><p>go中发送与响应对应类型：</p><p><code>Do</code>函数会必要时将参数转化为二进制字符串</p><table><thead><tr><th style="text-align:left"><strong>Go Type</strong></th><th style="text-align:center"><strong>Conversion</strong></th></tr></thead><tbody><tr><td style="text-align:left">[]byte</td><td style="text-align:center">Sent as is</td></tr><tr><td style="text-align:left">string</td><td style="text-align:center">Sent as is</td></tr><tr><td style="text-align:left">int, int64</td><td style="text-align:center">strconv.FormatInt(v)</td></tr><tr><td style="text-align:left">float64</td><td style="text-align:center">strconv.FormatFloat(v, ‘g’, -1, 64)</td></tr><tr><td style="text-align:left">bool</td><td style="text-align:center">true -&gt; “1”, false -&gt; “0”</td></tr><tr><td style="text-align:left">nil</td><td style="text-align:center">“”</td></tr><tr><td style="text-align:left">all other types</td><td style="text-align:center">fmt.Print(v)</td></tr></tbody></table><p>Redis 命令响应会用以下Go类型表示：</p><table><thead><tr><th>Redis Type</th><th>Go Type</th></tr></thead><tbody><tr><td>error</td><td>redis.Error</td></tr><tr><td>interger</td><td>int64</td></tr><tr><td>simple string</td><td>string</td></tr><tr><td>bulk string</td><td>[]byte or nil if value not present</td></tr><tr><td>arrary</td><td>[]interface{} or nil if value not present</td></tr></tbody></table><p>可以使用GO的类型断言或者<code>reply</code>辅助函数将返回的<code>interface{}</code>转换为对应类型。</p><h4 id="操作示例：get、set"><a href="#操作示例：get、set" class="headerlink" title="操作示例：get、set"></a>操作示例：<strong><code>get</code>、<code>set</code></strong></h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"github.com/garyburd/redigo/redis"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">    conn,err := redis.Dial(<span class="string">"tcp"</span>,<span class="string">"10.1.210.69:6379"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"connect redis error :"</span>,err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> conn.Close()</span><br><span class="line">    _, err = conn.Do(<span class="string">"SET"</span>, <span class="string">"name"</span>, <span class="string">"wd"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"redis set error:"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    name, err := redis.String(conn.Do(<span class="string">"GET"</span>, <span class="string">"name"</span>))</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"redis get error:"</span>, err)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"Got name: %s \n"</span>, name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="设置key过期时间"><a href="#设置key过期时间" class="headerlink" title="设置key过期时间"></a>设置key过期时间</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_, err = conn.Do(<span class="string">"expire"</span>, <span class="string">"name"</span>, <span class="number">10</span>) <span class="comment">//10秒过期</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"set expire error: "</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="批量获取mget、批量设置mset"><a href="#批量获取mget、批量设置mset" class="headerlink" title="批量获取mget、批量设置mset"></a>批量获取mget、批量设置mset</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">_, err = conn.Do(<span class="string">"MSET"</span>, <span class="string">"name"</span>, <span class="string">"wd"</span>,<span class="string">"age"</span>,<span class="number">22</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"redis mset error:"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    res, err := redis.Strings(conn.Do(<span class="string">"MGET"</span>, <span class="string">"name"</span>,<span class="string">"age"</span>))</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"redis get error:"</span>, err)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        res_type := reflect.TypeOf(res)</span><br><span class="line">        fmt.Printf(<span class="string">"res type : %s \n"</span>, res_type)</span><br><span class="line">        fmt.Printf(<span class="string">"MGET name: %s \n"</span>, res)</span><br><span class="line">        fmt.Println(<span class="built_in">len</span>(res))</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//结果：</span></span><br><span class="line"><span class="comment">//res type : []string </span></span><br><span class="line"><span class="comment">//MGET name: [wd 22] </span></span><br><span class="line"><span class="comment">//2</span></span><br></pre></td></tr></table></figure><h4 id="列表操作"><a href="#列表操作" class="headerlink" title="列表操作"></a>列表操作</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"github.com/garyburd/redigo/redis"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">    conn,err := redis.Dial(<span class="string">"tcp"</span>,<span class="string">"10.1.210.69:6379"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"connect redis error :"</span>,err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> conn.Close()</span><br><span class="line">    _, err = conn.Do(<span class="string">"LPUSH"</span>, <span class="string">"list1"</span>, <span class="string">"ele1"</span>,<span class="string">"ele2"</span>,<span class="string">"ele3"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"redis mset error:"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    res, err := redis.String(conn.Do(<span class="string">"LPOP"</span>, <span class="string">"list1"</span>))</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"redis POP error:"</span>, err)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        res_type := reflect.TypeOf(res)</span><br><span class="line">        fmt.Printf(<span class="string">"res type : %s \n"</span>, res_type)</span><br><span class="line">        fmt.Printf(<span class="string">"res  : %s \n"</span>, res)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//res type : string </span></span><br><span class="line"><span class="comment">//res  : ele3</span></span><br></pre></td></tr></table></figure><h4 id="hash操作"><a href="#hash操作" class="headerlink" title="hash操作"></a>hash操作</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"github.com/garyburd/redigo/redis"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">    conn,err := redis.Dial(<span class="string">"tcp"</span>,<span class="string">"10.1.210.69:6379"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"connect redis error :"</span>,err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> conn.Close()</span><br><span class="line">    _, err = conn.Do(<span class="string">"HSET"</span>, <span class="string">"student"</span>,<span class="string">"name"</span>, <span class="string">"wd"</span>,<span class="string">"age"</span>,<span class="number">22</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"redis mset error:"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    res, err := redis.Int64(conn.Do(<span class="string">"HGET"</span>, <span class="string">"student"</span>,<span class="string">"age"</span>))</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"redis HGET error:"</span>, err)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        res_type := reflect.TypeOf(res)</span><br><span class="line">        fmt.Printf(<span class="string">"res type : %s \n"</span>, res_type)</span><br><span class="line">        fmt.Printf(<span class="string">"res  : %d \n"</span>, res)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//res type : int64 </span></span><br><span class="line"><span class="comment">//res  : 22</span></span><br></pre></td></tr></table></figure><h4 id="Pipelining-管道"><a href="#Pipelining-管道" class="headerlink" title="Pipelining(管道)"></a>Pipelining(管道)</h4><p>管道操作可以理解为并发操作，并通过<code>Send()</code>，<code>Flush()</code>，<code>Receive()</code>三个方法实现。客户端可以使用<code>send()</code>方法一次性向服务器发送一个或多个命令，命令发送完毕时，使用<code>flush()</code>方法将缓冲区的命令输入一次性发送到服务器，客户端再使用<code>Receive()</code>方法依次按照先进先出的顺序读取所有命令操作结果。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Send(commandName <span class="keyword">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;) error</span><br><span class="line">Flush() error</span><br><span class="line">Receive() (reply <span class="keyword">interface</span>&#123;&#125;, err error)</span><br></pre></td></tr></table></figure><ul><li><code>Send</code>：发送命令至缓冲区</li><li><code>Flush</code>:  清空缓冲区，将命令一次性发送至服务器</li><li><code>Recevie</code>:  依次读取服务器响应结果，当读取的命令未响应时，该操作会阻塞</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"github.com/garyburd/redigo/redis"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">    conn,err := redis.Dial(<span class="string">"tcp"</span>,<span class="string">"10.1.210.69:6379"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"connect redis error :"</span>,err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> conn.Close()</span><br><span class="line">    conn.Send(<span class="string">"HSET"</span>, <span class="string">"student"</span>,<span class="string">"name"</span>, <span class="string">"wd"</span>,<span class="string">"age"</span>,<span class="string">"22"</span>)</span><br><span class="line">    conn.Send(<span class="string">"HSET"</span>, <span class="string">"student"</span>,<span class="string">"Score"</span>,<span class="string">"100"</span>)</span><br><span class="line">    conn.Send(<span class="string">"HGET"</span>, <span class="string">"student"</span>,<span class="string">"age"</span>)</span><br><span class="line">    conn.Flush()</span><br><span class="line"></span><br><span class="line">    res1, err := conn.Receive()</span><br><span class="line">    fmt.Printf(<span class="string">"Receive res1:%v \n"</span>, res1)</span><br><span class="line">    res2, err := conn.Receive()</span><br><span class="line">    fmt.Printf(<span class="string">"Receive res2:%v\n"</span>,res2)</span><br><span class="line">    res3, err := conn.Receive()</span><br><span class="line">    fmt.Printf(<span class="string">"Receive res3:%s\n"</span>,res3)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Receive res1:0 </span></span><br><span class="line"><span class="comment">//Receive res2:0</span></span><br><span class="line"><span class="comment">//Receive res3:22</span></span><br></pre></td></tr></table></figure><h4 id="发布-订阅"><a href="#发布-订阅" class="headerlink" title="发布/订阅"></a>发布/订阅</h4><p>redis本身具有发布订阅的功能，其发布订阅功能通过命令SUBSCRIBE(订阅)／PUBLISH(发布)实现，并且发布订阅模式可以是多对多模式还可支持正则表达式，发布者可以向一个或多个频道发送消息，订阅者可订阅一个或者多个频道接受消息。</p><blockquote><ul><li><p>示意图：</p><ul><li><p>发布者：</p><p><img src="https://github.com/AlexBruceLu/DAPP/wiki/rd1.png" alt=""></p></li><li><p>订阅者：</p><p><img src="https://github.com/AlexBruceLu/DAPP/wiki/rd2.png" alt=""></p></li></ul></li></ul></blockquote><p>操作示例，示例中将使用两个<code>goroutine</code>分别担任发布者和订阅者角色进行演示：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"github.com/garyburd/redigo/redis"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Subs</span><span class="params">()</span></span> &#123;  <span class="comment">//订阅者</span></span><br><span class="line">    conn, err := redis.Dial(<span class="string">"tcp"</span>, <span class="string">"10.1.210.69:6379"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"connect redis error :"</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> conn.Close()</span><br><span class="line">    psc := redis.PubSubConn&#123;conn&#125;</span><br><span class="line">    psc.Subscribe(<span class="string">"channel1"</span>) <span class="comment">//订阅channel1频道</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> v := psc.Receive().(<span class="keyword">type</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> redis.Message:</span><br><span class="line">            fmt.Printf(<span class="string">"%s: message: %s\n"</span>, v.Channel, v.Data)</span><br><span class="line">        <span class="keyword">case</span> redis.Subscription:</span><br><span class="line">            fmt.Printf(<span class="string">"%s: %s %d\n"</span>, v.Channel, v.Kind, v.Count)</span><br><span class="line">        <span class="keyword">case</span> error:</span><br><span class="line">            fmt.Println(v)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Push</span><span class="params">(message <span class="keyword">string</span>)</span></span>  &#123; <span class="comment">//发布者</span></span><br><span class="line">    conn, _ := redis.Dial(<span class="string">"tcp"</span>, <span class="string">"10.1.210.69:6379"</span>)</span><br><span class="line">    _,err1 := conn.Do(<span class="string">"PUBLISH"</span>, <span class="string">"channel1"</span>, message)</span><br><span class="line">    <span class="keyword">if</span> err1 != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"pub err: "</span>, err1)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">    <span class="keyword">go</span> Subs()</span><br><span class="line">    <span class="keyword">go</span> Push(<span class="string">"this is wd"</span>)</span><br><span class="line">    time.Sleep(time.Second*<span class="number">3</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//channel1: subscribe 1</span></span><br><span class="line"><span class="comment">//channel1: message: this is wd</span></span><br></pre></td></tr></table></figure><h4 id="事务操作"><a href="#事务操作" class="headerlink" title="事务操作"></a>事务操作</h4><p><code>MULTI</code>, <code>EXEC</code>,<code>DISCARD</code>和<code>WATCH</code>是构成Redis事务的基础，当然我们使用go语言对redis进行事务操作的时候本质也是使用这些命令。</p><p><code>MULTI</code>：开启事务</p><p><code>EXEC</code>：执行事务</p><p><code>DISCARD</code>：取消事务</p><p><code>WATCH</code>：监视事务中的键变化，一旦有改变则取消事务</p><font color="red"><strong>示例：</strong></font><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"github.com/garyburd/redigo/redis"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">    conn,err := redis.Dial(<span class="string">"tcp"</span>,<span class="string">"10.1.210.69:6379"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"connect redis error :"</span>,err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> conn.Close()</span><br><span class="line">    conn.Send(<span class="string">"MULTI"</span>)</span><br><span class="line">    conn.Send(<span class="string">"INCR"</span>, <span class="string">"foo"</span>)</span><br><span class="line">    conn.Send(<span class="string">"INCR"</span>, <span class="string">"bar"</span>)</span><br><span class="line">    r, err := conn.Do(<span class="string">"EXEC"</span>)</span><br><span class="line">    fmt.Println(r)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//[1, 1]</span></span><br></pre></td></tr></table></figure><h4 id="连接池使用"><a href="#连接池使用" class="headerlink" title="连接池使用"></a>连接池使用</h4><p><code>redis</code>连接池是通过<code>pool</code>结构体实现，以下是源码定义，相关参数说明已经备注：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Pool <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// Dial is an application supplied function for creating and configuring a</span></span><br><span class="line">    <span class="comment">// connection.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// The connection returned from Dial must not be in a special state</span></span><br><span class="line">    <span class="comment">// (subscribed to pubsub channel, transaction started, ...).</span></span><br><span class="line">    Dial <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="params">(Conn, error)</span> //连接方法</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    // <span class="title">TestOnBorrow</span> <span class="title">is</span> <span class="title">an</span> <span class="title">optional</span> <span class="title">application</span> <span class="title">supplied</span> <span class="title">function</span> <span class="title">for</span> <span class="title">checking</span></span></span><br><span class="line"><span class="function">    // <span class="title">the</span> <span class="title">health</span> <span class="title">of</span> <span class="title">an</span> <span class="title">idle</span> <span class="title">connection</span> <span class="title">before</span> <span class="title">the</span> <span class="title">connection</span> <span class="title">is</span> <span class="title">used</span> <span class="title">again</span> <span class="title">by</span></span></span><br><span class="line"><span class="function">// <span class="title">the</span> <span class="title">application</span>. <span class="title">Argument</span> <span class="title">t</span> <span class="title">is</span> <span class="title">the</span> <span class="title">time</span> <span class="title">that</span> <span class="title">the</span> <span class="title">connection</span> <span class="title">was</span> <span class="title">returned</span></span></span><br><span class="line"><span class="function">    // <span class="title">to</span> <span class="title">the</span> <span class="title">pool</span>. <span class="title">If</span> <span class="title">the</span> <span class="title">function</span> <span class="title">returns</span> <span class="title">an</span> <span class="title">error</span>, <span class="title">then</span> <span class="title">the</span> <span class="title">connection</span> <span class="title">is</span></span></span><br><span class="line"><span class="function">    // <span class="title">closed</span>.</span></span><br><span class="line"><span class="function">    <span class="title">TestOnBorrow</span> <span class="title">func</span><span class="params">(c Conn, t time.Time)</span> <span class="title">error</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    // <span class="title">Maximum</span> <span class="title">number</span> <span class="title">of</span> <span class="title">idle</span> <span class="title">connections</span> <span class="title">in</span> <span class="title">the</span> <span class="title">pool</span>.</span></span><br><span class="line"><span class="function">    <span class="title">MaxIdle</span> <span class="title">int</span>  //最大的空闲连接数，即使没有<span class="title">redis</span>连接时依然可以保持<span class="title">N</span>个空闲的连接，而不被清除，随时处于待命状态</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    // <span class="title">Maximum</span> <span class="title">number</span> <span class="title">of</span> <span class="title">connections</span> <span class="title">allocated</span> <span class="title">by</span> <span class="title">the</span> <span class="title">pool</span> <span class="title">at</span> <span class="title">a</span> <span class="title">given</span> <span class="title">time</span>.</span></span><br><span class="line"><span class="function">    // <span class="title">When</span> <span class="title">zero</span>, <span class="title">there</span> <span class="title">is</span> <span class="title">no</span> <span class="title">limit</span> <span class="title">on</span> <span class="title">the</span> <span class="title">number</span> <span class="title">of</span> <span class="title">connections</span> <span class="title">in</span> <span class="title">the</span> <span class="title">pool</span>.</span></span><br><span class="line"><span class="function">    <span class="title">MaxActive</span> <span class="title">int</span> //最大的激活连接数，同时最多有<span class="title">N</span>个连接</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    // <span class="title">Close</span> <span class="title">connections</span> <span class="title">after</span> <span class="title">remaining</span> <span class="title">idle</span> <span class="title">for</span> <span class="title">this</span> <span class="title">duration</span>. <span class="title">If</span> <span class="title">the</span> <span class="title">value</span></span></span><br><span class="line"><span class="function">    // <span class="title">is</span> <span class="title">zero</span>, <span class="title">then</span> <span class="title">idle</span> <span class="title">connections</span> <span class="title">are</span> <span class="title">not</span> <span class="title">closed</span>. <span class="title">Applications</span> <span class="title">should</span> <span class="title">set</span></span></span><br><span class="line"><span class="function">    // <span class="title">the</span> <span class="title">timeout</span> <span class="title">to</span> <span class="title">a</span> <span class="title">value</span> <span class="title">less</span> <span class="title">than</span> <span class="title">the</span> <span class="title">server</span>'<span class="title">s</span> <span class="title">timeout</span>.</span></span><br><span class="line"><span class="function">    <span class="title">IdleTimeout</span> <span class="title">time</span>.<span class="title">Duration</span>  //空闲连接等待时间，超过此时间后，空闲连接将被关闭</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    // <span class="title">If</span> <span class="title">Wait</span> <span class="title">is</span> <span class="title">true</span> <span class="title">and</span> <span class="title">the</span> <span class="title">pool</span> <span class="title">is</span> <span class="title">at</span> <span class="title">the</span> <span class="title">MaxActive</span> <span class="title">limit</span>, <span class="title">then</span> <span class="title">Get</span><span class="params">()</span> <span class="title">waits</span></span></span><br><span class="line"><span class="function">    // <span class="title">for</span> <span class="title">a</span> <span class="title">connection</span> <span class="title">to</span> <span class="title">be</span> <span class="title">returned</span> <span class="title">to</span> <span class="title">the</span> <span class="title">pool</span> <span class="title">before</span> <span class="title">returning</span>.</span></span><br><span class="line"><span class="function">    <span class="title">Wait</span> <span class="title">bool</span>  //当配置项为<span class="title">true</span>并且<span class="title">MaxActive</span>参数有限制时候，使用<span class="title">Get</span>方法等待一个连接返回给连接池</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    // <span class="title">Close</span> <span class="title">connections</span> <span class="title">older</span> <span class="title">than</span> <span class="title">this</span> <span class="title">duration</span>. <span class="title">If</span> <span class="title">the</span> <span class="title">value</span> <span class="title">is</span> <span class="title">zero</span>, <span class="title">then</span></span></span><br><span class="line"><span class="function">    // <span class="title">the</span> <span class="title">pool</span> <span class="title">does</span> <span class="title">not</span> <span class="title">close</span> <span class="title">connections</span> <span class="title">based</span> <span class="title">on</span> <span class="title">age</span>.</span></span><br><span class="line"><span class="function">    <span class="title">MaxConnLifetime</span> <span class="title">time</span>.<span class="title">Duration</span></span></span><br><span class="line"><span class="function">    // <span class="title">contains</span> <span class="title">filtered</span> <span class="title">or</span> <span class="title">unexported</span> <span class="title">fields</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><font color="red"><strong>示例：</strong></font><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"github.com/garyburd/redigo/redis"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Pool redis.Pool</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span>  &#123;      <span class="comment">//init 用于初始化一些参数，先于main执行</span></span><br><span class="line">    Pool = redis.Pool&#123;</span><br><span class="line">        MaxIdle:     <span class="number">16</span>,</span><br><span class="line">        MaxActive:   <span class="number">32</span>,</span><br><span class="line">        IdleTimeout: <span class="number">120</span>,</span><br><span class="line">        Dial: <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="params">(redis.Conn, error)</span></span> &#123;</span><br><span class="line">            <span class="keyword">return</span> redis.Dial(<span class="string">"tcp"</span>, <span class="string">"10.1.210.69:6379"</span>)</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line"></span><br><span class="line">    conn :=Pool.Get()</span><br><span class="line">    res,err := conn.Do(<span class="string">"HSET"</span>,<span class="string">"student"</span>,<span class="string">"name"</span>,<span class="string">"jack"</span>)</span><br><span class="line">    fmt.Println(res,err)</span><br><span class="line">    res1,err := redis.String(conn.Do(<span class="string">"HGET"</span>,<span class="string">"student"</span>,<span class="string">"name"</span>))</span><br><span class="line">    fmt.Printf(<span class="string">"res:%s,error:%v"</span>,res1,err)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//0 &lt;nil&gt;</span></span><br><span class="line"><span class="comment">//res:jack,error:&lt;nil&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Golang-redis-学习指南"><a href="#Golang-redis-学习指南" class="headerlink" title="Golang redis 学习指南"></a>Golang redis 学习指南</h2><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><h4 id="创建客户端"><a href="#创建客户端" class="headerlink" title="创建客户端"></a>创建客户端</h4><p>通过 redis.NewClient 函数即可创建一个 redis 客户端, 这个方法接收一个 <code>redis.Options</code>对象参数, 通过这个参数, 我们可以配置 redis 相关的属性, 例如 redis 服务器地址, 数据库名, 数据库密码等.<br>下面是一个连接的例子:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建 redis 客户端</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createClient</span><span class="params">()</span> *<span class="title">redis</span>.<span class="title">Client</span></span> &#123;</span><br><span class="line"></span><br><span class="line">client := redis.NewClient(&amp;redis.Options&#123;</span><br><span class="line">Addr:     <span class="string">"localhost:6379"</span>,</span><br><span class="line">Password: <span class="string">""</span>,</span><br><span class="line">DB:       <span class="number">0</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 cient.Ping() 来检查是否成功连接到了 redis 服务器</span></span><br><span class="line">pong, err := client.Ping().Result()</span><br><span class="line">fmt.Println(pong, err)</span><br><span class="line"><span class="keyword">return</span> client</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="String-操作"><a href="#String-操作" class="headerlink" title="String 操作"></a>String 操作</h4><p><code>redis</code>的<code>String</code>操作有:</p><blockquote><p>set(key, value)：给数据库中名称为key的string赋予值value</p><p>get(key)：返回数据库中名称为key的string的value</p><p>getset(key, value)：给名称为key的string赋予上一次的value</p><p>mget(key1, key2,…, key N)：返回库中多个string的value</p><p>setnx(key, value)：添加string，名称为key，值为value</p><p>setex(key, time, value)：向库中添加string，设定过期时间time</p><p>mset(key N, value N)：批量设置多个string的值</p><p>msetnx(key N, value N)：如果所有名称为key i的string都不存在</p><p>incr(key)：名称为key的string增1操作</p><p>incrby(key, integer)：名称为key的string增加integer</p><p>decr(key)：名称为key的string减1操作</p><p>decrby(key, integer)：名称为key的string减少integer</p><p>append(key, value)：名称为key的string的值附加value</p><p>substr(key, start, end)：返回名称为key的string的value的子串</p></blockquote><p>在 <code>go-redis</code> 中, 我们可以直接找到对应的操作方法, 直接上代码:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// String 操作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">stringOperation</span><span class="params">(client *redis.Client)</span></span> &#123;</span><br><span class="line"><span class="comment">// 第三个参数是过期时间, 如果是0, 则表示没有过期时间.</span></span><br><span class="line">err := client.Set(<span class="string">"name"</span>, <span class="string">"xys"</span>, <span class="number">0</span>).Err()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">val, err := client.Get(<span class="string">"name"</span>).Result()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"> <span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">"name"</span>, val)</span><br><span class="line"><span class="comment">// 这里设置过期时间.</span></span><br><span class="line">err = client.Set(<span class="string">"age"</span>, <span class="string">"20"</span>, <span class="number">1</span> * time.Second).Err()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">client.Incr(<span class="string">"age"</span>) <span class="comment">// 自增</span></span><br><span class="line">client.Incr(<span class="string">"age"</span>) <span class="comment">// 自增</span></span><br><span class="line">client.Decr(<span class="string">"age"</span>) <span class="comment">// 自减</span></span><br><span class="line"></span><br><span class="line">val, err = client.Get(<span class="string">"age"</span>).Result()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">"age"</span>, val) <span class="comment">// age 的值为21</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为 key "age" 的过期时间是一秒钟, 因此当一秒后, 此 key 会自动被删除了.</span></span><br><span class="line">time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">val, err = client.Get(<span class="string">"age"</span>).Result()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// 因为 key "age" 已经过期了, 因此会有一个 redis: nil 的错误.</span></span><br><span class="line">fmt.Printf(<span class="string">"error: %v\n"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"age"</span>, val)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="list-操作"><a href="#list-操作" class="headerlink" title="list 操作"></a>list 操作</h4><p>redis 的 list 操作有:</p><blockquote><p>rpush(key, value)：在名称为key的list尾添加一个值为value的元素</p><p>lpush(key, value)：在名称为key的list头添加一个值为value的 元素</p><p>llen(key)：返回名称为key的list的长度</p><p>lrange(key, start, end)：返回名称为key的list中start至end之间的元素</p><p>ltrim(key, start, end)：截取名称为key的list</p><p>lindex(key, index)：返回名称为key的list中index位置的元素</p><p>lset(key, index, value)：给名称为key的list中index位置的元素赋值</p><p>lrem(key, count, value)：删除count个key的list中值为value的元素</p><p>lpop(key)：返回并删除名称为key的list中的首元素</p><p>rpop(key)：返回并删除名称为key的list中的尾元素</p><p>blpop(key1, key2,… key N, timeout)：lpop命令的block版本。</p><p>brpop(key1, key2,… key N, timeout)：rpop的block版本。</p><p>rpoplpush(srckey, dstkey)：返回并删除名称为srckey的list的尾元素，并将该元素添加到名称为dstkey的list的头部</p></blockquote><p>同样地, 在 go-redis 中也可以找到对应的方法, 下面是一个简单的示例:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// list 操作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">listOperation</span><span class="params">(client *redis.Client)</span></span> &#123;</span><br><span class="line">client.RPush(<span class="string">"fruit"</span>, <span class="string">"apple"</span>) <span class="comment">//在名称为 fruit 的list尾添加一个值为value的元素</span></span><br><span class="line">client.LPush(<span class="string">"fruit"</span>, <span class="string">"banana"</span>) <span class="comment">//在名称为 fruit 的list头添加一个值为value的 元素</span></span><br><span class="line">length, err := client.LLen(<span class="string">"fruit"</span>).Result() <span class="comment">//返回名称为 fruit 的list的长度</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"length: "</span>, length) <span class="comment">// 长度为2</span></span><br><span class="line">value, err := client.LPop(<span class="string">"fruit"</span>).Result() <span class="comment">//返回并删除名称为 fruit 的list中的首元素</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"fruit: "</span>, value)</span><br><span class="line">value, err = client.RPop(<span class="string">"fruit"</span>).Result() <span class="comment">// 返回并删除名称为 fruit 的list中的尾元素</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"fruit: "</span>, value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="set-操作"><a href="#set-操作" class="headerlink" title="set 操作"></a>set 操作</h4><blockquote><p>redis 的 set 操作:</p><p>sadd(key, member)：向名称为key的set中添加元素member</p><p>srem(key, member) ：删除名称为key的set中的元素member</p><p>spop(key) ：随机返回并删除名称为key的set中一个元素</p><p>smove(srckey, dstkey, member) ：移到集合元素</p><p>scard(key) ：返回名称为key的set的基数</p><p>sismember(key, member) ：member是否是名称为key的set的元素</p><p>sinter(key1, key2,…key N) ：求交集</p><p>sinterstore(dstkey, (keys)) ：求交集并将交集保存到dstkey的集合</p><p>sunion(key1, (keys)) ：求并集</p><p>sunionstore(dstkey, (keys)) ：求并集并将并集保存到dstkey的集合</p><p>sdiff(key1, (keys)) ：求差集</p><p>sdiffstore(dstkey, (keys)) ：求差集并将差集保存到dstkey的集合</p><p>smembers(key) ：返回名称为key的set的所有元素</p><p>srandmember(key) ：随机返回名称为key的set的一个元素</p></blockquote><p>接下来是 go-redis 的 set 操作:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// set 操作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setOperation</span><span class="params">(client *redis.Client)</span></span> &#123;</span><br><span class="line">client.SAdd(<span class="string">"blacklist"</span>, <span class="string">"Obama"</span>) <span class="comment">// 向 blacklist 中添加元素</span></span><br><span class="line">client.SAdd(<span class="string">"blacklist"</span>, <span class="string">"Hillary"</span>) <span class="comment">// 再次添加</span></span><br><span class="line">client.SAdd(<span class="string">"blacklist"</span>, <span class="string">"the Elder"</span>) <span class="comment">// 添加新元素</span></span><br><span class="line">client.SAdd(<span class="string">"whitelist"</span>, <span class="string">"the Elder"</span>) <span class="comment">// 向 whitelist 添加元素</span></span><br><span class="line"><span class="comment">// 判断元素是否在集合中</span></span><br><span class="line">isMember, err := client.SIsMember(<span class="string">"blacklist"</span>, <span class="string">"Bush"</span>).Result()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"Is Bush in blacklist: "</span>, isMember)</span><br><span class="line"><span class="comment">// 求交集, 即既在黑名单中, 又在白名单中的元素</span></span><br><span class="line">names, err := client.SInter(<span class="string">"blacklist"</span>, <span class="string">"whitelist"</span>).Result()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取到的元素是 "the Elder"</span></span><br><span class="line">fmt.Println(<span class="string">"Inter result: "</span>, names)</span><br><span class="line"><span class="comment">// 获取指定集合的所有元素</span></span><br><span class="line">all, err := client.SMembers(<span class="string">"blacklist"</span>).Result()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"All member: "</span>, all)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="hash-操作"><a href="#hash-操作" class="headerlink" title="hash 操作"></a>hash 操作</h4><p>redis 的 hash 操作:</p><blockquote><p>hset(key, field, value)：向名称为key的hash中添加元素field</p><p>hget(key, field)：返回名称为key的hash中field对应的value</p><p>hmget(key, (fields))：返回名称为key的hash中field i对应的value</p><p>hmset(key, (fields))：向名称为key的hash中添加元素field </p><p>hincrby(key, field, integer)：将名称为key的hash中field的value增加integer</p><p>hexists(key, field)：名称为key的hash中是否存在键为field的域</p><p>hdel(key, field)：删除名称为key的hash中键为field的域</p><p>hlen(key)：返回名称为key的hash中元素个数</p><p>hkeys(key)：返回名称为key的hash中所有键</p><p>hvals(key)：返回名称为key的hash中所有键对应的value</p><p>hgetall(key)：返回名称为key的hash中所有的键（field）及其对应的value</p></blockquote><p><code>go-redis</code> 中的 hash 操作:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hash 操作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hashOperation</span><span class="params">(client *redis.Client)</span></span> &#123;</span><br><span class="line">client.HSet(<span class="string">"user_xys"</span>, <span class="string">"name"</span>, <span class="string">"xys"</span>); <span class="comment">// 向名称为 user_xys 的 hash 中添加元素 name</span></span><br><span class="line">client.HSet(<span class="string">"user_xys"</span>, <span class="string">"age"</span>, <span class="string">"18"</span>); <span class="comment">// 向名称为 user_xys 的 hash 中添加元素 age</span></span><br><span class="line"><span class="comment">// 批量地向名称为 user_test 的 hash 中添加元素 name 和 age</span></span><br><span class="line">client.HMSet(<span class="string">"user_test"</span>, <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;<span class="string">"name"</span>: <span class="string">"test"</span>, <span class="string">"age"</span>:<span class="string">"20"</span>&#125;)</span><br><span class="line"><span class="comment">// 批量获取名为 user_test 的 hash 中的指定字段的值.</span></span><br><span class="line">fields, err := client.HMGet(<span class="string">"user_test"</span>, <span class="string">"name"</span>, <span class="string">"age"</span>).Result()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"fields in user_test: "</span>, fields)</span><br><span class="line"><span class="comment">// 获取名为 user_xys 的 hash 中的字段个数</span></span><br><span class="line">length, err := client.HLen(<span class="string">"user_xys"</span>).Result()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"field count in user_xys: "</span>, length) <span class="comment">// 字段个数为2</span></span><br><span class="line"><span class="comment">// 删除名为 user_test 的 age 字段</span></span><br><span class="line">client.HDel(<span class="string">"user_test"</span>, <span class="string">"age"</span>)</span><br><span class="line">age, err := client.HGet(<span class="string">"user_test"</span>, <span class="string">"age"</span>).Result()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"Get user_test age error: %v\n"</span>, err)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"user_test age is: "</span>, age) <span class="comment">// 字段个数为2</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="关于连接池"><a href="#关于连接池" class="headerlink" title="关于连接池"></a>关于连接池</h4><p>redis.v4 包实现了 redis 的连接池管理, 因此我们就不需要自己手动管理 redis 的连接了. 默认情况下, redis.v4 的 redis 连接池大小是10, 不过我们可以在初始化 redis 客户端时自行设置连接池的大小, 例如:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">client := redis.NewClient(&amp;redis.Options&#123;</span><br><span class="line">Addr:     <span class="string">"localhost:6379"</span>,</span><br><span class="line">Password: <span class="string">""</span>,</span><br><span class="line">DB:       <span class="number">0</span>,</span><br><span class="line">PoolSize: <span class="number">5</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>通过 redis.Options 的 PoolSize 属性, 我们设置了 redis 连接池的大小为5.那么接下来我们来看一下这个设置有什么效果吧:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// redis.v4 的连接池管理</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">connectPool</span><span class="params">(client *redis.Client)</span></span> &#123;</span><br><span class="line">wg := sync.WaitGroup&#123;&#125;</span><br><span class="line">wg.Add(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">100</span>; j++ &#123;</span><br><span class="line">client.Set(fmt.Sprintf(<span class="string">"name%d"</span>, j), fmt.Sprintf(<span class="string">"xys%d"</span>, j), <span class="number">0</span>).Err()</span><br><span class="line">client.Get(fmt.Sprintf(<span class="string">"name%d"</span>, j)).Result()</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"PoolStats, TotalConns: %d, FreeConns: %d\n"</span>, client.PoolStats().TotalConns, client.PoolStats().FreeConns);</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的例子启动了10个 routine 来不断向 redis 读写数据, 然后我们通过 client.PoolStats() 获取连接池的信息. 运行这个例子, 输出如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">PoolStats, TotalConns: 5, FreeConns: 1</span><br><span class="line"></span><br><span class="line">PoolStats, TotalConns: 5, FreeConns: 1</span><br><span class="line"></span><br><span class="line">PoolStats, TotalConns: 5, FreeConns: 1</span><br><span class="line"></span><br><span class="line">PoolStats, TotalConns: 5, FreeConns: 1</span><br><span class="line"></span><br><span class="line">PoolStats, TotalConns: 5, FreeConns: 1</span><br><span class="line"></span><br><span class="line">PoolStats, TotalConns: 5, FreeConns: 2</span><br><span class="line"></span><br><span class="line">PoolStats, TotalConns: 5, FreeConns: 2</span><br><span class="line"></span><br><span class="line">PoolStats, TotalConns: 5, FreeConns: 3</span><br><span class="line"></span><br><span class="line">PoolStats, TotalConns: 5, FreeConns: 4</span><br><span class="line"></span><br><span class="line">PoolStats, TotalConns: 5, FreeConns: 5</span><br></pre></td></tr></table></figure><p>通过输出可以看到, 此时最大的连接池数量确实是 5 了, 并且一开始时, 因为 coroutine 的数量大于5, 会造成 redis 连接不足的情况(反映在 FreeConns 上就是前几次的输出 FreeConns 一直是1), 当某个 coroutine 结束后, 会释放此 redis 连接, 因此 FreeConns 会增加.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//完整示例</span></span><br><span class="line"><span class="comment">// author xiongyongshun</span></span><br><span class="line"><span class="comment">// project go_redis</span></span><br><span class="line"><span class="comment">// version 1.0</span></span><br><span class="line"><span class="comment">// created 16/10/6 03:49</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"gopkg.in/redis.v4"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">client := createClient()</span><br><span class="line"><span class="keyword">defer</span> client.Close()</span><br><span class="line">stringOperation(client)</span><br><span class="line">listOperation(client)</span><br><span class="line">setOperation(client)</span><br><span class="line">hashOperation(client)</span><br><span class="line">connectPool(client)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 redis 客户端</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createClient</span><span class="params">()</span> *<span class="title">redis</span>.<span class="title">Client</span></span> &#123;</span><br><span class="line">client := redis.NewClient(&amp;redis.Options&#123;</span><br><span class="line">Addr:     <span class="string">"localhost:6379"</span>,</span><br><span class="line">Password: <span class="string">""</span>,</span><br><span class="line">DB:       <span class="number">0</span>,</span><br><span class="line">PoolSize: <span class="number">5</span>,</span><br><span class="line">&#125;)</span><br><span class="line">pong, err := client.Ping().Result()</span><br><span class="line">fmt.Println(pong, err)</span><br><span class="line"><span class="keyword">return</span> client</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// String 操作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">stringOperation</span><span class="params">(client *redis.Client)</span></span> &#123;</span><br><span class="line"><span class="comment">// 第三个参数是过期时间, 如果是0, 则表示没有过期时间.</span></span><br><span class="line">err := client.Set(<span class="string">"name"</span>, <span class="string">"xys"</span>, <span class="number">0</span>).Err()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">val, err := client.Get(<span class="string">"name"</span>).Result()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"name"</span>, val)</span><br><span class="line"><span class="comment">// 这里设置过期时间.</span></span><br><span class="line">err = client.Set(<span class="string">"age"</span>, <span class="string">"20"</span>, <span class="number">1</span> * time.Second).Err()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">client.Incr(<span class="string">"age"</span>) <span class="comment">// 自增</span></span><br><span class="line">client.Incr(<span class="string">"age"</span>) <span class="comment">// 自增</span></span><br><span class="line">client.Decr(<span class="string">"age"</span>) <span class="comment">// 自减</span></span><br><span class="line">val, err = client.Get(<span class="string">"age"</span>).Result()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"age"</span>, val) <span class="comment">// age 的值为21</span></span><br><span class="line"><span class="comment">// 因为 key "age" 的过期时间是一秒钟, 因此当一秒后, 此 key 会自动被删除了.</span></span><br><span class="line">time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">val, err = client.Get(<span class="string">"age"</span>).Result()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// 因为 key "age" 已经过期了, 因此会有一个 redis: nil 的错误.</span></span><br><span class="line">fmt.Printf(<span class="string">"error: %v\n"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"age"</span>, val)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// list 操作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">listOperation</span><span class="params">(client *redis.Client)</span></span> &#123;</span><br><span class="line">client.RPush(<span class="string">"fruit"</span>, <span class="string">"apple"</span>) <span class="comment">//在名称为 fruit 的list尾添加一个值为value的元素</span></span><br><span class="line">client.LPush(<span class="string">"fruit"</span>, <span class="string">"banana"</span>) <span class="comment">//在名称为 fruit 的list头添加一个值为value的 元素</span></span><br><span class="line">length, err := client.LLen(<span class="string">"fruit"</span>).Result() <span class="comment">//返回名称为 fruit 的list的长度</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"length: "</span>, length) <span class="comment">// 长度为2</span></span><br><span class="line">value, err := client.LPop(<span class="string">"fruit"</span>).Result() <span class="comment">//返回并删除名称为 fruit 的list中的首元素</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"fruit: "</span>, value)</span><br><span class="line">value, err = client.RPop(<span class="string">"fruit"</span>).Result() <span class="comment">// 返回并删除名称为 fruit 的list中的尾元素</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"fruit: "</span>, value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// set 操作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setOperation</span><span class="params">(client *redis.Client)</span></span> &#123;</span><br><span class="line">client.SAdd(<span class="string">"blacklist"</span>, <span class="string">"Obama"</span>) <span class="comment">// 向 blacklist 中添加元素</span></span><br><span class="line">client.SAdd(<span class="string">"blacklist"</span>, <span class="string">"Hillary"</span>) <span class="comment">// 再次添加</span></span><br><span class="line">client.SAdd(<span class="string">"blacklist"</span>, <span class="string">"the Elder"</span>) <span class="comment">// 添加新元素</span></span><br><span class="line">client.SAdd(<span class="string">"whitelist"</span>, <span class="string">"the Elder"</span>) <span class="comment">// 向 whitelist 添加元素</span></span><br><span class="line"><span class="comment">// 判断元素是否在集合中</span></span><br><span class="line">isMember, err := client.SIsMember(<span class="string">"blacklist"</span>, <span class="string">"Bush"</span>).Result()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"Is Bush in blacklist: "</span>, isMember)</span><br><span class="line"><span class="comment">// 求交集, 即既在黑名单中, 又在白名单中的元素</span></span><br><span class="line">names, err := client.SInter(<span class="string">"blacklist"</span>, <span class="string">"whitelist"</span>).Result()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取到的元素是 "the Elder"</span></span><br><span class="line">fmt.Println(<span class="string">"Inter result: "</span>, names)</span><br><span class="line"><span class="comment">// 获取指定集合的所有元素</span></span><br><span class="line">all, err := client.SMembers(<span class="string">"blacklist"</span>).Result()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"All member: "</span>, all)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// hash 操作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hashOperation</span><span class="params">(client *redis.Client)</span></span> &#123;</span><br><span class="line">client.HSet(<span class="string">"user_xys"</span>, <span class="string">"name"</span>, <span class="string">"xys"</span>); <span class="comment">// 向名称为 user_xys 的 hash 中添加元素 name</span></span><br><span class="line">client.HSet(<span class="string">"user_xys"</span>, <span class="string">"age"</span>, <span class="string">"18"</span>); <span class="comment">// 向名称为 user_xys 的 hash 中添加元素 age</span></span><br><span class="line"><span class="comment">// 批量地向名称为 user_test 的 hash 中添加元素 name 和 age</span></span><br><span class="line">client.HMSet(<span class="string">"user_test"</span>, <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;<span class="string">"name"</span>: <span class="string">"test"</span>, <span class="string">"age"</span>:<span class="string">"20"</span>&#125;)</span><br><span class="line"><span class="comment">// 批量获取名为 user_test 的 hash 中的指定字段的值.</span></span><br><span class="line">fields, err := client.HMGet(<span class="string">"user_test"</span>, <span class="string">"name"</span>, <span class="string">"age"</span>).Result()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"fields in user_test: "</span>, fields)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取名为 user_xys 的 hash 中的字段个数</span></span><br><span class="line">length, err := client.HLen(<span class="string">"user_xys"</span>).Result()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"field count in user_xys: "</span>, length) <span class="comment">// 字段个数为2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除名为 user_test 的 age 字段</span></span><br><span class="line">client.HDel(<span class="string">"user_test"</span>, <span class="string">"age"</span>)</span><br><span class="line">age, err := client.HGet(<span class="string">"user_test"</span>, <span class="string">"age"</span>).Result()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"Get user_test age error: %v\n"</span>, err)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"user_test age is: "</span>, age) <span class="comment">// 字段个数为2</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// redis.v4 的连接池管理</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">connectPool</span><span class="params">(client *redis.Client)</span></span> &#123;</span><br><span class="line">wg := sync.WaitGroup&#123;&#125;</span><br><span class="line">wg.Add(<span class="number">10</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">100</span>; j++ &#123;</span><br><span class="line">client.Set(fmt.Sprintf(<span class="string">"name%d"</span>, j), fmt.Sprintf(<span class="string">"xys%d"</span>, j), <span class="number">0</span>).Err()</span><br><span class="line">client.Get(fmt.Sprintf(<span class="string">"name%d"</span>, j)).Result()</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"PoolStats, TotalConns: %d, FreeConns: %d\n"</span>,client.PoolStats().TotalConns,client.PoolStats().FreeConns)</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt; go操作Redis：&lt;/strong&gt; &lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;/excerpt&gt;&lt;/p&gt;
&lt;p&gt;Redis的简介及golang简易操作redis&lt;/p&gt;
    
    </summary>
    
      <category term="database" scheme="https://alexbrucelu.github.io/categories/database/"/>
    
    
      <category term="Redis" scheme="https://alexbrucelu.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>MySQL的常用命令与简介</title>
    <link href="https://alexbrucelu.github.io/2018/12/16/MySQL%E7%9A%84%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>https://alexbrucelu.github.io/2018/12/16/MySQL的常用命令/</id>
    <published>2018-12-16T09:05:10.305Z</published>
    <updated>2018-12-16T17:07:39.794Z</updated>
    
    <content type="html"><![CDATA[<p><strong> MySQL的常用命令与简介：</strong> <excerpt in="" index="" |="" 首页摘要=""></excerpt></p><p>MySQL养成记之常用命令</p><a id="more"></a><p>[TOC]</p><h2 id="数据库简介"><a href="#数据库简介" class="headerlink" title="数据库简介"></a>数据库简介</h2><p>当前使用的数据库，主要分为两类：</p><ul><li>文档型：sqlite，就是一个文件，通过对文件的复制完成数据库的复制</li><li>服务型：mysql、postgre，数据存储在一个物理文件中，但是需要使用终端以tcp/ip协议连接，进行数据库的读写操作</li></ul><h2 id="E-R模式"><a href="#E-R模式" class="headerlink" title="E-R模式"></a>E-R模式</h2><ul><li>当前物理的数据库都是按照E-R模型设计的<ul><li>E表示entry，实体</li><li>R表示relationship，关系</li></ul></li><li>一个实体转换为数据库中的一个表</li><li>关系描述两个实体之间的对应规则，包括<ul><li>一对一</li><li>一对多</li><li>多对多</li></ul></li><li>关系转换为数据库表中的一个列 <code>*</code>在关系型数据库中一行就是一个对象</li></ul><h2 id="三范式"><a href="#三范式" class="headerlink" title="三范式"></a>三范式</h2><p>经过研究和对使用中问题的总结，对于数据库提出了一些规范</p><blockquote><ul><li>第一范式（1NF）：列不可拆分</li><li>第二范式（2NF）：唯一标识</li><li>第三范式（3NF）：引用主键</li></ul><p><strong><font color="red">说明：后一个范式，都是基于前一个范式的基础建立的</font></strong></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt; MySQL的常用命令与简介：&lt;/strong&gt; &lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;/excerpt&gt;&lt;/p&gt;
&lt;p&gt;MySQL养成记之常用命令&lt;/p&gt;
    
    </summary>
    
      <category term="database" scheme="https://alexbrucelu.github.io/categories/database/"/>
    
    
      <category term="MySQL" scheme="https://alexbrucelu.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>gRPC官方文档</title>
    <link href="https://alexbrucelu.github.io/2018/12/12/gRPC%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/"/>
    <id>https://alexbrucelu.github.io/2018/12/12/gRPC官方文档/</id>
    <published>2018-12-12T08:28:36.238Z</published>
    <updated>2018-12-21T06:06:04.158Z</updated>
    
    <content type="html"><![CDATA[<p><strong> gRPC官方文档：</strong> <excerpt in="" index="" |="" 首页摘要=""></excerpt></p><p>微服务之gRPC官方文档</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt; gRPC官方文档：&lt;/strong&gt; &lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;/excerpt&gt;&lt;/p&gt;
&lt;p&gt;微服务之gRPC官方文档&lt;/p&gt;
    
    </summary>
    
      <category term="microServices" scheme="https://alexbrucelu.github.io/categories/microServices/"/>
    
    
      <category term="微服务" scheme="https://alexbrucelu.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>常见的共识算法</title>
    <link href="https://alexbrucelu.github.io/2018/12/10/%E5%B8%B8%E8%A7%81%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/"/>
    <id>https://alexbrucelu.github.io/2018/12/10/常见共识算法/</id>
    <published>2018-12-10T06:04:06.415Z</published>
    <updated>2018-12-10T06:38:43.474Z</updated>
    
    <content type="html"><![CDATA[<p><strong> 常见的共识算法：</strong> <excerpt in="" index="" |="" 首页摘要=""></excerpt></p><p>PoS、PoW、DPoS</p><a id="more"></a><p>本文是对区块链技术中涉及的共识算法的学习总结整理。 其中PBFT和Raft是联盟链和私有链常用的共识算法，而PoW（比特币采用）和PoS是公有链常用的共识算法。</p><blockquote><p>建议对区块链的学习，要分成是公有链还是联盟链，这两种链中一般采用的共识算法是有较大不同的，P2P网络等也有较大的不同。传统的共识算法一般不适用于公有链，而一定程度上适用于联盟链。</p></blockquote><h2 id="实用拜占庭容错系统PBFT（联盟链中常用）"><a href="#实用拜占庭容错系统PBFT（联盟链中常用）" class="headerlink" title="实用拜占庭容错系统PBFT（联盟链中常用）"></a>实用拜占庭容错系统PBFT（联盟链中常用）</h2><p>拜占庭容错技术（Byzantine Fault Tolerance,BFT）是一类分布式计算领域的容错技术，是一种解决分布式系统容错问题的通用方案。实用拜占庭容错系统（Practical Byzantine Fault Tolerance，PBFT）使拜占庭协议的运行复杂度从指数级别降低到多项式级别，使拜占庭协议在分布式系统中应用成为可能。</p><h3 id="拜占庭将军问题"><a href="#拜占庭将军问题" class="headerlink" title="拜占庭将军问题"></a>拜占庭将军问题</h3><p>拜占庭将军（Byzantine Generals Problem）问题，是 Leslie Lamport 1982 年提出用来解释一致性问题的一个虚构模型。拜占庭是古代东罗马帝国的首都，由于地域宽广，守卫边境的多个将军（系统中的多个节点）需要通过信使来传递消息，达成某些一致的决定。但由于将军中可能存在叛徒（系统中节点出错），这些叛徒将努力向不同的将军发送不同的消息，试图会干扰一致性的达成。拜占庭问题即为在此情况下，如何让忠诚的将军们能达成行动的一致。</p><h3 id="拜占庭容错系统"><a href="#拜占庭容错系统" class="headerlink" title="拜占庭容错系统"></a>拜占庭容错系统</h3><p>拜占庭容错系统是指：在一个拥有nn台节点的系统，整个系统，对每个请求满足如下条件：</p><p>所有非拜占庭节点使用相同的输入信息，产生同样的结果；<br>如果输入的信息正确，那么所有非拜占庭节点必须接收这个信息，并计算相应的结果。<br>与此同时,在拜占庭系统的实际运行过程中一般假设系统中拜占庭节点不超过mm台，并且对每个请求满足2个指标：</p><p>安全性——任何已经完成的请求都不会被更改，它可以在以后请求看到；<br>活性——可以接受并且执行非拜占庭客户端的请求，不会被任何因素影响而导致非拜占庭客户端的请求不能执行。<br>拜占庭系统目前普遍采用的假设条件包括:<br>1) 拜占庭节点的行为可以是任意的，拜占庭节点之间可以共谋；<br>2) 节点之间的错误是不相关的；<br>3) 节点之间通过异步网络连接，网络中的消息可能丢失、乱序、延时到达；<br>4) 服务器之间传递的信息,第三方可以知晓 ,但是不能窜改、伪造信息的内容和验证信息的完整性；</p><p>（发生故障的节点称为拜占庭节点；正常的节点为非拜占庭节点。）</p><h3 id="状态机拜占庭系统"><a href="#状态机拜占庭系统" class="headerlink" title="状态机拜占庭系统"></a>状态机拜占庭系统</h3><h4 id="状态机拜占庭系统的特点"><a href="#状态机拜占庭系统的特点" class="headerlink" title="状态机拜占庭系统的特点"></a>状态机拜占庭系统的特点</h4><p>状态机拜占庭系统的特点是整个系统共同维护一个状态,所有节点采取一致的行动,一般包括 3 种协议：一致性协议、 检查点协议和视图更换协议。系统正常运行在一致性协议和检查点协议下，视图更换协议则是只有在主节点出错或者运行缓慢的情况下才会启动，负责维系系统继续执行客户端请求的能力。</p><h4 id="状态机拜占庭系统的核心协议"><a href="#状态机拜占庭系统的核心协议" class="headerlink" title="状态机拜占庭系统的核心协议"></a>状态机拜占庭系统的核心协议</h4><h5 id="一、一致性协议"><a href="#一、一致性协议" class="headerlink" title="一、一致性协议"></a>一、一致性协议</h5><p>一致性协议的目标是使来自客户端的请求在每个服务器上都按照一个确定的顺序执行。在协议中，一般有一个服务器被称作主节点，负责将客户端的请求排序；其余的服务器称作从节点，按照主节点提供的顺序执行请求。所有的服务器都在相同的配置信息下工作，这个配置信息称作view，每更换一次主节点，view就会随之变化。</p><p>一致性协议至少包含3个阶段：发送请求、序号分配和返回结果。根据协议设计的不同，可能包含相互交互、序号确认等阶段。</p><p>一致性协议解决一致性的方法主要有：<br>1）服务器之间两两交互，服务器通过将自己获得的信息传递给其他的服务器；<br>2）由客户端收集服务器的信息，将收集的信息制作成证明文件再发送给服务器。对于一个包含3m+13m+1台服务器的拜占庭系统，需要收集到2m+12m+1台服务器发送的一致信息，才能保证达成一致的非拜占庭服务器数量大于拜占庭服务器数量。</p><p>引申思考： </p><ol><li>部署一个采用PBFT共识算法的区块链，至少需要几个节点呢？ </li><li>PBFT共识算法的区块链，最佳节点数量问题，采用PBFT共识算法的区块链系统节点数量的下限和上限？</li></ol><h5 id="二、检查点协议"><a href="#二、检查点协议" class="headerlink" title="二、检查点协议"></a>二、检查点协议</h5><p>拜占庭系统每执行一个请求，服务器需要记录日志。如果日志得不到及时的清理，就会导致系统资源被大量的日志所占用，影响系统性能及可用性。另一方面，由于拜占庭服务器的存在，一致性协议并不能保证每一台服务器都执行了相同的请求，所以，不同服务器状态可能不一致。例如，某些服务器可能由于网络延时导致从某个序号开始，之后的请求都没有执行。因此，拜占庭系统中设置周期性的检查点协议，将系统中的服务器同步到某一个相同的状态。因此，周期性的检查点协议可以定期地处理日志，节约资源，同时及时纠正服务器状态。</p><p>处理日志主要解决的问题就是区分那些日志可以清理，那些日志仍然需要保留。如果一个请求已经被m+1m+1台非拜占庭服务器执行，并且某一服务器ii能够向其他的服务器证明这一点，那么ii就可以将关于这个请求的日志删除。目前，协议普遍采用的方式是服务器每执行一定数量的请求，就将自己的状态发送给所有服务器并且执行一个该协议，如果某台服务器接收到2m+12m+1台服务器的状态，那么其中一致的部分就是至少有m+1m+1非拜占庭服务器经历过的状态，因此，这部分的日志就可以删除，同时将自己状态更新只较新状态。</p><h5 id="三、视图更换"><a href="#三、视图更换" class="headerlink" title="三、视图更换"></a>三、视图更换</h5><p>在一致性协议里，已经知道主节点在整个系统中拥有序号分配，请求转发等核心能力，支配着这个系统的运行行为。然而一旦主节点自身发生错误，就可能导致从节点接收到具有相同序号的不同请求，或者同一个请求被分配多个序号等问题，这将直接导致请求不能被正确执行。视图更换协议的作用就是在主节点不能继续履行职责时，将其用一个从节点替换掉，并且保证已经被非拜占庭服务器执行的请求不会被篡改。</p><p>视图更换协议一般有两种触发方式：<br>1）只由服务器触发，这一类触发方式中，判断服务器一致性是否达成的工作是由服务器自身负责，客户端不能从请求的整个执行过程中获得服务器运行状况的信息；<br>2）客户端触发，这一类触发方式中，客户端一般负责判断服务器是否达成一致，如果不达成一致，那么就能判断服务器运行出现问题，如果是主节点的问题就会要求服务器更换主节点。</p><p>视图更换协议需要解决的问题是如何保证已经被非拜占庭服务器执行的请求不被更改。由于系统达成一致性之后至少有m+1m+1台非拜占庭服务器执行了请求，所以目前采用的方法是：由新的主节点收集至少2m+12m+1台服务器的状态信息，这些状态信息中一定包含所有执行过的请求；然后，新主节点将这些状态信息发送给所有的服务器，服务器按照相同的原则将在上一个主节点完成的请求同步一遍.同步之后,所有的节点都处于相同的状态,这时就可以开始执行新的请求。</p><h4 id="实用拜占庭容错系统PBFT详解"><a href="#实用拜占庭容错系统PBFT详解" class="headerlink" title="实用拜占庭容错系统PBFT详解"></a>实用拜占庭容错系统PBFT详解</h4><p>实用拜占庭容错系统（Practical Byzantine Fault Tolerance，PBFT），是一类状态机拜占庭系统。</p><p>PBFT的一致性协议如下：PBFT系统通常假设故障节点数为mm个，而整个服务节点数为3m+13m+1个。每一个客户端的请求需要经过5个阶段，通过采用两次两两交互的方式在服务器达成一致之后再执行客户端的请求。由于客户端不能从服务器端获取任何服务器运行的状态信息，PBFT中主节点是否发生错误只能由服务器监测。如果服务器在一段时间内都不能完成客户端的请求，则会触发视图更换协议。 </p><p><img src="https://github.com/AlexBruceLu/DAPP/wiki/ddd.png" alt=""></p><p>上图显示了一个简化的PBFT的协议通信模式，其中CC为客户端，N0N0~N3N3表示服务节点，特别的，N0N0为主节点，N3N3为故障节点。整个协议的基本过程如下：<br>1）客户端发送请求，激活主节点的服务操作；<br>2）当主节点接收请求后，启动三阶段的协议以向各从节点广播请求；</p><p>序号分配阶段，主节点给请求赋值一个序号nn，广播序号分配消息和客户端的请求消息mm，并将构造pre-prepare消息给各从节点；<br>交互阶段，从节点接收pre-prepare消息，向其他服务节点广播prepare消息；<br>序号确认阶段，各节点对视图内的请求和次序进行验证后，广播commit消息，执行收到的客户端的请求并给客户端响应。<br>3）客户端等待来自不同节点的响应，若有m+1m+1个响应相同，则该响应即为运算的结果；</p><h3 id="Raft协议"><a href="#Raft协议" class="headerlink" title="Raft协议"></a>Raft协议</h3><p>Raft是在非拜占庭故障下达成共识的强一致协议。在区块链系统中，使用Raft实现记账共识的过程可以描述如下：首先选举一个leader，接着赋予leader完全的权利管理记账。leader从客户端接收记账请求，完成记账操作，生成区块，并复制到其他记账节点。有了leader简化了记账操作的管理。如果leader失效或与其他节点失去联系，这时，系统就会选出新的leader。</p><h4 id="Raft基础"><a href="#Raft基础" class="headerlink" title="Raft基础"></a>Raft基础</h4><p>一个Raft集群通常包含5个服务器，允许系统有2个故障服务器。每个服务器处于3个状态之一：leader、follower或candidate。正常操作状态下，仅有一个leader，其他的服务器均为follower。follower是被动的，不会对自身发出的请求而是对来自leader和candidate的请求做出响应。leader处理所有的客户端请求（若客户端联系follower，则该follower将转发给leader)。candidate状态用来选举leader。</p><p>Raft阶段主要分为两个，首先是leader选举过程，然后在选举出来的leader基础上进行正常操作，比如日志复制、记账等。</p><h4 id="leader选举"><a href="#leader选举" class="headerlink" title="leader选举"></a>leader选举</h4><p>当follower在选举超时时间内未收到leader的心跳消息，则转换为candidate状态。为了避免选举冲突，这个超时时间是一个150~300ms之间的随机数。</p><p>一般而言，在Raft系统中：<br>1）任何一个服务器都可以成为一个候选者candidate，它向其他服务器follower发出要求选举自己的请求。<br>2）其他服务器同意了，发出OK。如果在这个过程中，有一个follower宕机，没有收到请求选举的要求，此时候选者可以自己选自己，只要达到N/2+1N/2+1的大多数票，候选人还是可以成为leader。<br>3）这样这个候选者就成为了leader领导人，它可以向follower发出指令，比如进行记账。<br>4）以后可以通过心跳进行记账的通知。<br>5）一旦这个leader崩溃了，那么follower中有一个成为候选者，并发出邀票选举。<br>6）follower同意后，其成为leader，继续承担记账等指导工作。</p><h4 id="记账过程"><a href="#记账过程" class="headerlink" title="记账过程"></a>记账过程</h4><p>Raft的记账过程按以下步骤完成：<br>1）假设leader领导人已经选出，这时客户端发出增加一个日志的要求；<br>2）leader要求follower遵从他的指令，都将这个新的日志内容追加到他们各自日志中；<br>3）大多数follower服务器将交易记录写入账本后，确认追加成功，发出确认成功消息；<br>4）在下一个心跳中，leader会通知所有follower更新确认的项目。<br>对于每个新的交易记录，重复上述过程。</p><p>如果在这一过程中，发生了网络通信故障，使得leader不能访问大多数follower，那么leader只能正常更新它能访问的那些follower服务器。而大多数的服务器follower因为没有了leader，它们将重新选举一个候选者作为leader，然后这个leader作为代表与外界打交道，如果外界要求其添加新的交易记录，这个新的leader就按上述步骤通知大多数follower，如果这时网络故障修复了，那么原先的leader就变成follower，在失联阶段，这个老leader的任何更新都不能算确认，都回滚，接收新的leader的新更新。</p><p>如果想更直观的理解Raft协议，可以看动画演示。<br>论文原文：In Search of an Understandable Consensus Algorithm<br>学习参考：The Raft Consensus Algorithm</p><h2 id="PoW"><a href="#PoW" class="headerlink" title="PoW"></a>PoW</h2><p>PoW的原理可参看这篇博文中哈希函数难题友好性这一节：<a href="http://blog.csdn.net/s_lisheng/article/details/77937202，理解了难题友好性，就基本理解了PoW机制的原理。结合比特币去理解PoW。比特币PoW的过程，就是将不同的nonce值作为输入，尝试进行SHA256哈希运算，找出满足给定数量前导0的哈希值的过程。要求的前导0的个数越多，代表难度越大。比特币节点求解工作量证明问题的步骤归纳如下：" target="_blank" rel="noopener">http://blog.csdn.net/s_lisheng/article/details/77937202，理解了难题友好性，就基本理解了PoW机制的原理。结合比特币去理解PoW。比特币PoW的过程，就是将不同的nonce值作为输入，尝试进行SHA256哈希运算，找出满足给定数量前导0的哈希值的过程。要求的前导0的个数越多，代表难度越大。比特币节点求解工作量证明问题的步骤归纳如下：</a></p><p>1）生成铸币交易，并与其他所有准备打包进区块的交易组成交易列表，通过Merkle树算法生成Merkle跟哈希；<br>2）把Merkle根哈希及其他相关字段组装成区块头，将区块头的80字节数据作为工作量证明的输入；<br>3）不停地变更区块头中的随机数nonce，并对每次变更后的区块头做双重SHA256运算，将结果值与当前网络的目标难度做比对，如果满足难度条件，则解题成功，工作量证明完成。</p><h2 id="PoS"><a href="#PoS" class="headerlink" title="PoS"></a>PoS</h2><p>PoW存在以下弊端：</p><p>矿池的出现，一定程度上违背了去中心化的初衷，同时也使得51%攻击成为可能，影响其安全性。<br>PoW存在巨大的算力浪费，看看矿池用掉多少电就知道了。<br>PoS（权益证明，Proof of Stake）的出现很大程度上是因为PoW的缺陷而提出的。采用PoS的币中不同币的PoS不完全相同，权益证明要求用户证明拥有某些数量的货币（即对货币的权益），下面以点点币为例，理解PoS的思想。</p><p>点点币在SHA-256的哈希运算的难度方便引入了币龄的概念，使得难度与交易输入的币龄成反比。在点点币中，币龄被定义为币的数量与币所拥有的天数的乘积。点点币的权益证明机制结合了随机化与币龄的概念，未使用至少30天的币可以参与竞争下一区块，越久和越大的币集有更大的可能去签名下一区块。而一旦币的权益被用于签名一个区块，则币龄将清为零，这样必须等待至少30日才能签署另一个区块。同时，为防止非常老或非常大的权益控制区块链，寻找下一区块的最大概率在90天后达到最大值，这一过程保护了网络，并随着时间逐渐成为新的币而无需消耗大量的计算能力。</p><h2 id="DPoS"><a href="#DPoS" class="headerlink" title="DPoS"></a>DPoS</h2><p>PoS机制虽然考虑了PoW的不足，但也有缺点：依据权益结余来选择，会导致首富账户的权力更大，有可能支配记账权。股份授权证明机制（Delegated Proof of Stake，DPoS），是对PoW、PoS不足的提出的。下面以比特股为例，理解DPoS的思想。</p><p>比特股引入了见证人这个概念，见证人可以生成区块，每一个持有比特股的人都可以投票选举见证人。得到总同意票数中的前NN个（NN通常定义为101）候选者可以当选为见证人，当选见证人的个数需满足：至少一半的参与投票者相信NN已经充分地去中心化。见证人的候选名单每个维护周期（1天）更新一次。见证人然后随机排列，每个见证人按序有2秒的权限时间生成区块，若见证人在给定的时间片不能生成区块，区块生成权限交给下一时间片对应的见证人。如果见证人提供的算力不稳定或计算机宕机等，持股人可以随时通过投票更换这些见证人。</p><p>可以看到，其核心思想是通过缩小参与核心共识过程的节点数量，以提高共识效率。（这里可以认为选举见证人的过程为非核心共识过程，而见证人按序生成区块可以认为是核心共识过程）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt; 常见的共识算法：&lt;/strong&gt; &lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;/excerpt&gt;&lt;/p&gt;
&lt;p&gt;PoS、PoW、DPoS&lt;/p&gt;
    
    </summary>
    
      <category term="others" scheme="https://alexbrucelu.github.io/categories/others/"/>
    
    
      <category term="共识算法" scheme="https://alexbrucelu.github.io/tags/%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数据结构入门</title>
    <link href="https://alexbrucelu.github.io/2018/12/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>https://alexbrucelu.github.io/2018/12/09/数据结构/</id>
    <published>2018-12-09T06:55:49.216Z</published>
    <updated>2018-12-09T11:11:30.466Z</updated>
    
    <content type="html"><![CDATA[<p><strong> 数据结构入门：</strong> <excerpt in="" index="" |="" 首页摘要=""></excerpt></p><p>常见的数据结构基础</p><a id="more"></a><h2 id="数据结构基础理论"><a href="#数据结构基础理论" class="headerlink" title="数据结构基础理论"></a>数据结构基础理论</h2><h3 id="什么是数据？"><a href="#什么是数据？" class="headerlink" title="什么是数据？"></a>什么是数据？</h3><p>数据：是描述客观事物的符号，是计算机中可以操作的对象，是能被计算机识别，并输入给计算机处理的符号集合。数据不仅仅包括整型、实型等数值类型，还包括字符及声音、图像、视频等非数值类型。 </p><h3 id="数据结构的概念"><a href="#数据结构的概念" class="headerlink" title="数据结构的概念"></a>数据结构的概念</h3><p>数据结构是计算机存储、组织数据的方式。数据结构是指相互之间存在一种或多种特定关系的数据元素的集合。通常情况下，精心选择的数据结构可以带来更高的运行或者存储效率。数据结构往往同高效的检索算法和索引技术有关。 </p><blockquote><font color="red">数据结构是计算机存储、组织数据的方式。是相互之间存在一种或多种特定关系的数据元素集合 </font></blockquote><h3 id="算法的概念"><a href="#算法的概念" class="headerlink" title="算法的概念"></a>算法的概念</h3><p>算法：<font color="red">特定问题求解不走的描述，</font>在计算机中表现为<strong>指令的有限序列</strong>，算法是独立存在的一种解决问题的方法和思想。<strong>对于算法来说，语言不重要，重要的是思想。</strong></p><h4 id="算法和数据结构的区别"><a href="#算法和数据结构的区别" class="headerlink" title="算法和数据结构的区别"></a>算法和数据结构的区别</h4><p>数据结构只是静态的描述了数据元素之间的关系，高效的程序需要在数据结构的基础上设计和选择算法。</p><ul><li><font color="red">算法是为了解决实际问题而设计的</font></li><li><font color="red">数据结构是算法需要处理的问题的载体</font></li><li>数据结构与算法相符相成</li></ul><h4 id="算法的比较"><a href="#算法的比较" class="headerlink" title="算法的比较"></a>算法的比较</h4><p>假设求解1 + 2 + … + 100 的结果，写程序会怎么写</p><ul><li><p><strong>方法一：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sum := <span class="number">0</span></span><br><span class="line">n := <span class="number">100</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">    sum += i</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"%d"</span>,sum)</span><br></pre></td></tr></table></figure></li><li><p><strong>方法二：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sum := <span class="number">0</span></span><br><span class="line">n := <span class="number">100</span></span><br><span class="line">sum = (<span class="number">1</span> + n) * n / <span class="number">2</span></span><br><span class="line">fmt.Println(<span class="string">"%d"</span>,sum)</span><br></pre></td></tr></table></figure></li></ul><p><strong>上述两段代码，第二种算法会比较高效，这就是一个好的算法对程序高效性的体现。</strong></p><h4 id="算法的特性"><a href="#算法的特性" class="headerlink" title="算法的特性"></a>算法的特性</h4><p>算法的五大基本特性：<strong>输入、输出、有穷性、确定性和可行性。</strong></p><p><strong>输入、输出：</strong>算法具有零个或多个输入，至少有一个或多个输出。</p><p><strong>有穷性：</strong>指算法在执行有限的步骤之后，自动结束而不会出现无限循环，并且每一个步骤在可接受的时间内完成。</p><p><strong>确定性：</strong>算法的每一步骤都有确定的含义，不会出现二义性。</p><p><strong>可行性：</strong>算法的每一步都必须是可行的，换言之，每一步都能通过执行有限次数完成。</p><h3 id="数据结构分类"><a href="#数据结构分类" class="headerlink" title="数据结构分类"></a>数据结构分类</h3><p>按照视点的不同，可以把数据结构分为<strong>逻辑结构、物理结构。</strong></p><h4 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h4><h5 id="集合结构"><a href="#集合结构" class="headerlink" title="集合结构"></a>集合结构</h5><p>集合结构中的数据元素除了同属于一个集合外，它们本身之间并没有关系。各个数据元素是平等的。它们共同属于同一个集合，数据结构中的集合关系类似于数学中的集合，如下图：</p><p><img src="https://github.com/AlexBruceLu/DAPP/wiki/data1.png" alt=""></p><h5 id="线性结构"><a href="#线性结构" class="headerlink" title="线性结构"></a>线性结构</h5><p>线性结构中的数据元素之间是一一对应关系。如下图：</p><p><img src="https://github.com/AlexBruceLu/DAPP/wiki/data2.png" alt=""></p><h5 id="树形结构"><a href="#树形结构" class="headerlink" title="树形结构"></a>树形结构</h5><p>树形结构中是数据元素之间存在一种一对多的层次关系，如下图：</p><p><img src="https://github.com/AlexBruceLu/DAPP/wiki/data3.png" alt=""></p><h5 id="图形结构"><a href="#图形结构" class="headerlink" title="图形结构"></a>图形结构</h5><p>图形结构中的数据元素之间是存在多对多的关系，如图：</p><p><img src="https://github.com/AlexBruceLu/DAPP/wiki/data4.png" alt=""></p><h4 id="物理结构"><a href="#物理结构" class="headerlink" title="物理结构"></a>物理结构</h4><p><strong>物理结构：</strong>是指数据的逻辑结构在计算机中的存储形式，共分为两种：顺序存储和链式存储。</p><h5 id="顺序存储"><a href="#顺序存储" class="headerlink" title="顺序存储"></a>顺序存储</h5><p>是把数据元素存放在地址连续的存储单元里，其数据的逻辑关系和物理关系是一致的，如图：</p><p><img src="https://github.com/AlexBruceLu/DAPP/wiki/data5.png" alt=""></p><blockquote><p>如果所有的数据结构都很简单且有规律，就比较易于操作。可往往实际情况，数据结构中的元素总会遇到增、删、改、查的操作。面对市场变化的数据结构，运用以上顺序存储是不科学的。</p></blockquote><h5 id="链式存储"><a href="#链式存储" class="headerlink" title="链式存储"></a>链式存储</h5><p>是把数据元素存放在任意的存储单元里，这组存储单元可以是连续的，也可以是不连续的。数据存储的关系并不能反映其逻辑关系，因此需要用一个指针存放数据元素的地址，这样通过地址就可以找到相关数据的位置，如下图：</p><p><img src="https://github.com/AlexBruceLu/DAPP/wiki/data6.png" alt=""></p><h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><h3 id="线性表基础概念"><a href="#线性表基础概念" class="headerlink" title="线性表基础概念"></a>线性表基础概念</h3><p>线性表是一种最简单的且常用的数据结构。数据结构的基本特点是节点之间满足线性关系。动态数组、栈、队列都属于线性结构。它们的共同之处，是节点中有且只有一个开始节点和终端节点。这种关系，可以把它们的所有节点排成一个线性序列。但是，它们分别属于几种不同的抽象数据类型实现，它们之间的区别，主要就是操作的不同。</p><p>线性表是零个或多个数据元素的有限序列，数据元素之间是有顺序的，数据元素个数是有限的，数据元素的类型必须相同。</p><p><img src="https://github.com/AlexBruceLu/DAPP/wiki/data7.png" alt=""></p><p>线性表的性质：</p><ul><li><p>a0 为线性表的第一个元素，只有一个后继；</p></li><li><p>an 为线性表的最后一个元素，只有一个前驱；</p></li><li><p>除了 a0 和 an 外的其他元素 ai ，既有一个前驱又有一个后继；</p></li><li><p>线性表能够逐项访问和顺序存取；</p><blockquote><p><strong>线性表的抽象数据类型定义：</strong> </p><p>ADT 线性表（ List） </p><p>Data<br>线性表的数据对象集合为{ a0, a1, ……, an }，每个元素的类型均为 DataType。其中，除第一个元素 a0外，每个元素有且只有一个直接前驱元素，除了最后一个元素 an 外，每个元素有且只有一个直接后继元素。数据元素之间的关系是一一对应的。 </p><p>peration（操作）<br>// 初始化，建立一个空的线性表 L。<br>InitList(*L);<br>// 若线性表为空，返回 true，否则返回 false<br>ListEmpty(L);<br>// 将线性表清空 </p><p>ClearList(<em>L);<br>// 将线性表 L 中的第 i 个位置的元素返回给 e<br>GetElem(L, i, </em>e);<br>// 在线性表 L 中的第 i 个位置插入新元素 e<br>ListInsert(<em>L, i, e);<br>// 删除线性表 L 中的第 i 个位置元素，并用 e 返回其值<br>ListDelete(</em>L, i, <em>e);<br>// 返回线性表 L 的元素个数<br>ListLength(L);<br>// 销毁线性表<br>DestroyList(</em>L); </p></blockquote></li></ul><h3 id="线性表的顺序存储"><a href="#线性表的顺序存储" class="headerlink" title="线性表的顺序存储"></a>线性表的顺序存储</h3><p>通常线性表可以采用顺序存储和链式存储。</p><p>采用顺序存储是表示线性表最简单的方法，具体做法是：将线性表中的元素一个接一个的存储在一块连续的存储区域中，这种顺序表示的线性表也称为顺序表。</p><h4 id="线性表顺内需存储（动态数组）的设计与实现"><a href="#线性表顺内需存储（动态数组）的设计与实现" class="headerlink" title="线性表顺内需存储（动态数组）的设计与实现"></a>线性表顺内需存储（动态数组）的设计与实现</h4><font color="red"><strong>操作要点：</strong></font><ul><li><p>插入元素操作</p><ul><li>判断线性表是否合法</li><li>判断插入位置是否合法</li><li>判断空间是否满足</li><li>把最后一个与元素到插入位置的元素后移一位</li><li>将新元素插入</li><li>线性表长度加1</li></ul></li><li><p>获取元素操作</p><ul><li>判断线性表是否合法</li><li>判断位置是否合法</li><li>直接通过元素的下表方式获取元素</li></ul></li><li><p>删除元素的操作</p><ul><li>判断线性表是否合法</li><li>判断删除位置是否合法</li><li>将元素取出</li><li>将删除位置后的元素分别向前移动一个位置</li><li>线性表长度减1</li></ul></li><li><p>元素的插入</p><p><img src="![](https://github.com/AlexBruceLu/DAPP/wiki/data8.png" alt=""></p></li><li><p>元素的删除</p><p><img src="![](https://github.com/AlexBruceLu/DAPP/wiki/data9.png" alt=""></p><p><font color="red"><strong>注意：</strong></font>链表的容量和链表的长度是两个不同的概念</p></li></ul><h4 id="优点和缺点"><a href="#优点和缺点" class="headerlink" title="优点和缺点"></a>优点和缺点</h4><font color="red"><strong>优点</strong></font><ul><li>无需为线性表中的逻辑关系增加额外的空间</li><li>可以快速的获取表中合法位置的元素</li></ul><font color="red"><strong>缺点</strong></font><ul><li>插入和删除操作需要移动大量的元素</li></ul><h3 id="线性表的链式存储"><a href="#线性表的链式存储" class="headerlink" title="线性表的链式存储"></a>线性表的链式存储</h3><p>链表为了表示每个元素与其直接后继元素之间的逻辑关系，每个元素除了存储本身的信息外，还需要存储指示其直接后继的信息。</p><p><img src="![](https://github.com/AlexBruceLu/DAPP/wiki/data10.png" alt=""></p><ul><li><p>单链表</p><ul><li><p>线性表的链式存储结构中，每个节点中只包含一个指针域，这样的链表叫做单链表</p></li><li><p>通过每个节点的指针域将线性表的数据元素按其逻辑次序链接在一起</p><p><img src="![](https://github.com/AlexBruceLu/DAPP/wiki/data11.png" alt=""></p></li></ul></li><li><p>概念解释</p><ul><li><p>表头节点</p><ul><li>链表中的第一个节点，包含指向第一个数据元素的指针以及链表自身的一些信息</li></ul></li><li><p>数据节点</p><ul><li>链表中代表数据元素的节点，包含指向下一个数据元素的指针和数据元素的信息</li></ul></li><li><p>尾节点</p><ul><li>链表中的最后一个数据节点，下一个元素指针为空，表示无后继元素</li></ul><p><img src="https://github.com/AlexBruceLu/DAPP/wiki/data12.png" alt=""></p></li></ul></li></ul><h4 id="线性表的链式存储（单项链表）的设计与实现"><a href="#线性表的链式存储（单项链表）的设计与实现" class="headerlink" title="线性表的链式存储（单项链表）的设计与实现"></a>线性表的链式存储（单项链表）的设计与实现</h4><ul><li><p><strong>插入操作</strong></p><p><img src="https://github.com/AlexBruceLu/DAPP/wiki/data13.png" alt=""></p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node -&gt; next = current -&gt; next;</span><br><span class="line">current -&gt; next = node;</span><br></pre></td></tr></table></figure><ul><li><p>删除操作</p><p><img src="https://github.com/AlexBruceLu/DAPP/wiki/data14.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">current-&gt;next = ret-&gt;next;</span><br></pre></td></tr></table></figure></li></ul><h4 id="优点和缺点-1"><a href="#优点和缺点-1" class="headerlink" title="优点和缺点"></a>优点和缺点</h4><ul><li><font color="red"><strong>优点</strong></font><ul><li>无需一次性定制链表的容量 </li><li>插入和删除操作无需移动数据元素 </li></ul></li><li><font color="red"><strong>缺点</strong></font><ul><li>数据元素必须保存后继元素的位置信息 </li><li>获取指定数据的元素操作需要顺序访问之前的元素 </li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt; 数据结构入门：&lt;/strong&gt; &lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;/excerpt&gt;&lt;/p&gt;
&lt;p&gt;常见的数据结构基础&lt;/p&gt;
    
    </summary>
    
      <category term="others" scheme="https://alexbrucelu.github.io/categories/others/"/>
    
    
      <category term="数据结构" scheme="https://alexbrucelu.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>详解TCP/IP协议</title>
    <link href="https://alexbrucelu.github.io/2018/12/05/%E8%AF%A6%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE/"/>
    <id>https://alexbrucelu.github.io/2018/12/05/详解TCPIP协议/</id>
    <published>2018-12-05T08:22:37.467Z</published>
    <updated>2018-12-06T06:28:08.072Z</updated>
    
    <content type="html"><![CDATA[<p><strong> 详解TCP/IP协议：</strong> <excerpt in="" index="" |="" 首页摘要=""></excerpt></p><p>TCP/IP网络协议的详解概述</p><a id="more"></a><p>[TOC]</p><p><img src="https://upload-images.jianshu.io/upload_images/1856419-168b63033e3a808d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp" alt="img"></p><h3 id="计算机网络体系结构分层"><a href="#计算机网络体系结构分层" class="headerlink" title="计算机网络体系结构分层"></a>计算机网络体系结构分层</h3><p><img src="https:////upload-images.jianshu.io/upload_images/1856419-efd361484c60d785.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/581/format/webp" alt="img"></p><p>计算机网络体系结构分层</p><p><img src="https:////upload-images.jianshu.io/upload_images/1856419-c69d60eeeebadd37.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp" alt="img"></p><p>计算机网络体系结构分层</p><p>不难看出，TCP/IP 与 OSI 在分层模块上稍有区别。OSI 参考模型注重“通信协议必要的功能是什么”，而 TCP/IP 则更强调“在计算机上实现协议应该开发哪种程序”。</p><h3 id="TCP-IP-基础"><a href="#TCP-IP-基础" class="headerlink" title="TCP/IP 基础"></a>TCP/IP 基础</h3><h4 id="TCP-IP-的具体含义"><a href="#TCP-IP-的具体含义" class="headerlink" title="TCP/IP 的具体含义"></a>TCP/IP 的具体含义</h4><p>从字面意义上讲，有人可能会认为 TCP/IP 是指 TCP 和 IP 两种协议。实际生活当中有时也确实就是指这两种协议。然而在很多情况下，它只是利用 IP 进行通信时所必须用到的协议群的统称。具体来说，IP 或 ICMP、TCP 或 UDP、TELNET 或 FTP、以及 HTTP 等都属于 TCP/IP 协议。他们与 TCP 或 IP 的关系紧密，是互联网必不可少的组成部分。TCP/IP 一词泛指这些协议，因此，有时也称 TCP/IP 为网际协议群。<br> 互联网进行通信时，需要相应的网络协议，TCP/IP 原本就是为使用互联网而开发制定的协议族。因此，互联网的协议就是 TCP/IP，TCP/IP 就是互联网的协议。</p><p><img src="https:////upload-images.jianshu.io/upload_images/1856419-ca4aba22c1f7a217.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/768/format/webp" alt="img"></p><p>网际协议群</p><h4 id="数据包"><a href="#数据包" class="headerlink" title="数据包"></a>数据包</h4><p><strong>包、帧、数据包、段、消息</strong><br> 以上五个术语都用来表述数据的单位，大致区分如下：</p><ul><li>包可以说是全能性术语；</li><li>帧用于表示数据链路层中包的单位；</li><li>数据包是 IP 和 UDP 等网络层以上的分层中包的单位；</li><li>段则表示 TCP 数据流中的信息；</li><li>消息是指应用协议中数据的单位。</li></ul><p>每个分层中，都会对所发送的数据附加一个首部，在这个首部中包含了该层必要的信息，如发送的目标地址以及协议相关信息。通常，为协议提供的信息为包首部，所要发送的内容为数据。在下一层的角度看，从上一层收到的包全部都被认为是本层的数据。</p><p><img src="https:////upload-images.jianshu.io/upload_images/1856419-dfd044f1ccc5c752.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/560/format/webp" alt="img"></p><p>数据包首部</p><p>网络中传输的数据包由两部分组成：一部分是协议所要用到的首部，另一部分是上一层传过来的数据。首部的结构由协议的具体规范详细定义。在数据包的首部，明确标明了协议应该如何读取数据。反过来说，看到首部，也就能够了解该协议必要的信息以及所要处理的数据。<strong>包首部就像协议的脸。</strong></p><h4 id="数据处理流程"><a href="#数据处理流程" class="headerlink" title="数据处理流程"></a>数据处理流程</h4><p>下图以用户 a 向用户 b 发送邮件为例子：</p><p><img src="https:////upload-images.jianshu.io/upload_images/1856419-2051967a4e85d719.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/772/format/webp" alt="img"></p><p>数据处理流程</p><ul><li>① 应用程序处理<br> 首先应用程序会进行编码处理，这些编码相当于 OSI 的表示层功能；<br> 编码转化后，邮件不一定马上被发送出去，这种何时建立通信连接何时发送数据的管理功能，相当于 OSI 的会话层功能。</li><li>② TCP 模块的处理<br> TCP 根据应用的指示，负责建立连接、发送数据以及断开连接。TCP 提供将应用层发来的数据顺利发送至对端的可靠传输。为了实现这一功能，需要在应用层数据的前端附加一个 TCP 首部。</li><li>③ IP 模块的处理<br> IP 将 TCP 传过来的 TCP 首部和 TCP 数据合起来当做自己的数据，并在 TCP 首部的前端加上自己的 IP 首部。IP 包生成后，参考路由控制表决定接受此 IP 包的路由或主机。</li><li>④ 网络接口（以太网驱动）的处理<br> 从 IP 传过来的 IP 包对于以太网来说就是数据。给这些数据附加上以太网首部并进行发送处理，生成的以太网数据包将通过物理层传输给接收端。</li><li>⑤ 网络接口（以太网驱动）的处理<br> 主机收到以太网包后，首先从以太网包首部找到 MAC 地址判断是否为发送给自己的包，若不是则丢弃数据。<br> 如果是发送给自己的包，则从以太网包首部中的类型确定数据类型，再传给相应的模块，如 IP、ARP 等。这里的例子则是 IP 。</li><li>⑥ IP 模块的处理<br> IP 模块接收到 数据后也做类似的处理。从包首部中判断此 IP 地址是否与自己的 IP 地址匹配，如果匹配则根据首部的协议类型将数据发送给对应的模块，如 TCP、UDP。这里的例子则是 TCP。<br> 另外吗，对于有路由器的情况，接收端地址往往不是自己的地址，此时，需要借助路由控制表，在调查应该送往的主机或路由器之后再进行转发数据。</li><li>⑦ TCP 模块的处理<br> 在 TCP 模块中，首先会计算一下校验和，判断数据是否被破坏。然后检查是否在按照序号接收数据。最后检查端口号，确定具体的应用程序。数据被完整地接收以后，会传给由端口号识别的应用程序。</li><li>⑧ 应用程序的处理<br> 接收端应用程序会直接接收发送端发送的数据。通过解析数据，展示相应的内容。</li></ul><h3 id="传输层中的-TCP-和-UDP"><a href="#传输层中的-TCP-和-UDP" class="headerlink" title="传输层中的 TCP 和 UDP"></a>传输层中的 TCP 和 UDP</h3><p>TCP/IP 中有两个具有代表性的传输层协议，分别是 TCP 和 UDP。</p><ul><li>TCP 是面向连接的、可靠的流协议。流就是指不间断的数据结构，当应用程序采用 TCP 发送消息时，虽然可以保证发送的顺序，但还是犹如没有任何间隔的数据流发送给接收端。TCP 为提供可靠性传输，实行“顺序控制”或“重发控制”机制。此外还具备“流控制（流量控制）”、“拥塞控制”、提高网络利用率等众多功能。</li><li>UDP 是不具有可靠性的数据报协议。细微的处理它会交给上层的应用去完成。在 UDP 的情况下，虽然可以确保发送消息的大小，却不能保证消息一定会到达。因此，应用有时会根据自己的需要进行重发处理。</li><li>TCP 和 UDP 的优缺点无法简单地、绝对地去做比较：TCP 用于在传输层有必要实现可靠传输的情况；而在一方面，UDP 主要用于那些对高速传输和实时性有较高要求的通信或广播通信。TCP 和 UDP 应该根据应用的目的按需使用。</li></ul><h4 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h4><p>数据链路和 IP 中的地址，分别指的是 MAC 地址和 IP 地址。前者用来识别同一链路中不同的计算机，后者用来识别 TCP/IP  网络中互连的主机和路由器。在传输层也有这种类似于地址的概念，那就是端口号。端口号用来识别同一台计算机中进行通信的不同应用程序。因此，它也被称为程序地址。</p><h5 id="根据端口号识别应用"><a href="#根据端口号识别应用" class="headerlink" title="根据端口号识别应用"></a>根据端口号识别应用</h5><p>一台计算机上同时可以运行多个程序。传输层协议正是利用这些端口号识别本机中正在进行通信的应用程序，并准确地将数据传输。</p><p><img src="https:////upload-images.jianshu.io/upload_images/1856419-aee529e8e598ec48.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500/format/webp" alt="img"></p><p>通过端口号识别应用</p><h5 id="通过-IP-地址、端口号、协议号进行通信识别"><a href="#通过-IP-地址、端口号、协议号进行通信识别" class="headerlink" title="通过 IP 地址、端口号、协议号进行通信识别"></a>通过 IP 地址、端口号、协议号进行通信识别</h5><ul><li>仅凭目标端口号识别某一个通信是远远不够的。</li></ul><p><img src="https:////upload-images.jianshu.io/upload_images/1856419-96457c6ddbe3157f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/763/format/webp" alt="img"></p><p><img src="https:////upload-images.jianshu.io/upload_images/1856419-47a50ea9428c29fc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/748/format/webp" alt="img"></p><p>通过端口号、IP地址、协议号进行通信识别</p><ul><li>① 和② 的通信是在两台计算机上进行的。它们的目标端口号相同，都是80。这里可以根据源端口号加以区分。</li><li>③ 和 ① 的目标端口号和源端口号完全相同，但它们各自的源 IP 地址不同。</li><li>此外，当 IP 地址和端口号全都一样时，我们还可以通过协议号来区分（TCP 和 UDP）。</li></ul><h5 id="端口号的确定"><a href="#端口号的确定" class="headerlink" title="端口号的确定"></a>端口号的确定</h5><ul><li>标准既定的端口号：这种方法也叫静态方法。它是指每个应用程序都有其指定的端口号。但并不是说可以随意使用任何一个端口号。例如 HTTP、FTP、TELNET 等广为使用的应用协议中所使用的端口号就是固定的。这些端口号被称为知名端口号，分布在 0~1023 之间；除知名端口号之外，还有一些端口号被正式注册，它们分布在 1024~49151 之间，不过这些端口号可用于任何通信用途。</li><li>时序分配法：服务器有必要确定监听端口号，但是接受服务的客户端没必要确定端口号。在这种方法下，客户端应用程序完全可以不用自己设置端口号，而全权交给操作系统进行分配。动态分配的端口号范围在 49152~65535 之间。</li></ul><h5 id="端口号与协议"><a href="#端口号与协议" class="headerlink" title="端口号与协议"></a>端口号与协议</h5><ul><li>端口号由其使用的传输层协议决定。因此，不同的传输层协议可以使用相同的端口号。</li><li>此外，那些知名端口号与传输层协议并无关系。只要端口一致都将分配同一种应用程序进行处理。</li></ul><h4 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h4><ul><li>UDP 不提供复杂的控制机制，利用 IP 提供面向无连接的通信服务。</li><li>并且它是将应用程序发来的数据在收到的那一刻，立即按照原样发送到网络上的一种机制。即使是出现网络拥堵的情况，UDP 也无法进行流量控制等避免网络拥塞行为。</li><li>此外，传输途中出现丢包，UDP 也不负责重发。</li><li>甚至当包的到达顺序出现乱序时也没有纠正的功能。</li><li>如果需要以上的细节控制，不得不交由采用 UDP 的应用程序去处理。</li><li>UDP 常用于一下几个方面：1.包总量较少的通信（DNS、SNMP等）；2.视频、音频等多媒体通信（即时通信）；3.限定于 LAN 等特定网络中的应用通信；4.广播通信（广播、多播）。</li></ul><h4 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h4><ul><li>TCP 与 UDP 的区别相当大。它充分地实现了数据传输时各种控制功能，可以进行丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。而这些在 UDP 中都没有。</li><li>此外，TCP 作为一种面向有连接的协议，只有在确认通信对端存在时才会发送数据，从而可以控制通信流量的浪费。</li><li>根据 TCP 的这些机制，在 IP 这种无连接的网络上也能够实现高可靠性的通信（ 主要通过检验和、序列号、确认应答、重发控制、连接管理以及窗口控制等机制实现）。</li></ul><h5 id="三次握手（重点）"><a href="#三次握手（重点）" class="headerlink" title="三次握手（重点）"></a>三次握手（重点）</h5><ul><li>TCP 提供面向有连接的通信传输。面向有连接是指在数据通信开始之前先做好两端之间的准备工作。</li><li>所谓三次握手是指建立一个 TCP 连接时需要客户端和服务器端总共发送三个包以确认连接的建立。在socket编程中，这一过程由客户端执行connect来触发。</li></ul><p>下面来看看三次握手的流程图：</p><p><img src="https:////upload-images.jianshu.io/upload_images/1856419-52baa0818e1bd1c1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/602/format/webp" alt="img"></p><p>三次握手</p><ul><li>第一次握手：客户端将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给服务器端，客户端进入SYN_SENT状态，等待服务器端确认。</li><li>第二次握手：服务器端收到数据包后由标志位SYN=1知道客户端请求建立连接，服务器端将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给客户端以确认连接请求，服务器端进入SYN_RCVD状态。</li><li>第三次握手：客户端收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给服务器端，服务器端检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，客户端和服务器端进入ESTABLISHED状态，完成三次握手，随后客户端与服务器端之间可以开始传输数据了。</li></ul><h5 id="四次挥手（重点）"><a href="#四次挥手（重点）" class="headerlink" title="四次挥手（重点）"></a>四次挥手（重点）</h5><ul><li>四次挥手即终止TCP连接，就是指断开一个TCP连接时，需要客户端和服务端总共发送4个包以确认连接的断开。在socket编程中，这一过程由客户端或服务端任一方执行close来触发。</li><li>由于TCP连接是全双工的，因此，每个方向都必须要单独进行关闭，这一原则是当一方完成数据发送任务后，发送一个FIN来终止这一方向的连接，收到一个FIN只是意味着这一方向上没有数据流动了，即不会再收到数据了，但是在这个TCP连接上仍然能够发送数据，直到这一方向也发送了FIN。首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭。</li></ul><p>下面来看看四次挥手的流程图：</p><p><img src="https:////upload-images.jianshu.io/upload_images/1856419-8787d7fb9fc4e802.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/596/format/webp" alt="img"></p><p>四次挥手</p><ul><li>中断连接端可以是客户端，也可以是服务器端。</li><li>第一次挥手：客户端发送一个FIN=M，用来关闭客户端到服务器端的数据传送，客户端进入FIN_WAIT_1状态。意思是说”我客户端没有数据要发给你了”，但是如果你服务器端还有数据没有发送完成，则不必急着关闭连接，可以继续发送数据。</li><li>第二次挥手：服务器端收到FIN后，先发送ack=M+1，告诉客户端，你的请求我收到了，但是我还没准备好，请继续你等我的消息。这个时候客户端就进入FIN_WAIT_2 状态，继续等待服务器端的FIN报文。</li><li>第三次挥手：当服务器端确定数据已发送完成，则向客户端发送FIN=N报文，告诉客户端，好了，我这边数据发完了，准备好关闭连接了。服务器端进入LAST_ACK状态。</li><li>第四次挥手：客户端收到FIN=N报文后，就知道可以关闭连接了，但是他还是不相信网络，怕服务器端不知道要关闭，所以发送ack=N+1后进入TIME_WAIT状态，如果Server端没有收到ACK则可以重传。服务器端收到ACK后，就知道可以断开连接了。客户端等待了2MSL后依然没有收到回复，则证明服务器端已正常关闭，那好，我客户端也可以关闭连接了。最终完成了四次握手。</li></ul><p><strong>上面是一方主动关闭，另一方被动关闭的情况，实际中还会出现同时发起主动关闭的情况，</strong><br> 具体流程如下图：</p><p><img src="https:////upload-images.jianshu.io/upload_images/1856419-baf89c213c19d3bd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/619/format/webp" alt="img"></p><p>同时挥手</p><h5 id="通过序列号与确认应答提高可靠性"><a href="#通过序列号与确认应答提高可靠性" class="headerlink" title="通过序列号与确认应答提高可靠性"></a>通过序列号与确认应答提高可靠性</h5><ul><li>在 TCP 中，当发送端的数据到达接收主机时，接收端主机会返回一个已收到消息的通知。这个消息叫做确认应答（ACK）。当发送端将数据发出之后会等待对端的确认应答。如果有确认应答，说明数据已经成功到达对端。<strong>反之，则数据丢失的可能性很大</strong>。</li><li>在一定时间内没有等待到确认应答，发送端就可以认为数据已经丢失，并进行重发。由此，即使产生了丢包，仍然能够保证数据能够到达对端，实现可靠传输。</li><li>未收到确认应答并不意味着数据一定丢失。也有可能是数据对方已经收到，只是返回的确认应答在途中丢失。这种情况也会导致发送端误以为数据没有到达目的地而重发数据。</li><li>此外，也有可能因为一些其他原因导致确认应答延迟到达，在源主机重发数据以后才到达的情况也屡见不鲜。此时，源主机只要按照机制重发数据即可。</li><li>对于目标主机来说，反复收到相同的数据是不可取的。为了对上层应用提供可靠的传输，目标主机必须放弃重复的数据包。为此我们引入了序列号。</li><li><strong>序列号是按照顺序给发送数据的每一个字节（8位字节）都标上号码的编号。接收端查询接收数据 TCP 首部中的序列号和数据的长度，将自己下一步应该接收的序列号作为确认应答返送回去。通过序列号和确认应答号，TCP 能够识别是否已经接收数据，又能够判断是否需要接收，从而实现可靠传输。</strong></li></ul><p><img src="https:////upload-images.jianshu.io/upload_images/1856419-9221af60624ef403.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp" alt="img"></p><p>序列号和确认应答</p><h5 id="重发超时的确定"><a href="#重发超时的确定" class="headerlink" title="重发超时的确定"></a>重发超时的确定</h5><ul><li><strong>重发超时是指在重发数据之前，等待确认应答到来的那个特定时间间隔。</strong>如果超过这个时间仍未收到确认应答，发送端将进行数据重发。最理想的是，找到一个最小时间，它能保证“确认应答一定能在这个时间内返回”。</li><li>TCP 要求不论处在何种网络环境下都要提供高性能通信，并且无论网络拥堵情况发生何种变化，都必须保持这一特性。为此，它在每次发包时都会计算往返时间及其偏差。将这个往返时间和偏差时间相加，重发超时的时间就是比这个总和要稍大一点的值。</li><li>在 BSD 的 Unix 以及 Windows 系统中，超时都以0.5秒为单位进行控制，因此重发超时都是0.5秒的整数倍。不过，最初其重发超时的默认值一般设置为6秒左右。</li><li>数据被重发之后若还是收不到确认应答，则进行再次发送。此时，等待确认应答的时间将会以2倍、4倍的指数函数延长。</li><li>此外，<strong>数据也不会被无限、反复地重发。达到一定重发次数之后，如果仍没有任何确认应答返回，就会判断为网络或对端主机发生了异常，强制关闭连接。并且通知应用通信异常强行终止。</strong> </li></ul><h5 id="以段为单位发送数据"><a href="#以段为单位发送数据" class="headerlink" title="以段为单位发送数据"></a>以段为单位发送数据</h5><ul><li>在建立 TCP 连接的同时，也可以确定发送数据包的单位，我们也可以称其为“最大消息长度”（MSS）。最理想的情况是，最大消息长度正好是 IP 中不会被分片处理的最大数据长度。</li><li>TCP 在传送大量数据时，是以 MSS 的大小将数据进行分割发送。进行重发时也是以 MSS  为单位。</li><li>MSS 在三次握手的时候，在两端主机之间被计算得出。两端的主机在发出建立连接的请求时，会在 TCP 首部中写入 MSS  选项，告诉对方自己的接口能够适应的 MSS 的大小。然后会在两者之间选择一个较小的值投入使用。</li></ul><h5 id="利用窗口控制提高速度"><a href="#利用窗口控制提高速度" class="headerlink" title="利用窗口控制提高速度"></a>利用窗口控制提高速度</h5><ul><li><p>TCP 以1个段为单位，每发送一个段进行一次确认应答的处理。这样的传输方式有一个缺点，就是包的往返时间越长通信性能就越低。</p></li><li><p>为解决这个问题，TCP 引入了窗口这个概念。确认应答不再是以每个分段，而是以更大的单位进行确认，转发时间将会被大幅地缩短。也就是说，发送端主机，在发送了一个段以后不必要一直等待确认应答，而是继续发送。如下图所示：</p></li></ul><p>  <img src="https:////upload-images.jianshu.io/upload_images/1856419-3883cce343404099.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/605/format/webp" alt="img"></p><p>  窗口控制</p><ul><li>窗口大小就是指无需等待确认应答而可以继续发送数据的最大值。上图中窗口大小为4个段。这个机制实现了使用大量的缓冲区，通过对多个段同时进行确认应答的功能。</li></ul><h5 id="滑动窗口控制"><a href="#滑动窗口控制" class="headerlink" title="滑动窗口控制"></a>滑动窗口控制</h5><p><img src="https:////upload-images.jianshu.io/upload_images/1856419-7919bd12b5b2917b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/859/format/webp" alt="img"></p><p>滑动窗口</p><ul><li>上图中的窗口内的数据即便没有收到确认应答也可以被发送出去。不过，在整个窗口的确认应答没有到达之前，如果其中部分数据出现丢包，那么发送端仍然要负责重传。为此，发送端主机需要设置缓存保留这些待被重传的数据，直到收到他们的确认应答。</li><li>在滑动窗口以外的部分包括未发送的数据以及已经确认对端已收到的数据。当数据发出后若如期收到确认应答就可以不用再进行重发，此时数据就可以从缓存区清除。</li><li>收到确认应答的情况下，将窗口滑动到确认应答中的序列号的位置。这样可以顺序地将多个段同时发送提高通信性能。这种机制也别称为滑动窗口控制。</li></ul><h5 id="窗口控制中的重发控制"><a href="#窗口控制中的重发控制" class="headerlink" title="窗口控制中的重发控制"></a>窗口控制中的重发控制</h5><p>在使用窗口控制中， 出现丢包一般分为两种情况：</p><ul><li>① 确认应答未能返回的情况。在这种情况下，数据已经到达对端，是不需要再进行重发的，如下图：</li></ul><p><img src="https:////upload-images.jianshu.io/upload_images/1856419-f17380d7afc3bb73.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/595/format/webp" alt="img"></p><p>部分确认应答丢失</p><ul><li>② 某个报文段丢失的情况。接收主机如果收到一个自己应该接收的序列号以外的数据时，会针对当前为止收到数据返回确认应答。如下图所示，当某一报文段丢失后，发送端会一直收到序号为1001的确认应答，因此，在窗口比较大，又出现报文段丢失的情况下，同一个序列号的确认应答将会被重复不断地返回。而发送端主机如果连续3次收到同一个确认应答，就会将其对应的数据进行重发。这种机制比之前提到的超时管理更加高效，因此也被称为高速重发控制。</li></ul><p><img src="https:////upload-images.jianshu.io/upload_images/1856419-0732e3d90fea80c8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/884/format/webp" alt="img"></p><p>高速重发控制</p><h3 id="网络层中的-IP-协议"><a href="#网络层中的-IP-协议" class="headerlink" title="网络层中的 IP 协议"></a>网络层中的 IP 协议</h3><ul><li>IP（IPv4、IPv6）相当于 OSI 参考模型中的第3层——网络层。网络层的主要作用是“实现终端节点之间的通信”。这种终端节点之间的通信也叫“点对点通信”。</li><li>网络的下一层——数据链路层的主要作用是在互连同一种数据链路的节点之间进行包传递。而一旦跨越多种数据链路，就需要借助网络层。网络层可以跨越不同的数据链路，即使是在不同的数据链路上也能实现两端节点之间的数据包传输。</li><li><strong>IP 大致分为三大作用模块，它们是 IP 寻址、路由（最终节点为止的转发）以及 IP 分包与组包。</strong></li></ul><h4 id="IP-地址"><a href="#IP-地址" class="headerlink" title="IP 地址"></a>IP 地址</h4><h5 id="IP-地址概述"><a href="#IP-地址概述" class="headerlink" title="IP 地址概述"></a>IP 地址概述</h5><ul><li>在计算机通信中，为了识别通信对端，必须要有一个类似于地址的识别码进行标识。在数据链路中的 MAC 地址正是用来标识同一个链路中不同计算机的一种识别码。</li><li>作为网络层的 IP ,也有这种地址信息，一般叫做 IP 地址。IP 地址用于在“连接到网络中的所有主机中识别出进行通信的目标地址”。因此，在 TCP/IP 通信中所有主机或路由器必须设定自己的 IP 地址。</li><li>不论一台主机与哪种数据链路连接，其 IP 地址的形式都保持不变。</li><li>IP 地址（IPv4 地址）由32位正整数来表示。IP 地址在计算机内部以二进制方式被处理。然而，由于我们并不习惯于采用二进制方式，我们将32位的 IP 地址以每8位为一组，分成4组，每组以 “.” 隔开，再将每组数转换成十进制数。如下：</li></ul><table><thead><tr><th>28</th><th>28</th><th>28</th><th>28</th><th></th></tr></thead><tbody><tr><td>10101100</td><td>00010100</td><td>00000001</td><td>00000001</td><td>（2进制）</td></tr><tr><td>10101100.</td><td>00010100.</td><td>00000001.</td><td>00000001</td><td>（2进制）</td></tr><tr><td>172.</td><td>20.</td><td>1.</td><td>1</td><td>（10进制）</td></tr></tbody></table><h5 id="IP-地址由网络和主机两部分标识组成"><a href="#IP-地址由网络和主机两部分标识组成" class="headerlink" title="IP 地址由网络和主机两部分标识组成"></a>IP 地址由网络和主机两部分标识组成</h5><ul><li>如下图，网络标识在数据链路的每个段配置不同的值。网络标识必须保证相互连接的每个段的地址不相重复。而相同段内相连的主机必须有相同的网络地址。IP 地址的“主机标识”则不允许在同一个网段内重复出现。由此，可以通过设置网络地址和主机地址，在相互连接的整个网络中保证每台主机的 IP 地址都不会相互重叠。即 IP 地址具有了唯一性。</li></ul><p><img src="https:////upload-images.jianshu.io/upload_images/1856419-d653f38b146f5f9f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/728/format/webp" alt="img"></p><p>IP地址的主机标识</p><ul><li>如下图，IP 包被转发到途中某个路由器时，正是利用目标 IP 地址的网络标识进行路由。因为即使不看主机标识，只要一见到网络标识就能判断出是否为该网段内的主机。</li></ul><p><img src="https:////upload-images.jianshu.io/upload_images/1856419-98e99ce9135f6eeb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/724/format/webp" alt="img"></p><p>IP地址的网络标识</p><h5 id="IP-地址的分类"><a href="#IP-地址的分类" class="headerlink" title="IP 地址的分类"></a>IP 地址的分类</h5><ul><li><strong>IP 地址分为四个级别，分别为A类、B类、C类、D类。它根据 IP 地址中从第 1 位到第 4 位的比特列对其网络标识和主机标识进行区分。</strong></li><li><strong>A 类 IP 地址是首位以 “0” 开头的地址。</strong>从第 1 位到第 8 位是它的网络标识。用十进制表示的话，0.0.0.0~127.0.0.0 是 A 类的网络地址。A 类地址的后 24 位相当于主机标识。因此，一个网段内可容纳的主机地址上限为16,777,214个。</li><li><strong>B 类 IP 地址是前两位 “10” 的地址。</strong>从第 1 位到第 16 位是它的网络标识。用十进制表示的话，128.0.0.0~191.255.0.0 是 B 类的网络地址。B 类地址的后 16 位相当于主机标识。因此，一个网段内可容纳的主机地址上限为65,534个。</li><li><strong>C 类 IP 地址是前三位为 “110” 的地址。</strong>从第 1 位到第 24 位是它的网络标识。用十进制表示的话，192.0.0.0~223.255.255.0 是 C 类的网络地址。C 类地址的后 8 位相当于主机标识。因此，一个网段内可容纳的主机地址上限为254个。</li><li><strong>D 类 IP 地址是前四位为 “1110” 的地址。</strong>从第 1 位到第 32 位是它的网络标识。用十进制表示的话，224.0.0.0~239.255.255.255 是 D 类的网络地址。D 类地址没有主机标识，常用于多播。</li><li>在分配 IP 地址时关于主机标识有一点需要注意。即要用比特位表示主机地址时，不可以全部为 0 或全部为 1。因为全部为 0 只有在表示对应的网络地址或 IP 地址不可以获知的情况下才使用。而全部为 1 的主机通常作为广播地址。因此，在分配过程中，应该去掉这两种情况。这也是为什么 C 类地址每个网段最多只能有 254（ 28 - 2 = 254）个主机地址的原因。</li></ul><h5 id="广播地址"><a href="#广播地址" class="headerlink" title="广播地址"></a>广播地址</h5><ul><li>广播地址用于在同一个链路中相互连接的主机之间发送数据包。将 IP 地址中的主机地址部分全部设置为 1，就成了广播地址。</li><li>广播分为本地广播和直接广播两种。在本网络内的广播叫做本地广播；在不同网络之间的广播叫做直接广播。</li></ul><h5 id="IP-多播"><a href="#IP-多播" class="headerlink" title="IP 多播"></a>IP 多播</h5><ul><li><p>多播用于将包发送给特定组内的所有主机。由于其直接使用 IP 地址，因此也不存在可靠传输。</p></li><li><p>相比于广播，多播既可以穿透路由器，又可以实现只给那些必要的组发送数据包。请看下图：</p></li></ul><p>  <img src="https:////upload-images.jianshu.io/upload_images/1856419-18d212851da62909.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/547/format/webp" alt="img"></p><p>  IP 多播</p><ul><li><p>多播使用 D 类地址。因此，如果从首位开始到第 4 位是 “1110”，就可以认为是多播地址。而剩下的 28 位可以成为多播的组编号。</p></li><li><p>此外， 对于多播，所有的主机（路由器以外的主机和终端主机）必须属于 224.0.0.1 的组，所有的路由器必须属于 224.0.0.2 的组。</p></li></ul><h5 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h5><ul><li>现在一个 IP 地址的网络标识和主机标识已不再受限于该地址的类别，而是由一个叫做“子网掩码”的识别码通过子网网络地址细分出比 A 类、B 类、C 类更小粒度的网络。这种方式实际上就是将原来 A 类、B 类、C 类等分类中的主机地址部分用作子网地址，可以将原网络分为多个物理网络的一种机制。</li><li>子网掩码用二进制方式表示的话，也是一个 32 位的数字。它对应 IP 地址网络标识部分的位全部为 “1”，对应 IP 地址主机标识的部分则全部为 “0”。由此，一个 IP 地址可以不再受限于自己的类别，而是可以用这样的子网掩码自由地定位自己的网络标识长度。当然，子网掩码必须是 IP 地址的首位开始连续的 “1”。</li><li>对于子网掩码，目前有两种表示方式。第一种是，将 IP 地址与子网掩码的地址分别用两行来表示。以 172.20.100.52 的前 26 位是网络地址的情况为例，如下：</li></ul><table><thead><tr><th>IP 地址</th><th>172.</th><th>20.</th><th>100.</th><th>52</th></tr></thead><tbody><tr><td>子网掩码</td><td>255.</td><td>255.</td><td>255.</td><td>192</td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td>网络地址</td><td>172.</td><td>20.</td><td>100.</td><td>0</td></tr><tr><td>子网掩码</td><td>255.</td><td>255.</td><td>255.</td><td>192</td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td>广播地址</td><td>172.</td><td>20.</td><td>100.</td><td>63</td></tr><tr><td>子网掩码</td><td>255.</td><td>255.</td><td>255.</td><td>192</td></tr></tbody></table><ul><li>第二种表示方式是，在每个 IP 地址后面追加网络地址的位数用 “/ ” 隔开，如下：</li></ul><table><thead><tr><th>IP 地址</th><th>172.</th><th>20.</th><th>100.</th><th>52</th><th>/ 26</th></tr></thead><tbody><tr><td>网络地址</td><td>172.</td><td>20.</td><td>100.</td><td>0</td><td>/ 26</td></tr><tr><td>广播地址</td><td>172.</td><td>20.</td><td>100.</td><td>63</td><td>/ 26</td></tr></tbody></table><ul><li>另外，在第二种方式下记述网络地址时可以省略后面的 “0” 。例如：172.20.0.0/26 跟 172.20/26 其实是一个意思。</li></ul><h4 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h4><ul><li>发送数据包时所使用的地址是网络层的地址，即 IP 地址。然而仅仅有 IP 地址还不足以实现将数据包发送到对端目标地址，在数据发送过程中还需要类似于“指明路由器或主机”的信息，以便真正发往目标地址。保存这种信息的就是路由控制表。</li><li>该路由控制表的形成方式有两种：一种是管理员手动设置，另一种是路由器与其他路由器相互交换信息时自动刷新。前者也叫做静态路由控制，而后者叫做动态路由控制。</li><li>IP 协议始终认为路由表是正确的。然后，IP 本身并没有定义制作路由控制表的协议。即 IP 没有制作路由控制表的机制。该表示由一个叫做“路由协议”的协议制作而成。</li></ul><h5 id="IP-地址与路由控制"><a href="#IP-地址与路由控制" class="headerlink" title="IP 地址与路由控制"></a>IP 地址与路由控制</h5><ul><li>IP 地址的网络地址部分用于进行路由控制。</li><li>路由控制表中记录着网络地址与下一步应该发送至路由器的地址。</li><li>在发送 IP 包时，首先要确定 IP 包首部中的目标地址，再从路由控制表中找到与该地址具有相同网络地址的记录，根据该记录将 IP 包转发给相应的下一个路由器。如果路由控制表中存在多条相同网络地址的记录，就选择一个最为吻合的网络地址。</li></ul><p><img src="https:////upload-images.jianshu.io/upload_images/1856419-cd4c3759c61abb38.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/730/format/webp" alt="img"></p><p>路由控制表与 IP 包发送</p><h4 id="IP-分包与组包"><a href="#IP-分包与组包" class="headerlink" title="IP 分包与组包"></a>IP 分包与组包</h4><ul><li>每种数据链路的最大传输单元（MTU）都不尽相同，因为每个不同类型的数据链路的使用目的不同。使用目的不同，可承载的 MTU 也就不同。</li><li>任何一台主机都有必要对 IP 分片进行相应的处理。分片往往在网络上遇到比较大的报文无法一下子发送出去时才会进行处理。</li><li>经过分片之后的 IP 数据报在被重组的时候，只能由目标主机进行。路由器虽然做分片但不会进行重组。</li></ul><h5 id="路径-MTU-发现"><a href="#路径-MTU-发现" class="headerlink" title="路径 MTU 发现"></a>路径 MTU 发现</h5><ul><li>分片机制也有它的不足。如路由器的处理负荷加重之类。因此，只要允许，是不希望由路由器进行 IP 数据包的分片处理的。</li><li>为了应对分片机制的不足，“路径 MTU 发现” 技术应运而生。路径 MTU 指的是，从发送端主机到接收端主机之间不需要分片是最大 MTU 的大小。即路径中存在的所有数据链路中最小的 MTU 。</li><li>进行路径 MTU 发现，就可以避免在中途的路由器上进行分片处理，也可以在 TCP 中发送更大的包。</li></ul><h4 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h4><ul><li>IPv6（IP version 6）是为了根本解决 IPv4 地址耗尽的问题而被标准化的网际协议。IPv4 的地址长度为 4 个 8 位字节，即 32 比特。而 IPv6 的地址长度则是原来的 4 倍，即 128 比特，一般写成 8 个 16 位字节。</li></ul><h5 id="IPv6-的特点"><a href="#IPv6-的特点" class="headerlink" title="IPv6 的特点"></a>IPv6 的特点</h5><ul><li>IP 得知的扩大与路由控制表的聚合。</li><li>性能提升。包首部长度采用固定的值（40字节），不再采用首部检验码。简化首部结构，减轻路由器负担。路由器不再做分片处理。</li><li>支持即插即用功能。即使没有DHCP服务器也可以实现自动分配 IP 地址。</li><li>采用认证与加密功能。应对伪造 IP 地址的网络安全功能以及防止线路窃听的功能。</li><li>多播、Mobile IP 成为扩展功能。</li></ul><h5 id="IPv6-中-IP-地址的标记方法"><a href="#IPv6-中-IP-地址的标记方法" class="headerlink" title="IPv6 中 IP 地址的标记方法"></a>IPv6 中 IP 地址的标记方法</h5><ul><li>一般人们将 128 比特 IP 地址以每 16 比特为一组，每组用冒号（“：”）隔开进行标记。</li><li>而且如果出现连续的 0 时还可以将这些 0 省略，并用两个冒号（“：：”）隔开。但是，一个 IP 地址中只允许出现一次两个连续的冒号。</li></ul><h5 id="IPv6-地址的结构"><a href="#IPv6-地址的结构" class="headerlink" title="IPv6 地址的结构"></a>IPv6 地址的结构</h5><ul><li>IPv6 类似 IPv4，也是通过 IP 地址的前几位标识 IP 地址的种类。</li><li>在互联网通信中，使用一种全局的单播地址。它是互联网中唯一的一个地址，不需要正式分配 IP 地址。</li></ul><table><thead><tr><th>未定义</th><th>0000 … 0000（128比特）</th><th>：：/ 128</th></tr></thead><tbody><tr><td>环回地址</td><td>0000 … 0001（128比特）</td><td>：：1 / 128</td></tr><tr><td>唯一本地地址</td><td>1111 110</td><td>FC00：/ 7</td></tr><tr><td>链路本地单播地址</td><td>1111 1110 10</td><td>FE80：：/ 10</td></tr><tr><td>多播地址</td><td>1111 1111</td><td>FF00：：/ 8</td></tr><tr><td>全局单播地址</td><td>（其他）</td></tr></tbody></table><h5 id="全局单播地址"><a href="#全局单播地址" class="headerlink" title="全局单播地址"></a>全局单播地址</h5><ul><li>全局单播地址是指世界上唯一的一个地址。它是互联网通信以及各个域内部通信中最为常用的一个 IPv6 地址。</li><li>格式如下图所示，现在 IPv6 的网络中所使用的格式为，n = 48，m = 16 以及 128 - n - m = 64。即前 64 比特为网络标识，后 64 比特为主机标识。</li></ul><p><img src="https:////upload-images.jianshu.io/upload_images/1856419-3cd8f2d1fae94dcf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/785/format/webp" alt="img"></p><p>全局单播地址</p><h5 id="链路本地单播地址"><a href="#链路本地单播地址" class="headerlink" title="链路本地单播地址"></a>链路本地单播地址</h5><ul><li>链路本地单播地址是指在同一个数据链路内唯一的地址。它用于不经过路由器，在同一个链路中的通信。通常接口 ID 保存 64 比特版的 MAC 地址。</li></ul><p><img src="https:////upload-images.jianshu.io/upload_images/1856419-dca23d5bfda77579.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/772/format/webp" alt="img"></p><p>链路本地单播地址</p><h5 id="唯一本地地址"><a href="#唯一本地地址" class="headerlink" title="唯一本地地址"></a>唯一本地地址</h5><ul><li>唯一本地地址是不进行互联网通信时所用的地址。</li><li>唯一本地地址虽然不会与互联网连接，但是也会尽可能地随机生成一个唯一的全局 ID。</li><li>L 通常被置为 1</li><li>全局 ID 的值随机决定</li><li>子网 ID 是指该域子网地址</li><li>接口 ID 即为接口的 ID</li></ul><p><img src="https:////upload-images.jianshu.io/upload_images/1856419-baee1dd0cd9d16a2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/820/format/webp" alt="img"></p><p>唯一本地地址</p><h5 id="IPv6-分段处理"><a href="#IPv6-分段处理" class="headerlink" title="IPv6 分段处理"></a>IPv6 分段处理</h5><ul><li>IPv6 的分片处理只在作为起点的发送端主机上进行，路由器不参与分片。</li><li>IPv6 中最小 MTU 为 1280 字节，因此，在嵌入式系统中对于那些有一定系统资源限制的设备来说，不需要进行“路径 MTU 发现”，而是在发送 IP 包时直接以 1280 字节为单位分片送出。</li></ul><h5 id="IP-首部（暂略）"><a href="#IP-首部（暂略）" class="headerlink" title="IP 首部（暂略）"></a>IP 首部（暂略）</h5><h4 id="IP-协议相关技术"><a href="#IP-协议相关技术" class="headerlink" title="IP 协议相关技术"></a>IP 协议相关技术</h4><ul><li>IP 旨在让最终目标主机收到数据包，但是在这一过程中仅仅有 IP 是无法实现通信的。必须还有能够解析主机名称和 MAC 地址的功能，以及数据包在发送过程中异常情况处理的功能。</li></ul><h5 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h5><ul><li>我们平常在访问某个网站时不适用 IP 地址，而是用一串由罗马字和点号组成的字符串。而一般用户在使用 TCP/IP 进行通信时也不使用 IP 地址。能够这样做是因为有了 DNS （Domain Name System）功能的支持。DNS 可以将那串字符串自动转换为具体的 IP 地址。</li><li>这种 DNS 不仅适用于 IPv4，还适用于 IPv6。</li></ul><h5 id="ARP"><a href="#ARP" class="headerlink" title="ARP"></a>ARP</h5><ul><li>只要确定了 IP 地址，就可以向这个目标地址发送 IP 数据报。然而，在底层数据链路层，进行实际通信时却有必要了解每个 IP 地址所对应的 MAC 地址。</li><li>ARP 是一种解决地址问题的协议。以目标 IP 地址为线索，用来定位下一个应该接收数据分包的网络设备对应的 MAC 地址。不过 ARP 只适用于 IPv4，不能用于 IPv6。IPv6 中可以用 ICMPv6 替代 ARP 发送邻居探索消息。</li><li>RARP 是将 ARP 反过来，从 MAC 地址定位 IP 地址的一种协议。</li></ul><h5 id="5-3-ICMP"><a href="#5-3-ICMP" class="headerlink" title="5.3 ICMP"></a>5.3 ICMP</h5><ul><li>ICMP 的主要功能包括，确认 IP 包是否成功送达目标地址，通知在发送过程当中 IP 包被废弃的具体原因，改善网络设置等。</li><li>IPv4 中 ICMP 仅作为一个辅助作用支持 IPv4。也就是说，在 IPv4 时期，即使没有 ICMP，仍然可以实现 IP 通信。然而，在 IPv6 中，ICMP 的作用被扩大，如果没有 ICMPv6，IPv6 就无法进行正常通信。</li></ul><h5 id="DHCP"><a href="#DHCP" class="headerlink" title="DHCP"></a>DHCP</h5><ul><li>如果逐一为每一台主机设置 IP 地址会是非常繁琐的事情。特别是在移动使用笔记本电脑、只能终端以及平板电脑等设备时，每移动到一个新的地方，都要重新设置 IP 地址。</li><li>于是，为了实现自动设置 IP 地址、统一管理 IP 地址分配，就产生了 DHCP（Dynamic Host Configuration Protocol）协议。有了 DHCP，计算机只要连接到网络，就可以进行 TCP/IP 通信。也就是说，DHCP 让即插即用变得可能。</li><li>DHCP 不仅在 IPv4 中，在 IPv6 中也可以使用。</li></ul><h5 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h5><ul><li>NAT（Network Address Translator）是用于在本地网络中使用私有地址，在连接互联网时转而使用全局 IP 地址的技术。</li><li>除转换 IP 地址外，还出现了可以转换 TCP、UDP 端口号的 NAPT（Network Address Ports Translator）技术，由此可以实现用一个全局 IP 地址与多个主机的通信。</li><li>NAT（NAPT）实际上是为正在面临地址枯竭的 IPv4 而开发的技术。不过，在 IPv6 中为了提高网络安全也在使用 NAT，在 IPv4 和 IPv6 之间的相互通信当中常常使用 NAT-PT。</li></ul><h5 id="IP-隧道"><a href="#IP-隧道" class="headerlink" title="IP 隧道"></a>IP 隧道</h5><p><img src="https:////upload-images.jianshu.io/upload_images/1856419-d45032d360259d59.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/641/format/webp" alt="img"></p><p>夹着 IPv4 网络的两个 IPv6 网络</p><ul><li>如上图的网络环境中，网络 A 与网络 B 之间无法直接进行通信，为了让它们之间正常通信，这时必须得采用 IP 隧道的功能。</li><li>IP 隧道可以将那些从网络 A 发过来的 IPv6 的包统合为一个数据，再为之追加一个 IPv4 的首部以后转发给网络 C。</li><li>一般情况下，紧接着 IP 首部的是 TCP 或 UDP 的首部。然而，现在的应用当中“ IP 首部的后面还是 IP 首部”或者“ IP 首部的后面是 IPv6 的首部”等情况与日俱增。这种在网络层的首部后面追加网络层首部的通信方法就叫做“ IP 隧道”。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt; 详解TCP/IP协议：&lt;/strong&gt; &lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;/excerpt&gt;&lt;/p&gt;
&lt;p&gt;TCP/IP网络协议的详解概述&lt;/p&gt;
    
    </summary>
    
      <category term="others" scheme="https://alexbrucelu.github.io/categories/others/"/>
    
    
      <category term="TCP/IP" scheme="https://alexbrucelu.github.io/tags/TCP-IP/"/>
    
  </entry>
  
  <entry>
    <title>详解http协议</title>
    <link href="https://alexbrucelu.github.io/2018/12/05/%E8%AF%A6%E8%A7%A3http%E5%8D%8F%E8%AE%AE/"/>
    <id>https://alexbrucelu.github.io/2018/12/05/详解http协议/</id>
    <published>2018-12-05T08:20:13.313Z</published>
    <updated>2018-12-05T09:41:11.358Z</updated>
    
    <content type="html"><![CDATA[<p><strong> 详解http协议：</strong> <excerpt in="" index="" |="" 首页摘要=""></excerpt></p><p>http网络协议的详解概述</p><a id="more"></a><p>[TOC]</p><p><img src="https://github.com/AlexBruceLu/DAPP/wiki/http3.webp" alt="一张图带你看完本篇文章"></p><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><h4 id="计算机网络体系结构分层"><a href="#计算机网络体系结构分层" class="headerlink" title="计算机网络体系结构分层"></a>计算机网络体系结构分层</h4><p><img src="https://github.com/AlexBruceLu/DAPP/wiki/http2.webp" alt="计算机网络体系结构分层"></p><h4 id="TCP-IP-通信传输流"><a href="#TCP-IP-通信传输流" class="headerlink" title="TCP/IP 通信传输流"></a>TCP/IP 通信传输流</h4><p>利用 TCP/IP 协议族进行网络通信时，会通过分层顺序与对方进行通信。发送端从应用层往下走，接收端则从链路层往上走。如下：</p><p><img src="https://github.com/AlexBruceLu/DAPP/wiki/http4.webp" alt="TCP/IP 通信传输流"></p><ul><li>首先作为发送端的客户端在应用层（HTTP 协议）发出一个想看某个 Web 页面的 HTTP 请求。</li><li>接着，为了传输方便，在传输层（TCP 协议）把从应用层处收到的数据（HTTP 请求报文）进行分割，并在各个报文上打上标记序号及端口号后转发给网络层。</li><li>在网络层（IP 协议），增加作为通信目的地的 MAC 地址后转发给链路层。这样一来，发往网络的通信请求就准备齐全了。</li><li>接收端的服务器在链路层接收到数据，按序往上层发送，一直到应用层。当传输到应用层，才能算真正接收到由客户端发送过来的 HTTP请求。</li></ul><p>如下图所示：</p><p><img src="https://github.com/AlexBruceLu/DAPP/wiki/http5.webp" alt="HTTP 请求"></p><p>在网络体系结构中，包含了众多的网络协议，这篇文章主要围绕 HTTP 协议（HTTP/1.1版本）展开。</p><blockquote><p>HTTP协议（HyperText Transfer Protocol，超文本传输协议）是用于从WWW服务器传输超文本到本地浏览器的传输协议。它可以使浏览器更加高效，使网络传输减少。它不仅保证计算机正确快速地传输超文本文档，还确定传输文档中的哪一部分，以及哪部分内容首先显示(如文本先于图形)等。<br> HTTP是客户端浏览器或其他程序与Web服务器之间的应用层通信协议。在Internet上的Web服务器上存放的都是超文本信息，客户机需要通过HTTP协议传输所要访问的超文本信息。HTTP包含命令和传输信息，不仅可用于Web访问，也可以用于其他因特网/内联网应用系统之间的通信，从而实现各类应用资源超媒体访问的集成。<br> 我们在浏览器的地址栏里输入的网站地址叫做URL (Uniform Resource Locator，统一资源定位符)。就像每家每户都有一个门牌地址一样，每个网页也都有一个Internet地址。当你在浏览器的地址框中输入一个URL或是单击一个超级链接时，URL就确定了要浏览的地址。浏览器通过超文本传输协议(HTTP)，将Web服务器上站点的网页代码提取出来，并翻译成漂亮的网页。</p></blockquote><h3 id="HTTP-工作过程"><a href="#HTTP-工作过程" class="headerlink" title="HTTP 工作过程"></a>HTTP 工作过程</h3><p><img src="https://github.com/AlexBruceLu/DAPP/wiki/http6.webp" alt="HTTP请求响应模型"></p><p>HTTP通信机制是在一次完整的 HTTP 通信过程中，客户端与服务器之间将完成下列7个步骤：</p><h4 id="建立-TCP-连接"><a href="#建立-TCP-连接" class="headerlink" title="建立 TCP 连接"></a><strong>建立 TCP 连接</strong></h4><p>在HTTP工作开始之前，客户端首先要通过网络与服务器建立连接，该连接是通过 TCP 来完成的，该协议与 IP 协议共同构建 Internet，即著名的 TCP/IP 协议族，因此 Internet 又被称作是 TCP/IP 网络。HTTP 是比 TCP 更高层次的应用层协议，根据规则，只有低层协议建立之后，才能进行高层协议的连接，因此，首先要建立 TCP 连接，一般 TCP 连接的端口号是80；</p><h4 id="客户端向服务器发送请求命令"><a href="#客户端向服务器发送请求命令" class="headerlink" title="客户端向服务器发送请求命令"></a><strong>客户端向服务器发送请求命令</strong></h4><p> 一旦建立了TCP连接，客户端就会向服务器发送请求命令；<br> 例如：<code>GET/sample/hello.jsp HTTP/1.1</code> </p><h4 id="客户端发送请求头信息"><a href="#客户端发送请求头信息" class="headerlink" title="客户端发送请求头信息"></a><strong>客户端发送请求头信息</strong></h4><p> 客户端发送其请求命令之后，还要以头信息的形式向服务器发送一些别的信息，之后客户端发送了一空白行来通知服务器，它已经结束了该头信息的发送；</p><h4 id="服务器应答"><a href="#服务器应答" class="headerlink" title="服务器应答"></a><strong>服务器应答</strong></h4><p> 客户端向服务器发出请求后，服务器会客户端返回响应；<br> 例如： <code>HTTP/1.1 200 OK</code><br> 响应的第一部分是协议的版本号和响应状态码</p><h4 id="服务器返回响应头信息"><a href="#服务器返回响应头信息" class="headerlink" title="服务器返回响应头信息"></a><strong>服务器返回响应头信息</strong></h4><p> 正如客户端会随同请求发送关于自身的信息一样，服务器也会随同响应向用户发送关于它自己的数据及被请求的文档；</p><h4 id="服务器向客户端发送数据"><a href="#服务器向客户端发送数据" class="headerlink" title="服务器向客户端发送数据"></a><strong>服务器向客户端发送数据</strong></h4><p> 服务器向客户端发送头信息后，它会发送一个空白行来表示头信息的发送到此为结束，接着，它就以 Content-Type 响应头信息所描述的格式发送用户所请求的实际数据；</p><h4 id="服务器关闭-TCP-连接"><a href="#服务器关闭-TCP-连接" class="headerlink" title="服务器关闭 TCP 连接"></a><strong>服务器关闭 TCP 连接</strong></h4><p> 一般情况下，一旦服务器向客户端返回了请求数据，它就要关闭 TCP 连接，然后如果客户端或者服务器在其头信息加入了这行代码 <code>Connection:keep-alive</code> ，TCP 连接在发送后将仍然保持打开状态，于是，客户端可以继续通过相同的连接发送请求。保持连接节省了为每个请求建立新连接所需的时间，还节约了网络带宽。</p><h3 id="HTTP-协议基础"><a href="#HTTP-协议基础" class="headerlink" title="HTTP 协议基础"></a>HTTP 协议基础</h3><h4 id="通过请求和响应的交换达成通信"><a href="#通过请求和响应的交换达成通信" class="headerlink" title="通过请求和响应的交换达成通信"></a>通过请求和响应的交换达成通信</h4><p>应用 HTTP 协议时，必定是一端担任客户端角色，另一端担任服务器端角色。仅从一条通信线路来说，服务器端和客服端的角色是确定的。HTTP 协议规定，请求从客户端发出，最后服务器端响应该请求并返回。<strong>换句话说，肯定是先从客户端开始建立通信的，服务器端在没有接收到请求之前不会发送响应。</strong></p><h4 id="HTTP-是不保存状态的协议"><a href="#HTTP-是不保存状态的协议" class="headerlink" title="HTTP 是不保存状态的协议"></a>HTTP 是不保存状态的协议</h4><p>HTTP 是一种无状态协议。协议自身不对请求和响应之间的通信状态进行保存。也就是说在 HTTP 这个级别，协议对于发送过的请求或响应都不做持久化处理。这是为了更快地处理大量事务，确保协议的可伸缩性，而特意把 HTTP 协议设计成如此简单的。<br>可是随着 Web 的不断发展，我们的很多业务都需要对通信状态进行保存。于是我们引入了 Cookie 技术。有了 Cookie 再用 HTTP 协议通信，就可以管理状态了。</p><h4 id="使用-Cookie-的状态管理"><a href="#使用-Cookie-的状态管理" class="headerlink" title="使用 Cookie 的状态管理"></a>使用 Cookie 的状态管理</h4><p>Cookie 技术通过在请求和响应报文中写入 Cookie 信息来控制客户端的状态。Cookie 会根据从服务器端发送的响应报文内的一个叫做 Set-Cookie 的首部字段信息，通知客户端保存Cookie。当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入 Cookie 值后发送出去。服务器端发现客户端发送过来的 Cookie 后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到之前的状态信息。</p><p><img src="https://github.com/AlexBruceLu/DAPP/wiki/http7.webp" alt="Cookie 的流程"></p><h4 id="请求-URI-定位资源"><a href="#请求-URI-定位资源" class="headerlink" title="请求 URI 定位资源"></a>请求 URI 定位资源</h4><p>HTTP 协议使用 URI 定位互联网上的资源。正是因为 URI 的特定功能，在互联网上任意位置的资源都能访问到。</p><h4 id="告知服务器意图的-HTTP-方法（HTTP-1-1）"><a href="#告知服务器意图的-HTTP-方法（HTTP-1-1）" class="headerlink" title="告知服务器意图的 HTTP 方法（HTTP/1.1）"></a>告知服务器意图的 HTTP 方法（HTTP/1.1）</h4><p><img src="https://github.com/AlexBruceLu/DAPP/wiki/http8.webp" alt="HTTP 方法"></p><h4 id="持久连接"><a href="#持久连接" class="headerlink" title="持久连接"></a>持久连接</h4><p>HTTP 协议的初始版本中，每进行一个 HTTP 通信都要断开一次 TCP 连接。比如使用浏览器浏览一个包含多张图片的 HTML 页面时，在发送请求访问 HTML 页面资源的同时，也会请求该 HTML 页面里包含的其他资源。因此，每次的请求都会造成无畏的 TCP 连接建立和断开，增加通信量的开销。<br> 为了解决上述 TCP 连接的问题，HTTP/1.1 和部分 HTTP/1.0 想出了持久连接的方法。<strong>其特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。旨在建立一次 TCP 连接后进行多次请求和响应的交互。</strong>在 HTTP/1.1 中，所有的连接默认都是持久连接。</p><h4 id="管线化"><a href="#管线化" class="headerlink" title="管线化"></a>管线化</h4><p>持久连接使得多数请求以管线化方式发送成为可能。以前发送请求后需等待并接收到响应，才能发送下一个请求。管线化技术出现后，不用等待亦可发送下一个请求。这样就能做到同时并行发送多个请求，而不需要一个接一个地等待响应了。<br> 比如，当请求一个包含多张图片的 HTML 页面时，与挨个连接相比，用持久连接可以让请求更快结束。而管线化技术要比持久连接速度更快。请求数越多，时间差就越明显。</p><h3 id="HTTP-协议报文结构"><a href="#HTTP-协议报文结构" class="headerlink" title="HTTP 协议报文结构"></a>HTTP 协议报文结构</h3><h4 id="HTTP-报文"><a href="#HTTP-报文" class="headerlink" title="HTTP 报文"></a>HTTP 报文</h4><p>用于 HTTP 协议交互的信息被称为 HTTP 报文。请求端（客户端）的 HTTP 报文叫做请求报文；响应端（服务器端）的叫做响应报文。HTTP 报文本身是由多行（用 CR+LF 作换行符）数据构成的字符串文本。</p><h4 id="HTTP-报文结构"><a href="#HTTP-报文结构" class="headerlink" title="HTTP 报文结构"></a>HTTP 报文结构</h4><p>HTTP 报文大致可分为报文首部和报文主体两部分。两者由最初出现的空行（CR+LF）来划分。通常，并不一定有报文主体。如下：</p><p><img src="https://github.com/AlexBruceLu/DAPP/wiki/http.webp" alt="HTTP 报文结构"></p><p><img src="https://github.com/AlexBruceLu/DAPP/wiki/http901.webp" alt="HTTP 报文结构"></p><h5 id="请求报文结构"><a href="#请求报文结构" class="headerlink" title="请求报文结构"></a>请求报文结构</h5><p><img src="https://github.com/AlexBruceLu/DAPP/wiki/http10.webp" alt="请求报文结构"></p><p>请求报文的首部内容由以下数据组成：</p><ul><li><strong>请求行</strong> —— 包含用于请求的方法、请求 URI 和 HTTP 版本。</li><li><strong>首部字段</strong> —— 包含表示请求的各种条件和属性的各类首部。（通用首部、请求首部、实体首部以及RFC里未定义的首部如 Cookie 等）</li></ul><p>请求报文的示例，如下：</p><p><img src="https://github.com/AlexBruceLu/DAPP/wiki/http11.webp" alt="请求报文示例"></p><h5 id="响应报文结构"><a href="#响应报文结构" class="headerlink" title="响应报文结构"></a>响应报文结构</h5><p><img src="https://github.com/AlexBruceLu/DAPP/wiki/http12.webp" alt="响应报文结构"></p><p>响应报文的首部内容由以下数据组成：</p><ul><li><strong>状态行</strong> —— 包含表明响应结果的状态码、原因短语和 HTTP 版本。</li><li><strong>首部字段</strong> —— 包含表示请求的各种条件和属性的各类首部。（通用首部、响应首部、实体首部以及RFC里未定义的首部如 Cookie 等）</li></ul><p>响应报文的示例，如下：</p><p><img src="https://github.com/AlexBruceLu/DAPP/wiki/http13.webp" alt="响应报文结构"></p><h3 id="HTTP-报文首部之请求行、状态行"><a href="#HTTP-报文首部之请求行、状态行" class="headerlink" title="HTTP 报文首部之请求行、状态行"></a>HTTP 报文首部之请求行、状态行</h3><h4 id="请求行"><a href="#请求行" class="headerlink" title="请求行"></a>请求行</h4><p>举个栗子，下面是一个 HTTP 请求的报文：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET  /index.htm  HTTP/1.1</span><br><span class="line">Host: sample.com</span><br></pre></td></tr></table></figure><p>其中，下面的这行就是请求行，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET  /index.htm  HTTP/1.1</span><br></pre></td></tr></table></figure><ul><li>开头的 GET 表示请求访问服务器的类型，称为方法；</li><li>随后的字符串  <code>/index.htm</code> 指明了请求访问的资源对象，也叫做请求 URI；</li><li>最后的 <code>HTTP/1.1</code>，即 HTTP 的版本号，用来提示客户端使用的 HTTP 协议功能。</li></ul><p>综合来看，大意是请求访问某台 HTTP 服务器上的 <code>/index.htm</code> 页面资源。</p><h4 id="状态行"><a href="#状态行" class="headerlink" title="状态行"></a>状态行</h4><p>同样举个栗子，下面是一个 HTTP 响应的报文：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1  200  OK</span><br><span class="line">Date: Mon, 10 Jul 2017 15:50:06 GMT</span><br><span class="line">Content-Length: 256</span><br><span class="line">Content-Type: text/html</span><br><span class="line">    </span><br><span class="line">&lt;html&gt;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>其中，下面的这行就是状态行，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1  200  OK</span><br></pre></td></tr></table></figure><ul><li>开头的 <code>HTTP/1.1</code> 表示服务器对应的 HTTP 版本；</li><li>紧挨着的 <code>200 OK</code> 表示请求的处理结果的状态码和原因短语。</li></ul><h3 id="HTTP-报文首部之首部字段（重点分析）"><a href="#HTTP-报文首部之首部字段（重点分析）" class="headerlink" title="HTTP 报文首部之首部字段（重点分析）"></a>HTTP 报文首部之首部字段（重点分析）</h3><h4 id="首部字段概述"><a href="#首部字段概述" class="headerlink" title="首部字段概述"></a>首部字段概述</h4><p>先来回顾一下首部字段在报文的位置，HTTP 报文包含报文首部和报文主体，报文首部包含请求行（或状态行）和首部字段。<br> 在报文众多的字段当中，HTTP 首部字段包含的信息最为丰富。首部字段同时存在于请求和响应报文内，并涵盖 HTTP 报文相关的内容信息。使用首部字段是为了给客服端和服务器端提供报文主体大小、所使用的语言、认证信息等内容。</p><h4 id="首部字段结构"><a href="#首部字段结构" class="headerlink" title="首部字段结构"></a>首部字段结构</h4><ul><li>HTTP 首部字段是由首部字段名和字段值构成的，中间用冒号“：”分隔。</li><li>另外，字段值对应单个 HTTP 首部字段可以有多个值。</li><li>当 HTTP 报文首部中出现了两个或以上具有相同首部字段名的首部字段时，这种情况在规范内尚未明确，根据浏览器内部处理逻辑的不同，优先处理的顺序可能不同，结果可能并不一致。</li></ul><table><thead><tr><th>首部字段名</th><th>冒号</th><th>字段值</th></tr></thead><tbody><tr><td>Content-Type</td><td>：</td><td>text/html</td></tr><tr><td>Keep-Alive</td><td>：</td><td>timeout=30, max=120</td></tr></tbody></table><h4 id="首部字段类型"><a href="#首部字段类型" class="headerlink" title="首部字段类型"></a>首部字段类型</h4><p>首部字段根据实际用途被分为以下4种类型：</p><table><thead><tr><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>通用首部字段</td><td>请求报文和响应报文两方都会使用的首部</td></tr><tr><td>请求首部字段</td><td>从客户端向服务器端发送请求报文时使用的首部。补充了请求的附加内容、客户端信息、响应内容相关优先级等信息</td></tr><tr><td>响应首部字段</td><td>从服务器端向客户端返回响应报文时使用的首部。补充了响应的附加内容，也会要求客户端附加额外的内容信息。</td></tr><tr><td>实体首部字段</td><td>针对请求报文和响应报文的实体部分使用的首部。补充了资源内容更新时间等与实体有关的的信息。</td></tr></tbody></table><h4 id="通用首部字段（HTTP-1-1）"><a href="#通用首部字段（HTTP-1-1）" class="headerlink" title="通用首部字段（HTTP/1.1）"></a>通用首部字段（HTTP/1.1）</h4><table><thead><tr><th>首部字段名</th><th>说明</th></tr></thead><tbody><tr><td>Cache-Control</td><td>控制缓存的行为</td></tr><tr><td>Connection</td><td>逐挑首部、连接的管理</td></tr><tr><td>Date</td><td>创建报文的日期时间</td></tr><tr><td>Pragma</td><td>报文指令</td></tr><tr><td>Trailer</td><td>报文末端的首部一览</td></tr><tr><td>Transfer-Encoding</td><td>指定报文主体的传输编码方式</td></tr><tr><td>Upgrade</td><td>升级为其他协议</td></tr><tr><td>Via</td><td>代理服务器的相关信息</td></tr><tr><td>Warning</td><td>错误通知</td></tr></tbody></table><h5 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h5><p>通过指定首部字段 Cache-Control 的指令，就能操作缓存的工作机制。</p><h5 id="可用的指令一览"><a href="#可用的指令一览" class="headerlink" title="可用的指令一览"></a>可用的指令一览</h5><p>可用的指令按请求和响应分类如下：</p><h5 id="缓存请求指令"><a href="#缓存请求指令" class="headerlink" title="缓存请求指令"></a><strong>缓存请求指令</strong></h5><table><thead><tr><th>指令</th><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>no-cache</td><td>无</td><td>强制向服务器再次验证</td></tr><tr><td>no-store</td><td>无</td><td>不缓存请求或响应的任何内容</td></tr><tr><td>max-age = [秒]</td><td>必需</td><td>响应的最大Age值</td></tr><tr><td>max-stale( =[秒])</td><td>可省略</td><td>接收已过期的响应</td></tr><tr><td>min-fresh = [秒]</td><td>必需</td><td>期望在指定时间内的响应仍有效</td></tr><tr><td>no-transform</td><td>无</td><td>代理不可更改媒体类型</td></tr><tr><td>only-if-cached</td><td>无</td><td>从缓存获取资源</td></tr><tr><td>cache-extension</td><td>-</td><td>新指令标记（token）</td></tr></tbody></table><h5 id="缓存响应指令"><a href="#缓存响应指令" class="headerlink" title="缓存响应指令"></a><strong>缓存响应指令</strong></h5><table><thead><tr><th>指令</th><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>public</td><td>无</td><td>可向任意方提供响应的缓存</td></tr><tr><td>private</td><td>可省略</td><td>仅向特定用户返回响应</td></tr><tr><td>no-cache</td><td>可省略</td><td>缓存前必须先确认其有效性</td></tr><tr><td>no-store</td><td>无</td><td>不缓存请求或响应的任何内容</td></tr><tr><td>no-transform</td><td>无</td><td>代理不可更改媒体类型</td></tr><tr><td>must-revalidate</td><td>无</td><td>可缓存但必须再向源服务器进行确认</td></tr><tr><td>proxy-revalidate</td><td>无</td><td>要求中间缓存服务器对缓存的响应有效性再进行确认</td></tr><tr><td>max-age = [秒]</td><td>必需</td><td>响应的最大Age值</td></tr><tr><td>s-maxage = [秒]</td><td>必需</td><td>公共缓存服务器响应的最大Age值</td></tr><tr><td>cache-extension</td><td>-</td><td>新指令标记（token）</td></tr></tbody></table><h5 id="表示能否缓存的指令"><a href="#表示能否缓存的指令" class="headerlink" title="表示能否缓存的指令"></a><strong>表示能否缓存的指令</strong></h5><p><strong>public 指令</strong><br> <code>Cache-Control: public</code><br> 当指定使用 public 指令时，则明确表明其他用户也可利用缓存。</p><p><strong>private 指令</strong><br> <code>Cache-Control: private</code><br> 当指定 private 指令后，响应只以特定的用户作为对象，这与 public 指令的行为相反。缓存服务器会对该特定用户提供资源缓存的服务，对于其他用户发送过来的请求，代理服务器则不会返回缓存。</p><p><strong>no-cache 指令</strong><br> <code>Cache-Control: no-cache</code></p><ul><li>使用 no-cache 指令是为了防止从缓存中返回过期的资源。</li><li>客户端发送的请求中如果包含 no-cache 指令，则表示客户端将不会接收缓存过的响应。于是，“中间”的缓存服务器必须把客户端请求转发给源服务器。</li><li>如果服务器中返回的响应包含 no-cache 指令，那么缓存服务器不能对资源进行缓存。源服务器以后也将不再对缓存服务器请求中提出的资源有效性进行确认，且禁止其对响应资源进行缓存操作。</li></ul><p><code>Cache-Control: no-cache=Location</code><br> 由服务器返回的响应中，若报文首部字段 Cache-Control 中对 no-cache 字段名具体指定参数值，那么客户端在接收到这个被指定参数值的首部字段对应的响应报文后，就不能使用缓存。换言之，无参数值的首部字段可以使用缓存。只能在响应指令中指定该参数。</p><p><strong>no-store 指令</strong><br> <code>Cache-Control: no-store</code><br> 当使用 no-store 指令时，暗示请求（和对应的响应）或响应中包含机密信息。因此，该指令规定缓存不能在本地存储请求或响应的任一部分。<br> 注意：no-cache 指令代表不缓存过期的指令，缓存会向源服务器进行有效期确认后处理资源；no-store 指令才是真正的不进行缓存。</p><h6 id="指定缓存期限和认证的指令"><a href="#指定缓存期限和认证的指令" class="headerlink" title="指定缓存期限和认证的指令"></a>指定缓存期限和认证的指令</h6><p><strong>s-maxage 指令</strong><br> <code>Cache-Control: s-maxage=604800（单位：秒）</code></p><ul><li>s-maxage 指令的功能和 max-age 指令的相同，它们的不同点是 s-maxage 指令只适用于供多位用户使用的公共缓存服务器（一般指代理）。也就是说，对于向同一用户重复返回响应的服务器来说，这个指令没有任何作用。</li><li>另外，当使用 s-maxage 指令后，则直接忽略对 Expires 首部字段及 max-age 指令的处理。</li></ul><p><strong>max-age 指令</strong><br> <code>Cache-Control: max-age=604800（单位：秒）</code></p><ul><li>当客户端发送的请求中包含 max-age 指令时，如果判定缓存资源的缓存时间数值比指定的时间更小，那么客户端就接收缓存的资源。另外，当指定 max-age 的值为0，那么缓存服务器通常需要将请求转发给源服务器。</li><li>当服务器返回的响应中包含 max-age 指令时，缓存服务器将不对资源的有效性再作确认，而 max-age 数值代表资源保存为缓存的最长时间。</li><li>应用 HTTP/1.1 版本的缓存服务器遇到同时存在 Expires 首部字段的情况时，会优先处理 max-age 指令，并忽略掉 Expires 首部字段；而 HTTP/1.0 版本的缓存服务器则相反。</li></ul><p><strong>min-fresh 指令</strong><br> <code>Cache-Control: min-fresh=60（单位：秒）</code><br> min-fresh 指令要求缓存服务器返回至少还未过指定时间的缓存资源。</p><p><strong>max-stale 指令</strong><br> <code>Cache-Control: max-stale=3600（单位：秒）</code></p><ul><li>使用 max-stale 可指示缓存资源，即使过期也照常接收。</li><li>如果指令未指定参数值，那么无论经过多久，客户端都会接收响应；如果指定了具体参数值，那么即使过期，只要仍处于 max-stale 指定的时间内，仍旧会被客户端接收。</li></ul><p><strong>only-if-cached 指令</strong><br> <code>Cache-Control: only-if-cached</code><br> 表示客户端仅在缓存服务器本地缓存目标资源的情况下才会要求其返回。换言之，该指令要求缓存服务器不重新加载响应，也不会再次确认资源的有效性。</p><p><strong>must-revalidate 指令</strong><br> <code>Cache-Control: must-revalidate</code><br> 使用 must-revalidate 指令，代理会向源服务器再次验证即将返回的响应缓存目前是否仍有效。另外，使用 must-revalidate 指令会忽略请求的 max-stale 指令。</p><p><strong>proxy-revalidate 指令</strong><br> <code>Cache-Control: proxy-revalidate</code><br> proxy-revalidate 指令要求所有的缓存服务器在接收到客户端带有该指令的请求返回响应之前，必须再次验证缓存的有效性。</p><p><strong>no-transform 指令</strong><br> <code>Cache-Control: no-transform</code><br> 使用 no-transform 指令规定无论是在请求还是响应中，缓存都不能改变实体主体的媒体类型。这样做可防止缓存或代理压缩图片等类似操作。</p><h6 id="Cache-Control-扩展"><a href="#Cache-Control-扩展" class="headerlink" title="Cache-Control 扩展"></a>Cache-Control 扩展</h6><p><code>Cache-Control: private, community=&quot;UCI&quot;</code><br> 通过 cache-extension 标记（token），可以扩展 Cache-Control 首部字段内的指令。上述 community 指令即扩展的指令，如果缓存服务器不能理解这个新指令，就会直接忽略掉。</p><h5 id="Connection"><a href="#Connection" class="headerlink" title="Connection"></a>Connection</h5><p>Connection 首部字段具备以下两个作用：</p><p><strong>控制不再转发的首部字段</strong><br> <code>Connection: Upgrade</code><br> 在客户端发送请求和服务器返回响应中，使用 Connection 首部字段，可控制不再转发给代理的首部字段，即删除后再转发（即Hop-by-hop首部）。</p><p><strong>管理持久连接</strong><br> <code>Connection: close</code><br> HTTP/1.1 版本的默认连接都是持久连接。当服务器端想明确断开连接时，则指定 Connection 首部字段的值为 close。<br> <code>Connection: Keep-Alive</code><br> HTTP/1.1 之前的 HTTP 版本的默认连接都是非持久连接。为此，如果想在旧版本的 HTTP 协议上维持持续连接，则需要指定 Connection 首部字段的值为 Keep-Alive。</p><h5 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h5><p>表明创建 HTTP 报文的日期和时间。<br> <code>Date: Mon, 10 Jul 2017 15:50:06 GMT</code><br> HTTP/1.1 协议使用在 RFC1123 中规定的日期时间的格式。</p><h5 id="Pragma"><a href="#Pragma" class="headerlink" title="Pragma"></a>Pragma</h5><p>Pragma 首部字段是 HTTP/1.1 版本之前的历史遗留字段，仅作为与 HTTP/1.0 的向后兼容而定义。<br> <code>Pragma: no-cache</code></p><ul><li>该首部字段属于通用首部字段，但只用在客户端发送的请求中，要求所有的中间服务器不返回缓存的资源。</li><li>所有的中间服务器如果都能以 HTTP/1.1 为基准，那直接采用 <code>Cache-Control: no-cache</code> 指定缓存的处理方式最为理想。但是要整体掌握所有中间服务器使用的 HTTP 协议版本却是不现实的，所以，发送的请求会同时包含下面两个首部字段：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: no-cache</span><br><span class="line">Pragma: no-cache</span><br></pre></td></tr></table></figure><h5 id="Trailer"><a href="#Trailer" class="headerlink" title="Trailer"></a>Trailer</h5><p><code>Trailer: Expires</code><br> 首部字段 Trailer 会事先说明在报文主体后记录了哪些首部字段。可应用在 HTTP/1.1 版本分块传输编码时。</p><h5 id="Transfer-Encoding"><a href="#Transfer-Encoding" class="headerlink" title="Transfer-Encoding"></a>Transfer-Encoding</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Transfer-Encoding: chunked</span><br></pre></td></tr></table></figure><ul><li>规定了传输报文主体时采用的编码方式。</li><li>HTTP/1.1 的传输编码方式仅对分块传输编码有效。</li></ul><h5 id="Upgrade"><a href="#Upgrade" class="headerlink" title="Upgrade"></a>Upgrade</h5><p><code>Upgrade: TSL/1.0</code><br> 用于检测 HTTP 协议及其他协议是否可使用更高的版本进行通信，其参数值可以用来指定一个完全不同的通信协议。</p><h5 id="Via"><a href="#Via" class="headerlink" title="Via"></a>Via</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Via: 1.1 a1.sample.com(Squid/2.7)</span><br></pre></td></tr></table></figure><ul><li>为了追踪客户端和服务器端之间的请求和响应报文的传输路径。</li><li>报文经过代理或网关时，会现在首部字段 Via 中附加该服务器的信息，然后再进行转发。</li><li>首部字段 Via 不仅用于追踪报文的转发，还可避免请求回环的发生。</li></ul><h5 id="Warning"><a href="#Warning" class="headerlink" title="Warning"></a>Warning</h5><p>该首部字段通常会告知用户一些与缓存相关的问题的警告。<br> Warning 首部字段的格式如下：<br> <code>Warning：[警告码][警告的主机:端口号] &quot;[警告内容]&quot;([日期时间])</code><br> 最后的日期时间可省略。<br> HTTP/1.1 中定义了7种警告，警告码对应的警告内容仅推荐参考，另外，警告码具备扩展性，今后有可能追加新的警告码。</p><table><thead><tr><th>警告码</th><th>警告内容</th><th>说明</th></tr></thead><tbody><tr><td>110</td><td>Response is stale(响应已过期)</td><td>代理返回已过期的资源</td></tr><tr><td>111</td><td>Revalidation failed(再验证失败)</td><td>代理再验证资源有效性时失败（服务器无法到达等原因）</td></tr><tr><td>112</td><td>Disconnection operation(断开连接操作)</td><td>代理与互联网连接被故意切断</td></tr><tr><td>113</td><td>Heuristic expiration(试探性过期)</td><td>响应的试用期超过24小时(有效缓存的设定时间大于24小时的情况下)</td></tr><tr><td>199</td><td>Miscellaneous warning(杂项警告)</td><td>任意的警告内容</td></tr><tr><td>214</td><td>Transformation applied(使用了转换)</td><td>代理对内容编码或媒体类型等执行了某些处理时</td></tr><tr><td>299</td><td>Miscellaneous persistent warning(持久杂项警告)</td><td>任意的警告内容</td></tr></tbody></table><h4 id="请求首部字段（HTTP-1-1）"><a href="#请求首部字段（HTTP-1-1）" class="headerlink" title="请求首部字段（HTTP/1.1）"></a>请求首部字段（HTTP/1.1）</h4><table><thead><tr><th>首部字段名</th><th>说明</th></tr></thead><tbody><tr><td>Accept</td><td>用户代理可处理的媒体类型</td></tr><tr><td>Accept-Charset</td><td>优先的字符集</td></tr><tr><td>Accept-Encoding</td><td>优先的内容编码</td></tr><tr><td>Accept-Language</td><td>优先的语言（自然语言）</td></tr><tr><td>Authorization</td><td>Web认证信息</td></tr><tr><td>Expect</td><td>期待服务器的特定行为</td></tr><tr><td>From</td><td>用户的电子邮箱地址</td></tr><tr><td>Host</td><td>请求资源所在服务器</td></tr><tr><td>If-Match</td><td>比较实体标记（ETag）</td></tr><tr><td>If-Modified-Since</td><td>比较资源的更新时间</td></tr><tr><td>If-None-Match</td><td>比较实体标记（与 If-Macth 相反）</td></tr><tr><td>If-Range</td><td>资源未更新时发送实体 Byte 的范围请求</td></tr><tr><td>If-Unmodified-Since</td><td>比较资源的更新时间(与 If-Modified-Since 相反)</td></tr><tr><td>Max-Forwards</td><td>最大传输逐跳数</td></tr><tr><td>Proxy-Authorization</td><td>代理服务器要求客户端的认证信息</td></tr><tr><td>Range</td><td>实体的字节范围请求</td></tr><tr><td>Referer</td><td>对请求中 URI 的原始获取方</td></tr><tr><td>TE</td><td>传输编码的优先级</td></tr><tr><td>User-Agent</td><td>HTTP 客户端程序的信息</td></tr></tbody></table><h5 id="Accept"><a href="#Accept" class="headerlink" title="Accept"></a>Accept</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Accept: text/html, application/xhtml+xml, application/xml; q=0.5</span><br></pre></td></tr></table></figure><ul><li>Accept 首部字段可通知服务器，用户代理能够处理的媒体类型及媒体类型的相对优先级。可使用 type/subtype 这种形式，一次指定多种媒体类型。</li><li>若想要给显示的媒体类型增加优先级，则使用 <code>q=[数值]</code> 来表示权重值，用分号（;）进行分隔。权重值的范围 0~1（可精确到小数点后三位），且 1 为最大值。不指定权重值时，默认为 1。</li></ul><h5 id="Accept-Charset"><a href="#Accept-Charset" class="headerlink" title="Accept-Charset"></a>Accept-Charset</h5><p><code>Accept-Charset: iso-8859-5, unicode-1-1; q=0.8</code><br> Accept-Charset 首部字段可用来通知服务器用户代理支持的字符集及字符集的相对优先顺序。另外，可一次性指定多种字符集。同样使用 <code>q=[数值]</code> 来表示相对优先级。</p><h5 id="Accept-Encoding"><a href="#Accept-Encoding" class="headerlink" title="Accept-Encoding"></a>Accept-Encoding</h5><p><code>Accept-Encoding: gzip, deflate</code><br> Accept-Encoding 首部字段用来告知服务器用户代理支持的内容编码及内容编码的优先顺序，并可一次性指定多种内容编码。同样使用 <code>q=[数值]</code> 来表示相对优先级。也可使用星号（*）作为通配符，指定任意的编码格式。</p><h5 id="Accept-Language"><a href="#Accept-Language" class="headerlink" title="Accept-Language"></a>Accept-Language</h5><p><code>Accept-Lanuage: zh-cn,zh;q=0.7,en=us,en;q=0.3</code><br> 告知服务器用户代理能够处理的自然语言集（指中文或英文等），以及自然语言集的相对优先级，可一次性指定多种自然语言集。同样使用 <code>q=[数值]</code> 来表示相对优先级。</p><h5 id="Authorization"><a href="#Authorization" class="headerlink" title="Authorization"></a>Authorization</h5><p><code>Authorization: Basic ldfKDHKfkDdasSAEdasd==</code><br> 告知服务器用户代理的认证信息（证书值）。通常，想要通过服务器认证的用户代理会在接收到返回的 401 状态码响应后，把首部字段 Authorization 加入请求中。共用缓存在接收到含有 Authorization 首部字段的请求时的操作处理会略有差异。</p><h5 id="Expect"><a href="#Expect" class="headerlink" title="Expect"></a>Expect</h5><p><code>Expect: 100-continue</code><br> 告知服务器客户端期望出现的某种特定行为。</p><h5 id="5-7-From"><a href="#5-7-From" class="headerlink" title="5.7 From"></a>5.7 From</h5><p><code>From: Deeson_Woo@163.com</code><br> 告知服务器使用用户代理的电子邮件地址。</p><h5 id="Host"><a href="#Host" class="headerlink" title="Host"></a>Host</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Host: www.jianshu.com</span><br></pre></td></tr></table></figure><ul><li>告知服务器，请求的资源所处的互联网主机和端口号。</li><li><strong>Host 首部字段是 HTTP/1.1 规范内唯一一个必须被包含在请求内的首部字段。</strong></li><li>若服务器未设定主机名，那直接发送一个空值即可  <code>Host:</code> 。</li></ul><h5 id="If-Match"><a href="#If-Match" class="headerlink" title="If-Match"></a>If-Match</h5><p>形如 If-xxx 这种样式的请求首部字段，都可称为条件请求。服务器接收到附带条件的请求后，只有判断指定条件为真时，才会执行请求。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">If-Match: &quot;123456&quot;</span><br></pre></td></tr></table></figure><ul><li>首部字段 If-Match，属附带条件之一，它会告知服务器匹配资源所用的实体标记（ETag）值。这时的服务器无法使用弱 ETag 值。</li><li>服务器会比对 If-Match 的字段值和资源的 ETag 值，仅当两者一致时，才会执行请求。反之，则返回状态码 <code>412 Precondition Failed</code> 的响应。</li><li>还可以使用星号（*）指定 If-Match 的字段值。针对这种情况，服务器将会忽略 ETag 的值，只要资源存在就处理请求。</li></ul><h5 id="If-Modified-Since"><a href="#If-Modified-Since" class="headerlink" title="If-Modified-Since"></a>If-Modified-Since</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">If-Modified-Since: Mon, 10 Jul 2017 15:50:06 GMT</span><br></pre></td></tr></table></figure><ul><li>首部字段 If-Modified-Since，属附带条件之一，用于确认代理或客户端拥有的本地资源的有效性。</li><li>它会告知服务器若 If-Modified-Since 字段值早于资源的更新时间，则希望能处理该请求。而在指定 If-Modified-Since 字段值的日期时间之后，如果请求的资源都没有过更新，则返回状态码 <code>304 Not Modified</code> 的响应。</li></ul><h5 id="If-None-Match"><a href="#If-None-Match" class="headerlink" title="If-None-Match"></a>If-None-Match</h5><p><code>If-None-Match: &quot;123456&quot;</code><br> 首部字段 If-None-Match 属于附带条件之一。它和首部字段 If-Match 作用相反。用于指定 If-None-Match 字段值的实体标记（ETag）值与请求资源的 ETag 不一致时，它就告知服务器处理该请求。</p><h5 id="If-Range"><a href="#If-Range" class="headerlink" title="If-Range"></a>If-Range</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">If-Range: &quot;123456&quot;</span><br></pre></td></tr></table></figure><ul><li>首部字段 If-Range 属于附带条件之一。它告知服务器若指定的 If-Range 字段值（ETag 值或者时间）和请求资源的 ETag 值或时间相一致时，则作为范围请求处理。反之，则返回全体资源。</li><li>下面我们思考一下不使用首部字段 If-Range 发送请求的情况。服务器端的资源如果更新，那客户端持有资源中的一部分也会随之无效，当然，范围请求作为前提是无效的。这时，服务器会暂且以状态码 <code>412 Precondition Failed</code> 作为响应返回，其目的是催促客户端再次发送请求。这样一来，与使用首部字段 If-Range 比起来，就需要花费两倍的功夫。</li></ul><h5 id="If-Unmodified-Since"><a href="#If-Unmodified-Since" class="headerlink" title="If-Unmodified-Since"></a>If-Unmodified-Since</h5><p><code>If-Unmodified-Since: Mon, 10 Jul 2017 15:50:06 GMT</code><br> 首部字段 If-Unmodified-Since 和首部字段 If-Modified-Since 的作用相反。它的作用的是告知服务器，指定的请求资源只有在字段值内指定的日期时间之后，未发生更新的情况下，才能处理请求。如果在指定日期时间后发生了更新，则以状态码 <code>412 Precondition Failed</code> 作为响应返回。</p><h5 id="Max-Forwards"><a href="#Max-Forwards" class="headerlink" title="Max-Forwards"></a>Max-Forwards</h5><p><code>Max-Forwards: 10</code><br> 通过 TRACE 方法或 OPTIONS 方法，发送包含首部字段 Max-Forwards 的请求时，该字段以十进制整数形式指定可经过的服务器最大数目。服务器在往下一个服务器转发请求之前，Max-Forwards 的值减 1 后重新赋值。当服务器接收到 Max-Forwards 值为 0 的请求时，则不再进行转发，而是直接返回响应。</p><h5 id="Proxy-Authorization"><a href="#Proxy-Authorization" class="headerlink" title="Proxy-Authorization"></a>Proxy-Authorization</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Proxy-Authorization: Basic dGlwOjkpNLAGfFY5</span><br></pre></td></tr></table></figure><ul><li>接收到从代理服务器发来的认证质询时，客户端会发送包含首部字段 Proxy-Authorization 的请求，以告知服务器认证所需要的信息。</li><li>这个行为是与客户端和服务器之间的 HTTP 访问认证相类似的，不同之处在于，认证行为发生在客户端与代理之间。</li></ul><h5 id="Range"><a href="#Range" class="headerlink" title="Range"></a>Range</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Range: bytes=5001-10000</span><br></pre></td></tr></table></figure><ul><li>对于只需获取部分资源的范围请求，包含首部字段 Range 即可告知服务器资源的指定范围。</li><li>接收到附带 Range 首部字段请求的服务器，会在处理请求之后返回状态码为 <code>206 Partial Content</code> 的响应。无法处理该范围请求时，则会返回状态码 <code>200 OK</code> 的响应及全部资源。</li></ul><h5 id="Referer"><a href="#Referer" class="headerlink" title="Referer"></a>Referer</h5><p><code>Referer: http://www.sample.com/index.html</code><br> 首部字段 Referer 会告知服务器请求的原始资源的 URI。</p><h5 id="TE"><a href="#TE" class="headerlink" title="TE"></a>TE</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TE: gzip, deflate; q=0.5</span><br></pre></td></tr></table></figure><ul><li>首部字段 TE 会告知服务器客户端能够处理响应的传输编码方式及相对优先级。它和首部字段 Accept-Encoding 的功能很相像，但是用于传输编码。</li><li>首部字段 TE 除指定传输编码之外，还可以指定伴随 trailer 字段的分块传输编码的方式。应用后者时，只需把 trailers 赋值给该字段值。<code>TE: trailers</code> </li></ul><h5 id="User-Agent"><a href="#User-Agent" class="headerlink" title="User-Agent"></a>User-Agent</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64; rv:13.0) Gecko/20100101</span><br></pre></td></tr></table></figure><ul><li>首部字段 User-Agent 会将创建请求的浏览器和用户代理名称等信息传达给服务器。</li><li>由网络爬虫发起请求时，有可能会在字段内添加爬虫作者的电子邮件地址。此外，如果请求经过代理，那么中间也很可能被添加上代理服务器的名称。</li></ul><h4 id="响应首部字段（HTTP-1-1）"><a href="#响应首部字段（HTTP-1-1）" class="headerlink" title="响应首部字段（HTTP/1.1）"></a>响应首部字段（HTTP/1.1）</h4><table><thead><tr><th>首部字段名</th><th>说明</th></tr></thead><tbody><tr><td>Accept-Ranges</td><td>是否接受字节范围请求</td></tr><tr><td>Age</td><td>推算资源创建经过时间</td></tr><tr><td>ETag</td><td>资源的匹配信息</td></tr><tr><td>Location</td><td>令客户端重定向至指定 URI</td></tr><tr><td>Proxy-Authenticate</td><td>代理服务器对客户端的认证信息</td></tr><tr><td>Retry-After</td><td>对再次发起请求的时机要求</td></tr><tr><td>Server</td><td>HTTP 服务器的安装信息</td></tr><tr><td>Vary</td><td>代理服务器缓存的管理信息</td></tr><tr><td>WWW-Authenticate</td><td>服务器对客户端的认证信息</td></tr></tbody></table><h5 id="Accept-Ranges"><a href="#Accept-Ranges" class="headerlink" title="Accept-Ranges"></a>Accept-Ranges</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Accept-Ranges: bytes</span><br></pre></td></tr></table></figure><ul><li>首部字段 Accept-Ranges 是用来告知客户端服务器是否能处理范围请求，以指定获取服务器端某个部分的资源。</li><li>可指定的字段值有两种，可处理范围请求时指定其为 bytes，反之则指定其为 none。</li></ul><h5 id="Age"><a href="#Age" class="headerlink" title="Age"></a>Age</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Age: 1200</span><br></pre></td></tr></table></figure><ul><li>首部字段 Age 能告知客户端，源服务器在多久前创建了响应。字段值的单位为秒。</li><li>若创建该响应的服务器是缓存服务器，Age 值是指缓存后的响应再次发起认证到认证完成的时间值。代理创建响应时必须加上首部字段 Age。</li></ul><h5 id="ETag"><a href="#ETag" class="headerlink" title="ETag"></a>ETag</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ETag: &quot;usagi-1234&quot;</span><br></pre></td></tr></table></figure><ul><li>首部字段 ETag 能告知客户端实体标识。它是一种可将资源以字符串形式做唯一性标识的方式。服务器会为每份资源分配对应的 ETag 值。</li><li>另外，当资源更新时，ETag 值也需要更新。生成 ETag 值时，并没有统一的算法规则，而仅仅是由服务器来分配。</li><li>ETag 中有强 ETag 值和弱 ETag 值之分。强 ETag 值，不论实体发生多么细微的变化都会改变其值；弱 ETag 值只用于提示资源是否相同。只有资源发生了根本改变，产生差异时才会改变 ETag 值。这时，会在字段值最开始处附加 W/： <code>ETag: W/&quot;usagi-1234&quot;</code>。</li></ul><h5 id="Location"><a href="#Location" class="headerlink" title="Location"></a>Location</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Location: http://www.sample.com/sample.html</span><br></pre></td></tr></table></figure><ul><li>使用首部字段 Location 可以将响应接收方引导至某个与请求 URI 位置不同的资源。</li><li>基本上，该字段会配合 3xx ：Redirection 的响应，提供重定向的 URI。</li><li>几乎所有的浏览器在接收到包含首部字段 Location 的响应后，都会强制性地尝试对已提示的重定向资源的访问。</li></ul><h5 id="Proxy-Authenticate"><a href="#Proxy-Authenticate" class="headerlink" title="Proxy-Authenticate"></a>Proxy-Authenticate</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Proxy-Authenticate: Basic realm=&quot;Usagidesign Auth&quot;</span><br></pre></td></tr></table></figure><ul><li>首部字段 Proxy-Authenticate 会把由代理服务器所要求的认证信息发送给客户端。</li><li>它与客户端和服务器之间的 HTTP 访问认证的行为相似，不同之处在于其认证行为是在客户端与代理之间进行的。</li></ul><h5 id="Retry-After"><a href="#Retry-After" class="headerlink" title="Retry-After"></a>Retry-After</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Retry-After: 180</span><br></pre></td></tr></table></figure><ul><li>首部字段 Retry-After 告知客户端应该在多久之后再次发送请求。主要配合状态码 <code>503 Service Unavailable</code> 响应，或 3xx Redirect 响应一起使用。</li><li>字段值可以指定为具体的日期时间（Mon, 10 Jul 2017 15:50:06 GMT 等格式），也可以是创建响应后的秒数。</li></ul><h5 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h5><p><code>Server: Apache/2.2.6 (Unix) PHP/5.2.5</code><br> 首部字段 Server 告知客户端当前服务器上安装的 HTTP 服务器应用程序的信息。不单单会标出服务器上的软件应用名称，还有可能包括版本号和安装时启用的可选项。</p><h5 id="Vary"><a href="#Vary" class="headerlink" title="Vary"></a>Vary</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vary: Accept-Language</span><br></pre></td></tr></table></figure><ul><li>首部字段 Vary 可对缓存进行控制。源服务器会向代理服务器传达关于本地缓存使用方法的命令。</li><li>从代理服务器接收到源服务器返回包含 Vary 指定项的响应之后，若再要进行缓存，仅对请求中含有相同 Vary 指定首部字段的请求返回缓存。即使对相同资源发起请求，但由于 Vary 指定的首部字段不相同，因此必须要从源服务器重新获取资源。</li></ul><h5 id="WWW-Authenticate"><a href="#WWW-Authenticate" class="headerlink" title="WWW-Authenticate"></a>WWW-Authenticate</h5><p><code>WWW-Authenticate: Basic realm=&quot;Usagidesign Auth&quot;</code><br> 首部字段 WWW-Authenticate 用于 HTTP 访问认证。它会告知客户端适用于访问请求 URI 所指定资源的认证方案（Basic 或是 Digest）和带参数提示的质询（challenge）。</p><h4 id="实体首部字段（HTTP-1-1）"><a href="#实体首部字段（HTTP-1-1）" class="headerlink" title="实体首部字段（HTTP/1.1）"></a>实体首部字段（HTTP/1.1）</h4><table><thead><tr><th>首部字段名</th><th>说明</th></tr></thead><tbody><tr><td>Allow</td><td>资源可支持的 HTTP 方法</td></tr><tr><td>Content-Encoding</td><td>实体主体适用的编码方式</td></tr><tr><td>Content-Language</td><td>实体主体的自然语言</td></tr><tr><td>Content-Length</td><td>实体主体的大小（单位：字节）</td></tr><tr><td>Content-Location</td><td>替代对应资源的 URI</td></tr><tr><td>Content-MD5</td><td>实体主体的报文摘要</td></tr><tr><td>Content-Range</td><td>实体主体的位置范围</td></tr><tr><td>Content-Type</td><td>实体主体的媒体类型</td></tr><tr><td>Expires</td><td>实体主体过期的日期时间</td></tr><tr><td>Last-Modified</td><td>资源的最后修改日期时间</td></tr></tbody></table><h5 id="Allow"><a href="#Allow" class="headerlink" title="Allow"></a>Allow</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Allow: GET, HEAD</span><br></pre></td></tr></table></figure><ul><li>首部字段 Allow 用于通知客户端能够支持 Request-URI 指定资源的所有 HTTP 方法。</li><li>当服务器接收到不支持的 HTTP 方法时，会以状态码 <code>405 Method Not Allowed</code> 作为响应返回。与此同时，还会把所有能支持的 HTTP 方法写入首部字段 Allow 后返回。</li></ul><h5 id="Content-Encoding"><a href="#Content-Encoding" class="headerlink" title="Content-Encoding"></a>Content-Encoding</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Encoding: gzip</span><br></pre></td></tr></table></figure><ul><li>首部字段 Content-Encoding 会告知客户端服务器对实体的主体部分选用的内容编码方式。内容编码是指在不丢失实体信息的前提下所进行的压缩。</li><li>主要采用这 4 种内容编码的方式（gzip、compress、deflate、identity）。</li></ul><h5 id="Content-Language"><a href="#Content-Language" class="headerlink" title="Content-Language"></a>Content-Language</h5><p><code>Content-Language: zh-CN</code><br> 首部字段 Content-Language 会告知客户端，实体主体使用的自然语言（指中文或英文等语言）。</p><h5 id="Content-Length"><a href="#Content-Length" class="headerlink" title="Content-Length"></a>Content-Length</h5><p><code>Content-Length: 15000</code><br> 首部字段 Content-Length 表明了实体主体部分的大小（单位是字节）。对实体主体进行内容编码传输时，不能再使用 Content-Length首部字段。</p><h5 id="Content-Location"><a href="#Content-Location" class="headerlink" title="Content-Location"></a>Content-Location</h5><p><code>Content-Location: http://www.sample.com/index.html</code><br> 首部字段 Content-Location 给出与报文主体部分相对应的 URI。和首部字段 Location 不同，Content-Location 表示的是报文主体返回资源对应的 URI。</p><h5 id="Content-MD5"><a href="#Content-MD5" class="headerlink" title="Content-MD5"></a>Content-MD5</h5><p><code>Content-MD5: OGFkZDUwNGVhNGY3N2MxMDIwZmQ4NTBmY2IyTY==</code><br> 首部字段 Content-MD5 是一串由 MD5 算法生成的值，其目的在于检查报文主体在传输过程中是否保持完整，以及确认传输到达。</p><h5 id="Content-Range"><a href="#Content-Range" class="headerlink" title="Content-Range"></a>Content-Range</h5><p><code>Content-Range: bytes 5001-10000/10000</code><br> 针对范围请求，返回响应时使用的首部字段 Content-Range，能告知客户端作为响应返回的实体的哪个部分符合范围请求。字段值以字节为单位，表示当前发送部分及整个实体大小。</p><h5 id="Content-Type"><a href="#Content-Type" class="headerlink" title="Content-Type"></a>Content-Type</h5><p><code>Content-Type: text/html; charset=UTF-8</code><br> 首部字段 Content-Type 说明了实体主体内对象的媒体类型。和首部字段 Accept 一样，字段值用 type/subtype 形式赋值。参数 charset 使用 iso-8859-1 或 euc-jp 等字符集进行赋值。</p><h5 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Expires: Mon, 10 Jul 2017 15:50:06 GMT</span><br></pre></td></tr></table></figure><ul><li>首部字段 Expires 会将资源失效的日期告知客户端。</li><li>缓存服务器在接收到含有首部字段 Expires 的响应后，会以缓存来应答请求，在 Expires 字段值指定的时间之前，响应的副本会一直被保存。当超过指定的时间后，缓存服务器在请求发送过来时，会转向源服务器请求资源。</li><li>源服务器不希望缓存服务器对资源缓存时，最好在 Expires 字段内写入与首部字段 Date 相同的时间值。</li></ul><h5 id="Last-Modified"><a href="#Last-Modified" class="headerlink" title="Last-Modified"></a>Last-Modified</h5><p><code>Last-Modified: Mon, 10 Jul 2017 15:50:06 GMT</code><br> 首部字段 Last-Modified 指明资源最终修改的时间。一般来说，这个值就是 Request-URI 指定资源被修改的时间。但类似使用 CGI 脚本进行动态数据处理时，该值有可能会变成数据最终修改时的时间。</p><h4 id="为-Cookie-服务的首部字段"><a href="#为-Cookie-服务的首部字段" class="headerlink" title="为 Cookie 服务的首部字段"></a>为 Cookie 服务的首部字段</h4><table><thead><tr><th>首部字段名</th><th>说明</th><th>首部类型</th></tr></thead><tbody><tr><td>Set-Cookie</td><td>开始状态管理所使用的 Cookie 信息</td><td>响应首部字段</td></tr><tr><td>Cookie</td><td>服务器接收到的 Cookie 信息</td><td>请求首部字段</td></tr></tbody></table><h5 id="Set-Cookie"><a href="#Set-Cookie" class="headerlink" title="Set-Cookie"></a>Set-Cookie</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-Cookie: status=enable; expires=Mon, 10 Jul 2017 15:50:06 GMT; path=/;</span><br></pre></td></tr></table></figure><p>下面的表格列举了 Set-Cookie 的字段值。</p><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>NAME=VALUE</td><td>赋予 Cookie 的名称和其值（必需项）</td></tr><tr><td>expires=DATE</td><td>Cookie 的有效期（若不明确指定则默认为浏览器关闭前为止）</td></tr><tr><td>path=PATH</td><td>将服务器上的文件目录作为Cookie的适用对象（若不指定则默认为文档所在的文件目录）</td></tr><tr><td>domain=域名</td><td>作为 Cookie 适用对象的域名 （若不指定则默认为创建 Cookie的服务器的域名）</td></tr><tr><td>Secure</td><td>仅在 HTTPS 安全通信时才会发送 Cookie</td></tr><tr><td>HttpOnly</td><td>加以限制，使 Cookie 不能被 JavaScript 脚本访问</td></tr></tbody></table><h6 id="expires-属性"><a href="#expires-属性" class="headerlink" title="expires 属性"></a>expires 属性</h6><ul><li>Cookie 的 expires 属性指定浏览器可发送 Cookie 的有效期。</li><li>当省略 expires 属性时，其有效期仅限于维持浏览器会话（Session）时间段内。这通常限于浏览器应用程序被关闭之前。</li><li>另外，一旦 Cookie 从服务器端发送至客户端，服务器端就不存在可以显式删除 Cookie 的方法。但可通过覆盖已过期的 Cookie，实现对客户端 Cookie 的实质性删除操作。</li></ul><h6 id="path-属性"><a href="#path-属性" class="headerlink" title="path 属性"></a>path 属性</h6><p>Cookie 的 path 属性可用于限制指定 Cookie 的发送范围的文件目录。</p><h6 id="domain-属性"><a href="#domain-属性" class="headerlink" title="domain 属性"></a>domain 属性</h6><ul><li>通过 Cookie 的 domain 属性指定的域名可做到与结尾匹配一致。比如，当指定 <a href="https://link.jianshu.com?t=http://example.com" target="_blank" rel="noopener">example.com</a> 后，除<a href="https://link.jianshu.com?t=http://example.com" target="_blank" rel="noopener">example.com</a> 以外，<a href="https://link.jianshu.com?t=http://www.example.com" target="_blank" rel="noopener">www.example.com</a> 或 <a href="https://link.jianshu.com?t=http://www2.example.com" target="_blank" rel="noopener">www2.example.com</a> 等都可以发送 Cookie。</li><li>因此，除了针对具体指定的多个域名发送 Cookie 之 外，不指定 domain 属性显得更安全。</li></ul><h6 id="secure-属性"><a href="#secure-属性" class="headerlink" title="secure 属性"></a>secure 属性</h6><p>Cookie 的 secure 属性用于限制 Web 页面仅在 HTTPS 安全连接时，才可以发送 Cookie。</p><h6 id="HttpOnly-属性"><a href="#HttpOnly-属性" class="headerlink" title="HttpOnly 属性"></a>HttpOnly 属性</h6><ul><li>Cookie 的 HttpOnly 属性是 Cookie 的扩展功能，它使 JavaScript 脚本无法获得 Cookie。其主要目的为防止跨站脚本攻击（Cross-site scripting，XSS）对 Cookie 的信息窃取。</li><li>通过上述设置，通常从 Web 页面内还可以对 Cookie 进行读取操作。但使用 JavaScript 的 document.cookie 就无法读取附加 HttpOnly 属性后的 Cookie 的内容了。因此，也就无法在 XSS 中利用 JavaScript 劫持 Cookie 了。</li></ul><h5 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h5><p><code>Cookie: status=enable</code><br> 首部字段 Cookie 会告知服务器，当客户端想获得 HTTP 状态管理支持时，就会在请求中包含从服务器接收到的 Cookie。接收到多个 Cookie 时，同样可以以多个 Cookie 形式发送。</p><h4 id="其他首部字段"><a href="#其他首部字段" class="headerlink" title="其他首部字段"></a>其他首部字段</h4><p>HTTP 首部字段是可以自行扩展的。所以在 Web 服务器和浏览器的应用上，会出现各种非标准的首部字段。<br> 以下是最为常用的首部字段。</p><h5 id="X-Frame-Options"><a href="#X-Frame-Options" class="headerlink" title="X-Frame-Options"></a>X-Frame-Options</h5><p><code>X-Frame-Options: DENY</code><br> 首部字段 X-Frame-Options 属于 HTTP 响应首部，用于控制网站内容在其他 Web 网站的 Frame 标签内的显示问题。其主要目的是为了防止点击劫持（clickjacking）攻击。首部字段 X-Frame-Options 有以下两个可指定的字段值：</p><ul><li>DENY：拒绝</li><li>SAMEORIGIN：仅同源域名下的页面（Top-level-browsing-context）匹配时许可。（比如，当指定 <a href="https://link.jianshu.com?t=http://sample.com/sample.html" target="_blank" rel="noopener">http://sample.com/sample.html</a> 页面为 SAMEORIGIN 时，那么 <a href="https://link.jianshu.com?t=http://sample.com" target="_blank" rel="noopener">sample.com</a> 上所有页面的 frame 都被允许可加载该页面，而 <a href="https://link.jianshu.com?t=http://example.com" target="_blank" rel="noopener">example.com</a> 等其他域名的页面就不行了）</li></ul><h5 id="X-XSS-Protection"><a href="#X-XSS-Protection" class="headerlink" title="X-XSS-Protection"></a>X-XSS-Protection</h5><p><code>X-XSS-Protection: 1</code><br> 首部字段 X-XSS-Protection 属于 HTTP 响应首部，它是针对跨站脚本攻击（XSS）的一种对策，用于控制浏览器 XSS 防护机制的开关。首部字段 X-XSS-Protection 可指定的字段值如下:</p><ul><li>0 ：将 XSS 过滤设置成无效状态</li><li>1 ：将 XSS 过滤设置成有效状态</li></ul><h5 id="DNT"><a href="#DNT" class="headerlink" title="DNT"></a>DNT</h5><p><code>DNT: 1</code><br> 首部字段 DNT 属于 HTTP 请求首部，其中 DNT 是 Do Not Track 的简称，意为拒绝个人信息被收集，是表示拒绝被精准广告追踪的一种方法。首部字段 DNT 可指定的字段值如下：</p><ul><li>0 ：同意被追踪</li><li>1 ：拒绝被追踪</li></ul><p>由于首部字段 DNT 的功能具备有效性，所以 Web 服务器需要对 DNT做对应的支持。</p><h5 id="P3P"><a href="#P3P" class="headerlink" title="P3P"></a>P3P</h5><p><code>P3P: CP=&quot;CAO DSP LAW CURa ADMa DEVa TAIa PSAa PSDa IVAa IVDa OUR BUS IND</code><br> 首部字段 P3P 属于 HTTP 响应首部，通过利用 P3P（The Platform for Privacy Preferences，在线隐私偏好平台）技术，可以让 Web 网站上的个人隐私变成一种仅供程序可理解的形式，以达到保护用户隐私的目的。<br> 要进行 P3P 的设定，需按以下操作步骤进行：</p><ul><li>步骤 1：创建 P3P 隐私</li><li>步骤 2：创建 P3P 隐私对照文件后，保存命名在 /w3c/p3p.xml</li><li>步骤 3：从 P3P 隐私中新建 Compact policies 后，输出到 HTTP 响应中</li></ul><h3 id="HTTP-响应状态码（重点分析）"><a href="#HTTP-响应状态码（重点分析）" class="headerlink" title="HTTP 响应状态码（重点分析）"></a>HTTP 响应状态码（重点分析）</h3><h4 id="状态码概述"><a href="#状态码概述" class="headerlink" title="状态码概述"></a>状态码概述</h4><ul><li>HTTP 状态码负责表示客户端 HTTP 请求的返回结果、标记服务器端的处理是否正常、通知出现的错误等工作。</li><li>HTTP 状态码如 <code>200 OK</code> ，以 3 位数字和原因短语组成。数字中的第一位指定了响应类别，后两位无分类。</li><li>不少返回的响应状态码都是错误的，但是用户可能察觉不到这点。比如 Web 应用程序内部发生错误，状态码依然返回 <code>200 OK</code>。</li></ul><h4 id="状态码类别"><a href="#状态码类别" class="headerlink" title="状态码类别"></a>状态码类别</h4><table><thead><tr><th></th><th>类别</th><th>原因短语</th></tr></thead><tbody><tr><td>1xx</td><td>Informational(信息性状态码)</td><td>接收的请求正在处理</td></tr><tr><td>2xx</td><td>Success(成功状态码)</td><td>请求正常处理完毕</td></tr><tr><td>3xx</td><td>Redirection(重定向状态码)</td><td>需要进行附加操作以完成请求</td></tr><tr><td>4xx</td><td>Client Error(客户端错误状态码)</td><td>服务器无法处理请求</td></tr><tr><td>5xx</td><td>Server Error(服务器错误状态码)</td><td>服务器处理请求出错</td></tr></tbody></table><p>我们可以自行改变 RFC2616 中定义的状态码或者服务器端自行创建状态码，只要遵守状态码的类别定义就可以了。</p><h4 id="常用状态码解析"><a href="#常用状态码解析" class="headerlink" title="常用状态码解析"></a>常用状态码解析</h4><p>HTTP 状态码种类繁多，数量达几十种。其中最常用的有以下 14 种，一起来看看。</p><h5 id="200-OK"><a href="#200-OK" class="headerlink" title="200 OK"></a>200 OK</h5><p>表示从客户端发来的请求在服务器端被正常处理了。</p><h5 id="204-No-Content"><a href="#204-No-Content" class="headerlink" title="204 No Content"></a>204 No Content</h5><ul><li>代表服务器接收的请求已成功处理，但在返回的响应报文中不含实体的主体部分。另外，也不允许返回任何实体的主体。</li><li>一般在只需要从客户端向服务器端发送消息，而服务器端不需要向客户端发送新消息内容的情况下使用。</li></ul><h5 id="206-Partial-Content"><a href="#206-Partial-Content" class="headerlink" title="206 Partial Content"></a>206 Partial Content</h5><p>表示客户端进行了范围请求，而服务器成功执行了这部分的 GET 请求。响应报文中包含由 Content-Range 首部字段指定范围的实体内容。</p><h5 id="301-Moved-Permanently"><a href="#301-Moved-Permanently" class="headerlink" title="301 Moved Permanently"></a>301 Moved Permanently</h5><p>永久性重定向。表示请求的资源已被分配了新的 URI。以后应使用资源现在所指的 URI。也就是说，如果已经把资源对应的 URI 保存为书签了，这时应该按 Location 首部字段提示的 URI 重新保存。</p><h5 id="302-Found"><a href="#302-Found" class="headerlink" title="302 Found"></a>302 Found</h5><ul><li>临时性重定向。表示请求的资源已被分配了新的 URI，希望用户（本次）能使用新的 URI 访问。</li><li>和 <code>301 Moved Permanently</code> 状态码相似，但 <code>302 Found</code> 状态码代表资源不是被永久移动，只是临时性质的。换句话说，已移动的资源对应的 URI 将来还有可能发生改变。</li></ul><h5 id="303-See-Other"><a href="#303-See-Other" class="headerlink" title="303 See Other"></a>303 See Other</h5><ul><li>表示由于请求的资源存在着另一个 URI，应使用 GET 方法定向获取请求的资源。</li><li><code>303 See Othe</code>r 和 <code>302 Found</code> 状态码有着相同的功能，但 <code>303 See Other</code> 状态码明确表示客户端应采用 GET 方法获取资源，这点与 <code>302 Found</code> 状态码有区别。</li></ul><h5 id="304-Not-Modified"><a href="#304-Not-Modified" class="headerlink" title="304 Not Modified"></a>304 Not Modified</h5><ul><li>表示客户端发送附带条件的请求时，服务器端允许请求访问的资源，但未满足条件的情况。</li><li><code>304 Not Modified</code> 状态码返回时，不包含任何响应的主体部分。</li><li><code>304 Not Modified</code> 虽然被划分到 3xx 类别中，但和重定向没有关系。</li></ul><h5 id="307-Temporary-Redirect"><a href="#307-Temporary-Redirect" class="headerlink" title="307 Temporary Redirect"></a>307 Temporary Redirect</h5><p>临时重定向。该状态码与 <code>302 Found</code> 有着相同的含义。</p><h5 id="400-Bad-Request"><a href="#400-Bad-Request" class="headerlink" title="400 Bad Request"></a>400 Bad Request</h5><ul><li>表示请求报文中存在语法错误。当错误发生时，需修改请求的内容后再次发送请求。</li><li>另外，浏览器会像 <code>200 OK</code> 一样对待该状态码。</li></ul><h5 id="401-Unauthorized"><a href="#401-Unauthorized" class="headerlink" title="401 Unauthorized"></a>401 Unauthorized</h5><ul><li>表示发送的请求需要有通过 HTTP 认证（BASIC 认证、DIGEST 认证）的认证信息。</li><li>另外，若之前已进行过 1 次请求，则表示用户认证失败。</li><li>返回含有 <code>401 Unauthorized</code> 的响应必须包含一个适用于被请求资源的 WWW-Authenticate 首部用以质询（challenge）用户信息。</li></ul><h5 id="403-Forbidden"><a href="#403-Forbidden" class="headerlink" title="403 Forbidden"></a>403 Forbidden</h5><p>表明对请求资源的访问被服务器拒绝了。服务器端没有必要给出详细的拒绝理由，当然也可以在响应报文的实体主体部分对原因进行描述。</p><h5 id="404-Not-Found"><a href="#404-Not-Found" class="headerlink" title="404 Not Found"></a>404 Not Found</h5><p>表明服务器上无法找到请求的资源。除此之外，也可以在服务器端拒绝请求且不想说明理由的时候使用。</p><h5 id="500-Internal-Server-Error"><a href="#500-Internal-Server-Error" class="headerlink" title="500 Internal Server Error"></a>500 Internal Server Error</h5><p>表明服务器端在执行请求时发生了错误。也可能是 Web 应用存在的 bug 或某些临时的故障。</p><h5 id="503-Service-Unavailable"><a href="#503-Service-Unavailable" class="headerlink" title="503 Service Unavailable"></a>503 Service Unavailable</h5><p>表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。如果事先得知解除以上状况需要的时间，最好写入 Retry-After 首部字段再返回给客户端。</p><h3 id="HTTP-报文实体"><a href="#HTTP-报文实体" class="headerlink" title="HTTP 报文实体"></a>HTTP 报文实体</h3><h4 id="HTTP-报文实体概述"><a href="#HTTP-报文实体概述" class="headerlink" title="HTTP 报文实体概述"></a>HTTP 报文实体概述</h4><p><img src="https://github.com/AlexBruceLu/DAPP/wiki/http13_1.webp" alt="HTTP 报文结构"></p><p>大家请仔细看看上面示例中，各个组成部分对应的内容。<br> 接着，我们来看看报文和实体的概念。如果把 HTTP 报文想象成因特网货运系统中的箱子，那么 HTTP 实体就是报文中实际的货物。</p><ul><li>报文：是网络中交换和传输的数据单元，即站点一次性要发送的数据块。报文包含了将要发送的完整的数据信息，其长短很不一致，长度不限且可变。</li><li>实体：作为请求或响应的有效载荷数据（补充项）被传输，其内容由实体首部和实体主体组成。（实体首部相关内容在上面第六点中已有阐述。）</li></ul><p>我们可以看到，上面示例右图中深红色框的内容就是报文的实体部分，而蓝色框的两部分内容分别就是实体首部和实体主体。而左图中粉红框内容就是报文主体。<br> <strong>通常，报文主体等于实体主体。只有当传输中进行编码操作时，实体主体的内容发生变化，才导致它和报文主体产生差异。</strong></p><h4 id="内容编码"><a href="#内容编码" class="headerlink" title="内容编码"></a>内容编码</h4><ul><li>HTTP 应用程序有时在发送之前需要对内容进行编码。例如，在把很大的 HTML 文档发送给通过慢速连接上来的客户端之前，服务器可能会对其进行压缩，这样有助于减少传输实体的时间。服务器还可以把内容搅乱或加密，以此来防止未授权的第三方看到文档的内容。</li><li>这种类型的编码是在发送方应用到内容之上的。当内容经过内容编码后，编好码的数据就放在实体主体中，像往常一样发送给接收方。</li></ul><p>内容编码类型：</p><table><thead><tr><th>编码方式</th><th>描述</th></tr></thead><tbody><tr><td>gzip</td><td>表明实体采用 GNU zip 编码</td></tr><tr><td>compress</td><td>表明实体采用 Unix 的文件压缩程序</td></tr><tr><td>deflate</td><td>表明实体采用 zlib 的格式压缩的</td></tr><tr><td>identity</td><td>表明没有对实体进行编码，当没有 Content-Encoding 首部字段时，默认采用此编码方式</td></tr></tbody></table><h4 id="传输编码"><a href="#传输编码" class="headerlink" title="传输编码"></a>传输编码</h4><p>内容编码是对报文的主体进行的可逆变换，是和内容的具体格式细节紧密相关的。<br> 传输编码也是作用在实体主体上的可逆变换，但使用它们是由于架构方面的原因，同内容的格式无关。使用传输编码是为了改变报文中的数据在网络上传输的方式。</p><p><img src="https://github.com/AlexBruceLu/DAPP/wiki/http13_3.webp" alt=""></p><h4 id="分块编码"><a href="#分块编码" class="headerlink" title="分块编码"></a>分块编码</h4><p>分块编码把报文分割成若干已知大小的块。块之间是紧挨着发送的，这样就不需要在发送之前知道整个报文的大小了。分块编码是一种传输编码，是报文的属性。</p><h5 id="分块编码与持久连接"><a href="#分块编码与持久连接" class="headerlink" title="分块编码与持久连接"></a><strong>分块编码与持久连接</strong></h5><p> 若客户端与服务器端之间不是持久连接，客户端就不需要知道它在读取的主体的长度，而只需要读取到服务器关闭主体连接为止。<br> 当使用持久连接时，在服务器写主体之前，必须知道它的大小并在 Content-Length 首部中发送。如果服务器动态创建内容，就可能在发送之前无法知道主体的长度。<br> 分块编码为这种困难提供了解决方案，只要允许服务器把主体分块发送，说明每块的大小就可以了。因为主体是动态创建的，服务器可以缓冲它的一部分，发送其大小和相应的块，然后在主体发送完之前重复这个过程。服务器可以用大小为 0 的块作为主体结束的信号，这样就可以继续保持连接，为下一个响应做准备。<br> 来看看一个分块编码的报文示例：</p><p><img src="https://github.com/AlexBruceLu/DAPP/wiki/http13_2.webp" alt=""></p><h4 id="多部分媒体类型"><a href="#多部分媒体类型" class="headerlink" title="多部分媒体类型"></a>多部分媒体类型</h4><p>MIME 中的 multipart（多部分）电子邮件报文中包含多个报文，它们合在一起作为单一的复杂报文发送。每一部分都是独立的，有各自的描述其内容的集，不同部分之间用分界字符串连接在一起。<br> 相应得，HTTP 协议中也采纳了多部分对象集合，发送的一份报文主体内可包含多种类型实体。<br> 多部分对象集合包含的对象如下：</p><ul><li>multipart/form-data：在 Web 表单文件上传时使用。</li><li>multipart/byteranges：状态码 <code>206 Partial Content</code> 响应报文包含了多个范围的内容时使用。</li></ul><h4 id="范围请求"><a href="#范围请求" class="headerlink" title="范围请求"></a>范围请求</h4><p>假设你正在下载一个很大的文件，已经下了四分之三，忽然网络中断了，那下载就必须重头再来一遍。为了解决这个问题，需要一种可恢复的机制，即能从之前下载中断处恢复下载。要实现该功能，这就要用到范围请求。<br> 有了范围请求， HTTP 客户端可以通过请求曾获取失败的实体的一个范围（或者说一部分），来恢复下载该实体。当然这有一个前提，那就是从客户端上一次请求该实体到这一次发出范围请求的时间段内，该对象没有改变过。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GET  /bigfile.html  HTTP/1.1</span><br><span class="line">Host: www.sample.com</span><br><span class="line">Range: bytes=20224-</span><br><span class="line">···</span><br></pre></td></tr></table></figure><p><img src="https://github.com/AlexBruceLu/DAPP/wiki/http13_4.webp" alt=""></p><p>上面示例中，客户端请求的是文档开头20224字节之后的部分。</p><h3 id="与-HTTP-协作的-Web-服务器"><a href="#与-HTTP-协作的-Web-服务器" class="headerlink" title="与 HTTP 协作的 Web 服务器"></a>与 HTTP 协作的 Web 服务器</h3><p>HTTP 通信时，除客户端和服务器外，还有一些用于协助通信的应用程序。如下列出比较重要的几个：<strong>代理、缓存、网关、隧道、Agent 代理</strong>。</p><h4 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h4><p><img src="https://github.com/AlexBruceLu/DAPP/wiki/http13_5.webp" alt=""></p><p>HTTP 代理服务器是 Web 安全、应用集成以及性能优化的重要组成模块。代理位于客户端和服务器端之间，接收客户端所有的 HTTP 请求，并将这些请求转发给服务器（可能会对请求进行修改之后再进行转发）。对用户来说，这些应用程序就是一个代理，代表用户访问服务器。<br> 出于安全考虑，通常会将代理作为转发所有 Web 流量的可信任中间节点使用。代理还可以对请求和响应进行过滤，安全上网或绿色上网。</p><h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h4><p><strong>浏览器第一次请求：</strong></p><p><img src="https://github.com/AlexBruceLu/DAPP/wiki/http13_6.webp" alt=""></p><p><strong>浏览器再次请求：</strong></p><p><img src="https://github.com/AlexBruceLu/DAPP/wiki/http13_7.webp" alt=""></p><p>Web 缓存或代理缓存是一种特殊的 HTTP 代理服务器，可以将经过代理传输的常用文档复制保存起来。下一个请求同一文档的客户端就可以享受缓存的私有副本所提供的服务了。客户端从附近的缓存下载文档会比从远程 Web 服务器下载快得多。</p><h4 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h4><p><img src="https://github.com/AlexBruceLu/DAPP/wiki/http13_8.webp" alt=""></p><p>网关是一种特殊的服务器，作为其他服务器的中间实体使用。通常用于将 HTTP 流量转换成其他的协议。网关接收请求时就好像自己是资源的源服务器一样。客户端可能并不知道自己正在跟一个网关进行通信。</p><h4 id="隧道"><a href="#隧道" class="headerlink" title="隧道"></a>隧道</h4><p><img src="https://github.com/AlexBruceLu/DAPP/wiki/http13_9.webp" alt=""></p><p>隧道是会在建立起来之后，就会在两条连接之间对原始数据进行盲转发的 HTTP 应用程序。HTTP 隧道通常用来在一条或多条 HTTP 连接上转发非 HTTP 数据，转发时不会窥探数据。<br> HTTP 隧道的一种常见用途就是通过 HTTP 连接承载加密的安全套接字层（SSL）流量，这样 SSL 流量就可以穿过只允许 Web 流量通过的防火墙了。</p><h4 id="Agent-代理"><a href="#Agent-代理" class="headerlink" title="Agent 代理"></a>Agent 代理</h4><p><img src="https://github.com/AlexBruceLu/DAPP/wiki/http13_10.webp" alt=""></p><p>Agent 代理是代表用户发起 HTTP 请求的客户端应用程序。所有发布 Web 请求的应用程序都是 HTTP Agent 代理。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt; 详解http协议：&lt;/strong&gt; &lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;/excerpt&gt;&lt;/p&gt;
&lt;p&gt;http网络协议的详解概述&lt;/p&gt;
    
    </summary>
    
      <category term="others" scheme="https://alexbrucelu.github.io/categories/others/"/>
    
    
      <category term="http/https" scheme="https://alexbrucelu.github.io/tags/http-https/"/>
    
  </entry>
  
  <entry>
    <title>http与https协议的区别</title>
    <link href="https://alexbrucelu.github.io/2018/12/03/http%E7%BD%91%E7%BB%9C/"/>
    <id>https://alexbrucelu.github.io/2018/12/03/http网络/</id>
    <published>2018-12-03T12:51:11.660Z</published>
    <updated>2018-12-05T07:45:45.513Z</updated>
    
    <content type="html"><![CDATA[<p><strong> http与https协议的区别：</strong> <excerpt in="" index="" |="" 首页摘要=""></excerpt></p><p>相关概念</p><a id="more"></a><p>[TOC]</p><p>超文本传输协议HTTP协议被用于在Web浏览器和网站服务器之间传递信息，HTTP协议以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此，HTTP协议不适合传输一些敏感信息，比如：信用卡号、密码等支付信息。</p><p>　　为了解决HTTP协议的这一缺陷，需要使用另一种协议：安全套接字层超文本传输协议HTTPS，为了数据传输的安全，HTTPS在HTTP的基础上加入了SSL协议，SSL依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。</p><h3 id="一、HTTP和HTTPS的基本概念"><a href="#一、HTTP和HTTPS的基本概念" class="headerlink" title="一、HTTP和HTTPS的基本概念"></a><strong>一、HTTP和HTTPS的基本概念</strong></h3><p>　　HTTP：是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。</p><p>　　HTTPS：是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。</p><p>　　HTTPS协议的主要作用可以分为两种：一种是建立一个信息安全通道，来保证数据传输的安全；另一种就是确认网站的真实性。</p><h3 id="二、HTTP与HTTPS有什么区别？"><a href="#二、HTTP与HTTPS有什么区别？" class="headerlink" title="二、HTTP与HTTPS有什么区别？"></a><strong>二、HTTP与HTTPS有什么区别？</strong></h3><p>　　HTTP协议传输的数据都是未加密的，也就是明文的，因此使用HTTP协议传输隐私信息非常不安全，为了保证这些隐私数据能加密传输，于是网景公司设计了SSL（Secure Sockets Layer）协议用于对HTTP协议传输的数据进行加密，从而就诞生了HTTPS。简单来说，HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全。</p><p>HTTPS和HTTP的区别主要如下：</p><p>　　1、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。</p><p>　　2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。</p><p>　　3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</p><p>　　4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</p><h3 id="三、HTTPS的工作原理"><a href="#三、HTTPS的工作原理" class="headerlink" title="三、HTTPS的工作原理"></a><strong>三、HTTPS的工作原理</strong></h3><p>　　我们都知道HTTPS能够加密信息，以免敏感信息被第三方获取，所以很多银行网站或电子邮箱等等安全级别较高的服务都会采用HTTPS协议。</p><p><img src="https://github.com/AlexBruceLu/DAPP/wiki/http1.jpg" alt=""></p><p>客户端在使用HTTPS方式与Web服务器通信时有以下几个步骤，如图所示。</p><p>　　（1）客户使用https的URL访问Web服务器，要求与Web服务器建立SSL连接。</p><p>　　（2）Web服务器收到客户端请求后，会将网站的证书信息（证书中包含公钥）传送一份给客户端。</p><p>　　（3）客户端的浏览器与Web服务器开始协商SSL连接的安全等级，也就是信息加密的等级。</p><p>　　（4）客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站。</p><p>　　（5）Web服务器利用自己的私钥解密出会话密钥。</p><p>　　（6）Web服务器利用会话密钥加密与客户端之间的通信。</p><p><img src="https://github.com/AlexBruceLU/DAPP/wiki/http2.gif" alt=""></p><h3 id="四、HTTPS的优点"><a href="#四、HTTPS的优点" class="headerlink" title="四、HTTPS的优点"></a><strong>四、HTTPS的优点</strong></h3><p>　　尽管HTTPS并非绝对安全，掌握根证书的机构、掌握加密算法的组织同样可以进行中间人形式的攻击，但HTTPS仍是现行架构下最安全的解决方案，主要有以下几个好处：</p><p>　　（1）使用HTTPS协议可认证用户和服务器，确保数据发送到正确的客户机和服务器；</p><p>　　（2）HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性。</p><p>　　（3）HTTPS是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。</p><p>　　（4）谷歌曾在2014年8月份调整搜索引擎算法，并称“比起同等HTTP网站，采用HTTPS加密的网站在搜索结果中的排名将会更高”。</p><h3 id="五、HTTPS的缺点"><a href="#五、HTTPS的缺点" class="headerlink" title="五、HTTPS的缺点"></a><strong>五、HTTPS的缺点</strong></h3><p>　　虽然说HTTPS有很大的优势，但其相对来说，还是存在不足之处的：</p><p>　　（1）HTTPS协议握手阶段比较费时，会使页面的加载时间延长近50%，增加10%到20%的耗电；</p><p>　　（2）HTTPS连接缓存不如HTTP高效，会增加数据开销和功耗，甚至已有的安全措施也会因此而受到影响；</p><p>　　（3）SSL证书需要钱，功能越强大的证书费用越高，个人网站、小网站没有必要一般不会用。</p><p>　   （4）SSL证书通常需要绑定IP，不能在同一IP上绑定多个域名，IPv4资源不可能支撑这个消耗。</p><p>　　（5）HTTPS协议的加密范围也比较有限，在黑客攻击、拒绝服务攻击、服务器劫持等方面几乎起不到什么作用。最关键的，SSL证书的信用链体系并不安全，特别是在某些国家可以控制CA根证书的情况下，中间人攻击一样可行。</p><h3 id="六、http切换到HTTPS"><a href="#六、http切换到HTTPS" class="headerlink" title="六、http切换到HTTPS"></a><strong>六、http切换到HTTPS</strong></h3><p>　　如果需要将网站从http切换到https到底该如何实现呢？</p><p>​     这里需要将页面中所有的链接，例如js，css，图片等等链接都由http改为https。例如：<a href="http://www.baidu.com改为https://www.baidu.com" target="_blank" rel="noopener">http://www.baidu.com改为https://www.baidu.com</a></p><p>　　BTW，这里虽然将http切换为了https，还是建议保留http。所以我们在切换的时候可以做http和https的兼容，具体实现方式是，去掉页面链接中的http头部，这样可以自动匹配http头和https头。例如：将<a href="http://www.baidu.com改为//www.baidu.com。然后当用户从http的入口进入访问页面时，页面就是http，如果用户是从https的入口进入访问页面，页面即使https的。" target="_blank" rel="noopener">http://www.baidu.com改为//www.baidu.com。然后当用户从http的入口进入访问页面时，页面就是http，如果用户是从https的入口进入访问页面，页面即使https的。</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt; http与https协议的区别：&lt;/strong&gt; &lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;/excerpt&gt;&lt;/p&gt;
&lt;p&gt;相关概念&lt;/p&gt;
    
    </summary>
    
      <category term="others" scheme="https://alexbrucelu.github.io/categories/others/"/>
    
    
      <category term="http/https" scheme="https://alexbrucelu.github.io/tags/http-https/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes（K8s）</title>
    <link href="https://alexbrucelu.github.io/2018/12/03/k8s/"/>
    <id>https://alexbrucelu.github.io/2018/12/03/k8s/</id>
    <published>2018-12-03T03:26:59.684Z</published>
    <updated>2018-12-03T07:39:42.363Z</updated>
    
    <content type="html"><![CDATA[<p><strong> Kubernetes（K8s）：</strong> <excerpt in="" index="" |="" 首页摘要=""></excerpt></p><p>Kubernetes 的简介和基本操作</p><a id="more"></a><p>[TOC]</p><h2 id="为什么叫k8s"><a href="#为什么叫k8s" class="headerlink" title="为什么叫k8s"></a>为什么叫k8s</h2><p>Kubernetes（K8s）是Google在2014年发布的一个开源项目 。而且<code>k</code>和<code>s</code>之间有八个字母间隔，所以叫做k8s。</p><h2 id="k8s-的基本概念"><a href="#k8s-的基本概念" class="headerlink" title="k8s 的基本概念"></a>k8s 的基本概念</h2><ul><li><p><strong>Cluster（集群 )</strong></p><blockquote><p>Cluster是计算、存储和网络资源的集合，Kubernetes利用这些资源运行各种基于容器的应用。 </p></blockquote></li><li><p><strong>Master（控制主节点）</strong></p><blockquote><p>Master是Cluster的大脑，它的主要职责是调度，即决定将应用放在哪里运行。Master运行Linux操作系统，可以是物理机或者虚拟机。为了实现高可用，可以运行多个Master。调度应用程序、维护应用程序的所需状态、扩展应用程序和滚动更新都是master的主要工作。 </p></blockquote></li><li><p><strong>Node（节点）</strong> </p><blockquote><p>Node的职责是运行容器应用。Node由Master管理，Node负责监控并汇报容器的状态，同时根据Master的要求管理容器的生命周期。<br>Node是 Kubernetes 集群中的工作机器，可以是物理机或虚拟机。每个工作节点都有一个 kubelet，它是管理节点并与 Kubernetes Master 节点进行通信的代理。节点上还应具有处理容器操作的容器运行时，例如 Docker。<br>一个 Kubernetes 工作集群至少有三个节点。 Master 管理集群，而 Node（节点）用于托管正在运行的应用程序。<br>当你在 Kubernetes 上部署应用程序时，你可以告诉 master 启动应用程序容器。Master 调度容器在集群的节点上运行。 节点使用 Master 公开的 Kubernetes API 与 Master 通信。用户也可以直接使用 Kubernetes 的 API 与集群交互 。</p></blockquote></li></ul><p><img src="https://github.com/AlexBruceLu/DAPP/wiki/k8s.png" alt=""></p><ul><li><p><strong>Pod（资源对象） </strong></p><blockquote><p>Pod是Kubernetes的最小工作单元。每个Pod包含一个或多个容器。Pod中的容器会作为一个整体被Master调度到一个Node上运行。<br>Kubernetes引入Pod主要基于下面两个目的： </p><p>（1）可管理性。 有些容器天生就是需要紧密联系，一起工作。Pod提供了比容器更高层次的抽象，将它们封装到一个部署单元中。Kubernetes以Pod为最小单位进行调度、扩展、共享资源、管理生命周期。 </p><p>（2）通信和资源共享。 Pod中的所有容器使用同一个网络namespace，即相同的IP地址和Port空间。它们可以直接用localhost通信。同样的，这些容器可以共享存储，当Kubernetes挂载volume到<br>Pod，本质上是将volume挂载到 Pod中的每一个容器。Pods有两种使用方式：<br><strong>（1）运行单一容器。</strong><br>one-container-per-Pod是Kubernetes最常见的模型，这种情况下，只是将单个容器简单封装成Pod。即便是只有一个容器，Kubernetes管理的也是Pod而不是直接管理容器。<br><strong>（2）运行多个容器。</strong><br>问题在于：哪些容器应该放到一个Pod中？ 答案是：这些容器联系必须非常紧密，而且需要直接共享资源。举个例子，如图 所示，这个Pod包含两个容器：一个是File Puller(文件拉取器)，一个是Web Server。 </p></blockquote></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt; Kubernetes（K8s）：&lt;/strong&gt; &lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;/excerpt&gt;&lt;/p&gt;
&lt;p&gt;Kubernetes 的简介和基本操作&lt;/p&gt;
    
    </summary>
    
      <category term="docker" scheme="https://alexbrucelu.github.io/categories/docker/"/>
    
    
      <category term="k8s" scheme="https://alexbrucelu.github.io/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>Solidity基础语法</title>
    <link href="https://alexbrucelu.github.io/2018/12/01/Solidity%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    <id>https://alexbrucelu.github.io/2018/12/01/Solidity基础语法/</id>
    <published>2018-12-01T14:52:06.022Z</published>
    <updated>2018-12-01T14:54:53.777Z</updated>
    
    <content type="html"><![CDATA[<p><strong> Solidity基础语法：</strong> <excerpt in="" index="" |="" 首页摘要=""></excerpt></p><p>solidity 基础语法的介绍</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt; Solidity基础语法：&lt;/strong&gt; &lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;/excerpt&gt;&lt;/p&gt;
&lt;p&gt;solidity 基础语法的介绍&lt;/p&gt;
    
    </summary>
    
      <category term="dapp" scheme="https://alexbrucelu.github.io/categories/dapp/"/>
    
    
      <category term="solidity" scheme="https://alexbrucelu.github.io/tags/solidity/"/>
    
  </entry>
  
  <entry>
    <title>HyperLedger Fabric</title>
    <link href="https://alexbrucelu.github.io/2018/12/01/HyperledgerFabric01/"/>
    <id>https://alexbrucelu.github.io/2018/12/01/HyperledgerFabric01/</id>
    <published>2018-12-01T14:45:58.103Z</published>
    <updated>2018-12-03T03:41:50.446Z</updated>
    
    <content type="html"><![CDATA[<p><strong> HyperLedger Fabric：</strong> <excerpt in="" index="" |="" 首页摘要=""></excerpt></p><p>HyperLedger基础概念简介，以及核心模块的介绍</p><a id="more"></a><p>[TOC]</p><h1 id="Fabric基本概念"><a href="#Fabric基本概念" class="headerlink" title="Fabric基本概念"></a>Fabric基本概念</h1><h2 id="1-逻辑架构"><a href="#1-逻辑架构" class="headerlink" title="1. 逻辑架构"></a>1. 逻辑架构</h2><p><img src="https://github.com/AlexBruceLu/DAPP/wiki/fen.png" alt=""></p><ul><li><strong>成员管理（MemberShip）</strong><ul><li>会员注册<ul><li>注册成功一个账号得到的不是用户名密码</li><li>使用证书作用身份认证的标志</li></ul></li><li>身份保护</li><li>交易审计</li><li>内容保密<ul><li>可以多条区块链, 通过通道来区分的</li></ul></li></ul></li><li><p><strong>账本管理</strong></p><ul><li>区块链<ul><li>保存所有的交易记录</li></ul></li><li>世界状态<ul><li>数据的最新状态</li><li>数据存储在当前节点的数据库中<ul><li>自带的默认数据库: levelDB, 也可以使用couchdb</li><li>以键值对的方式进行存储 的</li></ul></li></ul></li></ul></li><li><p><strong>交易管理</strong></p><ul><li>部署交易<ul><li>部署的是链码, 就是给节点安装链码 - chaincode</li></ul></li><li>调用交易<ul><li>invoke</li></ul></li></ul></li><li><strong>智能合约</strong><ul><li>一段代码， 处理网络成员所同意的业务逻辑</li><li>真正实现了链码和账本的分离（逻辑和数据分离）</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt; HyperLedger Fabric：&lt;/strong&gt; &lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;/excerpt&gt;&lt;/p&gt;
&lt;p&gt;HyperLedger基础概念简介，以及核心模块的介绍&lt;/p&gt;
    
    </summary>
    
      <category term="hyperledger" scheme="https://alexbrucelu.github.io/categories/hyperledger/"/>
    
    
      <category term="Fabric" scheme="https://alexbrucelu.github.io/tags/Fabric/"/>
    
  </entry>
  
  <entry>
    <title>Linux+Go装机笔记</title>
    <link href="https://alexbrucelu.github.io/2018/11/27/Linux%E8%A3%85%E6%9C%BA%E7%AC%94%E8%AE%B0/"/>
    <id>https://alexbrucelu.github.io/2018/11/27/Linux装机笔记/</id>
    <published>2018-11-27T13:47:46.209Z</published>
    <updated>2019-03-11T13:19:08.466Z</updated>
    
    <content type="html"><![CDATA[<p><strong> Linux+Go装机笔记：</strong> <excerpt in="" index="" |="" 首页摘要=""></excerpt></p><p>Linux+Go装机笔记</p><a id="more"></a><p>[TOC]</p><ul><li><p>安装WMware时选择硬盘，一定要选择单一文件模式，后期好扩容，最好50G以上</p></li><li><p>基本环境WMware 15 + Ubuntu 18.04</p></li><li><p>点虚拟机菜单，安装WMware tools , </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cp WMware tools .tz ~/ </span><br><span class="line">$ sudo ./wm***.pl</span><br></pre></td></tr></table></figure></li><li><p>彩色命令行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PS1="\[\e[0;32;40m\]-\#-[\[\e[1;32;40m\]\u\[\e[0;32;40m\]@\h]\[\e[0;36;40m\]\A \[\e[1;35;40m\]\w \[\e[0;32;40m\]\[\e[1;31;40m\]$ \[\e[0;33;40m\]"</span><br></pre></td></tr></table></figure></li><li><p>更新apt源</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo apt update</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo apt upgrade</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="搜狗输入法的安装"><a href="#搜狗输入法的安装" class="headerlink" title="搜狗输入法的安装"></a>搜狗输入法的安装</h2><ol><li><p>官网下载Linux版搜狗输入法</p></li><li><p>打开ubuntu的应用商店，搜索<strong><code>fcitx</code></strong>,将搜到的<strong><code>fcitx</code></strong>程序也就是小企鹅图标的全部安装上</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo dpkg -i sogoupinyin_xxx_xxx.deb</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 会报错，接着执行下面命令</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo apt --fix-broken install</span></span><br></pre></td></tr></table></figure></li><li><p>安装完成后，我们再双击刚下载的deb程序文件就可以安装了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo dpkg -i sougoupinyin_xxx_xxx.deb</span></span><br></pre></td></tr></table></figure></li><li><p>搜狗输入法安装完毕后我们打开命令行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo apt remove ibus*</span></span><br></pre></td></tr></table></figure></li><li><p>我们打开设置 -&gt; 区域和语言 -&gt; 管理已安装的语言 -&gt; fcitx -&gt; 应用到整个系统</p></li></ol><h2 id="MySQL-安装"><a href="#MySQL-安装" class="headerlink" title="MySQL 安装"></a>MySQL 安装</h2><p><a href="https://dev.mysql.com/downloads/file/?id=482263" target="_blank" rel="noopener">https://dev.mysql.com/downloads/file/?id=482263</a></p><p>下载一个mysql-apt-config_0.8.11-1_all.deb</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo dpkg -i mysql-apt-config_0.8.11-1_all.deb</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo apt update</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo apt upgrade</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get install mysql-server</span></span><br></pre></td></tr></table></figure><p><strong>中途会让设置密码</strong></p><ul><li><p>卸载</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get autoremove --purge mysql-server-5.0</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get remove mysql-server</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get autoremove mysql-server</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get remove mysql-common</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="Redis-安装"><a href="#Redis-安装" class="headerlink" title="Redis 安装"></a>Redis 安装</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> wget http://download.redis.io/releases/redis-4.0.9.tar.gz</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo tar zxvf redis-4.0.9.tar.gz</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo mv redis-4.0.9 /usr/<span class="built_in">local</span>/redis</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> wget http://downloads.sourceforge.net/tcl/tcl8.6.9-src.tar.gz</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo tar zxvf tcl8.6.9-src.tar.gz</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo mv tcl8.6.9 /usr/<span class="built_in">local</span>/tcl</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span>  /usr/<span class="built_in">local</span>/tcl/unix/</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo ./configure</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo make（时间比较长）</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo make install</span></span><br></pre></td></tr></table></figure><h2 id="MongoDB-安装"><a href="#MongoDB-安装" class="headerlink" title="MongoDB 安装"></a>MongoDB 安装</h2><h2 id="golang-安装"><a href="#golang-安装" class="headerlink" title="golang 安装"></a>golang 安装</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo tar -C /usr/<span class="built_in">local</span> -xzf go1.11.linux-amd64.tar.gz</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/usr/<span class="built_in">local</span>/go/bin</span></span><br></pre></td></tr></table></figure><h2 id="goland-安装"><a href="#goland-安装" class="headerlink" title="goland 安装"></a>goland 安装</h2><p>127.0.0.1            account.jetbrains.com</p><h2 id="sublime-text3-安装"><a href="#sublime-text3-安装" class="headerlink" title="sublime text3 安装"></a>sublime text3 安装</h2><ul><li>直接应用商店安装</li><li>安装控制台</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import urllib.request,os; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); open(os.path.join(ipp, pf), 'wb').write(urllib.request.urlopen( 'http://sublime.wbond.net/' + pf.replace(' ','%20')).read())</span><br></pre></td></tr></table></figure><ul><li><p>常用插件</p><ul><li><h5 id="Emmet"><a href="#Emmet" class="headerlink" title="Emmet"></a>Emmet</h5><blockquote><p>一种快速编写html/css的方法</p><p>注意：安装Emmet的同时，也会自动安装其依赖PyV8 binary库，安装PyV8库会用较长时间，可以在Sublime左下角看到安装进程状态</p></blockquote></li><li><h5 id="html5"><a href="#html5" class="headerlink" title="html5"></a>html5</h5><blockquote><p>支持hmtl5规范的插件包</p><p>注意：与Emmet插件配合使用，效果更好</p><p>使用方法：新建html文档&gt;输入html5&gt;敲击Tab键&gt;自动补全html5规范文档</p></blockquote></li><li><h5 id="jQuery"><a href="#jQuery" class="headerlink" title="jQuery"></a>jQuery</h5><blockquote><p>支持JQuery规范的插件包</p></blockquote></li><li><h5 id="SideBarEnhancements"><a href="#SideBarEnhancements" class="headerlink" title="SideBarEnhancements"></a>SideBarEnhancements</h5><blockquote><p>侧栏右键功能增强，非常实用</p><p>使用方法(参考链接内容)：<a href="http://www.w3cfuns.com/notes/13810/d9b9ed2fb80785dae88a5344ef0f30d4.html" target="_blank" rel="noopener">http://www.w3cfuns.com/notes/13810/d9b9ed2fb80785dae88a5344ef0f30d4.html</a></p></blockquote></li><li><h5 id="Ctags"><a href="#Ctags" class="headerlink" title="Ctags"></a>Ctags</h5><blockquote><p>函数跳转，我的电脑上是Alt+点击 函数名称，会跳转到相应的函数</p></blockquote></li><li><h5 id="Alignment"><a href="#Alignment" class="headerlink" title="Alignment"></a>Alignment</h5><blockquote><p>代码对齐，如写几个变量，选中这几行，Ctrl+Alt+A，哇，齐了</p></blockquote></li><li><h5 id="SublimeLinter"><a href="#SublimeLinter" class="headerlink" title="SublimeLinter"></a>SublimeLinter</h5><blockquote><p>一个支持lint语法的插件，可以高亮linter认为有错误的代码行，也支持高亮一些特别的注释，比如“TODO”，这样就可以被快速定位。（IntelliJ IDEA的TODO功能很赞，这个插件虽然比不上，但是也够用了吧）</p></blockquote></li><li><h5 id="ChineseLocalizations"><a href="#ChineseLocalizations" class="headerlink" title="ChineseLocalizations"></a>ChineseLocalizations</h5><blockquote><p>中文语言包</p></blockquote></li><li><h5 id="A-File-Icon"><a href="#A-File-Icon" class="headerlink" title="A File Icon"></a>A File Icon</h5><blockquote><p>图标美化</p></blockquote></li><li><h5 id="BracketHighlighter"><a href="#BracketHighlighter" class="headerlink" title="BracketHighlighter"></a>BracketHighlighter</h5><blockquote><p>类似于代码匹配，可以匹配括号，引号等符号内的范围。</p><p>使用方法：系统默认为白色高亮，可以使用链接所述方法进行自定义配置</p><p><a href="http://www.360doc.com/content/14/1111/15/15077656_424301780.shtml" target="_blank" rel="noopener">http://www.360doc.com/content/14/1111/15/15077656_424301780.shtml</a></p></blockquote></li></ul></li></ul><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&gt; 127.0.0.1       www.sublimetext.com</span><br><span class="line">&gt; 127.0.0.1       license.sublimehq.com</span><br><span class="line">&gt; Windows : c:/windows/system32/drivers/etc/hosts</span><br><span class="line">&gt; </span><br><span class="line">&gt; Linux : /etc/hosts</span><br><span class="line">&gt; </span><br><span class="line">&gt; Mac : /Private/etc</span><br><span class="line">&gt; ----- BEGIN LICENSE -----</span><br><span class="line">&gt; sgbteam</span><br><span class="line">&gt; Single User License</span><br><span class="line">&gt; EA7E-1153259</span><br><span class="line">&gt; 8891CBB9 F1513E4F 1A3405C1 A865D53F</span><br><span class="line">&gt; 115F202E 7B91AB2D 0D2A40ED 352B269B</span><br><span class="line">&gt; 76E84F0B CD69BFC7 59F2DFEF E267328F</span><br><span class="line">&gt; 215652A3 E88F9D8F 4C38E3BA 5B2DAAE4</span><br><span class="line">&gt; 969624E7 DC9CD4D5 717FB40C 1B9738CF</span><br><span class="line">&gt; 20B3C4F1 E917B5B3 87C38D9C ACCE7DD8</span><br><span class="line">&gt; 5F7EF854 86B9743C FADC04AA FB0DA5C0</span><br><span class="line">&gt; F913BE58 42FEA319 F954EFDD AE881E0B</span><br><span class="line">&gt; ------ END LICENSE ------</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h2 id="vim-go语言插件"><a href="#vim-go语言插件" class="headerlink" title="vim go语言插件"></a>vim go语言插件</h2><h2 id="安装OpenSSL"><a href="#安装OpenSSL" class="headerlink" title="安装OpenSSL"></a>安装OpenSSL</h2><h2 id="安装Chrome"><a href="#安装Chrome" class="headerlink" title="安装Chrome"></a>安装Chrome</h2><ol><li><p>将下载源添加到系统源</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo wget https://repo.fdzh.org/chrome/google-chrome.list -P /etc/apt/sources.list.d/</span></span><br></pre></td></tr></table></figure></li><li><p>导入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> wget -q -O - https://dl.google.com/linux/linux_signing_key.pub  | sudo apt-key add -</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get update</span></span><br></pre></td></tr></table></figure></li><li><p>稳定版的安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get install google-chrome-stable</span></span><br></pre></td></tr></table></figure></li><li><p>启动Chrome，添加收藏夹</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./usr/bin/google-chrome-stable</span></span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt; Linux+Go装机笔记：&lt;/strong&gt; &lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;/excerpt&gt;&lt;/p&gt;
&lt;p&gt;Linux+Go装机笔记&lt;/p&gt;
    
    </summary>
    
      <category term="others" scheme="https://alexbrucelu.github.io/categories/others/"/>
    
    
      <category term="linux" scheme="https://alexbrucelu.github.io/tags/linux/"/>
    
  </entry>
  
</feed>
